<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8f4a4620f9cb8f79d82b467b91bbe7f8ee5664fd2b8d2e6b077369d4b7cc0c8cb78d35c142cdd0c49849b6224d41fdac800c59424b4861028a318e5d2b631442c739bc2f091c18655989b1c204c1a341cd20b9f771f6fcd6e989f16daf98af176006ceecd1e6e06fe4d87dfbded1e6a55d29f9dfd3a86ec8634322b83493385eaeb4b66ad8025135adc331a4aa60061ddbce12a0868d443ccb2889710314a558dff94dc7e45ae52e2d1a4ecb647f24ea2670561d509337cae848b3f3f5ac820d24f7fc02d637269b614f1d88ac7bacfa8d1b6eb79399a9adb4e1b3757ff118a9c4cce99165f46489baf5d09c5988942b6af2127d54aaca6362b92ed4416739905f12c43ef3bc1091726a0d9c34b8e65de7b3a4663f80d4f043defd18a06e9e82ddc58247b2bddb09c7edefd9c983c79a26528dec0780de53308f88fdee4d7ff8b8e4b8e7e6eaf6f049ce9d4de27c930f2eaf4dc45dc8160366104d7be009970482c3b0055501528d64d82e9231f2acd5bee0ae4903fcfb42b01f0dbaf0dbcf689f00982d86237a1a73cfe18cb6103261f5e20e7e5d4bc545b1c4669336326b5534bbabf6102a4a6e05cfd04b8ab84e7d80125921297e9a58fcfe1a515f0ebe8b7f790b4309aa822a77d6d8e84ec3d3c704c77cbddf435b680a857e0b1807465d9db44d9e4ea39e403977ca496f119661dc6dad91f5e6cf13e9b645c8b1b14540e87f267bfd0440cb4f7ebd79f6d04a10d42357ee118ad4bfa7f67b06129f2d4d8798590b1a922048969e0318707f51f4508d26ea3a728c416763aa10386ae1867ed666ebbf57eed4f7486bdcccd410b5fba1811f643017d31fcc6eba61690cdbb8c277eb14331a7cbc6ee1a52ace73a46d76260f1df1534f299239aa3df912ae578c9ecd5bbc1d96fca811b9c4cadb71fe1a994921537f50705004f4d75f27410e8b7f016b1a8df4edd63481af22c275c02da24319bf8b2323f2c2288ec8f99c13128e6b829ce02395cbe5c3d5821a03b95ab08c7135dec360685be3e9ef5274c94aa4227b0083c0db5d8c1c52d3db551669346a8510e45f905e65a7347629a91c916f1bd76eec582d7b6eee938192738929d6fec293037600277349f8244bc561bbcd901b1ec655545150ba3456a56f90e7535f32ed48c62696a28a8ea358bf694395075d7a175ec118c8c01dbfee92462c21820d3257b7fa161bf7059de61c6e9efdffa90dbe859c99cfc3ad23f315b7566251a1e553b12b183c23b5685d98a2d1bd706725350cda31cf82bb0555fd94fff8825a65169312908c8d4b4b5614f1192728eb1d54403122737304f8e3721c7fb455128faae4029bc8ce55b45214906123b4f3b8e09e8eabc8a2b205f52c07cbe8d94b510e9c4f53b4c7277e064cdd31157ff082c60fd5b637e92a1109ec9b98401acbadf4b78860f9ea76754142d16f80ecd591c89fbe5f72c002ddc39d2c4c829334cf2c4d6284ce84342d6f4437d0a7356d967151a67b2a1586586f670fe4efac3677a3b393eda3d2615cb47ec59f421f6f2e963460893e40f780e83f1acf9d0eecf12ae189ba087a86a0d41e63c7a9f7527920a9eb6b91dab772c9064dd8c88cb77c091723f86cfd289e492d4d8abe5c38736282bd2b75fa1bf68bce348bb0f57ab89961f062a64c667a971c5a1f8d7bc493e1dcb23852c5ff8852931bb28612c2d104b8630437bfe4f63b6043c1c6c09480c6eb4c5f7d318b9693780c66b8dcab8e91e3ea0b664f3b03b321587c488652f2a032d05864d11b7f3b8874407348f8952bc0e3235fd702b3b14578b241df48af2397cd180ce68fe9559dbbe78211b582d8e83b726f593f2d3515bad18c41d56623fe29fd8bf6ad56c46942244df2ce8b85f834c4f12a8c33e1b1aecd97d03d3ed641c3a16f0299dd241b0ff493c09579ccd4cc959c782612eed0f9f97c8f7624620588b45813eeaefd95c90596c639587d2f037a99281e1f5ed4cc8a103ca73fb309bc6c1062d30f52e090028621c561d5b7d9ccaae91cac98b1595cc62de7263d0ea524f3ffe389ca465c2aeb5fcfda53b376ff7fbf9c80ee6a2f1bae50feef5d091351d0182ee1f7a0150c06bec891dbae07b5e29fa91c6e7eddf32a2d1b07caa39fde42a67290664e61faa13ff2959f2a3cdbe3014d4096e72a66373c7179875f442da73cf9d0639b9f72b023e45103c69c8731e81967dcc6199d4f69b77b42bde4733be68e21a25214c9d5797c62073755cdacc52fba23a2b7e6f2ee870cfb98fcb12511f86caef583ba3d96559ed605b32af1d858d5bb106b723da80fdd0711378c4140c98a9daff0eac31bf3594ea1f764633c3319c532d86fb3be1b1bb27c127dba96e5c9d4100f9aed5775c1e1c8a3a1c9430f30d02bef00d8d47aff2a37c851fe885cadec19d943c353aa0cab2b2afa7a19308f61dd3cdf2546f6f793034561718c81ff962fc12b573e1bb56e8dd1543773df029b61c5f6b350bc0293167eb2d9124ff8e32ff17f7520e2ad479d30d4a63f4ddc6ef9f3805d6c7a6d0f56692cacf0f21ca57a2dc3ef2830e44ddd24cf7a0efa35f0c87638506100c62b361486f318f794f11dcd8cefdb58d76d7e614d1f6a532a429daf9fb3cc958018c0d8924500f1697ab5a5ca14378ba5142c16fb94ff6b9b0a60ede185625102e29888b910579b2a4dcf6d764464b407b12e00618df4b2c4ec80ae80d7f59766fe4bb86598a732343d7bdc50ca9a8f2a1145fc9286a9c0219f3641af3b6bbd543666a1f3f61c84ec38dc36d8bebfe9620f1bd7d0cf56fa3e61d660cf3cdfcfbd044bb8175fcff523c28de938c275747c09b0dece0ee76ec46aaf497e376ec4d190a7ccaca67acf83bcf81badddb7d29e3b42e65c39f36451dc031f1372809cec64c7918e7c3a3213b44342e05365d47d1fa8ea08f967e6e8c8aa521fc5586b5db245e0a2767dd062381bd47144d861b95072ea1a5e5e7d623ca177c0f747db55b2d8c89f084b7c5c6eaae551ce2c5f6cdda04f80d066a4dc77ac42b7c6956289a8e3ae67bc66f3776ac9c8c1a64c3077d3a74f815fe75ef80122bd9d59e6ab36465e07c15086f4f2d8fbfc831668105fa13e795c52a949428ba776dc87155cb624ef73e19acfecb3a1fe535a87a277ca63bb8d9941229277375a60fab52945abfc8e25b982b69e13739ac8f161bf4559ad459f1c7421d77967b9ff13ff44b4bb68937da595230debe674f97f247f09c4bd4142c701de92b66d237d00720176bf401900c934805e80cc2cae66022cae1977b62827535cd1d1732099020277e7f1b9fb4e76ca27c76be8c30f1feb3b1a208a7bacaf43cbc2fed0723adddb1a831c4fd6dd38c1c50275cd4667dcd72485e8da020be8fa5b8f857f3bf87f84f7ff5d741bcf37955b26dea66b7eda8458b6d86793c2b3553de15362c368f60b890f41f5de752f4ac5316c7c9310d80ebce782825839c7a2f407b1dca54d0fabe42f3eed1ecbda923d94e84ce85ce9032e895c53d8da193796847acdc70bb07e2eafb7c1f87d3b94fe292a638ea83c72d284ccc02b52a6f7740ff77b3320c3e0122430129d582dda4bb3e593e47eca3984bf34ea65f1965c3c4aa19e31d09ed267cb04aa5676e93c964b073d24a2d3b6862b9f0fe2f7567dd4e94855c699efdc8caaadc0a8030c3c063d4ed7c99ac670714ad424d5ba8b5eb2fecf46448693904c67096e922ec9c1bd0ee766b394ffbdbda18ba95bceb6d036fc0536b3d8c8b65dc901cb716c16938c0dc8ed46aac4325a0ec4bcd2fe2809d957decacd4ec53865d78962d0841d3eaba31bc374cddc3644ed80db986a1693049ebbc4073d952475b4265931ce88aeaf002bb16515aa5270083cb34da635c9c6d403a465442c3503c2d6b9f99750a3e8e0d49cd75505d673dad298ce50e1dbd0ac49fb57a88b3995c2ff01b69023226055cf09770012a333501166f8807db9bedfc19d041e6354fd72199c96edd2b7c1222d789c9b4117f71767bd129acfc49dd9662002143ae33e6249de8f107ac8a2931aff0c928d943a43465cd772ae2a505abdbbeb20d26c4c7a4099dd2b1f200be64df8085e4f4c7cbb20901d078b8e69ac93bddcd617c1429663d69b59689e7b827bc1965db063e887ddd22c2b6e7149c95da0ae67b4e8b10dae52f6ed62c8368bd9bf033272c5789e3292c4a5c630bb9b10b7f696e1ae0b43e60c59fcd4a3542871677572e88889d98e6610244cdb9891552da5a30c5972c42a19149aa1d1beb7c508bdfe5d5a38c22c637248884d56c859308368091526f367d611a86df2ffefd783ba764cc9ad7b533136d609bb67ea454c0e1f89654a5fea2bbd11486d1ac51255139336ab09ad93ec5e80521ed3cf8caf61fac37b7d499b42a12576350821985d9b544cfef95f64b2a552bd2f77675814c17589bf0b64b318c13b75d5768aa53e6e454740478da67e07c9a8380277e657705e5b56bd411ba9cfee22965dac0367eb41bb343f8cb335f2484e35ab56237f9dfc50f278c6f6e7cd567abd00e3b5d3b664982359122ebb0ddc1e4efe3b0a44448b2369e4078650806e4e8d3f79bfb8bb897b288e6c3facdd9246c63b6c13d1da0ec2609ba6256884ba88d63673433308b9b3dd33b86bb098d5254077eda98172167418d941d6117a9be61a6b8bff85c77e6a5251c3881e1126dc4b42d358859ce61006e84f47d2f6e60e534e90748c664b39d9b76b3bb20a7b30bd9b2322da07eccf6eae2b9f5f24108c2c63b156336989a29791f80dcc703126d899b1726134142a7555e4f48cb43a846af8551e498d1827781ed985a9f019aa1d1fb47d9d07ca42f90896b23bd7829a6d79818eabe46783058c6aea1ed1ce6a3bb089ffcd0e3ae271851fa3b995fac94edf1bc0284d7edde99bd0bb31121af252d721f0f93a7eb5a4e8509630f780ad3ad3d3ee2af0ded1ee3b26ccf5bbbf3ffbea87fbf1e30ca3886cba4c771d56bd5f029ffb18992b8bda8a8a622471517d42568e404cfd95a7101bb7041db7212b38cf224217a8f0205d01f96f16cc8d0817ae5e488e3be719f4141bc730925692b1a45ba88c72178c1e9c2fa18c75f010966b170088a94ac9e757e3b484cf2d3ccda8fc21183cc03cacbb7b6a06b5bce7d1c9d9abb9a2094b23cf0936b8037f1f6f4262060bce74326cc5d3919f76c3fbc9b6cb86ee2e785d8c6b837bf4e8b1adbc22bdac410ddc4c10787ac535c241804c9f5b8112552d540207487ca341867004e4a204a92d383f83170f0e45f6e767a0f449a1eedf5eadf95d89123f8bcfe5bc9b7f0a670b15744e7720670668a687fb67400a08776b335ae4503f3e7a181644cdc3dbb9973777204c5523cda8c7bef54eef78f4087f65bc9c8853beb80e14ce29508c2c75a79261ac187dfc6dcb2a0d32295c2383c0cd5aa4064bff7894a09f354d06c84f1171eeb0c24210c1d3f82e639820777269db8ec0ff16d510177185bb24cea65262b2a655d6d48e122977d27cc5cc0c9f694f18368c5a3555c291dbfc34c53c2faa2367d67acc31d641659c0a5f70a362a356fcea30f9c252691c47f3c0be397a97fbbb38417916c1e592cf3d3db1b581d2d2e075245e1d7e04d3314af0bc203d118ed45bfe549f62751b47f2c1add0550cd40e76d9b7c2892481aef7cf71a345cdc3d5dbea85dee3fdfc2b8bb3ec0ae222f8a1f288fb510f66baf681d2ba5dab81ad00dce3da894cebfc62d4b6e73c9c0631f3fcae837b71bf9614e82a540b3a5c8939fa8e66c3162b85f83e314fb8b9f4f48f29f6b2f59e0352a58753530b7025f1066e689df559cdd5899b5b1ac30b2a01daafaa124fca8e3f7244a26f5911ff4bfe569102b6ec25c6da7515951be77911f8d83b6bd55c6e577f43a7560bf3cb2f26c687cefbf0688ac8b158e078197c25adee4efffa1a6a05122cdbfa63e603942b42e6bb6672c3c9a91c5b810d0d9cb5cbd572cdf72aa9e97dce3acbed98ccfe108fd6d03dd8a708009f11d90cd15ce20cbdc003327f320c485436df6524f4caf2afe4a899ef7a6fb530f2d30c4e5c08019ba9e4bb509ef74f0f1c8c9ebe8618f0f8f248503915e3aa7f1b055b58d0a109bdbf9a2bd9b1c8804e27d082f517eb4c33ad79a3490009400dfed1deb09a9b5b7eec641a8aebe1fae134d62c18ccfac04d5fbc6bb86ec74535eb3040d76cd8864be96b194963cb910607917a1c60ce85e55bece29297fce99a84ce6f30f17ec8ae4ac5609733a9f448d181a974c7213847b74ee313b3f528a19098e0799dc4270f9b119bac8f6b3bd179ba395bdfdead2d595904a9e892ff71d4eccb3aea73dd9a35d55165eb539c91c04808bac07dd1cf615358bbae39574a1ba3a54654608a75b3613b202602d0263d3046abecdf30d322d9c22415bc2c557ade02b70d8374825145a49bdd9e453ffa484200965099ad4ef29e6828cfe015ea1b3c2835c315df5bde1fb587f1491d10a3d65092e890c533365abdf9bb0bea050543021964cd3a762b3102fb4c6bc32c3f8ff12f10ab0d60e91de081929a2a7207194631afe4157e428b62fbc33ec64d9cb958a049ecf40d1ef3ad70d77d4031fb2b4ea25854214f608538277215789cfccda296eda65d2ed10ac22c99128e0dd9e9ab839749c811ed0149911630480b98085ebac8974a7a7a99c3b6da86af74e39fc2343193fa1c0a192d3d1ec5ce8f803dd2a51b0c7326d02d0e3a098280ec85aa9a3a656e6d5f5d393359d7dec746f67883cdd866de7d1299e7150c3dc8296eb70318a184a87a1c31369eb91b3d488c36340b4c7aaca4c8f7a62159b999e82c57b5329e313bc74b3a55c9d025a40b877b440f742cc40f7e2b4fb8358dad402825ea7b10d6b84092a804a23fa9e5447f5211ed6ec10e8e559579b9f527c331443703c17c1f7411077b793f754316477d0ac53d0eb1dcb65484bc16b938c1669a570b8b0110d856c9616c531d1fe7cd6abecd923c01bea1a6aa1404a3fae71018aa0d8c3213263e20d071d07bed6de39dc85e33312d425f89cd244e18feff8fe548818eb91c4b0053bb2ea2c57c0f5f7a2b5b0897e6b7eb43a7a98be1b98ec414bf30e80d9bd4741833140dcae56e7b50eb151811eeaec8c4c84d5de72f87b8fb3d6528b937bed33b58597a6a1ddb4603a0610c230cd8b97e53e50634536906425097ae531f793db45a9defe05105db6bb8fdad27021829d86b82bf938f0a0630cf7cc9e7a378d7fd578460b50dbfcca7b4e0646569d9698822d925d6c33189837350714ca39a22f5547846018b55d39b27b98da4e682c96308dde3cb397e2432688a3d7853b3656966791e5be098752ab07fb26b30135897ed29d7d7e9a1685954a03bf59dab157fc9f1f768172469924c0ea38431d68ec8ccf260a19cdd194babe4f116a8d179edf051f962f8b5f07836802c153d7126a49b00ccaa94b7855a3a42cc2aae5479f2c609987ab9f4198d547a967cda5681c0263729f3a296dfc3c4e6ce76ad6c4d92eab19854b66b22e508ab2cbbc7a506aad38be952f26e12e5110c0be89259dd4d10d63dfc20fbc1fb632a6bfea22f09c6dd51f47e9fe452d0145a7e486946b23e66b4462ba982cf3d851645e4a4e1dd035943f7ff83759dd8172af0bf4b67e0aa7a74c4b4cb47336a8c8518a60f49326debd767d9b3e28f1c4c0c3e59562ecb1b65a0fca3894c2b8ad35dd7167fe43efa79c8b3ac1a0e1be44eca79550b55560d1870b7737c364244a6416148b9cc803192cd872975f3e022e4c612eaa7bc8a12cee85a9f3f658082c9cb13e8c4db8f1dc6dcd8f32da7ed92032997c11a0fcb48c9c8dac005a12b70b5903bfecefa179f64c408f74fe7b84a1d01b110909940a2a1d44010e7b95f0353466d3535ea97ed874b3bfd92d5237de19ac7749f9d4da7adbcf0b39ca93cd01eb4378485a298bf6f2ac394a0fba7903a94d95c5f4f3e573ff05cac39acbcd72ad6d47b482a013b96de2618039f52889f91c6e33144a0b7061ebaa1abbb6988e8f41e2c526f775903b5ea3985857fba34d9059b67f10416e8bb1cd51edeeff49da4e69dc9f0cc00b54307c8a9e72119243231de94364ea59737e81416b9406dbb7fa98e1da2c11b4519cf4ed487d6516ede3d436aeb6750978122637e4843fd418e22e1ce268287f8fa45299f401829ae1b0823bac4ece31100a58c5b95e33e9e4d91196b7ce26dcec0fe27444fe25035a07bba22baef177eb58b25ece60f083b54e7b8d674a5a67fbf10c0cf5076cebd4d77879caa585b332a0a173260b09500a56ec12d92112ae7516563b1a3cf74d1c73ceef389ab3cabbe5996eab4863bcabb4179ddfb7b12e45accf3187fe663c8f88b9a54814abdb28d736e56e5dda8088b897f6fe9521a825d84af19dce6e00bb0cfb8968290576cba4bab0e14df32fa06a1bfc6d09698794790a7441f981f4d0ad095faf944dae822bb7a76e4511208273f3c2d29793a023e572743ee560a6ca7d61bba2066b9ba7ada819e389ec0d9d3f5928355e06e1c8ab48581eac7397c41128c5f8271bfc9ca385bb0d249831c193eb895ee9a5893dbfc3d5562cdc067232b9ffad1dcfb3f51e88fb235f4f9f0cbd32e863b802296d5042aa3dbbfac333260686de07050c82504fef4edc2c9fe4bfd28285fcffa0ca9c4cb2d950daab949e629cfd007616f28c78f7521e77060eaee3b53edf2e6753e318f0a08e0ed15ceac607606162dc1b762abd21bd60a2ade714ece4dcbcd58495e498363b7042a0be37065c0f79e0a5a9666e75e2d5b9842bce2fdc1ef2cab42dcaae2d3d64c7b1fbfe0f18edf2896519c88dd6dee3050eb6d7caa6ebfb01965ba785d448235371d2596b1d5f4f50e15fa3183fe9c60b453bc18d60a4099553e3552511a1337be873b3b08684ef336ac80821129a81e057af2cbbe39b8e168d5ec1b9f8357d386c0d12963c2a66d6bb607f7b14f811dc31b3b365f0598fcd054410b70c596331a4887802a02a2ff1558806a2fb017c6da3cafd2f3c91380382529acce2e8d0a484c5a2da824b21d8d8a923572efe21cf80f88f1bb684540b4efa87de32d6a2b440720cafff388c2352d7151c19476ef1a31a45f782457acb2b423703670edde68348dae8f84b353648ae8deda322652bf1232f045b26f622a7189859f0618460f7e779a7ead1ef50133cb0c247a73cafa9dccc56db2a0783c367a32b21f6972bb322a596cdcefbe4deaf42425c4a69b4c9f625f70b63344d25f1232c5d1b2ea2b7b4bfacf3ee45a5d73b66c3f8e6ae5a2a21a0e634601aa9f5debe47babd15654d29d1011b5410388e9a7a2209ebcf7215f4edc2f6a4481fcf0021b7eefdd099f27ac35a3a3f48a839a753e51f6c8c8fd47fe54ea93169c3f62b25005dca978b77721f29ee3f94cec14e44f60c6d21b7d7fb78751b784134fe3e28ff0c00de8b86dfca535f9512bde00d061bf5b6c5b464d570791c6be74a8c0a1b6cc2fc61523df1995a46d0eada1843830aea5a0c427629df42a6603f7265e1130c9eaff6fc8ba4e36d02235bcf4a9473098fdd711898f5e3a903970d05ce54c947946b3534f3bbbe650de1c27894a19aec1075087d7f4dbb4c437c893f5f8776db433dad9afd1675254482d1419e357249e56e459a396511985e9a397d14556d89c1006501abeaebfca5e646282afd47ed88de50565647aa145a8f72a839e118fea227e7599799946459fd2aee87c518254128b6e49cf57393f876f667022e9c8da91ae6a636e61a40c9dbb087de27c2ef30e5f06e1cc1533908d556acead3602d1009b7bf9c55a9b84b99a487a9211b0588754759a97ca71ebbad846eba69e64880ea65909ef8c7b05ab5a2d918249eca8856a9cd35bd4dd7c8aeea04b4bedbf06e0af6184fc85d02c9b041c1d82d8e2e0eafabf60add27f5fbfc756650759f3b5df28704321d54c19cca604049db121470e0e0fe3c389eaebb7edf816ba3c3ec6ac3c1d1353fa774f70ce79de2ca541eed080ce2eee32ed307f67327d5890ed7f97fc577d4f7752a37e46e451eeedb1a1876c97ead9432a6f76f719b6efe7aafdc6d2bf53b3ae54942871331df301431997f17cc3eb6336efe95369132d4d8444a3e5dce055ba0032798d43be8ca182afa8a2e16db87052701ad02af844c9177a329fd310cea6c4d993468f3ac760b3b521612e1b3b5f1d66aa69fb176e4487e9b411714cca87d683d1fdf9b79f267f9bafe29364b627f6cbf6a0daf0bc06b4a9594578cd2b64d967695a7bba7220c5ca717fb285e0be6081f8385f9af13ce068ca76016fd480d49fc8445673a299b5ee098d5463c18a5ba8d26b1e7d73e5c08acb593476b44d2f0a2f92c657b40fc8ea111de9553ffb5a3a970f2dd8e5b44ba569de05e7525deda2ee027b00cf91aac2c14916d85dda7be0dd3786f221997b6de8b58ba203c3c51deabf13da622d2a93a9d0dfec610682eed36467bbcab131496496f792b48547310cb37804486d29280de067aef4e4657b7d433b02198e23ee22f0aac4fb7c525651f7e32a11238f47b01f83931dfef8ada8be06eb586d5d392ed6f19c18846d03e8d66bf8676da42d1b9fc366b261cdefcb85b2a2f85614fcfb26cf63cba664e121a65c00c69ccc7564585ca4686b24ab6317da79505f0e99aa59a406c86787503fa767292a700d5463da191c344a83fa6be19a8238b57a6e04446411e2a3d97d51944cd8f1ff776a55c39b5a2f2012a64f25bb2c546257d8d241a20d527a28b67f0cdbe249f2a694da509068b04a151a4228d42e2b192e0bbbaf03825aa82d785d3cb871edd7a51ea6c8d05b80e40755c1181534db4aa236be065e5804e219118d191ae0d79859f5a405a933ee6e239cf832beee498e451b2948d84bc22d4d58f94a0b9695ea4ff1b6687054284eafc55579f2efda1c8ea891e75a8a767d4b476e20ad28f9e6743355e7a9b0ec26c18104d3bc0340696a2f5e22428e3374021b2838681ecda9482e4028078baff91e0573b2794f233d95dbdfe948f7c0c86465760c074900cca8e1703c8efc960668514435ba9d9c4c139cf8ad7d023e0f3248cc12b3a09e5d48ad96a12c9a74215d09a9ab0bafd988e181cbf99829930f974656e147ba5e15284e97d187224e2e6e51f03ae84ef156cfb64bb30c406ad9e4e2b1fd549b7112f4821bcf1dc748fe289f830b2ae30201ff1ace723e0bfb10f368b8c157d3327978ccf663907957807b49663a3f775a1edc175bfef065b0a494d839e7640c9899d7f919f547b3e67b4f81703c736988b49b85e0b8cac8c96b6517d206a8dd376150e563479fb20ca3676a6ebf9e697c94fb481eb9a4d8b1581e4f5a9ed44a67493f2a0da8f311c9face0f5ab1a2f3db6834fc5479d823067aaeda48209d8e6976e9bd710b75424c14e5fe405fb741d009cbb46d188f1640201773d4951f8e0aee0c2cd2fdfb129020da4d7be09e58c19a1d702671eba87938b886156826082a4d6899b095a643e5ebb382ed699246e9b5c68020082f3844ecc3dbc27283704008acfe10123b879575947edc54a8dd35b6a382fbf191ee205e55e85d12dbe7bccdb4ba30974e7d115ee4a5fa7fbf503d2115fc146423229f1cb852f8ed46a300c2bbec9c2bb70ad61f6fcf71fa28abc448a93f3f4542979c61a3caa91f3bb33fe11e204eedd61de90310f76877e85b524bd4322780172354485f52a09085201086055c52bd73ad40b02c47b3698905e9144e9a49dfded518a0ef37a520a9bfef59372c02dba4bac62f4374b6625eb469488ed7649443d8c65dfa500efb140eb36863bd3137499fd616c05efe701d8cd1c8e69723dbc2295d6f07de775b54b0cdf071f693f1d84d64a780d8ecc2a428c7edd3abd70454370894554830b717cf58dd1d4f0d41390dec230086eeea01a08d20cfd4bce23411fe7ff7a9d19c8367b53157772222ce15414d372eb98356372b91212e1a817e44642cb65dc284f220f4347f46aa49c6b973f29e3d3ced7922f7afdfcfdf3fdfcdc8c68e685ac64b189f321c4e3a8bc52918ecd29ab949d1f62082bdd9c48a4a4afcf6cf807a737b9d9e3f9f993e5569c6f3588c7d625879b5573c5dc06510d56fb4125679431825a65f6f31664d7dd02795497382823efd8aee07be627d7fbf341e9eac6a727de1d215ceb305656bd698797eb8012b497a828604b7cc3ef68886856a40d0fa60f631251ce4cbcf728c824a7f9206bd8f782071919a7dbd9ee83d0c30a1479d7c536f9f864aa7a0f9b3c10909de58b910a47ef21437237cb6da30df0df3ae3259167e47a1c5753d46fdaeeafe4e8fa73499054ce2772b48f31aad77bd7e8a841513b7df6ef27332104cee486de61a735eca4cab499067e8cfc302b4e8a06000f1b8701e995237dc240944439f5bf2290423444f346c1e1e8c81264ca4ce74983854e4e39ecae57b3001a24743f3e5867ef47ecfe1f5c530f7711f7f4b381c21d0cd85b5fa030754cfd805dc97cfc6867ea12f719200bf6c1901be406ae56a9c4c28a92d2c60618ee6b13e80","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
