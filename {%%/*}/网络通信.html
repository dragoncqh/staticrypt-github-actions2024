<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"367bb7bd87423035d4cd493febb53aa7d5b7e4b7a207c714b05cebacb19913e52d5a6c40fc15857ce7fd3c2214f47021e9549a210a2c27df819c7721322594dbd52182dc9aeb80005bb80d6bc9bf9995a286dfef7af7970747254f5ab9427c39f4b849acfe2868b4eab254ac63a98c734f0acbf07ffdd609477088336253e8870b1961734595c4bf2e1a9fc03fb5dbe31577c09d57eee414d40b75fbaf433c69470c06763987770083720a1f368485fb8f4853bdd6124314059eabd635cfef1bf4b2dfad1f14dce4c4ae8f5e02e0d890e5e7a87ee45c1774a79de60a17472f72a666772e2bdb957232f37a405db3b04f335ec9754b4e50e2f2eaaf3e209482c6d9725dc15106d6838a6fa7ec7602ab006a1b701592723dfd1fecdf86f501ad1c91c6592103594d2cf943b062dfe3fc8ef00c4aaaa5aeabd36c6133366ceae1e2d740794a89c7d314a59e581e9c0d67eaaf960981db8911ef9155704a09f593fe9a9e4c8d55bd249777c79525f6afa3d70afefad73cca519970b170b69c828162c6fc4fdd9cd555ec879df8353285e5c2c8470d952d4562702459c531d18e4309a49cb841dddc7018b3885f48dd18fc06a6e95ce45f25c2e27f54193a6d440a0b02f43bfcd11cc9454abedcc5370efbcd26f10c6c44c5aa6e925fc561eaefb99bc22058a3be35bd1882d6d2a28689c6752249014fa29174101aba89709ec082881db4d576361914088eaa88fc61351708687e2bcf7da0e5213bdf5f4a43b2d9094bd105baaa70c0dbaac97c29cb95ac0586ada262c6aeaee6a450f2065b4c87c14738d7f63b297d6733b8e295df3a33a885077399d713e7236fc9d935d3a3cd6c23d7bb0c223d0eba14bdc8eddecc2f9542187f1609ee7eb3b0a829477d970b0307d39368473f3c9ebf8b51d9f511139828e735153090cc67a95bb27b2872723d2e20318997036f4b00bdf4a624dd0f9a8eb24a83cd511e3042bf1e356a306d829d1054bed10bd7151ccf33489b3f00ac5060faf8e89bcf65a026ca6f86bd6a2424e6341447079ddc55f2285830233373fb27eff5bb8db95d82742221e86dcba364d9cc4ba738cc57258494996c947d0c62dcfa63113a507951343ed7844cf667662abff8eb0f8f03687badeb9637d489383a39ba8f0ab35e70476471f52abce20f96046e74b42b474972be08c571d860a467a014d7017cb1ad34b9142752896ffb5512da029cf055974f7eec31b2a1ecffc003eaabea4fea4a78e8b4a4d848b9a9acdb5350fa5627d410ea8cd11308b8a77dc0ad4db48d8c43abe342e52997537d6ebda182d141ff084ddf90a647a26b7f92a536ca389e880b8f14e49597149e26add9b3492f5b5e360965b7518130a6417f2fb74153dcf41ae56ffa1b51a12133dcb4419656176500dd734b0cfb6312af4ecb6279fdd30c0d652a5efe9f461aeb45a0a534cb369eb2ef80d66d4d9ecdec96130c1a287c523304a3d67d4b5319079f0b400f7a1f60bc45034bb67c24a8edc2fb7259249f282048248e666b72809470597ae60145f9ee1e5bf99a44b62186c29e0bc42135e946214b50a77df448a11239705363557c62f0598ae4b903c102f70030cd5a405327ce9a7b218f0c09297bbcdd13267da3c26af4f127f5ed9e1a82deb90a9bed7f08816aeaaa7b89726695ff5a4f813cca680c03c62b9c6c1651ccea1981fec5e99cc7f2eda5d36c1a5b0893015e4c2ca6e03c91188a7343b4f24f0f08c702946b4639be5a510cb0e56f1ec20f15bc8e1e72cb80183fac65d30d3abad74966f17f16a6a61cc4e340cbe61bbe3ba256f3b43ca5f856410ebf54441ae1c84423dd751fbd03ca8e20b830551e543c7ea6d6a7cf5627c5df76c69a20d8c9f590c0f3519cebc97f7c81f86645dd5004f2e201a0287b571b8246bf5a73ab2e9ee3c9cb738022da8e89d2230632de42316978d7fa35c7f17f7f2eb7b40fb9d44b89e1c88b09fdff525fa72b7753d1a6708b1de00332e125a7a3b299af41380b6cf65eb40b33611310f5af6557eb53c276316f2b9401d5e58aea70f10a22f84acdb7eb8a265c995332dc8cb09ecc84527ad6c796013f376f777c592b1023177445b9d6a0be12f5567fa643973f5cb85536e19a02edccb047582480178d055ee4d22e4d09174363a1c7fc8a91b9d40cecd306545e2833edb3d255edfb65a7c14c5e0ecf2419649e91326be441773867a315ffd794104402e35f22767e45fd35b21b7732f03afbb9ba8b7b23c31eb71eb2ee58459fb35af595dc2f43a62be501096e9b20c8a2f95f0a04b12eed971c2225170c411f2fb59a50945d956dd9debea5e1e9c781125d12df41820d3414c46f147cf1179a2a931794684b6d009c0097aa08d2b227cdb7d1cbf9dea3b9af46d01cd81aa5463698793e69dd14d1d19ad4e4deb476820d83cbc72633bbe87883c1a070df39ed67a9e705a6aa2428a425bc7856088f86f8a07e3432cc798f3a72a5636d0ec2718098c7e1a8dfb05a5b38482747d626523755d0650a9e0e5d97f1d7e70a1e1c6251f764f457c02cd852fdd63551097098efba915fc2120d3a74991c66410f0459feee5ca3db758f997c7f44a05bf57cf15a0e0009502595dd715d7bb04d26dbcac099e28ee98a7ae4ce33e3c165d997f9882dbc62cb026b7ec0f5c8b59d7a5d3e182c8e6e81239d8eb816e92b0b5a31a3591fccf5f945710be7d63680199f7f85ed47cf6e1151c12c6e11931578c894e73232ab6a9ab46b7c9b3eae34234649bd3674a7f099ee129ad7e625b9a31fed17ecd490ed3c6649831dd49681414fb56779fdf2676df1730c23f652327b01ad6a21e67a82e5aff5e275f83895069780dcbdd209a47e28ae5eb8f1bd3cbd124cc98abcf378e8d7b177fd8ae1b4275c8dc302a619c46d060f7c0b3ebfc5701f921263046e41dc5260fc67bcadd3cf2c63a8d73537935f77d905a341998f9de51c4329f36081a30b28d9d4ba3fc6d56a1dc0ba83dd0fcf90d67ca7578aa7848501acfd39ca48de828ac0285a30e9a456efef7746cf5dce35c1e314bd93fbd88fea4f968ba91571783904d9569e608f642fc5465f01ca08800f67c3e54a3479a848bf6ea33395291494b83856300bd9e5b1e219086c95fbc12623dabff239af7d39b9c666cd5d9e80dba82cc37ed25d17ed5da3ddf3dbeaf2789f8390e235c2563c7a9ed057ba1bcc4429a6b7a15290976cf234aa81ab27ecc3c620f747aecd775bbecd36f1eccc63c83f7989bd34356c9c1f34bc6123c76fe1e67095053787a582bfe868af4525324af0608d9e1f203e5dd4ce0257c735357e929aa3ab393e0e3da51c45f26160cb153ccff78503411dee708377f9079c8d51c4e6a385a84a0f1039111c32048c51c04385c1034b61ea4a5d2a892476bbfef11daf1e1d4af5f350bb35afc284c06e251756f8211d30f7029e6b9cf2503b6e74e4b86ea2f0c3262f1bc6cb71bcd9f60d7307ca81a714609da641aef559742f2737fe4b36aba5d43414c049aca8c9041882bbd29b5275668f13b97439c162e64b97bf8d02e32a90965d1b061a4a410b60d91ad8915cdf3fae78e8ae1e1bf9845e61a0e3d85eb1bd807f4fd3221dc49485a3af64cb94c70948d21f2ddedcdd6dda03199a7e8a98612feb861ae70e0e0dffb0ea905f35cf0d261290899aee74b99f1c5a2ba35edede26a2cf54e32cecfef4278815a4e4a3d989bd1cf2c8b4d2717a31549881d7deed423796738a89736737d19cb4871323694e96f922b881596ba45bf59e07dc5fad5c2abb94c1eff0722968fe6445cfdc0457ebc8195fe02de0555053193a9ca8bf125bea83fc3939ea2fceb8a9e5a89739201632d558558147b2573e68b3371a3295e64931763d8819243adfb6b9f09a8fc57dbc2cf0b26142a2d2df7082a0475a1eb666d5e861011d771e16ad1087a7acf9499813cfd72c0b07424de63961c00709a50127e8e17db43c1540c007ef16cef3d5c4022a03d1df8c3224fe0683b81efb1511da27d8a29c38ce50eb3dc7dbd5a779829fda59b2b4d0133e2b308a8a8b6b06c3c5fb0a475bac4fa7913c79ccf2abc063605411bcd46c8941644e14ce5a5c8ea5e901fc2026707ba2f4ec6757231f228c4a39498f369e374844fcc4cf332b9ab90d76e04ac0a8f41d4b143cac9aa861d2f41e9a79970bb904f6354b289663f5b41fe4ce67aa42f55116ebde2c9f2c5a491f89528812e5dfa52597403d23f1d83e5108d9c14dba42f60851cc5e5d6736c1f27d801efb33e9975f06e3f4781b16544ea3e4aa0a6c3a1017989553917260743f96e5382977d0dc7aeff9775a3d0dc261dff7a2af891128ca2b7bac26d23ebb91d3590216e3c2788927f18658b65e710870a7ddaa256bf73f0b14f18cc19aae3483d92c3aa67a1c1a19bc8e5a9c95ad264fa2c0251293796efb4ed310459710aea3f6902ceb78fda86a393793bdd628578b0325ec100ce785089f50fcf431c47081f8419bf0e3d38d0d63c50fc4b39a4b237b3111077e813d7c398492220052146325f2bb7cb248197831faf7b5b143c38f19f8500f88b45109778d55cd4adf208397516dd50fba7d82d5497c3582948214ee1cec56ca24c0484fd290ba537d25944a0c4fe08a8ba944836f322a52e6940d269ba6b517e5ee3f2639d1a0bfe69b2e87f007ca9072903e5be8d36adc5d1d561c032d9cf7c859f828805c64ca34859442d466674dfe01b0a66052715a0050ada3b1271c3fdb1d44bf983e5849d5ba4356fd3c8092debbd40e62eaf435adf0d6c5a76b3dc6c4c52a4175fe558c101ddeaa86792e300256a10fa08a89c246e2aadf49f10d6c18a7261ed2080f9a0e9604636d5fd3fea2ec19808e6ae15e07e04be82189cd3e3c8911b9ace1bf3d2c7eda9f7c1f0972151f92639719b88768dc8d29edfeee46565c3e59eb43481fae9abfa1a051890170b9d238760ae3421cc6e04b7f2a33cea3db0485c32b49d0916aa849ee677bedd2c7485f80d49b8d2fcb38c5462066fece25fec33fdb71593f2c1c514e7f14dafa7c8764309c7726f5aead0d1ece04222c91eab334ee6d895ed2a0515ef616d0167e663a26e4274f93e6162dfee65e7c44dee08f21ad0dfc002de580c465a5a00598d04e39b7fa55fc7c26fa2d202603940a40559509a2ae1a6bffde7e72c27b65cf3d0600f6fd3ed1ada57ebb0e8623d6d116b2cf1d75880761360990b65b1f817355933e8a775a8bb1f0b91bab76c8bd1fdf1491f517a24f36f3168a41ad86068cb0edf8b23611c5cbe9c0477f6b3c41aa9842e03cbd423f220f90bf4d6d0028660e3cd677c74f5595ee4e4d7f870b7da5894488d2da87de751500b0dc2587946ad5a0e94a250bb6352ab0b80e45d72596031e9550f3eef91331c006adc388e25f3409cfcbc29a6eea9f4442f8489bc329e3863d2b35cf18cfe1ed0665d03570219e3cabc514c8c7b2f80af8248d611db59cd7c69ea0f9c5f2ad02c1901e8aff45c24975d2060216a9fb83bb41f772b668fe87a2799a3413366ea6a57b6c4ddfbc6a436dd4657eeed8b8d80ab92d1ef7726159b8bec4382e1ae297a03db6301b2c340de6bafe805cce0e9e49cda83930fd12e1545fe5a709df0133ab69c095b99ccd7e35744a5ff6e826dd85443fecb170340fdcf7ba3d6e0f137e5d5c40b2539a109d190526b5ad5c587f7798e2b82d7812aaf92b1c662cb9a93ba0e19c6e27b453c981e3a7f510ffa2734efa4fb57b7d452889333e9b633d5a9e9e4456787f18d2a9ee0ffee66e23b9584090d782a025ec48c4d1066da45c115d4cc2531b7db575c95f71655c5cb2b8091e15681eb8629155757b9fb640e0ac4a5f4eb766a88ba767cc5880f4d96c7cab6fd3727abca1074da55ebd6b552d80ad4d8c1f665cdaa84694c39cb035bf8027383ed26edb7cfb6d2eb1ae4211e9bc22fa70997639cd58bc1ed10976972add5b8fe559bc131bbd4b06ac75e36b761a5d130092b917d58776f8d8fbf8dfcd72f70171c8803bb4a6285fd14ce7dcc33ef27587054fd92f3184c978e079bc2c225e6567a0ee5e652be86114ed84ade6ccb236afd1c31b1a267a2ffef63cac926389240831eec2be941480fc3c95d8fde5f226455ea184da670ed4aa09534eb682180a1a75039d6b4aa15bcc400d79e6e9911b8fa444e4a917613c616dc3db2de07eef96a6e5984f22cb17230e2436ed7719d85620280d4c6c622f011d4172d6703369fa6122f33a2dd9e3ef604a171ab9a6abc870dffde9ae9a8d662e9d78e8b060d7e57383c84cccf9fca83a0571b9cb6416fbe7584ec80d0aab461d5bc94f128c4624e180617ac25f6ca782df803e9fc73e190855eb359dc0ea5bedfc506a315de12062fac931d8171f0c4fceb74af574aa77a9e68c464a64706773b04852a7c817315d0e9552b1e6152db2a08cdd8e9beada9fb1e1db5ee6ccec3ca5970bb28ef94755eea6cbd75e9fc34bdc25a24a81cdeaa94379121897ed20aa72e61517c70b2ad472108cb746e6dbdbc680a28e8b86c1b895f839f1b29d4bf9b0f1e7f783e2df221cd2f58aca1dea2f03b39008559de01e5521f0fa1eb9771f859462c0eeb56853238602b5d3c8650b3b8e8cd850920248087d506471ee6348f29674f57713536fd7c8e138cfd3421baa6320e00d6a4160bdbf2dd823c1eb7a9641f5e76622a6b10d8cf35e659573413c1e535df82556159c83c9703c31555a97641ec5d03520f633a2631a775bc9676db1b73e5dd01d4497262ec88c710e735ba717c6a70030cc5f81aa3ecbc2524dc2289eedfec4069d67c52dbc572959d19fa2a0a72b8590b7681af22607b3bf13d50fbd2a806cfcf04159244c2170e9355a15c64b09490797d35090b157f05f7668405ad9feb014caaceb41a8b00fd045fbb4072b13c963c6350c6265dda0bc7cb52dfab1f3bed89b51201a0ed07e90415506e5efee0440722c38cab81f878ff438ff08c4b9d8e24ab48272fe7d940549903586763d74bcf79c67dad4a63a8bd6287b3a62339a0f56de82f8cc908b21e655ebceb7e94729549f9837a1ebf8b4833d4a309e929a95dc34d880611fa1b571bb744bcdda68e8a6312c5ba958f048805ba0068e9a1dd67ccc2ec2fd02f3f6c8a0767728662fbfe08e9d51908775dc6ed70df70a1d1ca9dd804e78521b22ceeb38eeb3be3ee70ee7e76412826f97d6ddc8cfb9a01978435182dbb753e41d2880c1c0e176a4cd981bd7f2697ef4f24b2e6f0b6e7484cbb2aafc63781fc13cd14163cac0364dd771db55a52df2e9de48f3d43075a9f148e8056061cc6b812a09089fcae4a3cfdcff96bae703c4daf5100803d785ddb12a7bf07947db5f3306dd4878e8bd58b1a009db05bff60c25addc42fcd176fa8af222a53f9f5f6adac08adc2584e1a170f536161cfc6b43945de57a8311e1ee05c952ac3f3e4d4a64dcb17d8d3116fd335be8e79bbee0da6e288bae0be3bfc868be2bbc8c9d4577952dccf772998f798173e2de0cf115b00f4c1e3bdad8e069ac902ed4c45c946e90d4c6f157bdcc8b7989fb34326f47fca57b8d80798d73591d938a43035587c7a1b6564e7291c2342a344b93944f73f1eb0a7ac41102aedb2f2db9f44512b9de5110c3a2984ee08ff0402d465f83e22969137cb38f86709b79f9f7c3ba95bb143816a8d00084865e73818b8a2c574123d6e3d2d696fd307bd0a8ac061e831d2e2e45c037dbb5819ab7b19f80548cd825e3436bc4a0501d0aa89ceb2e0fc7f86224df764debe462507732ea94b65be0257695de95c9a40920a3a5dfc0b691da5c5cb64c952bd879cce68d27c2b8db166f34e2decc5a0151e72f4f5189f893d006312000472f880f871563a143e16d0e3eaa1273822c143d3608b8d94ee030ca17287173224c2fcee39953b6b3f2b5e217148bf5627a2a4a92802548b9756b59341c3d7dcaa0a519ffc70da8a86c9000c4746d345ec967b736961265d4cb6921572db8bffeb2522a08d250a630497e2a82734582e174db09bdf067bc8a6066b42f8f9eff070655aad3af90c03258979d9d8c42e048ebe7a6fdc86c1824142c31ce42563874fd61aa7bfb780abf7d47a4c82082f64909df2ad3d832ae797dfe3d62e93749446b0d0dfb5b39a8c53f437814ce06306f6da3f7953f889f46f98837d0e639c4cd051bfed136b605673530a7e6db7f8cd212f6f01ea5f58bd256bde91966c24139ecd057571287d98b261f9c6da4201446f4fea36199e8f0fb84b8a24c972870cedb4588409ef7bf44acabe6a4072591834ce147e8a393049f8efa8164eedce9fa2c335718c75a2bbac979bb30c5f37f85bac6998112dc061af5a8731ddfde4f13a2305698872c855cdee153fedbd29796539e11482e9b718ece0bb356f17f989eb6349409bade7c7c7e5225de0879f96c1e91e7a029dc88aa3cee3ac732e39f6b6c2bdf9b1ec099f8e74ae72ecbc0157d7c5205de127c70dc656fce56c77766c56302c1343ece0e16e6edb5bee09cad4e37379b8e7c0f5a56fa0f5f270a90efadd54208bface88a618ce8f5c89e915b9770dddeb4b96e0dd06203de960f03c6a589201aa260bc84094980895425953f3a31623cba71e079c5260503799cdac3c952abd823fe5e8536b6c45fae1afa5efe4c04047917d8f9e06b43b3bfa63bd405ab8e9b44028eaad3a95016f043f81502a668f2ca2209ca46c6f3e1625ffbecb7757fdf3a9ec93608164bb2e3ba11cefe24f852a683eb7249f765a6ff5a9a01de6850682f3f0c6fb0bdb5911f7757ef9e9543d2004a62817907a19a16dc7a45c99aa696a4eb46103276d1ab32aa79efd2351f5794b4b261e69d0cc78aac1aee9fc405a902e2ac99ea9c544c25d2e9af38d0d0b799d5aed97ef02ed539832a2be66fa280ef1b239e28b811a0eacc041e75662192316d5a949caebad0f477247ad9130b71ce71b2b6e3fbd3172659de903cfc03fc18745f6c6b0eb54122d5198bcff41e81861b42eb6e4aac2f95fa58b302851104c55a539d7fffcb69a4fe5a7baea041935c2d5d334b974ad72fe3066cadb7d9493c4cfd797bc5e2edbfba465519f84ec560dacf4bcc2185722d1f368453251f873e66936247c23aa9a9e3f607f5b3aea0d61df732964838ab50894ca4e6d7e8521be13946371e88f588a8ccf2d54ae584750954e4c64dd6d02cb772f8475b2c26c0bc4fb1ea11ceeaa432c00c1d66616f0fcb0ad11e744cc805a547cb0871a6b13f679d9ada20e69643d7ea383305308136c39ff5d3d6943d1d9698c85f443a6bbe2e247ebf9fe120c92e74d6fdd1fa4f9f9bbd2ad1c5525997f56b453871b78d336ed9bae94b7a5a1fb41853fbef5c16a09a9263263a00846ec61da760a771c0f16422d3715d0190d2f5c5c74aade461c2104900f246d154d1450ea5d45ce7e5c53fc6b3514ba8388fdeb52c4343d54815173c799498483e95eea7c377caa76f013b68ca29d6649ebfbce68ac8e36782b69e2e5fe349c092da0e7f843f9770f50efeb34b3d64b317bc2ac04a84a57d4e8c3f6a556ee3d61a0b7b05379dc648c22cc20fb19232b81d48a7534e41ab3fec93ef0cdd087b2af842b4ae3daa564ff1ed83ad83faf37ff838c56f671f208fe805091f5428d085e9783b0572a646c1fc60b4974915e24eb9ccd1f89b46bdbeb5fdcfe1391a1026bba563a68b8136340ca570531278583d03c611dddf9577cf81fc1c9f117fc4464aaf416dafa49eb769411b39c39dbce87a976e10906a003a41fac58d3f3b13a50c05465bb4807be641b4c95359301b8dbe5c74720e51a7aa643d0645e899d6140d11084029fb5555fd22548737d3d4a848fc26d28dd33715c5bf5245026d8da9bc0bee2186efeafe8cc6f762aeadd4c911260aac9f5cc0f79bc3bb7dffb8224f77ceb260e4611964fd5949fc35c198c0c93e9dcbe80784967acef5a4d95846fcecd8e447db8cd57801fb19a905074595867a442ccd69ee6cf5cba0bef4bd8a01df94915f1913dc173b08ab16185a7f173a4c97d929a22765e08b450cd6f23f3f77372ad6addd8f61ac88b4a6a2a7b21676ab17c4f1227e0adb71630c45d212a56e67028dd583a22a4689e2c3e9a6c2b8bc615654e519f99b5e1558094ba9ff151d5ae656244868f1489b23aa1bcb252c7ee5b38a03b0d196ec00711f97885d888f3581c46239246aee1c166f552c4bba31065a16904865fe3adae49eeaa70ce1df164c2921ae36836be7cb14ea34c098e6e508d945c9aa25d8a4d813a9a85db5be444e71cd0da2656aa57f9862633aad13e5cc6b658db7f812674e5b94b8f6d8403a17c3d6759eed48af9692625cc0eccacbb6937d42e61ed734fd6bf69751fcce52f9e5f7beb62dab1aac0cb5f1c019a2a02bd5a1c183448226389b452b4af51db3d4e2ee517fc7f9db295940b4849087da77b3586c7dfb238cf36bbe8f1905f460e7955c171be5b263f8c87b509b7e1ca7d4e1cabe11439c1461561c23d008cdd163d6341fa8082a11c34aabd6273c6663fc4b13454a59ddddde9b1129b6ebba5764c7a7063ac767d9a6f6b8a5d89a195acbc6544bd0ccd99ece8ba528792c795d1324febbacb8b9dc99691a84a522023523e3d2cc48ebe87ee10a239a856d49df9b00a79e4c3f88119d4f06d70ba71cc15d8cf4d7720a917ee877be8f8f906da49f34a11864205608c5ea373b07e6a75fb62bb1d8f680a1f0247d3f6c9ac42efb6948a61d0489c0d74e92b0192bfcff6a0211d19c4fae1c0b86506525fa751c6921adaf677c89e0973c7dfffa4e94c85c9981734c4c4fac3003379b281ca71a589f3356d31880060c08c2bcfa69d6f8008f3a420b16faf74ff3d302615e3b1ba1b766f9188db07f522ff5e58ff26faf423786455950cb51d9edc410b8c5b1483d36dc31b41e11ea17041bcccd88df4d4301265221903fa80e7b9e4c462ed1792a4b7b9bf940f811064e2e91916e265461f99525e90dbc31efb39169aaa739d1290aec78aa7dc91e223701ebfe955ce57214cc916bb6b6816b94b25b45ea29b102493ed5baff1a6db89de02dcfb60f9c2dbd5e3f24397ab9218c9ef10f1b6db4d410ba009687162ed9e930f32b15ec83a6a6099af783161efa0aa1c12295b630ee112441a6188e36ef53c97fee621d7d05c51d1001540836d3994aca9a2a17f3a9bd1b0df6bd3b548bc8796f2d37d9b09454c2667da710bf06b3a3afad625fee6547c13c9d86bbab4af33ce8e8acdaf7545af10314594da13bdcefa448f8139a184e6ebbd62f7b74927a14119c5a1988f6a4b801b8b43782dd5b4c24e3f5a930340cd17a6ab2da255ca45b025613f605436af42ee66186db222e24d0a942e18eab4da8e1caa5f6808607b4800ffd10ae4a2f7a5a3422854b69e1228af992f64b5b5f170e0269e1b408306df0f7c18dd073fd582b527c7b832dd5a141bcc16b0a7ee80571e0786706a63b397655c2e175721502f3e858f4af7184e8dc086ed8ad481cff646ca9a296eb4d9f91e28a9544bfc6a9463df3162775d9774ace244dce409bd1ce7dde2326291682bcf03bf05c067559486bfd9d25211c720c84097dba9e3409a14d4a8e495172e9cd3cc82d37fda44e5a3242a88a1070b93bda3482fcb047faddef98604aceba2879ebbc271631fe964d0abae01a8ff28b57e5e0d571909320c04788422eb613cef3b82bc67e0bd23eb93cbef998e38a36998f8c4871169c2ca290ad80f143f0d18a2b07ba8018a625f46a4ae09ba38bf796c69b2180cf47208aea6390cdf0eec8535b6062a3ae5f4ce3681bfe6f33eb9958a49173568a2fadaf800a389b0055ec3e8629cc29a4551d3fc446089b4cc155c5801c7c770efd5734a7efaa19d60a53a550ed6255bb8a086e9481d595493e3622fad05d8f0684053c8945e9d534e3a3dc9cf0d3c0021c4e1fe30e30957b68bc497e7d5c8eb662b5bb672e1f77db3bc446338e0aa9363fa77ed856b6ddfdd64fd4587df345a0be08759b550d1d2ecdb8086232e1d83aea8af077c62c142d68250c9841458b19a74a210181331adca34f91d3ab5ffb47f08264d012ff0bdc997a6f1a88daf1282339a97b66c2b4af481934153af4c9d9e6677dcd37270100588f7742d780fea715446e79327e842845c06d47ddcbd37614a5fe98f2163f40d1a1ea23a45e4f6e80db4f1c52b6c0b289f0c31ff6234e41f9f1b959d39b37d338399825432866c056cf6e7312395af3bd36b076b036ab289b84425b3589b5c7873d61212ab392e5e1dbff9e31f1af07029af46a1a105466922e7194c3eb925ff33fd89a298ca4cc208eddbf1b30170eeaa736369f6f901b87c9e2d902f34cab0ef1ee90ceae0c05798b75a93e74e0ec717426e3cd8e8fbce7a004c3382e1395d16b30d15c39a97517afd73c15e6b81301c9329015751ecb6b885ae390fbb6bd5915f90a9957084a1ca536c763089db3a7bfcb78fc89af1bd1bae370db419c6080171e987d563bdd2129a96f36582f636ae0b9146cbb490456bb9b124a7ef8982abe24a604f5106523a012be22952358fad7fb10c32b43c24cf343166b195b28090682c7e8f4f21f5f92457e04d32983e7514f1e9879f657856b0bcabf95fc5c4138a131d744a4098237df9420d49b911782fc2b6eb67a1f4c79bf4d7b72a260748e9906e46bd935fb6f770d9568c99dbaa2ec13d37f471f32634e912489ba2100d265c127fe66b043eb6f73b4863f299be28485f12da7b47c3f34ddda18e8c5e3f98de951ac5c46e29411a6e4aeaf9a0d96dc8625b2e215d895bb86312f16d9648109dbb3954f2f720158dc82bfc07657daabda59e773765cc65a2b4cface02abb7e4a6adbd7426dd1941a0f3be317f502462909fc42e1d45d13cc42ec104b80d4cb9817c1cbb13aa55b05de06dce95dba6658470b875991628e977a973b4d56ba3f13e19a80654118c752b78a49e4c64144f7f35960d3f0ef575a28baead99dc88f3209b7aa88a28bb0036de4e69d1c02cf55881da1a52e77bfd248d57eed04f0057d376c6c839a3ccc864b8e2c7e54ed33afe53e4eb3dd67585a3fb49a6da741968b345ab7fc6b036085b6ddfbe8eede7b4c1d58542b6e3f1777bbdd2806db79f83aab3466e32ba5c96f7fdab54f23d8e7e88c8217f4f27f88ba99c4bb0af384758c68b9a9a3951ef3c0aef4da443263479636f10696530faaa2cce09449c6e1b9a50ff051ffff8fcf8d4e2f4ca7c299bf65c58f198d480985348df19cf978338113998539db0804528904dc82e5d10ae981967d80803830ceaa2d36a0dc4bd3162c39d6f4908e97f16b51e4798d6b36bbd6648eac85f9b48dff4fb43de444100175535fd7458568651f621f274f419c10d8387f30d84e031ae009e1547e74b2b55145d406e8f19dbd01757c6b77b080a879da1770f8c35d46fe261478d5de0db6b8f5841981c15481076d1c9aca0f5f04f0fc69ebfaa9f3578ffb3fb735b788c8c2b693b552753f04ceeef69acaf35bf196d16a1d1ad8acbac43914b9274c1425252193fbc8c2c1465a5f2aa85657ea505b80866d219faefb6d7f1e45c540dcea6132350bbcc01b154023806c0648d6ee3b10f8aa380e79fff94e5a5faef8acc5fa085957190c30437bfa7c9f4b7faf63c02f31449af5c535f792fd4867b3db5cdb664cc43ee5f1a7bad414cef48d1d5b0f6832f2f023fa5695fb1e160425eae5943d00f6dd7fc717ec3df1079ebe24200b86d0a5b1b7b5ccfeed4576467883935ad8cf71f78770a1f6ef7293f5f7448bb4dd56de43e74e4097477eff40df1aa8d9f795dd37de6f331065aff030ebb7c2531bd7707ffce3f91d284c6a1341967aa7aab59a9418ee06019e5baf057597a9452563b624c7fe39780936cf6a43a617a28b3c39033069c012ce0a7066a03b385bab1a66b059dc9a7f62263376a32392f6da713828ff7f58ee1a3d543460a02454dcc90164629624c486d0ecd378c972de4a33f7393779e253fa8dd8b6c406f56f1b74602580fdb546d5086551a61904127337ec7bef4f2e00bf9ba080a0228b5cf1e9487f8b6178da005ff28b0e99faf1a3d5021ca22f40f0124ef82331984a585bd40a8d4b0ae830fd2b85939eb93f98eb8fb09d5f3bc8c1b904f86330c240383356e9ea026de3d0155fb85ff680c4c5dafcb211c4a1f14ac0989038b1122248f879001d6ec4c614ec9b9d86a9ebe5b841352a87f830c95ccdf7bf5af0da29d898951738605783e3c459af7038b2b4a4044aa1eb6fa940d686b107170d76dc03fd8205741015a12b92b4a57854e4e0916c93e1109e238aad1d1c1bfc8aad013388047b9e34698b46387525a0ef056db4d6ec494e06a69053641a136236addfbf5a78e941e6285921be27fb51036306ed561d99878422d1f97c1bdba987ae705d5cf7cd4006a0306d4c2777fd7cee863628a1e7f80fb30c9cbc71603b28f4a2e3084ee219e229d4a2fac58b0097dc4ec1198084e1ffa2ddc332059abfae942ab6a4baf1d44073760be02660527053fe184f4cbc53bcfcedf5b529f48d0c48fcd4844b18d704a114682e8f51881d4ed51c1fe595ad2d3fd56bc69dc9dd6b8a478e3e079cfd30d24353f4b518d3da796cc83c2cacdbc02e82bca9606f9ff303dfe349b4008005a7b0ac37dfe34e858a7e32f74f19a69f0de0991c37ca0e1f9effbdc44ff70cee11eceb2229d01b7c6891bc682945fd7eb15bd6f0e1d433b4db43128d23476b336af98c2eb3c97ac7a330e8775af1bd10aa559639f97fc74287b33b878a2f46d20306b81c298d2dc3391662d478a3f3238b14a1a2fa3842701c833d0ac1a17fa8bc0e719166fb64ffeb811a0c305f4e975b3d3c20d47efdfa73aebf5ccb5ec91dc211844d461d710fa6c05b72e9aedd41b6f8b5ff5ca8cff52f9940f5142a99f747841fa77800eac615e517a40ea8a6418e0460562c83b894fe546a7e879d493a044d8b7a0f9f58cf1bfc2b5066770dd6fc82c688befbff3120866b04877352a0296e4e5e48e4c6616c2564605e4a968f2c97d7d1895fe5a5c1f0cdbcca9076631030de2daa0df4fc378d0011b86c34d65eef2b86356c5553ad81c39944e874cbfb7dc2ec2e24bd562164a42b9e3494b512deb044265c01471b31d0e98de52c2c7c914257c2245d1565e243fe8d844e538f6dc814978b637df047a7a57cba08664a23eb6a647e17c4d018844b2a1914dde799b27727979d341f1a83741d29df73d0b917054c8d04e6c3ba71d2aafb0ed23168430126fa49be570be1db361911ffb65c8caf18a2415290f6fd2897c6c337540554ca1d12fca339737a6d0102613a73899bb7b6d80d0d14d466bd641d9796275d1a39d2e6324dfe85eaaa921d0d6c14da762fb592f023a68e7b15acc1fbe2ae2434eeba64cc3fdcffc5c348f87d72a7e350331a5c5dd453b58342213145bb521dde74a4649b46970d2b3a07845aa3e91f1e92c97dc25ea56c0ab06aa9253813036f111246f59594ee3ef4086a2e05977fa3588b4eccef494811734228adb3053adf3afbb5e67c0ee58ccba60c759fbcd47e24c52dc4ab0ec10bf2b5dda33c80ba04821d38676065291319fe3af8049344d4bfb8ee785a96b506a2e38c9b04241d05184b36f4b8cae635b9ab1acd085dadaeb881097e492972f5cb067988922bc8f0daeeb44b734179778c507bb7bf6736d843e9c23be6e33bcfad33e902aa7c01d092e16c6d1ef583dbe60bdaf66bb4c720fc953123554002b96c5998c741aac76fc4012e2a0c4d4c4e02a164aed906f084541c903286f3dbfa6dfa8f22b6f5417b6466b6dad7513fee92e2b5d69297ec3303d232ceda6d64dcb2ef88c30367c355510de554423d361eb24b8bacf016cb2a5be9a839d4a403661596e490859f507b45594b50dacf85bdff7c99e875c9dca0523c0b3d4eb667c0eeb5bbe992cefb73c6d9cf548f9eaf225fdba434ab08cb535e2af00d306f05bf011db3a1e2186af4cefdce2ad259b558efc6047f165731d90800696b53a991843d0105fd0b44c7b1c338eb71f98cb223f907931efe868fef31dda318f0f1fcfe3482b442fb6f374b8a6e42522d8de73e2019c35b035f7b3ff36a3c311a9586f1c91e782a19777b50b64bef78cd1f9c7d40fff845b893cb21674c3fff9a95bbfde354b13763db3fef9c4fdf587248fd1080ae0a5876b65831537e349bf89ac79b413dc98f79677766ced0baaf6a706ed34eb24a521e5f95df5f527e37a3de384947d3c68c364748dbf9fae076d5abac5c0a9d4aa115dacfd3fb46117c039f06e4dfb027014626a983c7668a8317f0efa579f1c742078dc624e173aab5ca0b34ee6163f80a7f4f81a398134ed63e1c8c42a773e900668809e2a2898bf80ea8fde58b1ab215febcc88861be4ab04f5fe10623a8a1304262f125239d5b03670601dc50b05b78245f6caedd080db05b6acf2af46082d30394aa769c26b41a529dd2583d545c2787d3fc6dfcdebb5f65491a34ab5bf463c9abf39d08aba929a4c334708eee61821ff7f189a0d5023d47a9725b4cefe36afde1948a76634a37864929214e667c63e785a614ecc2ec45bae04c811f450202aadbdcefa99c718aba7547f9731b050f7292c4256e0321b0d54891bc2f1e5328ee97ff4d480b9d689bbe6fa4bf4025dab0d0de60d4bcf0eb3de0f19daa81a64e3211889cdfb1b8f89883992944381b5a04144dedc27efd842f0cf52a802b67249417d78b2100241ebaa3dc78ecc7dfdff810dc1b7bd95137250f4f2af46117a8fc516478f5fde5a8eb154ab3cacf0827921278ba640aa321f308279bd372e10c4206eace0bf01d17470f234f8ddba34a098837609ff17269b9a281d39b9b023b3b6f1ec2d37419c9ffd6b7d28ee723fd0ad9417b2f20b914b0a93da847ef176c58ce07ea6ad53d2ce124572143be73e4d06ca02b6289fe2857481a68d5cad0e14bd2b67195a576a3004ea6d15857e54d48fc9434a12c07651ce13441017c32023b0b7bd45f174a1abb572446e8a2dcf2548768b4d91f03c1b5fee7136746cddc20838492b1e80bd5640799263984c91ef474dd350ba805b2462f5d631bd44036f0f32628e66cf5f78a73c62c5c204fd4999f4c1ac2a59e3e57a1196cb6da796a5c4923ec8d2b6bedb94d580c486954b4321ca0a848fbe43f441a3396dbb9c428cb5599f515b26ac727fba5996af987656e76b5ec34edf5c3917adbafb21b34c70cc71c2b4e03eb595661fdc613b067a263ed6efb3467c71e8134629cc36053a0f08fbbc528c922497db7c8176d4a0a34cf00a4c725e2bcdea8c738dd6b661e8ef63a7f9bf4afe5971e51007ceda1941330ecd9438e909be1de688c3c495f9617351a3c07408530a13237c23e14d55fe22746f7784ff9137680a75fbfdb71770848c879818ccf15f5db57c561cdf861ce368b85c98f383432356020695bb46e2ebf76a923c954f087cb85dd2a0a481fb9a3b888711951a072515fc1d50d7426d660200a5beab2ff20e28cb7fbed5dbb62cb72e09a76abc6ce78bc53f5dabb38b0859138f637538db09a99d982cf013427176314ebf1c556707a66874829988c94141746aac2336d1e6db559eb0e416badfe44a793b5ec1199074c1fef78c2628ed4e35ba4d9785a7cb268fe5ad03aa07e561526ab15380143dbded6f4595fd431bc70b3bbb739370e5794f9547b37c8fa325ec9baadd53ad47944b8e648ced5689a625a956b99acf60b7a05b4ebdbd1befc3b7223d57ec1329526ae85978fb3b7f6dbf8295ec590975b369e1305a3a632b57d364a2dd6afc78b5fa281a9dd76c72efa88526cebba9e86f714ad2a4d0edd005838003de0d78afc8b18a041bc07b1d300e74d15384fd6afb64e855def06b1427112b832e8bcc8f8b1238c5e89c4dbd0066068132aaeeb832debfaeeebd03f63e6050a2ea5be14ccf926dbac412dc65b5a0ec00378745e7e156ee9ea8d38b9fa958cc3d32da4ef1d971db808a973494731ea881191872d5663fa4bc8c0455926fdb013499adc382c0a0f40f56cdd48bfd1482095aeed18dd81fa4ffb844d4c82438bb9ac264bed282e70d2cfd6dac2d47ad1e60bfd4e13069effafde7f1c2c2540a720cd0d000420913cdf3a8890d18641f2c7829b9a52613065f1ff3c28fdfca6fdeb4ccfb8fbf016828ab3b8c25fe5120255f51f3e877ecdb6ab9a50f63313b15f330284fc0d556cb7ed812ca8bbd54b48e3e5026d6f1671abcc91872db992fcbb5f3f15222e4dca9767a3d838b68b435639813e29ff9f6b901a8857b7626e7f2566daeb9de53030c917ec12b5f85152bf72c05d22ab0175c354406186633477dda0e5ed9d7b86c5a79a7dde8bdb5910ddd2d75abbaa6491fd9447147237d86cf8069b42553d6c692f0413858bf599532441ffdca3ef2052a2950b9b8e3e5ce0075e27c40d3abf31d601ed3b8760734c931c98c59ae686e0d339b195917d9f1bd05d5fc4c44fc6df2fc7a7c54980680e3ce1fae97c2f9465796da211380740b09e03587f89677161be971d2de3f68d06c8a7584c49277dedc2afd59b33a981ece6a383efab7b273a1b8166a75688c7ec8b898660655d7d450530a106eb649c0b673765879b3decfa6f21bb39ee77ab80c830d14a4f03e3d6d47b88a6dbbbadd4afdec4fbc8cde64392bc7201f1908f9132847c982531450c341c5f4ec2c5be79e87bd7e41afc14f9445fd06af99503ec4e3ec376b2ee8de6e2cad7d36899a11d957401da056060dc2717d97846c98fc4ec3edb0b6d008c782d04112a9e615b0ebd84c06eed943d5e3554431b6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
