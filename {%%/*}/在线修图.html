<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"db5139db20a8137420ca866f630269b02999accd705a676577d1db0ac424b58dd120eb31d2d8bdd0c28805051145f1a1841f545d4916a22facff64852f043787273cbeda73907cb58a7a60a64613d68beedda61e07211cb4bd3769df295a24fdf93d24748a155e342027d311dd046622565a95f1d043d76ca32c3831b6a6e12adbe7497c89c053069d1e7436faa35e611aad83e5df2237daf9e63951a449d3fcc27b8a64a7347237f532d5abb8ef6c3d8fa0e9890806770accfd18ee13a7db98ae883523d84160ff63165f896d4e374678505669ad43f290cde44c3e7eca587bb8fb3e549f9f09579774640fca5b5ec5b8c36a567a94018f244d4c9cdd634a4f0615239d923005969da7a9a5a4fb16862d99cc9fa51cd4624119a245c0a5133755f5e07a6f49f2c2739044aa1b7354c0632dff993035fed45c9b000ce8b1b8de33d8148d47d34c12a7173eeba75ce152ea8fa54be8f4bd4012a10dfb732b3b9e1e9a43258f2f93611e80fb089e7b52b218006302c4343cd51ca6b37540fad4036896e21ac15685895662d106ba04800314d853d15b660ba354431dd8dbe617be4981fa421735d3f8eb2c3b11d65c1890e8931d7f76830b66c7600c450b59ef9ecbd28c6fba6b9286485e99144914da3be0b92278d419da59d13b784912e1b84b0e6ca6bf6cf389d49b6d91a9991a643141eaf4b9ffab86d608fc5d93c22564260faab88ef0e155f4af0be2092118f5a8533840a42bccd5c34342b54f88427fb3232e9e44fde26aef9a5e48bb1f30c7550ca86143e6856174060e9fcef0d1c2221e37e44762a8d97ca7adbc94c24b46f22cf80ee773a8441229a92ee960e2fbe0162f7a502adb0c55143548695378ddabacfbe6c7a12118f24d92bf9e7c9594606d7e41a764fa65dd2f2b4bd9a8e41fe19fce47a9d05230a156ce8d76f79fc62f8635bf70fadfa27283fc66ea6808124c72a31cab407050d931705609d41a7b800459cea9b5473f2b749a4132ab0781ef0c3b2b837b85845c53a5bcd9da3db27c1f549a7c354a640d545141df33eebb83e86d445645c6d8caa97089482b3d6b44d2dd3e9046b493edc861671a8ddeef741bcd78aeb4e96f39227eec96e62efc7464f6cbbebbff42548af2862557ab0c56a1f9ca47853e051c0387aba144f6c855793165be41abeec5dbfff0894e52c7aaae5b3c36c8654939f8248229eab7d07077637b38e8f049518ac2152d1f9e3f27af9891601021c91065d43df1492ee566c77bca67f77ade7413794e233cd27f6bc2f16e543f9b680709b256e51d904986d508d74116665adcdc9745a62b980020d7b535d7a722d03ba7c25d5347ac2c24b9ed6527dae4c2f2710eb99adaf4b1385919e5ed8aebc146415eb0b93d6499e36be2b92ac72676f06ac7b45672c18c26c73e96c1b178aee35762cd7cbf494e91be894b1da4f582b0dd5db0f0c889aef7804e989c7a458129ea65d1674dcaf27808d552cd2f0235c0b90bd96e2b89269b4503c0266cb04d6af43fb96448f33ca288d196c9b5b8a9a7823fa2c67c9fb8b94749ecef6bbd6ee0d612f64003732644c0f6e60452ff6a22358efc578122514598d9008acb485ba49ac88eea2118f0540bbc185555b993ab04377e365598261e1dc0e451c1c30656cf514ae694f0d15862c6a4b873b85558c891e6a6a597b6ea403c8a8791e3817f776b35d5e062df8dd73bdcc7ae3384e9e2188fc72a04d724f3c399f4976383582be36abf7fb3f50043f1f604072c9d9ae791762c431415d5cbc1be3ffe3ea26e4f3b2c22e43939b9e9a14965ea79af8b4ae221128c370d7ee2ca4ed667214895f2507bbc73a567793e31277252b29db8563724ff177eb56099f6f9b719d7d1bddcf6bef37ebad023de52e7005f649ac6f7da11dbdb12026b6d2882be979b1692ea9b118b89151854ed1b4550254434004a5a5245bb28525932169efaa30c28184fd857229f4540ce48f7fc18277d51c23f224064790717d1c44e911d1000c2965402f05624273042ba08d1dd5b05214abe20e3581608b9dadcee728673a08453d0f9da00ee6d89a63510d746d35b8577e27b9a615d671f2265bac1a0ecda4d2d0e307f9fcb851aea759a9359caee33da52c5b85dde1b1038b4089dc7e7fc9d885f5a35e691f072d6cf94117ee2b4cc328f53a66dd728c60ef70c055b5d0cf02bf4daeeef8024d6b28a0cc264f561f63f190d4936600b8733cd17b3ea9f0a502fb2f697cc3c7ed7eead3785d72cbf337c9a6ca9de2f0592112b1ea3f7ae4736d8674092c90db7261c7ddc18035ee9db25f334b7575078c3ff90a7ff30cb5c57a64e1702c5940b409dd8ae1d6a6f525346944d2e7b2d4c9b033690e1bdcfbecb88976411dc66f4e0791d458d5efc2c923cdcd3c3aabc0a9655359e5aaef4d912937d7172371a5acabb06dc987a747dfca04df4f79a999f8d5f97511b656f78bd2586119acbdd966eb996d5afd3b19e6ccac23b98c119fcf681a9cc3f37dbc1ad10166381f82b8340551d49f5b3ca0b2dd99a3126ed0f3603cd109475e0ecfe2f3ce852dc8d9bd99b6f21e91a16c5805d1cc0d6a40fa0e529ef705e8f65540c3c11dbdcdb6422b8ab87209ea16bebeb5262874e2e07807fcbea051033f115140588f747ba0cfd88329421114729e3943b7f71a0badcfa0e77eb16d0cd2807d353e02d8c8bea9b238d8b2f68023d9a4e8866ff7ac2bf8c6919034ff87b4a3f6af53617c5cb594d04d1efd86f86d03737bcc0667e8eac7e2c5bd23528851aeff41ee0adc3228e9c9d6eb2ccc0845ffe3b68379b0a0719235612c17b1b99c01e7e8933b1c0b7a7f72ee83c0551dc3ab0d7b39c8716b3cab5637ae6f96300efe8f8e93ee5cad8f2003e96a4954ee375a2c01a38adb85497d3e6e7637f7df75dab7ba6789b6b2387b68295e1edd4907a563c8dd351bf95be92548de34790c4ce580159e92649b7a8776c3f7149edbcb06a4a43f606850cf966eb75742d49eb690cc55924cb672fe2361604295408bcb1cba50dac7a9ca97ab5cd5741022f9003fb86714cea556a860d1a0d787a79bb741356aa347d0db3df1e43a6bb6ff5e76ae5945323f4ea3b9dea3ca1eddf47dacd0a0688fffa5361319e7d4213e5b992a4bd45a9e28b777313012d80758a4e9ca0034084aa0cdfb20a9fba3142785e67799c3dc3a4910def0da982e787ba95f2f730ee457e33dc1f73cd99ccf76ebfc69d7a58bc478df9a2981a6ac02661ef8d6844eb5d47d355c1c33527c297a6fa3c95e054f1efeae7e624ef5c953f9a61b653e22fffe200bef9cc3bec856141e7dae9461197738d93c3c6f975015468bed87f805058b2e4f4ee24418ec46f3799ca8c432ee50b98953f4917024eda0c0b4194791b1e8ce604e7f6118100f9732e45c8ff5ccfd2e304f0fd54e690b5ef47af915efcbafddfeb059fa7498cdf8344fabfaf0f1274b55331ebc13beb0dac1bb0187b021cdf7a7475768c53422380fb6085f854c34d50fa30e8109219fc712ecfcd91c6e922773cd3a704b1ed72222b0d622ce24bb630fc446b1269e76fdc6acd199cc171f5d7482e885166972734b0e0fbd58b42ea1a81cd0e6a55529896a1ef54817780c58ca5db27055fb6fd8ce197dc3aa5554fbd394714b4d9b12eb4f8e733bb30db91d2ad789ddcfc751292060f7817bc0e2196c3fef02b9f4977cff88bce729453c75d9cd19f44616b1b3767157154cc3cdf9741ba2f0a2643468bc20cc8f2fd1fffddf4f7c870fbe92c5bbcf9204b4411915a1f20476ed81dba191c0daf3bc7bc0c9f185d070135ec2d1aba42a9ce2e1a657630261b302d17108d11e54ce1d390a83eedc53ed8ea52be693ef1f9dd4e935d96a2721b7c790a0c156c9dafd1af00d4bc0613eedcee4ea2e3f7d62d83d3e2eed2e4283929b371a4e0e5ecd1635cc5b0a51d89d18f3431132efa0a2682db0e9f184ae8d62b8ca5da96e185aa6739506709d13bf32970ca0add6b4d15aa99c8fddabc3960e9405b82085c60f2ff176b59d571a625acffeea27c4f3cc83e5d41f3f8466d32c6ec42e3254543df1e2f585763b7f47cea5d37a37f36c7752f35ccb04ce9a4e476a448ffe2c69b356f62a2a051250086cfefcdd16c0b2ab96ba6554347cf7fb52b375a1fd0a4297d4b4d306e4eb031c7dc0a3e562897b24122557b61c4213abe35f8fa612c8a5c40099a21e5b7e1ab0376339a38295b23db017a5882990dd4a41cfe2c5989792b1d37675a4ceeb75e33631956207d547b69886d76423b8cbe6a1aa2a2595d3e3d99fb976b40424c7481e765fd8f04fe85c1f3163db49e6b14b53d8c38f04f1399e2f7b00180970b7cda43e243177291e31a04e26c7b2429903cbfc0677f0d36c46e79ecf3bda288515792400cf353a3dd66da51191ba2bbfab32e9472ff9a0424e24e49e3735b70922cf79b79c493283a43d7fec3793679dc559c15d605171be1787cc1c0d47ded1081c7337943596c1d69c1b1fd841ea6a1c3f203cedd9a7506c2794a6daa81f55b11499891499eda1b419f4fd970637ae8c0df72d3f3f3f433e7a65a08e875c209ee934eacfde373b250b0d68c672b5bb566fb401c73a01d5afc1644d319b2f9ce493a74ea2872d45726693d5d15db25ed5a221bc12cd2e207cf086dbf1303ab6e70d94ae09a2262d7bdab1f11550a133881733c3df593f85a1fbf145a3a11d1a405ef4a2acbb03c385dbd121645727576f00de9bd15609c647b96013a33b7da7bf1bdb57c383481b133036779ffaf50cd71db23ec78eeaf76d7421be8c9184b4c51f905c34cf5cb502de7b5e74e20c02203274ad57d72cc7a5ce6c7c26b17b827c39522f97138648f1aafe39e3178b4465b14b540a16508e3e115ff753be5935d1b36e73b13bf580ad72be154e2860ec2a22e0b3aff5cb2dfa0a69b357e7acaa600133efc5a477088f052eb6a2eb0678aa199fd255b18de2572d1680b4bdff6c600170db73aa8ba04cd204b59dad04a897d65d768db6f362a3e62b75f17cf99a34cf7e9f7cf3242352a9750836eb22ca3e27a5af09c142f98607955c0759928bd72dccdfe0710a7a5b4d9e907f5746c96d95adadf479c2147426366461f26387b52a800d3c0e0d1102fff82496a9f5debb3f00e5ba5e367821b3ed901ad87fa1bc921ec1d23083f694a3d9bc69cbc74556fba3831442a6347e1594803d54fbd008324a634bd6a4da8355b90893e519cdc41ce1a1e3cce58fedd0bc4e7292b789eec2c5f8130df1899a05ab5a46015a7078c543cede8f8720b16a3a85729ca0d329604692158ef79f2c98bf41de22bc0f8d045a2c5dc6e907662d54652958429676b4314a8376394174abae2cdbfc4ab8745b01f90b7544877bff632716643787e6681d4484ed8d6146379dad9618a5e36e9dd9482c582d62cf73e2b2cbc6bc5920dbd0e5a7c2d05d42477d060d9dc5d0a16809c917435ba0e8f9d76fbee138c2041ae5530031344512e855a8ab98d58c5803fbb6f40409b80ed1bcbab1faaa6f4295d553770a13666eac576614c84c7e68fda6a18d5c0adfec21050562572c13614227e4b6e1c07a4c7362de6c349df2bae7e3b67a53b294baad9286bcdf48d4ac0b7622e3f13ec942b9f6a112822f958c293c2d24517333d614ef7bc39cc456535ac09de0e23a48213010791b3ef77cf98e90184509d44a85cdd6cdb64595792dd75f5949fca54a6681304216a3baf1c5c548d8c640e25a2440ec1dc31dc1cbf5979c3651615608a6e0e1bccc78fa2ebc16ac35c9981c438ab0553fc81a0fc37d75811cc647060570b812741051a8d42732781be6860e69d068fedc3e096321cad52d38ee71c5ce1dc3e9c436464d43686abbcbfe255204f2b19595d959007999e56e07d9153843807a21746ddb218f130a03bec51bc05e227a60d51e70eceb32161e50c843d7b8a907be8b67889078931c67d0cbe3e19595a21c0d18d53f85ed08cf7f7388d131f6a3a0abd73113d202a6c6cd335203e8bf5541e4ad53e4862c0a7c508d7f5595ec20e06a63e76cec1c9063fb7e25f392b698823eb1c82a8019ddcd62b278663960f013f69394a0ac79e910ed405308ca7c25f993fc85d33632c4e2d18580939f864f6f719fbe5e78250c4cd65ffce8004fb9b7c7b8e1abc25fbf0c7fd734caa70aa33330700579d9300626c5c3ed612d7913b5cb77c03fb4c7aca6328dbf893c06dcd24e23224d436608961d3f96ef472332647e8bced3d6e750507d0daf16b6bcebf555efcfa4a20beac1d2c2d568080bbda9ba3f53d197894b45e05e9c53a720733112c48580ac7753aa8bd24d9999c340d5b43f74abd5d0fc75e8dac689facaa932b11df51c8551bdf28ad1b65a34afe97393e4108e857e354702da8c4dc0e022a4d708ac75418bf0b19b494fdfcce27c9cb7375f004097a979081546ed5ad3241b08823d73ac88e05a11a453c770a11041295a2892941ec76044ba9964530c9d60316f6b6ad0047c674542273e41adcad2d6b12cd9e6f20bf6a3d74a9732e00c0e900954f7a848589ef89a2848b70962d095b8cf535b96ba110169b98e7999afbf28af61bd07706b98d275061ac5bfc3ecfc8eec9587f86875c87e46dbc724f597b45c47b3eb811c3157653454d890dc4f1fe8cd6f22efb2cd866f956c3a20cc86a17bb413fd02188a568a80151b9455829d042c9ae5c45923a8a112a537dd2e98433da9542215b5878444348f31da0d07e5eef644c5c95af85bf9f0b0ef451c5ae8f3411ec6c6202c054c1c7f37b942f03bb5c10c802c9ea1e803a196c6a313790baafa1f454e49f4f6b61e47a611a7cf55d401530d5d096a0844252bf284eaaa127c8664d561d882946d594d01579584a57767470de73cadfe1a82157ca91fe993b645c1300cd0c1100506e6e049872ee95a73e9d257e9fb215070dced8e0d5a4b7b9f2ab69ae0083f30b3bd018085a817733b39e148017c4e1701cda2ab709ce18cd590191762d4e0fe7af98a08b600d09b036e6205b1c758498ee2add1e10f1d5d03f1f93f0a7509c3e0dc83be35496cf0cc42e1f49af86a221b209e5e1763eda9a85c4fb54a3bb5edbbf3080e71f53c182035227f6896570f39d3ce8c54b1c1048e2ea0b6d9161c25bddd592912daad95cd79cc3c7bbc635d97a4ac77ee03b473a9c4173ea580e96a7db0ef67020479200294634788e615166f27a83b53dc0dfa6ace26f8ad6414858b10b94f9c885fbb73bed0afe446e24cb6f8207b02fc2ef23945f75755baa00f712aa42173538e0ad351c1833b64f703ea9a1a38ea26b81527489a6a29b14f39cd9239a1da1aeb6ec4c6f74b6d2c6e30cc534e7b708605d5261038d605fff10418cb7cc4766fff55c2fe700f283ab189b906d63a9bf35b1899d11e861736ebe8a7ac2cbafdc70738973b15dd137a60983ab7bddfabb95643630d1af537691d755bd27406b12a57085bde98bea9bea58b98391e60f53d9e0a494447bffde7649d3a2c18cfd41fc3762d4383eca7fb832d5a00161cda0cd852bc8a77a38a2b79a5bc3ab765857b417cdad7efce381de677698da27b3ccd5209f09fc6f39afb6115ea73b0fb0f419baab83dc091d3d410d3c042f0d78bf1dffbb87d9b714bbf59480ff298148b96fb1e655d832724c2fb648d6f5cb8e66ef0b481dab4e382fc2d637cf6529c450bbd9fbf2af4bc99fcdfa3ebca8229fe62f1e8e66169d384c2763c98b4b5799adc92fc7467799fbd8f4f37466f2bd89459b14e068bbab53a88013ea4318ff756b97707f2e5493696c6357fff3d0194a49f7d886d6a8bc7171188c14dec16f2b2b341fa9b4b109fd85ee6855b6942645d87cd384210c74ef717b54732a3fc893ac82b80119eb3b94388f88b84ca557b941b4cda8c0768eb8bea37565a730a27b838ba438efa7a302490f7c36935a509478c7b1c40ef078b1a9bc6fa659e838ae83bcc76eadbf28c5283da70c3c7d367796329e0ee1455b20826f7b6ed489df03e243b65473d3c39179ce633542094274727246ac8510d55163bb8d95f908042a3d57da82043cf0cf373043ebc2b16794340896a01a0d697a350ea03c883a889b83d2a7853eaa87fb696a9bb51aca6a1433e1d2fcf653e6b7fa012b2e1ad29f6fbe942317115d302351cd7904658e95045c4b8f9bdd1cf44c34095d8c9c2a05d816fcdb83cc2e09561a47369d9f7732f7ae7fb0f7094be0fa092ff7d930262aa98e88c672d83e8d1563d9b4dce06d571f537a2b0b147a593f0d3a869d3d77f969e693e21c357d1bad688d583fc94ce5fd8e7c00b36181dc297797728728af4e64ad4cedae3734695ecdde17153754d143c31e0c26e7a2511c2b594562bb360ebf578ff5cc0ffb92f95dd83b57d121be39a12106c756333357c62dc278c954757b44bd4cf29f55d88741efc86b0d49299200ada2026fecd9704359f3789b5f9162605c22900ff856ff44639a3db17de77919e51d6ff8026247f639e0ad28b1e1d7c6544c58a037f5f255d3dee3a07b59c420e6a73e47230d4ca231632be7c3f50f4d328058663e78090b0a70a0d2dbfb8bcc7488e60888ec9eefbeadac3e4913782699a84e4994c365a0ce595aa669aba527fa54609485f00688cac2d3c826fa41d4da0552fe427eafb8b5777b29414948d72ac6e27c5aa00b5adbc754e0fd5ff5825156b04d102cd6aaf882db2a1c356637ed08bae437e675d9e3883ddc0a746f1d6a3ab6f7c838105fd2f34b84e10a517b2fc9c5202e748ae32dd0366cc76d3bb81175a7cdfe1382b6ff60517ed9b5fac4e1bd5a050b9cf24d733a4502cbda374eec11e9a2bbd07baa2e8d669e0c8521026f7bb64f54e1937d19b299ce3e45766b81711f5258dc3e5db329dcc712be45e1ed4fd521e6867280682447714f0be6e1cd730f253d313ad0878d59a9159eb368bd7b2e4929247e10700811f125f6da2a99b901586885ac3b96cdacb5512916629bb45c394777ec534175a026fbc50aaeacf1b462397dda887125a27b6b6c0dd01074adb06ab2b9a813c8a6ba7bbb4726d9070fa42d8886e986b8180ab57760f44c2e0450ff3c09bcbdd24f7546cde99a0a0d07a3e9c779021fd902b4fa996ce4ff8c1f678099b44a667071ebe6850543e3fa72e29f24562a97876d7fa4a04ccff7cec3e36f5b2ca222af25cb928a01a64969c0625f1a444f433d89f9e995286b3893960f86f05c694728e876de285cb8630945ea40b3e9ffb6fbbe2fc4c5f3e9472cc4231fa86b875f3847a9e34d6d963264b235aa7adeb705f25f3dcecc855857df12197c177c42e28d181122ae88b921ddb7b44473acebbe2662c1e67d455b63b5a5995e573365e396a68b119b21d20572e2f317b502472ff8f474b4cb51213bd3fa9a3a303195fc63c60479f151d4e7a9953856ee947cc5fdd46df226a2d66dba788ccf69440371c8e08a349f0667e37a2826464162c8c9054c54117314b1b2513ec2330ced0e589dd04f1c2b55871f9de02cb583b0fe3e5809e598b8897b483a451ba6c4fd3aa14d4484dcca1152dafc5948957ecaa3e618a753225f6dca58e4609c0f774a28a2ba2f0f2229a4d22895e821f18a80b84135cc8e8873b54d56bd2258100194288904ac3417850a2d5349ff98bcd0f0c43e2cdfc33d05dc65ad2b27647ed0e65abed3f0f74bc6eceea24334dcb3646cdc8e6fd63b2d33c6704da4bf0832523cf984b45d0a39c00c268d7cae41777b1b3bec10f7789ef243e1419c5ce60dd93e3ac81c48cbf41c183128c971fabc1fc00e246603de848be2f786827e7bae585c13305a608a5176a61c5b1eccacce693ccc8770c2af3a59eacfe81d62910cc08a1e21cb704943b374fc14867011c9921105ef9af9851753745a607f54ebe62096957ae491cbb80db93c59deb7214c183c4be34815e7e4d9f49ed62839656f04dc81c3bcce5193d471c57a5680e886c303756f3df2192403544c3076c9c930f2f3de20e868f3e7bbd466bad4b1c909c85ff15bfe546b389b8dda57dc8f2ab7ce7f78960dbe0355903bf9db5552bca1ccac677adf38982bf712f66c91016e6e038ff6f952080e99e038144a9f070048225d94eae64ae30776662830362c8cd2612db651addb5102fd9d736364f312ff0ef58bc042ce5987d363fd6f9901407ebfa32dc6623b044cecc64cc7834395c8634ee75b47e8fb54e3c9ebab7283e14ae9c1a96e62f904562209e8cd61b14015f7c64b8da1def8cd4ecba8994d1bbdbe639aef65380e08745e9e97530f74c7f2941fd608f79e739753f4b915c49fe0ecf6def5d1e3b535f3d42e083bab060e7cee36a4a7a1f7bbdbf9076c48bcaf31a81ff0f30e3b04360528a973970614af066c103575fb8f1cb71d9dbec1df362e7e689ed3b1f3bfc01e679b19fb238daa3947edfc29e4b06ccc0e8941890c0d75f918a38536ed9a0c1badc5697e862a470d786eba94d7c4edd848ac6d33008589ed027d75a89a9a30a805110df5f2e9dba163ee95f3c4db8bbcc871127d8ba6dcba56f14585f3f3a6c6a3bdfa0fa81a1e1f3514aa5b259164bcbb9f58a5fbf538edbcaf3da86d87ade79da77c7e13f3f8162bd03884903719a1dc693747666339dc4d386dccf9791776224e6aca07474804cfe56738d65007507b5cdd373a675ef2783eb9ad77c2ab6abdc9a2e19c8a94a4fd784fa355784c20700137d9f3ea85d72f6219bdc458808c18493b6ad6f699b19b5c6ff6da43e75182df1af3805ad69e03c49c0f98eda09375800e2466a6f701e339673f16751e195b4f4ca74908a5221d3209991f71cb91052dafb8153302c865869fc240650ee5a4fcbba9f1cfda7971f7ee7cf0f42b4dbf6b36b4939d7aeab6492d0de77397fe7310f3dfd9afaccf17994b07f79326ead8708cfa85791c15876ff7585ac41bf8e047a30eb493491c2071f8c48a0d62ccf994521e53c09fc4439cfc66f697f714c7971faa9ee3dff8140561d1e3ecb783acc25ae49c96653f63f8519ea8fe2c04abcbb9dca38c0ea1bf9b2b62c0e0216daceb4e453da8cc999f542ebfad2a0903a962a69efe66338f78c6031f9290c2f51ed9a1563620fcff2a21062f937c413fd808b13631409fae7720c26911dc51c0800f8d43d6f5bf58e728cc531188746ab694eaf0fc354f8cc234fd6085945e803ee200eb65620f5333271a06c60e6070d4bb6e3a80ccfddaaa8e052182d523952233ca9016c29906e541c0e5da4c604455a738fefcad2ce5171782f4a8ec14b4b6940f003ac972399c80817eae5404d1799337b54aa2f5607537d1947f2c7543688aabb46e6083c7a6bd28f56db0e98ebab5cfe78ea2c0b0d62cba7f4b3c9c55f858a5b993f6a1c535e3927c1f3335fc979ce8e92c07c49ec26e019b824a7b5a0ee1de57e2b213f3894190a266db4bce01b245bfdab28d5f91244541eddf28a60ae6637be246bf179e0be33c650e044da5deacb0aaf4ea19b88938881a26975e0054f3423186bcd7e43cf60ce3a7666de9c4a6db1ddfa13a079ed1ed869a5b5eff56027dcd19dd01e9f1e28775e5002d118aa5ce10a362dd81bf02230f1abb505730becd64d41dc68eb9075d3a41222b62722966f31d37c38aeebd5f427505fd3db46ca9cf14b5913d377dc775655af209049552ae50075db07e5af74f741ec4c03012d8e6604e900eedacbe882a603bcd11572b7f085708ba47294390d170e970cbdac978e72c41e9426bf5acd4b41f1898c602e49c2d88f03ce95ad5bd5e3a5dc18aaf4d1f1f324f8611c2638597030c64b9204434f429983e2961287e21aa558b4710115ba1fd4da09bbddde9125366291fd5ed50ae189e0a7f40f3fe380cae23d203c45b8d67f45c66bdb310c6c6fad34dcc12dc099029478ffc5f1cd8e4b17332d6cd0b0e05945b1cf2e95db095043b1dd8cbc6762a3f6417b94bcdcf69fba3e3730973737201bcd358c2ded0273c864396cf62fc0da56bb793f2f5efdcb6f3faafeb9287802f620b241bca53506ab38682308c0de2efb600ea0d8f7e9625e2b28a11bd112feaa53023679581891d26ab270bcae6c202377efaa6168361c4c8b82356473d0be7e8ffd47b74ac34faad6ad94ed5e5457d11a0f5b0f6c10e691133484be8757d116009c3e36e12a37b1b86b4c286c8f39d81800aafe115c81ae9d59650ee28b530e875988a4a262e014c02d864d988d8302277070d1d43371854c046720187207096bce64bc185de83652157b13038eba20307af53812fede41274253f48f27bcb1946acb2abc835dc0d9c0c475b9274d5930b30af4053d4f2ba2a19a41d0f8951b957ad02f2221829dc1a27858a67276f6e8cf3c12552e0283299ac18bff17439520e528dc06b0e7c7e92e99d3974426322120c44c3488d3f02b6d4aafa5ab1d77327fbe19ab1f8390693443f2411be0792048d87536bc3907a22eb72e25a6baf1330cf63f9a97eea9b6c983f6c158afc88c362d3d44d831fe21135551801fedafc2583fd2050caf54a83912366ab872dba29f9bce99fa4a0ad231bb5b0e2a1ba89022cb7116bc4846d6e80bda247a9aa6cf6ceb3485028148a4c63f07ae5225d57af38d203781bdd41731dc36e50ba3206f837efc55866fc20541597f9afaf443a360fa90f9635b2ae6682694e13bcf11cde8012e4520bca8c355566e63035ce44a1a9b4b26843ed0ff48ed3cab2b5dd46cd7103cfd6dcbbc7f5f076192cef5818061d8d8d9cee6414f4df59739fbd27823cd5a53da79a02d50501cd3047e451da288c6bd92ea1166b1fa80350cf9a6b50a0c81f502c68fbf193bcc3fa81faefeee3937ea2058ce38b107b415300f6871584be9cd29c67f95c621a56b1b2128f47c4278275b792e8f31751259865131217e6cd883903b5e24bc5301a2584395ddbee0b5a3e02ca6219b593d30ee13a0f35e98cd649","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
