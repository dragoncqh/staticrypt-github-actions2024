<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6191692bf5ee4daf0ff78d7df73a87cea88be913f01bcfafd3138850e8fc81e14a59cacb9c898ed64c75d53ba3db0880d1ab7af8df59c01c8aeac3d8f6c566eb2ef8da9f4b323c41dc7e18f26f953cc13270cd6e983be026f42fad22a76bd7276c9107e38219390149121cceb093d49c5e404da5d4bbb4d90648082fdb4e163e0e9625fc82580abdde3718b9a31407c2293048b3697c3065c9f9312262242582db8462c912021dceca9d41068a5d95c49bd7c238c1d0895654667700357675ab118113bdb7dbe999d026a01cb144cbfc3aec118858645f7092277835f9ffeae53950d349b9b77cff360bc944d11ac24a5652a9cea5008c68292f01b9fbb248da03ae8e42f72c38e20685f73a0b2fb5728064d53d589f3aa5bc73becdd048e385f537746ae7e059ea64e9f781fd72e80ecb9435d75e397d3681636a61c62017a0686ab08a77d8fcca9848db21578d7b50ece7a9cdd43e69b20d6bb40513e967c7d9e04b8de92b05008d1aca24e64d3469558eea3c438d0270f864096036ed70e79930cab15f01b00bb897c546a2a721eab9f0a1e2bac0adb92d13bd71fc431189d7a525bdde599e8313ea162de7674e386c7ac157064cfb2594ff10a6d775b4c4f950375f5d8da1d25c3a58646c0d6fb63d26008d7662ffd887c03ee2978774d9a772107e623e0cd5dcb50948c81aaaf52ef595d5a3eccf9b1c4d5db6a632b214c7d60767dacad9b3d9206e0b5496aa51b0885c00208797894dba3fd729d3b1ec68cd22a2e7bbb5aef9e653a33ab47e00ddf7cd99395cbc3038fe79d77a09a7ba1e1115d97730476d2663e412d2798de8fe162254a7112a61862b78e516861af1b114db57b0b574150e2eb59fb4816bb0c9cbd322f219da8c95d4ac314f77b1d50257b58d08d61a13f52428723875a12b7489947355318df0c66363fd8ec115cb0e4dc0bcf2861b7d8dd53b5088c145852bfad12ebdc7f8ba262be351b26fe8f2249a16600818c2db30feee100ae85dcf832549aba5d6a132093c661b6bc5228968a10a5b03894b75d923a327c375cbaebfba667b424f3c5cab5e258935d0b57b9cc3ef81b49dd33fb5535c7b89a1ee3cc979a52b017b7a0be557ddbd7052df05bae9d9a243942b1c33c567b369deef24e969b58bc20f962d86637e44b86cd95c96944065dab34c1e161c2cbbd7d888673a43c9a8dc4bc02c008df9084201f8834aa8eaaa9dc35e29f202a3b8a6e9757a0c7153e12dd73538879c0e661e37ef4dce5aaeb8719a66b85210c2652ea38ed899abf16478cccb19f5fc2b4e03901102492b31c6a9a587a5ac36030c4746d46477b96d735ab1b12ca9d81f4045b01c3bac54e484e7c272a9bbb897ea0f3cb5ed5b719b4d6ad3285b5af65b48192a5110d4e565edd2fb5fc1a5c298c1090ce03ac580984f912721b32232a8f439e38ee140c023afdda282e48e9ec9e9bfc8444743c2b746ec90d16bee26fbc38f86ec4f78e06af983b36bcf43200633d57e6878ac752cc8272e4165155db490be07b82f86d3bbfb56bc1541b1ac2eb5d44856b552b6e3199dca72518c86ee45354d12a55fb846c6a76d9538dbd5cd6c7637f4b1793c542b18f611432d71cc5837db37c8e39ac088dc44d5a562d5fa307264a320c038848f0494ec615c11c2ce00fd810ba0f31137c2f35bf9ff9ac5b83c31822b86fdcb9ce99d01d0ff9b2b1c068bb979e67a2b238638e9a8e4629941491a13cd56ca7acec2ba1f73608dd373ec26dd394ac88f27b7133642f742d7c480350826497fae55cec7841a8a69844c45fc3be79bd0f03f91b4b18def13921fa4cf75ce16636ba3bf09a23843ffa1e3c7f1934728d1dd164108701c338520a55128b0fa8ba6ec5d579db4268ad73af83fe331a309fa0abfbd5e1491eab7b2126ab72a2d5025f6368d12f14d6e15642e4f5e6164720f9a45344347b9c2f4509a3a113f9ac4a500b9a879f692122b561112df3df3e037faf03c3c91460bfcbe924c826535f3f7fc42cf55b785124dea5ef7799154089c3b857e134ef6f0362bada8dc0f50e984ace273887b4ee98515d4c753a7585f5fe37105d23c2d64da1a5504d0235f421fe2e1886ba9b229e571612d4978b9c044ae5e3ecdab25df6f06e75b98bdd684ff254274387daa4bf6cad53ce7c3c670fe5e9248b67fc8885626714ff84f4d56c716c352c16577de1f0721c0aaef4e2f377f5ea9d8791a0f0cb8e06c49d00eef31ba2117967eb4e93a3596d59c01c48d746771d12fbbdf5d8eee94f10dd23fd2391fe263078a0b7e87028d37f0b6a7f403b9d2fbf602f97845d7867e2b218cc97c8ff2a26da9953a74df5b20d08a4e7af2a3496ec38686fed94a18c6482309b7add3cb0c9833dc40ea93c3ce9fcc4c84136bb26582225b4016d846163340da77d46d07c34f178fd14bd91a4b1676b914892037bde7bbdb5da23df118cf7780a48e07031fdf25820c77c8c6921302cc1def749b59712553e3f1c038672cfe9053507ab0adc0bce2f2fd75071728610858dde3d0d09f74bcaea9f91ccbb416970af384f2429f248d88376b27f0b4f9b6e180b89ca42e0edf3bc0279138db2873307a2179ca54343ec1b5bbdbf7c73b18c80f6a5c5033157016410a38738c73578dbf751f35d0ca2817bbf8defd3b7e9ae2ed6beb7530a9ce470878b8133a0377a01362154f110d38e3818c89400c35974f8bce669372784cdca0ac2d75eefc63894b0629444a4160a6ef87d2a2f406057d981fe78330030cc717c7a7af63569d246e16c654388f48e525dd12cd48974b3dc1fe3875f276c04715d4a2fe50894c5bf79b07f9e1a609ab3cc587baee25ce1f2bdd5837c372199eb22373e24644827fdda799024f462198846ed7b4a8b389de898aa2fc50b6ac48af9aaf05524159762f32f5fde0eff71a7e36640f510b20bb68b6c927de803ecc873137badb6ae63fe396960bdc49392c8a0686bdcba7e6100a99b61b3dc166f38662796cd89e106cfd6662c93dda4840cafb392cbd848297df076ceb1d351c84b5872c316b0d24d0a816394c98e21749ef0d7713c5e72e1a224747a3a8d62e8db3449632bc779e3a89ca1fc2ad9e41708da87f2d5b9e9e97b87aec1ddb5a430755eccf18874bf814af97396107c006aabdd8cf00d1e26748dcc5eda58f742374a6f2106f24134859f0d8426e34f864b6f50d91dd79e5cc20274e8d29671fac5e91561d31eb9cd34696fb1a657792ebe0c016721dae4c73d21fd014c1d31bd27e6eaefca7be3cb49391d9017c75df6ec56560181966136639fc47f9b6f5e505f14c6b7cdfae7653f21f1917bfded535e3afdef721d492e833ed960fcafaeb82004122d0c4e8588ebe1457b0f4f73d3cd538979232a83a2e6febcb9d7d38cdac5e5d495a810c24fc5eb768105410164405249013743fc1daf827dcac23d855dc575bdff070a8737b7ac8a622d20600d5b89d7a65bba9baf034bd13c2f5c9b146b893bb44d5baf0358dc28d7e86a89589b2abc3c7b1100a28b679468c51b35f11e52dfc0189bd7524c3ce6bf85948ae8790a0a14d31560d8344f75ba1e5b1cade103938cd9835b50c30f8871066de961ed06f5929102650eede89c72ebee24c6646945be4b6baac97e7a2fc8c977fe91dfbb5727989fe2305bd4ca8827b9015ec13de45f76f14e79e5f83d8b07f6ae197a8cb8d826f19fa79b587e954bde5f7a506184faaf240edd43e4d00bca18951004d12bc77f90876d73ffb27d1ea06cf333e1f88f10c665144388f3e84b782ffa8b4355ba76709307800550032cd0115b3edd00461b69ab569eac8c975cf80ed7b9b080f4b49b9f4bd59d72bcf069bfd4da5fca2ca6add72ec3305829fb2d61d050830cb7082f9963b88b9302b520835ae9b1847beeff7bfbd847b4c8619e542053c3ddfe6b23890a8008eb43f894d95465d06b87787ea1b3387b01973aaf2a4304b58806b87571ec110740dce668c953dd8f5c95fc3e3424c702e263f1d50fc8ebf45bdb2b254251b43ef51d7493aec701337d9009dbc510f75961ff1eb6654c6674e252ae9c3f4d27c738a600e9dce9cfaba36207dbb266bed1b73f73581066bf423d6c341286709642645c2e55f577e98e7774b2120a93c6df45e22f8c476620b342004f7145ffaf01985aca61358e63613d40f2ffa59cf8003d5222e0c23d5e91332171a8b50221c8f4269861bdaa2c40e157f1b114573f2d8d8456c31218af159f5ee8ad7e1d70d164f2e0740209fb5aeda8d9702d2bbb4321120a200d6e321b63c6ce0655a2b4550bae706132c43d287b3df99d13731ac4911b9e67e5e4b449d1341bc6cd4a0ce48b784b65a3189ce5950833f9548bda1b5413946aff8b99409741bf3d423e581a4c70a78c9c371c782003e5b00b9f06599efc5d96557eb8890cc5289457aff05efb0d1d0b460f1664189f0d897b8533f344575102a4a8cecf53249c108d0247eecf2d78368a2d60da6ed92741572ac97e5701f2d410141c5572591015610cf9330fe725d7a3f6ba7d6c5db1bea9d372758be5c0605dbb84f06a95661f2703b4ba9457f20642d663c7b2661ed6a4a7f5ebaf058c25e2b6ecf400e888cf5fe4566db855852a9997f07c752780825e8d749fb0950a20063e85a4db0670d153e9cbef1211c5e421e21ae07f83e917101bc324dc0268fcc0136e6b0193c8a275a250a536c4bbefd49046cdc5ab3f9d6559edab651826b60ac1a6eb81d3ef12d31cc31ad5251dff1020a1422e896e2612ba814ad25b651f34a3823b18971f4eb991a1366f01bd780136b1e3af800a915ff9ee66574e3c8622b01ef4aec271712ea35dfd6a01da77b17bf05c721f95e634796ec9fa324a22df3b2efdc799319cf8fddeb5ad8126e1910f66da43cc3c907297ba541a98c8bc24913befc84f6e117c2ba5db06260ee5dc6a1e9752def1c425f92d4e7fb8a5412953e1317700f6bdb18cb9356bf5bf20d1eb4075c025a18c8de1958c231a3b518256c1b5771ebace3c1c739ab0499a8589ac7f536d44b97cdce70333af90b7f2bafc6ee6cece34be437049a68765d3f258a46b2557adb5a1860643355cec1c167dfa0e2d0ee404d670643079377e0312d53e88449bafb9a4de28507dc37a55043b5e7edb59e290f10db7347c2313c0f87c5daa3473e64e33edd47858b77b177aecda3b3e3afc10b8541d4a38e7c4e52652cbbcd45817012e3712f5aa81593df6bdf01fd47eb1d0e64a8e34c5ee8802520f1636c36523c7d527fc7a280d777f2250f700ffe40fb80e02e15a20fd7088b041246a24d75c916026beaf6c87b9f3df970c79bc11a45fdcacf0f32f1bf1ab768d8cbace2d23f27600293ca8382d3bde2b03bcaa8115a864fdbb446931055f435248a2e8e524fa7ce6a33073fe60a06f77744107982feda8eff186131700d486fea5301f9a3e498385ff9bece82d8809c70b19e90dce4fc1136e3d20cf23a67c2c05d1a55bf31e95316c313bd94708463b6bedd6df43e4145965335c815965d63aa3ceff26819f99b71c1fd49d1439dff6741786e07869b03a688e1d8e4b141268291ae1b4df18b73c9bf7f12cd907f9f58dcfd401aa6d0d9de54f73592f961a41ae4463d1f406670484c4ec8af10a9c1f5faa74d2f9f05b5fa39183e9fd34fad0d0337f82adda6bfd1df1bca6b1e947d49a3c3b255a484e2327fea335b0635f57a05e2bfad606a641bc32d638daa0bb22c29a13c9353bdaf5a69c2d5d1df770c98eef4f384c6ce37a19749832513eb777586dbcaeefc3418566a8095fd5cb5d247836ec7e94208c69bd00f488ac2111ce7923c60e0ad21b03b589f14c829ee030018fb801a435d05ac2eaa372fcbe096c0c21576d9a64af90f0ca18c2c8ea13df864b2d0446ddfa89dcbc6e2ed8ae60732c88310273577a19097eead7cd10e86a715bce267472b02e08fa51472b9e911f9b9c4962e0afe92068615078d3954c3e8cf020579d25c51c37ff1d431fbc10ce0eee93ef57cdd90a41d4dbd5b17e6c4452565ecfd6d8d5608b4379d0aa57b41cd50e95dcf797d3650ef592006513e6bd711dfe97ad88fff7c31fdc97d816ee97c8527f44e883222481fe6103cb4032b3b476b762b144ba2fce7dc36407eb86b94ee04d79f88d95d4dba733661a1d814c87c72a9d07646163caa1a670e18efe4d929d89ed600b7f391ca00ea374a71b6655d7e2df9b296e95f8b398fcbdcc7ddb11426cb0ae0bf966676dfaaa9ef6605c34f5a41b89cb2930f2b6b5386a172062bf7a79cfe2827f23056b0420d15749d8a5e47a1fe0a24a191621dddc8310a72fa08544a4653166281aa96989c67357409cf703a0b6f902602ae1150635cff34a91b5c7aee861a8beffe9e2704f4e3474a534e2a7b755d3494d04d61c9034ac546e63cd623c8a4d3355d7637e617aafbaebfc521e057768663d74a8b5b9537750ba837953bdc8b510fc51185b1901740feb276a9ad899b79a41dfc6b6ad51d9a496b90d2d4dce1951420229872d96ad176c43b355d66e408c29b123e64023a9328641b411eae02331e721863157028d559f0f3b8d40210ac2d34377e569d6c79a619c224d82c9cffe87889aa4e926f1ffe1467975379328579b6e751e39b2213c2fd7bbec16bb4cb7e3ada568ead43c123a1c95943602f159341d7f286122046b3019d543e9d2d193bba9c12fed5ed0cabae5ba6ade945813dc37b421e0c683d59dc0cf7fff451a1f66593fda7f17fe171f12d5dd8ea01286b19c5cf4a7e1abcd236c729ade636f2d7261b8f8de5ccce2c29e8cdd0ac91c440a0bac8294e8511fa3d406f5149a4a65894fa97e33c521e6af73e9bf77f07b35e6b1c9431c71bfdb047996f647b6a8005eabb0d956054ff0a56155e6e46990561334cfbf2dbb25a9b792ec5f758edf520a119627294c081465da5b4e2fbf9f08e8dffe82367fed295d1cb5831f3c00ddd929511cb02b3a69c393a6ad0ef607af9bfb30ce6735ec14dfd321217d037e0e5c2ea8d298fb26a4ee108f13dc7d39d65471d353513dd809ec0c35608a9814a7d4c2c88698f067aab7256ec9e59ecc06e71bc0d4967a893df64e3e922840672d9e3f4ffc4a277c2b89acb55bd9069a2d1efc6be9399e07fb6cb940688c19de861f0ce5a71546827a978c0907e095be47ffd33d9275e346fb73c3c37f02abb1948161d73084ab99c59b7daa62c0028740973870f2e948ad35e8b7db8e3adb5a2c0698996277c124a23258a0dbf8716c90af24d57cce6ddaca91f1e19ba02e5605e1c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
