<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a8ce834e6baba9ccb46b96186957225f00d72f8f0ca40d34fb1b78770b9ecc08a7e3d9578e2830921a647933d0bc6c08c3554745b4e75d49b793eb5c0d8e9eab40f1bfd2f0a3f53dff631f3a7d1e792e10fd6630a4b0668642d8b1677625965ff15b61e60f7d58c0d58b0854362394b30e8b5eed9d2cfafc0f279eb00322133184e1b59084d5464ce473d093ce514ea5ae08ea7802eea27f8967a6b92974b9d493ead86f81716055c86f1afdc05c6477ba0cd040ee4071d523fd5c7320dde1778189e60c66b8415da2a7b84d330952f8168b921658f24424f51f691922f80dadbf118d4d2f3372d33a9acc42b2b25d70e4713ac977b54b96414420746e74b7385f3abb640c7577598d2720f17ce3cf992bda77722d51d3ea69216153589feedd820d82c7dcba26c9ab4407bdd55a3fb48c931d0bc03c55d843ec41854d1bc89254d59be10d17e8611960eb92d453601f4565f2beb498dd48110f53045fa1924abe9858b72926313a8c537fde21e3909d965af656f09b5e93ab242fc39598cce4ed588b409cf74c56cdf74b6c64ba17d9be9a87d0118d410a3ca51bca515f15fcbae8ed1a0f926aa6b25e713032c7ac81958f4ae0126a343a177186f9a035f44041b2616865a5c0ccc8298ae2dd7e816e4a2989d92702bb9f5dd03d3753f817e90f97b04e5b8df9d428211c8feb1f65698dcc9184ecf930c9a35a94bd288e6e30902c900c4cbd14fdb2e4670fe04a07f19020327eb868cae7681fe3597dab5813e513149efe5e431d031642aa5468b7015e35008f084d9fdac5d02e891fd629f273984dff6cc6285e5ca26302bbd24ab58b7150c7ba68ec57e73820c36916dcd3bff78cae0ce434e6cfa0f8905aa871de9c7efee2f0841159a225766c974c4535bd245a8e07ddf227717d01ab6daf1bbf8bc66e9082bce022d66e1e382d8c83a953b8f0c0b6569f6dc77e275e0e3645b3783294bd0b5f28c113717711b48a9db18ee97f0e728f02ab2750e23de0728ae0fcfa1b8e63155514d055cb92c1231339d692f638d139c99477f232a486cd100655ffa12326c377cc23b304f4773042ba1df3344da8ae6c1cab4bf6bd05bb87bac6adb0ec025a23407f061a4cdd849135885d0a26daefa7345a171c5b388db79c252d6f23690420c9bba862046421b2717dadecf76875c4a28425c795b18823847b1b3ced23afc0a178f0082a97a81467c02a96012de1d0a494229dd5487c90df3741b22ec4fa88391ca26461f4f575eac4a73ed2e2513eebddeab6bc954b8bd6e703db2c2da93708e40cedd6db63ad0ec34da6635cd58d0996a48d33209afb77f42d66f32c2bb7bcffdac8591c666154dd2c90dac1fc2c1ce28a2916dc1b6b18f80cc6a4c66726a0db7d6ccafb6e7605778316e85bd3a416227969b27a099d44b273a98b1ed0706dfbd4daa387ede03cd2f5cb08b133b026eeb92fc4698787ab0b90d53461ce44b04779d15ba89795565795b9c84853f975d4318b5fef075cf0c9f68c9a7f8678058845eaed412a7b9927a867b417a38c929d307f9e422020f359ec7c266732b67293a198b721a4cba460dce56d09379d8f23e8f94cf3861acbb253fb89a6bf2ba307b6c433a1c4330b222a39e9fa1f196c025f65565f03bb3334426f2498e68eaa0563ac29bf4431ffc93520d0eed744269706bc91809fb5de33b7a29dbba3a147ade2768a0180296075cdf3c3b5a08a3b7a0cb4c1728ba683837df1ad5f8c1888bf64324348c5106a2de1320cc4dae58c0ee7a7aa6d702d7373491966f089c0841450f2a84b063c24aacce96688d7458f2ce3cac9dd3f78c3cc0d1bada4a5b411d53e09c0c53b07b42c7b84de7108f6d4fed54eb152ce2f100fe57bba554cce48290489514f6ba6d1ebbdd92acadf9394bab9cb80920444f18a6ba34fd907248cb22d095a9f99449ab1357e700ae618c5941c045660d427d37627b902fc612ca15ff859d38bf9fa599f51100b3eea39a0b8e65ceebc571fb72d456d0643d1010fbfd1afd30c9f5c0815c8aea4acebf8c9354608807c5c28b5c807e0286ed077946a0339e52a6b7ae85a1e2256ed311488eccd50dfe6b319185f25e4fd9ff8142ec0de85968319bbe365493603defe56def4c4fa352b83b15b965645c83bc9022b4ac01972f8a1453978cc255335c080281d574ef614c9081b45d62d5a1755bfec596c6c55439225414ab095eeef034ddab9a1441f0e354050860791ce01c60fcff299c7f106de7225b0c62573bb87127bcff8e4fd27a456169b72c1ca78ff86726798887329482fa26f27cd6ad7fdb0af05db7cae0e8fafcfa7f77d16f8cc1a1a6384d0335c80d1f045b2778027cd2488c4375b5090b316b52712c78b44198a80debe0a5d6a18bc6ad0e0fd1bc1aa91fdecf755840c3859ba873e6ea2fdc1b14352e5e5bb87cdeee84d60916a60e5934d67b9e936a7a99d74241baec56e42c2593c6be762f8b5ee58402c4d89fc24bbac5336d4adff04778ffb867e8edffa065bd20724bf0ada4c41570647561b6d83caaffd8a40d1d0b5b596ff36e1f2b081cf2080830ad3eb4c7a51b782b63ebeaac6f5c04cf6bf4173c59e9318cabc6c663b6ec62ce6e6e1332d8816c2ff658849c9e02b0e490fa7425794103ed3c87abe2bae9d4066bc602af3f9798e4e6afa569c2344e70e0a407c4e1e178ca12b0daf6e32a889d880ad4ab96aad0df869b33104f5c2b52603c476cc5954c950cea73ee7232bc2f09f22a094f198f83b8c4d8a89234e39a7edc59513fa02f2c27b6c04b395e3dd097e51184733a1daa32f16d59e95f18aee4ab636a1ec66335b65b8f93332a18a1f86090dbb26764dccb83db308a1a2997ca79404a7b9363ced2ff094cd87288bf62ba8ab9acf550f247fca29d0105ba88f5826ac909f433230724849ef30fa0e21a74052397296ffb789cc4267a1bf172d95f661c8eac97e72a9e096811b708fd23a195d951d25a0d932dadeaabfdf0ccd2e9fafbbf52a84a21a4bc45afeb8cf4155f0376648e0cbe805fe6dc864e4bae28610f6e43ce3ab120a5de693d4a4a107c3968b20fce95b92ceb326850449e9221b8b748f4ad69484d8311a21d3aabbe6047c6f74bc316b747abac40b1c56ef38e6979316d52a3dae41636ffef1550cbf9411116c572ecc3ae6bb5c04cfaca0bff1f298fcc13a4572ed0587ce37e876df198624e38dbff5409258c2182264988a7fde57219deb192b9c9a2a6e02da943fdbf7591abca222dab09fb682324ba2dfc8b06f55d2eb2be23128ffdd1f01c59f02ad9a4295526d53df85e041a1e643551cc5a0dab2c29f486492f3fd50d4c9d6f4785f989a7ef192fe8b813c1d259bc9446687e396a2d028003f8fbec4204d4939e871b7da60b4d31567f02d8a44b626dc7dbe25f6fbd3a73072a62d14a0200c1c6e1aa4e8ef590261c63d5aee0756269086eef3d517f63bc5641f61587d359fadc7819517f8b974a6a4284cc702a24b95289bb8146f7da2a3a2286d12466dc3102fef9e630cc2e11f62e8f2075ba5c15d9c109b0a22056b1f3f1c42648fa755b433f8f6996cd03e9bb5ddafb5a0db5228b1dc5b4b7310cae35e5442c576bc36936fb6e8eb151a913a8190f472d25c8c4b20ef3cbf0636eab7cf5aa52bebd0d81fdff32d70ea1b673e7af4f0dd096f05998910d0dfd07f411af3a222c22e08bffa9292b46adcadccb81d8a715945d9daf0404713fc3390d0f796b192932af2bdb79e990e97ec3afb42cb4e3297ed6298517e41f936289d51b99451fb87a37b1b3e091276463acf72ab98078948bf82419bbe4a56e8e2274da0ca61158d8c11d11ada36816b25770699135526578024b20cb75e766f8d29d4e90fd62e6d12a0f6730dc2e09fe86da512117b3bbaae7c420403d51c5cafa53d180f03fca192a1624dd703db34237852622820a6bd66c5fee4e148f2dbab2074e30b94af941baafa11787a4daefd711874034c8f2f13df3f0b053e439cf7b1b43a38e805c4f87edfe88cb551705b785a95433ce77dc09db004bc7ead5db2e03438aefda6765307752bd77fad5b938ea7286c500202a7f81b5d3bcbbb1ca319803dc03634904e433207ce926338cbd80fd7e6aa82691df2f7b8f61464df4268e5c3d3b0884ed3e2d9f9d758c9d480b1e5d6e597818348f109c15f2ee9c6bb26577370302b2d7e22626c1cf7bd89eea1990392b9e8d432f5b6c2b8baf4e71f75157fc4ff1e797b4be148864ac26ce6d72c974e2be84a202b666b53f9cffa8d0df3dacf0acb8412696200ecd86f8c6e6b68eead0f8a3998226a06059e0c6af151e2f79de458dfe6f7b6a215d0ebd85ffbe8612c46a8c36495c5e994ddc4f5a7cba2989fad4795b8342133519110822c27d5501fecf71256e56c2ddfdd4d8a2bc66ec0d27bd1f48837969440f26086eff8563f4507225e7ec1566bc098dca8c61755d8461361b59737dcda306b7d99f57d12fab0e4cb653b308d8496e5fe867327dc7ab7f919d1d249b93ade2d53b7cf5ccbb0215eb2eadfaf559a7fbd72b992753d4ca58db2d457ce451005a96bf22a4b47a70ca1264a86c4ed8d1121900c40afea1057ce3a3c0e31249335f9fc452f080f6d2a41f37284e45861ce3970ee69179e4253bffef42a27643bf6e4418d9036c46f84de77ad80111b5eb6773a39480bf17958802930d3e0eab62e0ef2c56f76c80155d49fa63386b0363049bf1ef6a5da0695e672cff16aa076d9e53a9d35cf05471614483104ba23d8f0bcba292648f958df68b928cc202edf0107d3379348c1834a2649d66cfe33f17fc087c09105801ffda98253cf4c63d01cbee11ed2a4b232298bc30d604cf82722a3228d65158aa30fe56176c9322050eb9c10a299cfbc9c770fe9f6fbc0ed2f85513c8ed52b802c221b0d736602407f243920b2ab2cf410ba42eb0d545076621177f01ee5082c7b86909d19198ae9be22c2cca7ec84a7a49098e0e30a62f7a67000103033b7e8c3f47b2ad9c5d534e34ea196b074a55eef26ca60940383ba8ecfa8fa740b85d222c501ec6e5ed1c752e895e6cad6ba0564b04633f13f8b907f23d528e07910086c73ca25b65bd873e1dffc13cfee71b5fc5dcbdc2579de73589ee8c3ed99840a054d64035fd184c1dca99f3cb6e358ea0020ed2e282665f42d5ae6065a6288d983abaeb446a05c8d51b9e15e440950eb4c5066a6033f7f1fe5565392e1dc33a8df7a5ff237495047784de9d74730feebab81291d1b8053fa75cd630d0df0aa72c8e9f4e6d642e81277a6029072410487726bc8d2495532b509c7e22d8b8021fd662034fd5a56b3fee1105aa6d53a46a72ff20a0cbd17f6e9d754af6018ddcea09b20d5ed9ff3538501c079b150d5cace1cd7555b11387ac8e20e1e1b913dd17e8bf3681591c57fcd242928fb9dfc7448859c97a0ddfa5987e8115b60bab15d018ad059d56fc94fee51628469897e9c33d0904738335b349977db89a19945d2791f3f2d313982a7ac908aae58020c61930a54b72863fceabac557b3d2dbac7391ff24dac3dd89ab671c828b28184eec6d97a46147f3f1d9a3015415a4c06521e9bdbb57df358abd7f464d1124f5523d457d75889be40a505505a5aa1e1b9cfe9f6872fe1e8968745240670378fa2ac18f262b928afef173d34d72fd69f6cdede99b0bf5b877a0ac12a99017ba7fdc91ccba95b487949ee8398f55fd26db8955d64a7302dbff9bda8bf583d1b3d77e08ccd92901966993f9f935f9e7260db5f7fc815dc371cfb3fab464fc484481ffd6e43cb4191c037d00c689a0119efd4eec7b32c378fea5cf0f32fbc5a94736ed71d8a437bdfdcf12e2206b38ac3855fc934585087231e2f554708037d50ac14ffdff663cc1a566ee8cc05efbb685afd3ac0e8b24c3a002ac5c04f82ff18897a49f6de851fa87533f8350da3fb65e310fb94cd8582b3881fdb9197c530e020670a6e7f680ccd1a32f388480cf0c45023ac94e436acb7c02d99631ba8f7bfaf0ec98c2b74fc0cfd2fb879a221e400bef708d176027baf578a0e665f525bc1060d0c2f6f5c743ad071888e92f2fb8705a0e14cd47abdf469be26cb01704fb51c41c934b23054538080123feefec430c8422db0140ae3379338fffe74f14040c44ebafeb6aa52c9cc000acdb2ab02036ba28aa9e9395793f081f24ab744808d6feb3e30cd693105f59f3a191bbdcd202204cdba504672b558f7a74379af7242076c1d1cc1a939506ecfa1a487d03950a831ef2ff87dbb079159a99da3578fbfdea25d6cea0b15857436b3e43e80023616c6662321a9ac217d6bfc9cfb415fba5d27852bc8c9e2c1a4214758417b5db0a42f3938ef72f43f4e2fad3cfca5dc9f8014b3354c2a88916a168f7f76c312fb700cb3d226f83183e0bc4d3200dcb1420d21d23f54675f91fc61ee5fb332516bc1383268b93340cb0194a63caadcc94b653e63e2aa42796f315f9f811b3b664794d60dc31fe96aa688e319476fb2177cfd01a69549590c9585ed160165ab73fe7cd5ddb2898e6a723acb1ddf1833fb1c02f2d5ac379a8919faf76bd6d744e4c21ab02c74b0c9ef5dbe4109d976a9c268054c573832187c30184d1cb1363ed73f85b9b7ef34e13f2a1a15fc1003af5be7c600c88e4942b36343833909cf323bdc862e2ea335e7dac24ceef0a2fc2207637c7f910a04869ec5c46679809b024db1cc67a3dad329c3e1988c010f2317b40d27ee9a55d0d3381732b44d322792fd8c44b06d1a5aad779fdaafa876f6d985b7c3d9190b617b264c40a217289df708921825cd298634df080aecf8fa67dc47b46863f3eebe6dd37b809b8af5d040239a5bacd2f536516675ef1ef042788099a0e62c40032d1c819e56ec6beaf39712833d0886e117afb97e332c70a2581e6b4d7a30ca6ff47ba9c4f79005a16a440f67a73b8e060cf20eb28f76ef385831a231abb5d2f49ac74d24cb98cfc5b39f869e54ed0e36ec3be8342f57f8a110b50cfb7d4e6f1dace5e0dc074cc15749d99665f917ac1cfcbed59b7927cf4c6b25ffdafcda5dbee17cb36b442de360af0009739f827572565d0b63bd4a0c0efeaa12c637782e662fbf8ccba0040539e21fca9a4f8e4c52a1664b61d7e363d69052a63dec27c5f32a53ae1fcf55ad066e7e2047e770e80ae809e05632d434cdd6fe991d9eb6d6ffbba549acedfb8c99dc6ac7c1753ce78ab9584e4e1b7b37b0490b8b003483e2fa172b5c63ca21b1fcab28f208c2f04fb1b0ec8d10c7104432156f34d8e70d37fcf06112a8e86667a4fc7bde8743b54dd93ae86a49e128903a415988a89ae64ad48850bb013605f13f3432f0965b8cf78db141a820c8a57723f9008225dcdc7d51032b9efe7c376dd1405c8c418371e81c94089f7b1e0eb320f1bf64fe9fc0bd93747097ed866092b2a3950c4a6c89770edd700a47e34d8b0af9e6bb8035090df4d948b6d4069f3ae935d70fe1e0bd3337b4c1f081632b8d9cfbad1dd01ae38835a24793bd881b139139d8aee295c874276b2d459b1ed949a7eda3dddc0b9a08ee3289403b07157bc7800f55e90fd947d16dcdcfa88dea5d105c9c8f488fef2a67e5f1d96f737a5d9182a41651bb67085f4b669fe64e6f5e3349c6a7a38d0dc9531b7412cb95fc494b1fa7267cc8dd58da9152d2a8b51234480675e998319794b5b75187bc80814b97e3e7506e4eae0a91d49ed2e9a3e1c48f08e9361b75ec643aa2802ca5848e9959114089dc67258f930e1572d6f96881ff0fea9f3803ce64fd80c010e98f40fea28735f18858b22db6335054e8e21a9b7e2d437224fe1041eb0da38d3f80816ecde2d3c7aed6f62b806e83d8fd7d8b595ac043ef8b112fd6ce51322a75f901ac44d6d2436155ddc1bb5a9b648f32e0ee50fa754c827c67a3af2c017ee6a5a1918587a9e487ff899f97b601f73ad71175c0504d8acc38c74ca0c488ce3609af1c448b2a04cb600d6c762cf5ded08bbcc8d0b1b6d62c872d62ce9fcb259cdaa35543cffb83cd3ded978a8f2084051b66458d656bd5f1d77294854f466a66e7cb84e46368cf200a121ae80e060baee79188040a05f753c3f5f800006429bb7a44f1af443cad9a3e1a448d69f0fb12ef4a67e83f869cd84dfe7dba22e8fc478af05b9f9b69ebe031cbdde1146ad777d516fd3e00ca50aaeb4c9a0d9287cc7f165b9d806e495d079582a0583f0f28a6455d624fefb0a4835503716be6ae6ad3c78827a7c97565d6616cbc176374aba4e7322e89a617fa5c9f9322abcd14ce209394bd2be7829e932320ccb2a9782ac7139647b966a4f402394b218bcbbb779242d04bcc90c6e1ae725b1f62016abd1213c13905949ba3d861f5b332db0383ddb7fab920a3ae5e7f064c876ed77d03928e64779fc432412ede14424d213b7a831dfff1c55baf4af031816f27377d08126801487217cc3a99532efe5fd6498573528eee91ec17953fc8c2d7fdc35010a453321a4cf05bb224a2b8181522ab8f411eb4b5ed125b1fd274cdb50840afda72c20d9adee5cfc40f94bb770cc0d88cb9383a5c08fd1e82c34da8d6db0a7f2f126dd0716c896a750142ca418cebdf28e4aabec56506d92555fa03700b698b573d7d3f025ac6d61728ab5d712b26086d1f0ecd54dfe75bf449cb38a7907b989039fa086c052b697a85ab9dbcc91b0bb91c65b441690cc2fd66baf0a008f0c17e417ffdcf950f4ab53126d99791db45b4737c09a881557f85a801c630332d96ee53d88ac2e88fc8cd3953858ab94a58762b206c5f96f565534d464083040b68fa378cde5a0e561be730ffcffd2ef8c1e8d9323a52dc460ccbe6f5ce144178ecc9e5d180ccc426d8ecd2e43d52c3fffa4875d6f1ef300728638fb636f5213f073b195ba48ff5cf4c54cfe9ca60b89e0f029de8cba25daacf82a37a24bee7bd02420909fa4a12ed3f69db2231b3810e28d3d35883fe90e6a7ac06e68ab734d73339773745ebc7f42c125b0b0d3b4d013fe8c7710db96237d929b5197a14838ef03dddf4bde6715d06e9c9970a76ffbb6a698478ff628d808a6d8a9b19e3cf2bdbe08b759fa92129d2c82bba82a6a6dfd07b9c6c617b92f38294407b757602b65e9100982a9c0f2a8d6c1159a201f581a7fe4cbb7f21390c29422d7e92eca3ce48b902d100433dcfd8178880d68b9a84ab3898d7a3bff50d1a1d655dfbb7df69c004f7096ed41d8678a85263e625b1d36caed1a14e1f437cebe0d604b6cd8604f9f0ca34536cf7ecb534970fd86d2b03796fadefa5f7f507b7f5923937fdcf5292d6f8519c6961efa98442a6e45d29d49b99d7dab2f386823e615e744e49981a7ea2ff31a0443247289da6a42bb46f6ff575b1f2d8ee6e2476c77df28dac376b08146fc58d11c0046a2f47b5dbb12fe834879e2a8626855d05e92017e1fd3937979089385006de67b7ef23b939b2271e7930e6f9748585362cd8820b67fb3913a0d0c890c61b6eb9e0312dc3ff5e524d9d30278b99d74a55f0ae3d396c59025157ac6c7b31e0fd50ebf7662a51dfa6631587d88e789cf6ccb791fd48eee864137992ed95312dcf2bd338879ffae97c03cd0f70e54ffedc41ce3c4ecd73dba506e32c794a62f54d777827c5d2637a1443ff3483306e946267e900538e0b4697c867f9bccf0735b7dd2f79efe9d2ab9b3a9150f4904e5c3b0f1f9c0d51b195de0c70c053f02b6e8e5490e54159bdcdd91b9b503872dd4e8b3c9ed616afae95473000b4370a255579d2bf39ae75498d8d09562ab62f279ac7364e85ca994c1cb6bd3fb99f625b1d43d605562590d4592903c53fd11b6ed30bb2a3cf969f34d53d6372fc17370148efb6150a2514e62df74af28c112fcf14afc0c53b442f685dba6cc8d6d0cafea3359b070455db3860bf6e8e8949f2f9b7e29028f34111cbe738d3decc3460b5fef2813efece5783ca6cb209a7aa3c596e58f2a7c0d8463f7aa8e6d6f235d5ab1e74e2fd7eac3bcaa29fa560b5b9941d5bf1188ad146d62e95218716961aeeb12a25e08e409a77e80987c386e8a607b21bfb5586f1f38a6645ea829be15f267f9db851ab5564b5729a6c2374c4db3e49826713517e5b9d250a87a2686ffbf6b43fd95745d990348e8e70831f25184fabdc1ff81a40f6f50a4f01086ca044f2e34000e0f12944a28ee1caabc1a77eb9d688603bc9f9fd788f7b1ca7a0380d7e95958dcc152277c1197b1621c8f99d23a1d6537d1eebb0f14965cff86f377fabda6f70869326f7838a39e07cca5d8da89898d6b037ac269268d392bb93ae2c360966e0a94adf6c6c0c2f701fc99d157a1107cdebb4ca3f6776d39bfbe3b9df171769a7086b07222294bbdb0d736d8dcdcee67b642dd10b51034902c7734fb217d4ac5f039dbf8c7fd83fc590399e2367c5bf9b2a1f67c11708d454c0d7fb73367a162f9a271fb70b9f2c83ed2f093c4e80046f6ce89ec54dfe9bb29c501259fe2de02e301a66be6bae84d123081d3c32636b8f0ef9a0d1cdaedd4a3302a051287a49c29053817af1d75de465425ea96189bd081e64294b3f54f3f470e6b5a0812c8bea98782259b7c47d74b73d94643f4a26ebf0d57f57abe51c3b05a08f3211fce80e6d68b9d1e76a506764600e8a7be8f94a2e99a8d986a028d24dec050eda60983e35846102518b2735bb72fe635eccb14bb8b9890295a67701430ca5ff30bde9a21d7e7edd203531cc3331098e38c01331be2213add2568bdec04c8cd89aa7b8d181d7523b54cec3c3faa7e0e5b27507f636110d407a87c791320d5bc6b7d81138ad34b1ff2bbf5f075051c73aa33bbf49465c1af4570a9d3972309d8868d53849813ce72e87b15874b80a5b8f256b85c41f90ec9481a8bb398357b43ccd3cac61a89d332204e4f7ab570700ec1ada7e9b6225d5bc345f9a6820192bc0c9c4da7f1332d7d2f3654d0a98c240b813ad9d3c706158c7bb8664f0d29dbdc17aa68187053bd18faea656c6baedfa84fa3dd0bbb80b0bbb1b2a58391492952cb01d6c2ab9b46497f201f2148fd2f9780b173481ee8566e1232c66d1ac7fcc74992974924a51e23ca06374bfce14a4ca38e1299ffc61d312ae34d536924846405a6b9a87610b80bd82438373ad8a765b2d07b7c1cce102d56c61037cc7ca0d6916cebf2db850991372b3638c51b215a73e81e12d3629529e439596fbbcff471e3081017e176538d7ac936cb38ce0f93852dae8099ff7a438408c3983990f78be2322c686f31a293252753ee392d049ca85fcb74bcfe8707b4537e82644e8a1f7ea695d6c5dbfa9a16c873716ac93269e2c210d1fc3df5d8c27c20f06c92bed68344929cf2c34f305b89e93ce6c9ec52ca3033f633bb902714cd8e5771a3638f82e91591113e30b7279f1f4aac47a72d5aa5d2b9fe2eeca812e55518eb581aea6a2bb74b42fe671ddea97bdc86e84bab6d16c318b789ca0a2ae5e892f2264b4a75ca237ba3bc07f752588b8d96f69555b8a29a43dd1579b17650779f3f41cc26031d61d5f11fbc8e7393796badda01811d949fbe2f6f7463113c30b17eac662ba0e6f65200619c09b03b5cb1ffa7472c006193477bb6977c115fd62c48890438559bbf229575242b2cf0149e988d5ff43aae22200dfb553183e857f1238241a5a47f657e21e2fea297f5618af21ccfa729c8b1efd664bebe91ccf3c7e939a073c93dec9ceaf7911cf3d4bf3fdf18b1d96346a73e23a3b7b2e79d505a7e786810a30017b36a9947f03b75d5ad8b7d5eac1993ce4a08faa64233bc09d8781bc09002285da0ed8f332420bc0a38d7b96180a502fb4088798e3c033cbdc4bad7b049c634aa46560e286746e281c87d7997f623ab1280849a50a1757dfe3266663bc230677ea67719ac173206d38b193a543c4b34b416ad084844701aba45e7c8233523ca5805c5cd6f1611faa311841aeb63bf372fc62b5ab4454acbd7585a346ea4f33d9daebf9a3c8999db14d1231024ea8a0503bed768c681a14a158053d46f98b106b9f17d9f1f6f186c9ca27fd256f04ee3e7d7f970eeed3f01bb3472d03b3a1a86c501e41bbad94596d713c48e32a8970354e945536e316df685e80a3750d3a0f2147b467da1de96b94ded0baecd4979636595e3455bb44081c5f5ac0d95d086b5df28e52e3b80c6da8b6871dad1b96c30a287f5b4ab15eb0c4d92b3d11ecfe23eb0542f2db60433c7f5f8ec5633b03ab4e4e6aa1970a683fb20db17e6ad30dd2404c1b5f2705eec5e80e2dea0bba92cb65b3978bfa9f54913d12107c773a6df7377ef402f0022ef796016c44c637a0be122a225042308f40edc5a4da74d98b49cc7493965c6827ea496d63cc0ea9ecc0f59d802456218ecd65cfd65e9fb7631b4b77484bb03ece68494b2a181333b6ea9fa902358eddaae191afd3f8c59a09f49c439fd2bf5a3173d10bd16b31dac9411746aa829e53f1c28ebaef14f8fb353721bb2cf0fe8c954733e8e7b5b9211b00f99e8938ea3a59e12f9c14da99fb5cfa73127e21b55b543a41ea86602e96efaa68e2c9f9f1aea61be81860537d8156ce989c83402e1c66f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
