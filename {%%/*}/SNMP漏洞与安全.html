<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1d5ceea9d0693e77af21ea4574861b554d8731aa5c85790fafc63e3d971fa0a8b098c4c626a8c32329cd99ef2562c3b8c23243faaf70ed420f6f4cccf3e31d5c1a58ed01bf3abfda5cb82a27928bd785a65f8d1a8cc1d08a8246dfb71324550afa96b830b12793d42951fdee6a22a423d2603110784c4b8ea72c2f78a0bd12296e23c68005fb63b56a9a0bce430b53284501501c1896077fdc9ef5bafc26256ae62a067ce5f07c8cdf2cfd0f9b70d999654cdc28091af50285f0b7c2c5a85706ea7a1803b010ae80fcaf5fdc46ad1dc304915b033f6db5802b1cb214a3f878dc2960a357ce83437c2244e431d40f0323defa57bbd45631b815d7e0dd03a1cd8bb73206e1ab4b4be328b72c0efe2dfc4b7aa03ea82ac202f7e20b96a4239dd564317666c583f14ba2beeb838df21866db7568778b6085b325d53fafa912f05f839721b8dc5b7f22c658573ea60d8a805058d1f3320df85897a8f17f08dbefac3053e6aeacc394caa58e05a4debd0ae5d81d36a5f77f132475e41067318d6901d8454abf15a59235a91dd241a55173ecd64e3fcd58f98993f8217b7caa56d7af950d9d4db2f424c488c86999400c208716527aa53e215bd20248adc73f54389956e0353b2af131715124e500aa7301f060a11c00b7d69fd61913c3e2b2f1af4e9cff4746c3d14b7f544fb303ec8d4f753864c2ba99600f2dca54cac3722c5ba0bb608a9a6212e29f91c92f916a1bd2ba736a4690885f7d3234ae1086a466a96595708c61e4c229e75f823618401d3fb3927513e5581f37a232eca0b1d27325e3aa411efa3a2d7438b32ae53a01db47996982b77ffd82ac78690a0faa620c64e650564b6924cc067cd708aae72b6d7b0c31a8983e620cc22d0f14e7d8aa9daf150e9549e30a74c3afbd54af0ae5175fb9586fd3f33c241356c8ffb2747a302e2bb988b9ddde25b8f9d82796b9f554004da069fd0c1301810ccfefb443f4ce3ce10c5ec0f859f10222d8db2410b45d4be521f39053bbc87a57d967dc3f5d28c7fe5f59ee1fb12802c5e2c1836cbe5b89326822d230f009b31f1208bda0467a5cab20bcb28c4e01754fadaec2abfe25ec2941e927e1dfb9b3d6660e09bf396a1e444757027c4cfaacdf130fb5f5111267d4ca8d04162e747a6dbd98cb8a221176d6bafb30962d4e84782eeaebf8b877d97b30024a828b2b3f97d84533036210ea2252f13223ee46dafcf063bf29f4bf7d40c30b52392170e9500a011b4c3bac459ff9cd3987228938eb1f5ba82781572e4a76a0898680fbe73eaa1506f655e637d4314e1607340603ce9fbda230daf31a15cc658fde79317b4291518b07beef4800d76a2de4f78b78b9d3ae093b0feb143b9cecc03a9c2a6a1c0edee2a7b4b703d957e065aae3c81456cda9106e070d70895f19c4ccd742117404198ec58d65e50756cf223e192a2983a4614be01190d4aeecf671ee2af65a00ab3ff103e4ed97528590659ce6615f10177021f9cb1a63e1de82360ed332b3a70ee11f8345268139b5204a08d42b7636e589c138be1639f58ed564c0ed109552ce2bbe8e00e1a596e20398d8fce04ecb7e75f540d9786d4760c6aea4ed64e63a0d0bf6683a213861d3d2c9ae4b471d3eca5cf267b75c228bcea5bf723fb886c329fdb2b4eedf31738dcf99c2cd586a7afbe4c2f48118d584849ca713edca451a231d452431708b95a48c145b3bd38cfa07a37079f77849a63d1fdc54c73ee4b12c627ad9b418d4400e485faa6d40c8a2f6239e86ceab6e0a983574aeaaf8b10330c2aa00b9c33e71b8764d11124277b85b251acde885fc62b737ed9c6133a101ad2242bc77ee2081e175e292b998e375a91ff5cdc9efe054451974bdf58427c727a2b938c08e5622ee1feb2b2a9e5aecb893a27b00ac114d1c3683819aaa4ab2adcaf152c721758e8f6e0631d47bbd23b1e15d67d546aa036d05f3d154a7322f1ed60b1b6ed8fc709fb5284cedc1f3fa94cdc097917c0fbc27096db7e38b0e827709f9325aeeb351f1dba8405f3318d71a089fda13e8de8da8edb8e3e3ea9bc5a05006a8ee393f0cef26ee84977450dfae429b7dc91974a52b336acdda439826a26247be0a998a2817c97e25555fd0785048fb0760f4ff898187f302c28ff2d78f7d8c49dc300ee47b8f3b7a0d460b5106d13d57752e23194b91ea646a1552d4351a2c890c071d1f9f7b69cdc6dc2d29d934190cdcf65e20370aab090ed245ce7c6bed4be30185b9a65c2163a7e4bc51df86d5de8e79dcdcd676b5d6c91c9349f507715bf04d715ec0c18d5e61014234007e08fe4253b7eb6acdb3194232a96a711b636239b7672482dec92fde7dd86aeb9752cc60aa1d084fc1391400b57d50a45af7f2dbd15e452063958e4c948e48d78631abc2b47ce8b44a5f0ced2bd0808931dc152dc61c1bbcfb8d619f0f2d0a7b272c810b6e20409ee53513b3ac7d6eded9a20058b15d4d1b91cf9d11867c922e8b9ee1e5b05593f50315abbbc7ae9a16676784e184e76a7da9548eb3c43f7238928c6e70db281fb46749efd4c3ad0fe68cee9acbce753ed0b7ba4255f46eeb913fb1dd8110de94f0a00ee7d141710e1e0ca3a7146cbf57e5c6cfcccab9dc1a0deb28b611a82282436bc398f6e4b5207ef65a2c13216eb87795be9ebd82d05d11abcb0a8d79666a617d47ec31242de8ad116a020fae68e89c133c404e80edd1e37c8f2bc42f4b2c744466e8256ca3f82b308964580feab964f31143c43dd858a263f50df603d137c55b2da54df1c3c67d1e9e8511e50477fd969a5176626bf15eadfbefa62818cff132fcdede585b2cac0ab970ee464484fd85b531c81bf779f59fee20277196535490782876541d46fe03319db71269fe4eee7340de45c3db66d348ec75b9cd0023141cc9bf4023052419c8cd37288c270efd74b4e76e02a462e395c3ee949e266b56e42b9e94347cc0a279abe08e20a7481a82cd7b8bacb0fba4d5a690def73cfdee11c27bc5189f0f26f70ecb7bbaf7ed2222db753bf01a5b51cd07b9e31c0521ba2ae00fa2bafe8e531e0ac336bfdd604adf27ae45cfe006104aff77663f5d9bb78bbc9e48e51ba676c6c7b8daaa6580756c77515894db85ab265cbc57bf62472e3ff914f981f5cfde49866f5016448f5acb4e46937e50074636556d90a503e21a583a63a7143a23edcbbb02f9c838b0989d601c0846638299dd7a712ff63202371408b2bbb649d310328387683d328ceae2b6bf6f134740391193940de9de3e8ad36dfae9fbce8b813617bfe950cff9a663ff7e11166b2a90c281f673ea7de1cb66dda19852603bb3063ee56159757342790b354af29ea74248e620ca526f1d1849ad55809f193d84ce5f7e8868e205ecc31384fe2f05bd7f4b6f1629a5ca6ffa6654d8d056d6f2dfd4911bdc2eef259cd5a7145dd1aa3045c97d72e48407b18692fc4e40034321806a5a591d40ca133509548bd86cd70baef218497ec4ec344671c0f52a523807dc307c0f0a6382d2393aefe4a8330a6aa267535a4199af6d1ec8d69b0e8b5e25213d9e667c826645b6da41737253a1a17d64f98ecba53a608dc7bc53fef75f736a1b4d9cc7b3377707d70a0397f7487c92a0eba24d46cc6b600a1b659f7ce62a32af61fa949ed961ee9ba2ed5c95721573d0f36c2b6b790e57a410b05904e74bc10f0d08181418ddbe967946511a0ca13a598f6e8aabfb8ca2e870f1059fd5d4aa8ea77872e16337f0917db55775315ee5bca5fa0dd9604ec4f0896022440a8a7b17ce226ef768eea494af2e05f794c8ab5325ebe190c2a8ff6eed5282578c5de84de07e314c31de37c06fce7c70e3c66eb2f560b1339ea13dd2e396da7a6b3e0360f977882dfd0dbd56215a5af586944c9c3b56a2fbcf649cd5791b92884c91e96a0f0432bf5f97a6bfa0961b5cd6ff34cd9e9eb16f6d79381bdf6b41cdc050ef7a319f2c46aea03e281daa5fdd49f4557d315c6349fdb26b2c46a4cdb32bcfe0c327631d212d667d0bab618d73a83f6b29a1239aab5d662c10934d23a06fbb55d84a1f1377d5cf29306a1e6db79f615ff3ffae94b461e82b8169e89a4722fcb869edf9440f9d91d6e93f288379afb8c3601b119b0ccc26766029bb2569dad0d580cd24af1a8584120831fc36cb348032b904cb638b48a92d6c0bc989b4e067688e3db07737c4faf159082b591a1c5772d1b15bc2b9cff2b95ef6997b53e550a85bef6560aa776d4084692b03dccd1606f0b414e4efffa8be30fae777630c830da7f9dbe0a6227bbf4f15293b098989f186d513bb24580c1904d0a192949b466826b512a4d28675621a50ef02e5e341434b957998edeb4ef387097dbe2c21cab0d3116ec291cecc8a11bda27477d3cecc93a95b89a71d296ad56dacd3d829ab3da5f81cfdb897171dda88ca310c47bcec400a6ba5d783b73da0310f71a1e2c543c5ecbbbfd081f0fe6d192f89d988ecbb7bb08799a4dd5e6c4b35fc131329876987a0363951058db12c0073924b2ed9c981b242ac0a63b9dfc289cfd03dec87197c07fb0e87577c774b899a71d8ddaef29809f5ba29449689da64078c520996aecb3c048f7d2cf747d4c7dfc66e1069e0b51be41784da7cd9b4d5cbdb76afe8d0cc85560c9d853e5ff520e3a7d0f9ba1a74d82a479710bea536aa23ee7567a406198e81614199c0a85c1b43f784756d89b3cd9bbbef89fb59e1656cb360a8494ad096385c631137b513798fb5a836dfb22029f8c1fdcfb541065a773e3ed9b088a04543a4c6d94d9db1f1a6078c6f0e9c0b4bc3c7cf0e104176f13124e0d7f49ae68541dab01acf345b9e7f8448a4f10347a2fb6888a0726625d5f7c5be2326eaa4d6b06ef7693a502b2612896e79703308f8c2384850ba2081a2f77b92dca363b3043733e49275ed8c4682bef3cb549a620c42c15874d69574c101baae100da6aa5f8ab1e8c88e7af6fc6ababfcebb07eb6c7d81d31b0ff46287634e6d00436e3e31e884bce1793bc172c4256bdcf89a7c1694cb0936ce5233f1b4ac873224c6544c0fde2e5ce6d04ee6c46217bdf0d40b322176bbd6b3af409bbd55a429a9e915ec0cf47cc88d54b94585ac6fdad426adaea807c9148f1439075e3460ed553790b63dbe64921f1b7f1c63f8e8c4bb6b04ea11bcf6ddb1b62a86643c8b71e81f311b0e3f611c37676f2e02250679ef1910466cfb9ef52795d4f43563553c140f3418167eb7cbcaea9c554295a8d98b4b67027151047f7468668a90b1f3602b533d0fdcbd3391719519ba9c06a17761fb3412d5d6a454a20df3343de14d62c6b739cd483b15528e14d9b1fef8657fa208abd63e1a9221269c51fb8539f36bd94be40feaf4ddb116a5cf366f8df272778f9240bebda6c39e72b4196b1279be3ef47ea1ccfa41c5b3e126aa42d73eda1c630bbff24d5c4a52f0998424a35cfe757a6e35b4723bfb5510e696533e3eba285a7be7926fc458651a78abc414de105e9afe3e048c03a76bbb890f352d95ef820085ed352d3de853011b5dc7fa9a60ed1db9ffc71152d549f8848d0549a0f62006907f56c64ad5451d7f84b037f2320a03754d0919677745fe70972154846f1f91dfb25c4fc9dfbf60496617277731856597037e65168cda6043c3ba80e4ce5e5ecc69d158ce965ac173ab7b6b1246a0923a61d5cca74d9c77bbf877d28042234531674b70a568c4fdf1d3fbf6a3cbd10b70022fcb0d43620c38cc08592ba0d491ab070b638e0b59ba0605e9655bb060209470006eb22beea734d01375dcd353ea340d4613d877622ba5f2268b99c64a3155e8b886f01a66d151870964db1dd845f2c6d0edb0c4d0222ee9aae67dbdeb58c28c3451565d28e5c9d21b1ad6067eb52a3aef455edc4552ad438208bbb444e0d8c679204d91aa07fbdb6c1b9a2d6f244acae6ee7d3652b513ff39289ecf7b3831125c634f8c7cab7561dadbc08af044f827702886c9fe9dc8d8a2f4b10670ba73f165b1d4d484b89d7562ebe597463251dcf6af0afc438fae7f1305a03923f07d8acc5fea029cb36202b026352682ba2965c541dae34aabf7fd39b1bbf88c02d8c1a76cd18edcacf3e7409f20bb675558ca10684d718ed6cf31420b8ee9a83abef28d81dcd9ddaf8b3816bf01d8030e2929008a1c50ebf47f26230e1119228a4b3ebd1a9e9be2cfb579947f3c733c3f645bb14ed4c124474bef133fac53519ae42632421f1ee17b84514f0b2d540f692d0eff361c33a093a60036476771d15ee6804ec0e3719939b9c733b4f90bbc2a43b82ca8029b3388a4c35cf2052a48af86973fd35c9cf2c734c1b40e510ee11954ad3ca78ad26a56bb2e959b8deb7fec026000ae57570d22e76d82fd4cc26f71f59a9c38da92a05db85eceebd72346ba66dbb5cf1d4a253094bacc50220fed21372b54891f2c0649e2a9a861ef91810a45bd29b257cee985a10607f33369af94bcd531c729d81cbe60332f19229994b7eac974a4b325e2bced9807fba88336a88082741aca936715c9e19902c74be4b19a7fc07ffbca922b427f30ec2be74a7a25dfd6216952bcd86960596f2dccb02db5101c8fa6f8b8c699f3984e4819538170000c95351ae9cdfe74adb307ba036244edee80e30446fa75c32e829eb819fc094be10ff6e73afaa7add0e77bcfce478de3143dc7e359535742c5c480c8d568378549f0e700763b633103dd4d14239cc3b3e755050dcc92880bfba27d5ac55a59e7463bdf36ad119e0f8599a534dce4d5cfbb6657e6018a7b9dfc4fc4a2af8779af6c3b4e1a8c2167b0cbef2711297fef906cceab8910c0b2391f7516a0ae6d2fe7b2786e3678d152d6ed5588b249e77744f5dbf54c8bfaa00c9cbf49850c12874cddb7dc7a8eae97888168c4175b59af2727e67bfd650bfc927f7e46fc4705ef854a0634630c6c59ddfa779e9a2ff8c975e2515790626544cec1e9f5a0bc167e93a65becbe5e53e9c1a894471073fe3c3507c68da26a19862cb6f7dd2162d356e8721b53e447278c23a94dae35ee9c2d02c6f54240968985f83d67f4d137b4c6c2351024797cc53446d4e6fa7762cb13153b902c5a4ad3f3801090b775ab75c10a4e895c4c26426a92160f19f72c88f9f3a7378e715cd3c0ec782743fcb24fe156668ea39ceed3c62009ae592303c2d789c07ad35e6e7ab239fb7975a5348296f440bad3e4e48fad6dba77e89dde46119c304d4907496ca6b97e574ceaa109347efad9188fda5aa704ec266a1aec20b3e70fa610e64c908fa2fdf0b1fea41e5606deb6e67c66be69453b06817e3f302b718bb1f29c1bf06c94956b0183b683cd5b39168bd511c9ea8c08a4a1cb7f8c9715cb38f077c201ba8e01d568937d43e54c1a11e406c742b320b35b0790ab8ee029b1f942f3e1e54703dbabd2623368eb804baccbcf1d44bb07247fb9906e205faf177aee553ccf7670fa0121aa3154068cb78285cb30449bf70ab8d6983beb8cad2adc1e83d0d78f055c8592d03c6d589318619dc8da3892f328e35cdc7c8424c39587dc9587158ada781ba3ee29af1832e1a6d9ad0ee3cbfc7f498997567fb2a6f653882a6f313a07020acb56207cdb43be3b27d98b0498aab875daad30c76f289ff036e2dcbb64db757f8c1f05c2a1911c9c88be44d0f6d5f7005a86b9110fbfea428bd966b59bc63b7dc222f89162a37ce0faa24dd2d9846f0922a04db681a13bc514a872cdbc1a239f3b092856541baa38e554a90e5b53bb395a200c25c721c4b56b9127ddf2fbfed4799a5724e892fa25b20ccbb34fcfaed725b567784fa845f8b85eb7a8bb2cdbb96da45f999a8baefb47aaa411a2b1ad39301055eba192182ba141e57b46f711d03998fac709448829ae3b9337fa0e50d055a824175c2d974bfe434bdaa53ed3123b4e0b28401a13a21e2bc7a5aec9f27a8b6e1a70956b44c6e044abd3d5a5e7aefff82ca3e7992c2c1f6ca338d32a81992852d29cad440c4356b8fa23ecc12fa168cacbeeafd1dc0005e4dac8d599617e300210943321e88e2f8afaa707344bdd8d83c94763c9a4dd55c995f4d9777915f32a52bf55a6341cb99b1472316ca297da8edbfc0d80f7afe657ee81da66f3a75272424d7892e20ff1444039046bcdb7f00bec58dbe387d4ebaed9fd9f6fbe0633b72251958a8386646e4746e41ee07ab14eeb13aeb7111c1bbe9428298fc32a8f5a0700480ade697b59835af83228561bc0e1070225448ff43803f53578c0167d0909504b49101a6e3dce4f4e9c0d4adc04244a8519dbd2f2935875b9ec023fde352af1e44805e844b9260172bfde6aee1fbf17a24ff48d3dbddf8544df46a827c3ed921aa434b30fe0dfc4988147e77fac4a3bd8c9734b77fe4aba0ee50e2845dec67aaa34f61fe138692e5b6c9d6d309550dc933ba54ed4fd540f6a5700570a3f37b108508969ff6d673c50fad41fb6e16e313394d3e7d5237a598a9ed888fdd0af315497edd7e5672478c7c48dbfd863d486d301ce85006f04c4136d611100151b6edeb6de5201b6731258f0d512764927ae9982a218aafbf2d7ac301e06b908bbbd4962db4cbb03919606611e6224512ee8f3560d061dd0937581c20326f684cbc6212ff2b513769bb2c4640f252c8e751acd23eaac1a74376dc73cae99468934f069887b1e7cfabbfef8e3f4737cda006d0e8a7e9f7fb1c7d89b6d130f69f97ec10d771d91e4de1b1325c8c36ce42bced63ea71f8952eaa172775df5bd06c316993312b9154b621c6dc820aceaf9339d6d63ae42de4732ded5fcb1086c97b704782d0250cb126b80147cbfaa9606c307a6a053c3c58c42b2b9788efac2b1358b374f4371b9abc4cf340462eedf5c6945ac68331b467f34775227f33a4f0ceebf853d40427b6cdf8d373b603e4d67e54b7afc42d57d112f8f002b27d7a0ad2130010b1201bd6d92102d9fe3723720f4779f2c679606688b2dfbbe252b1e2bf17b5b623e3d6e141bac5780b33571d4cdf1998f3541e3e611838d4ab77c16f667c54e246497f9aef928121deedaa1cf481bd26a7a7591315ae603a44335934d22a7a7e8544369e25d5737c760a005a6786837181271761b84ea12ed6586b6af92c718e4b728a38f8eca74c37338a050ceaa922838e6eb373ce354a547e1be3550f774482b5e27647fe930db8723e3e85949e21e750e1a67700e5dc1d3d90f07e68e78b827a1752a5d8ba78eadb09727f4534933e53ab90b4a6502ba52c577458e3a0d200f594084d613faf6b3be7608596a7271c79957dc411ec99261ea0c785da4f13d78d488a49a653821cedf69c92e2f9eb82c251b2673b4f94a96f6df8ab33c84e3ddb7de6a697c1bf497b1d85405f189a466a5179d5958a5746268be0c5f2c36e1d48c35c21cbbe65bf68dd6341f0b978ebddd45a2927bb256d43d0150064f6c020f76a899722416388a8352c9cb4a397cda4b2ce339b8a35280cea0cebe68a03639b4c13634574efc2456337525586cb8805ab5e99414de5d8ed8016f5de6941b4608a890b4d3d9e952d97e786e2be5c48d11252d6df972cfd503ed5b760b3af2f39fa9f975d1104ee11ef44062364201951875861357929a81b322a4119d362efdc9140511356d1c12e2971ae59fba99f0ebfb2d5a02a35e95b6d497107af85c624907ec75aec733480a8803e5c2b12c7d94b49c21ea5dffb5726e20a427b3c5802eb2de89ec3ab911fb782defc848ec6acbe2fd673d21c7c5d50f3069e91f0b15adac445dcf630c28586d3fcf003f8759e81aa5f0274c72061c92b87b561a2821df684628b857852ab38d14d297d623dd915e1763e06c6155c39ce893dfeb27ef54a95f95d211e151631591a8d437ae40f6d538c5f6739dc6794db8b0424a1350d380aea5688565402ba39891e77a9d65cc515a9ba57cee62a6eb058931ff888fe65a2b8b5b2a1bde608985da1182a3fa9e2abd6627713b953111e836d3b386c596cd52bfec6b3b91625c5cbbdde7ebf5e49681e7059fea71f581ddadf28305f5d304735f6470deed2b9e023d497c3772b079de0ddc5d7cbc7a66cedca546378aa33ba50b0e9d3c8c5010978613491dabf6dbe0fd2c1bae14a7bd2fab31b13b66084c082c80c49dd19f575740aa6ad50eded97bb05cefb4e18738880430e10a5f7b964ecf4b3de375aee54d3f5f65014231a12fded43bbc8bd23d0fa6c51c7cdff495a41c2fe998997bc5c08bda14ffd8a1b36fe7c8b134dd56e1c261ef1f264664b2d7c4182f52490b172f6862887506e58307661df8f684f73b492ed5c938676a8a814b7c2153586a3d38033cd94368eca7b441590106d82233b5670907c199d53b872862a10312a43d38bf33d595e27ffc8f09d049a11220b4f9c020b24651e4024f207c4f1a85e3bd73f2d17cda2fdffae929392f23cb1ab8b0abc39c9ff1efecc29ab087d49177f2a12a0410a7c0c946c4e1803140334bf970597eb85cca92250fdbb33b2a569db381bb41680963006fe4b539e3a03ad141d904cab31b5789bb893e78b214405cfee2fd8bee1cde89f26f6dc3df05fe78fb1dbb9a35233893150134ef2332b6c2d8bda1d03f6bf28fc809dc6f3580432a5dc42a46ff1489b5ac90866ad3bb3eac8807523f36835098765aac2fda93269cdc53434e0578215fa05d21c2d80695dad5577ecbcb5d79be1250975ba6d6f44ed5e888862992a667e0d4e032a351f8633b51c5e92d2e2f1ebd37aa7a7616b1a948cee39056adaadf135fa9396b24451b8b29ce479806000133751d0211ff70f3487a8b0fee095252123e5bc25555b1963fb1da4c1881f7f467249559764e9c5c0c33e1bfe1e32dcf0ab70dfa9bcc59135676e32e4ca196d2236d70fc9a9f41c34fdd8ead91f34b518aec082c3eb96f0292fc71453b0969948d00535185c3d9e34d2471602375986cf920145e84e0a1d35df8d46d602ce87cafb85c01178b762a3b0a9465d04365970bb624b15a24152e2245d22c57e6a58a00b40fadf1e6f51757137ba03e334e93975a9d9b26a8171396607cda7af885d11e0b9a0f67ef595eb227ec858b2a5d9ed68187e8969b2d678293b97732a56683a28d3bf738a504e76bf9f5226e4afd5f3985257f6253b947027a69ca15715edb232dadca3c604ccc2d8b1c74fdd3a929459ba58b690a05ba93b1ec765354580745eba9e494777bba8db7abcc90750c723e643405822b7ca581d91bfc53fbeebd88f447b087d44bcab81c48a898d05d2b1f484c3cb71fa71d18526164490889a6b2cbcc915548334cbb64f592486220c9252fd85f7362398f185c861cd4ce9eda330046943e391968c0fb72a02edb55b147c225a126d10cb516b82c924f8ea7c24a4d2a1c6691985683b3d529c5b7ca8f23a82d5b5de1284cc886b5047602ba491c8c5fd2717245e96fbf46b3ca46bcaec338b4b8ba0ffbbabbb8023cd60ff45b775a3be2f1d94d0ee6f7b27a5365aa528242e380355d5c22635d7ca5c52eca0ee0286d941e59d554bfed5c4574772462f16cc53420b05957cd0693a40d8e652381ae7a6a7553e95d1cccbd6ea8e080af3a7c7750a7e41825a3d66b73ea9a67e69fa5fd5ee982e0168c89819c11bb5e4da3bdaf8dbc44dd0ddda2d4c63726769a6eaa267e8d71dff9e8672a4cf13bacbbee21ed9ad377b32c486cad27389d5a144d2faa0391bc3d89a26d7f2bf69f5b85ce2bf0ab0975fc02af76ae3a223b15c01ee8b84ad3fb1a74b26f33a07b586d6df40f440b91e9544ef0602983b1b80cb4c2ecf0f6b8bbc6ede8eb1e313ae5d19b26ec4e6978011612f4771fbdd870b128819cb3367fa0c8f448086f29cfbc9ec82f563e311042337e8bd6374d7cd0649b609dd4c0d4b2b8d1e1d24b20b59a91823c7c3f3827729c876061df16ce1b6ba34ecbcad61fabf7055aca705fa6fbe9a1660677a4d8904b48caa2e874be035a7c2778a395b1bf1a5b2f1137b9d7e7b5ff8a0a9e5dc8766bc4039105efa2c77f6ee9e835d1e9948b06cee2c79bcee443fc3e542707e2d15c966e92c6250671f5daee0d285d4e9e1cb23d4a05cb4f47e9ddee5e2187da37b83ff5c8d5a9f0586a32b56526cecff1951b7557e44e41b0a8ff6c18cd1234132c8637db27fa72ffdecacc7c6dea699974da2401c45e6d7b0452d4af71df03f4697f8a671ce3fa3bceb4cbd8b15c0b455212c9381148f124ccccfc5856e17d0d86e9b30828cb37a876c15b047b7c11d7132ba9757c970cf4f6ea306a31c6bf548980a3929962ccf10d7c9fc47cfb21324a7bc964563402ff00aeff064467b84cdd1582ba3278813f40a08fa4536160c17085426157e574859ca4ca706ed6a92ba96fde899a55c91e350d9aea44e06ef4b7382014500ac2bfe7e9657a192cee8edf90fd4a934f2071aaf3293f7b1ad715cb2800368eb84ef602d0f3971a1525761c8142f1dfb991a243657903342db9c58e9ebc72f48882ef6ad84c24f9382d827e16ba8f35d7a7fbfee86d68ffda7e286889448eaf4b8729546a0d0f38593cf2693ec9cb59177ea1c8f4edb700394e4e7799a0af2683b177a4691e25a4202bfe4961050c07d273032eadb6f5e63494859cf64dcfde08272b02450ed1350211ae43b44e2bab032bf0e5dd8cdd760b6d228923f9b0e12dd9548f14913b63730fc3139f88c1a1c36a1846abee122b0cd7bd812c9da04a3fd96c9f1eb47b37db5fdef27e6ef8baadd6d651f82d37f14a1ba99211064d69eddc11f61df658b19d99063ce92e9e52dac3f2087f0f2fefa03850242c0a949204169be2719be79f01adffcb06940b436a16ce10445b33261724ccbb980bac9cb65a903a55491e7a3eee2a9d9765158ed8153a765b84725cc649fdb0ab71ed2a541acb2f29feae71d7070ff1a6d3d2f26fb357bb7eadd7daf7f2107ae9e7d0dd7f8c682d26045f921ddbc79f56d1cc817f7816a51689754fc00368afa5c467f8fa4cb4660c8cefbff26803c02032eb17a3f8af1dca503cecfcbbc68f9cbac79a20363adf5857b3a91fb37b04b250f85d2f9cb69e691c17c8d920d77f5032077a961560b04f2d16c21256013b203c2c9911951abc725901432fc384fdbf20a2a8a6efe0c050d08c9b1bffdf41fe1059c5f01d03ffdd7c0d9ae76ef454077b13433a044f6957d9411c2547f0be7d34028b1579f7a2d74e62ef19c1e51b7df6788362da361bd885f08ddec32d64c99b551456637e79a74e199fa54d87782f977e77a7f2bf79ebc8b288078ac695674dc6ee95a16a451dc89b264829564297c315f1a52a862cff1585380d892508316862f0cbbb07d990103c569bf5a2fe51b7e3e98c29c6fcecfaa6720804c62b0fa47ce23c43168915ee03043f0a51a6c5134d27bb70acc9706a588f5efb7b9e2d117f0050a0ed66cbd26ffa02e3f714585137e96f1e3f51437ca461c559aa652c24fb18ca2144296fcc5fefd297b78956e3464acff8eef34b819c4dee4d6584a720c80e335b86ea1fa6d73b8f6c402b12a606bdedfba69451382159bc148252e03de54cc7229107037e73273b83c9821fae198f2d3b2c26a68e0cd6d82ad9003cca6433949cdf2eec3ae27d60df43ec2ff46f94615f447525a6169ab739cb1ae829a61ce30cd790e442e35b317a34b03f330e447082898ec6c0a6eb816158f60006bfae9e55f4fbfce215c6257fa18c0c50eba1364a7bbc95212171426bdaf4cfe34edb6262cdeda225de3bf7e480f2f14927312d58df11b19f277d433323f29f3158565e9441efd1e8c00251d37a8544f0ba693f620956692c45e195bec2d1380018dc112eec3fc0549a16053021af1b049fa76380f3f1a658c05f76509c860f4e479e2f57c84f08ae4470aa9f2812e111f0c44caef3733eeebe8a88f9f8d68208188cfdbc513c0651726121a681470e2f2fac5d4891e95b6f798445585cb4b03ea66e6fab951db6546e3955db8597a433f83a8b7c5e3b39003f671ceca4e5be816b3f592e5d1b17cc27a0813c76b1ddbffde20c68ae101004cfe0b768a12cd736341fc93917f888b4e648faa247bc2580621602f41eaea721af9d4363dd279c43e3028bc1e934a9ced476a8bbcc8c38db1e434acf98a2b5b49932c25176f9336e62fd8d41e8d4f2c57046671e4660ec4aba616d3e80ea88344c23c02b4c4554174adf08457bb544f3d172ea23be59e80ba882b1a0afa4f30ee939987c97e33993766ce02b42f8cbedbc96abc1d0f54a0ec1b06fb10175303a245821a72caf1d63a1e19a20fd657712a247cc51c23b0a22d47414faa2d1c9e63f315dad911caa827305e39bf0a8a48811a84eb4815844dff0c6c94fc8d8b5137080bdaa14d2b147ec60310f60446eb534cc339be03387d3231f976d35bc69608accfef010c318c9a79a7ae360e4863b22be732a2355cfa1ff14d6a785a70c2a1cb4fb0bf4c1afee578b3c2f55ce5d0ac4f73fa6bfb4ddd75ba8e439fe7d8323171fa61e7bf8191c4cdb24afc8b2c3dc5a9258d0c2a6817f0d5c65db2d195c17dc5b28a9c16ed0bfb997a279b75b59014424d844fd0c6eb513a90b1bc7a4c467976850c85d10eb59fcb33f4b44563fb135e6aaf67276207cf76a78dc3dcfec57cdf214","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
