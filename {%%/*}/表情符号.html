<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0c65eeeb36f2d66087c0a0f9a15d0b2a2e6287a23dc8fc4273da750575b67cc0ad848c068cde92ea54ac53754139a3cabd7863938f82032222d6526b1c486f7511bcb7267213ddb5805ba8881e1f050199d3593217db1714a83d491aa377de78a0d5b278c5c516bbcd80818e8bd1caa6e51b2a11179dbc907bb6c7e9b81b9c6fab308807b63aed3e944a142041fd4d40798bb6e52f4394af9e09a767e2ed21f50c4f91072638f0e9d9c4b809ade4f0b804f63bff457dbd36cdedd2838c080c16cac3fe1afe9fbc0c83ae6673cb40b910401700152828f548e8dac681f7979174e167f1d10dc0c7861253e51289f9753372e8b4dad63a26d9a94fa59938465a998e83f7c02ad8c6854947a62a3dd9858d5c2f2f4403eb2a2fc268f82128f97c3b3ed6da43d8b1ddace34049eeff19aa72c03f89fc7b18016bfa3b81741bb103ccf341fe0aa6194896a051d164150e9abf4901bf3bd176d5d2629072c854b58d74ff96d1678704174a3fb2b9e6a58f410deeac829fb69211f509c552b2ec144dee6a37b4cb2916348f479f88e38e446b5eec75542a0546a197b8ef02591d8b76a22daf76a4a0bfbdfc1d32a5ee223044e982d7343779edc9584d4b3ffc518fff8aa6fe53af94f9b0e0480046398f3c4fbf5b9ee678b6c63f1a7dd8608fc5031b94970080c3c24e743950a6a2118f831325e062a6361043a96c426c670b01672c4a57057aec138bdd6f3df42e227250350d72415c0f07b07cfe9f70c00f918d14156ff0ad4e494701f2dae3417e54182effd1262f0401bf9cc9abab5d2f14186478bb6c7ab766938333956d3c7dd697c7b5e5f1cd16f2cc4df607c1334c4140818cffb9efac18a858730e79f18918c0cda0d85f4de55cb3fcdfd8e1f3c144b4fd389badffc9bb8acc2dc95e58408530da720d96d0ad83dfbce391adec6e6808c0604be2f3a32b1d0c4ecfb339dfc20776e900e6e2e64e9023d4dcd5815bc50a1d8fffa900e0fe0c2e2963a4e69f20d8360d6a7f8c37d239532b37f63278d232a1e0e95bdb6532e392affe930e33d6665bb47909d755a2951b43f77c049a4e9a9dc8a1bf647f8426d0e8abfd462310f693ed0178c5c062e6be87881e2517aac9d62d73aa7a5165d3a7b118be86bdb46432390e588f0f167d6f68c1f72d787a71fc9da8b04cfd80370dd8335e2a5225683cf37ef05f40e13bcf0fcb7f2c5cf858f9dbfc2b6ae7dce99aeb05c0a25031b338a8267ca6af25754fc1e8e6b9979ac03fee0e9d6b1206a79f5661527a26b81dd90cdf9c0130d3f7e9bf5c86d0a9b8ab8241da632d9821237da99445a9462e3d4042acfe1fe0579205ec16fac8deb7f4c557b3ce43fabc84eb4b7e14ba5154b48b9cec7ba374fb6e277fee13d92b84c21ae7322f1b25fb5b8933126008a8ff6641da7ae21b7ef323681a6ee187e3c32b1375c82197fe336b526bde484d216dbb60d6529b16d5d8b9d32f5c8154c3f410d3abf2fed159f2cc93df4a1536059d5f9957c75ac85462c90b63c85b3d5605cfc6add4b331e81c0259f7dfdf66edf496f0b9e0302227bbae15638e168cc921ed884a789a7373da3fac25896d9c9b732faa5bcc18a59e1367dbe7ad8b8f34857dc8f06d680b9e7940a1fb1d7c934281a62cb8e446c45abe05bbb2cbffb498a6080f1fc23f1e76ba6322b3c7bfceb9423544d3ae610c66ccae3c459d5f64911762b57da88137f5753809bf7fc1ee7007bf98c49b0d8183315bf8544c7b24f2e94c0df20ab18de5c28d74aba80eedb83abdb4601c901441242f816fec403622f4f6869f8942da521336d1d1bbb10c2db9a6b056ef604eae081b4752023d6992b2f8cbee5e817c3d8daa8203311a3e909538fc4c52d0e7bf2d5b6a095c01be1990f084382d18210b4a3edd3c6dde9e70c22a663de9ee6d8f5933bfd7f1b635ded7bcf08aef17cee84dcf7813f7c91cd25e0e6b131f5a3955b017c2b1cf5d39f88f93230b8b35eaf938bc7f293d3b7a175a126ddd065d35a818b940dff211844584ecb829486659fdf076fe9740108fee92d74382c0bdde13c257f5987582fb1e77c816d14f20db296dd842fc1f85132ccea8c0bfeef00b1884b26d8fc2921bdb5f44e53e7e6808e65e524fa7922e028a90a8bdbc089c80b2145beb0206c6739be47f9214f8311dff6da130981bfa48a5162660041c2f8575013f1975b4c9e944cd5cc780ffbe5a92a567b83d06665d7d016629c816ac7e46a12ddab75fb32cb346b1dc045d940d612e1699e40d5a25efbfee265e31929305d1692a89609250d45df72ee68caaa318158b758685c8e605e9be41ecafdb7b959c6c2358c6826dc3f43c88670929d4902af3aa9c79d7763ed65c2988381e2608410320c47890a8b1c32bd8aec6dda69825067c22652c62aef49c2ad5c87edc1c169c76d10c609d70a2ec84b1a0adbc43995e5df40f7e31a7e9833da4bb4f2170308e2bfb1683d44a2e40651c04bbd78bde2970fe0db75e20a2836820f882babc4e6fb3cea7bd6bd2d6c6e9f29ec76c6200f72ca43ac79339b2aa7f677135b152fac0c5af73bab1733a849903c3c2f9044bd9e6d54cc82e5edf67165801d0c9ed646e7552935ddd867363aafa95ce8c3da21a41b6a5100d4e9259ea5ffe85b771aaa6988f4867277783481aaaebe5214f74160304f45b4869c90789950bee9006aaaa341f12a9f34ad32f1a3bb2e2a27bdbc5b3772a33920f1a1464c9706b485c843d7651f2516367cca1b7efb775be32bb06216ae4e8ddbb3e8a57f4db709849941d067a825702e98671f263dd80a23f6d9eaf85668568055c62fbede96cee3b92fc28cda09213413218c62d8fb12291af2642f861ba5f0c1601b1e52655781b361e25063bd3a4bf16a29e6e657096b1f1560d1aa7722b11e21e65ad26f4cf1568beb05e8ff02127a09b8f61b2663f1a8d4c378743cb7768cfbe9bed00b16b3babfcceddc306fe368252cce030552bb43c754e993bc3321a771f7890da2aa7d24330888364a1ba7a82257e6c4a0a90402039f2e7669e9b7068024cf09fff4fd66cb78bb6e9f2369345cc7a5d7d94ebb90efdcc78b7857956c2dba085393ae8bc637566784e395097b38a0439f238f6572b38bae8eca18a078c06f130e1a303de14a0f4f439c3fd0a3e43fdfd22680ebe0256419a75156a51570d73be2024cb79e93c083d8e4d9fcbf7d6dfa715bbca0167528ebd989307bb9093194808b420c77f197d3d224531f7b43b5cdcc1822e5c6f01224192bc192c60127bd3fabf9a0cf566954f6a03ef336d0d5434d2fd60775536972248fdee0feaba4d070d3e9261838a2e25b74530ae74c69a4a405794fafd7905d242bd529376e24020c72dd1471bba9072d13f9fa8720e2eb307b146f9b21b41269f704dc3dd3e5fc9280a03b5315317207b862b4a0d8af0e2b12291eb22dc5caec9984d5556457c7893bae8bc3c9f3ee63ab5792da549307b71d19a459e91b0abe24969ca2ef1613363030bc7906c80c8a118e654c6980b7a5b7873dbdf002618e07886197247a02feee9ad4a573ed5ec27f82f3f336dc445b1250d4331d27857ec502ace6280f12066813f0a8f2347e4bfd3db110b93c272f5194de8d0babbadf8fefbfd952a680b157a3e6859741a44c80158f9d56ef99f921ea1794a8ca66fdd15330eb0795de10b1ed5cff8054fef1af94df99cf48034b3085a818d26991251cb45187334e945cb2b4567f905d81764dc27623bd181b7b923e4ea10c120d5ab07f25495a5c60b49ef842556f3804c7aa49f9c42f2beac4da23b88d729d8b9c8eec29d616b39ec1b3f3b20ebab4466aaf8ee992415fdd2e2d42878bfad19a7352b3cd21b1edd3de7db0b5283d59881c6d4c8e6a1cd9a03a1b9925544d62ae81571641c64090d4701e6b12fb402d2ac0d17c01a24009afdc8d99670542e2d1774db0f7e6aa9f78e5dece6f733e58d18093433432662a464413e19e8d9bbc6fe54cae378a54ebf783bf211332abe8f663dc2b7e517662de73cff9b4e558ebda073f986eb26a13ca31e26cabde11080b269cd5e311f168f3e7bf5e9034390dc9f11c7f99b46a4b885971c7de0391c717611be6ac70ade0aa44ce7ee5868a95044979a38f4113cd6cb6f20f297134d73a2d42fdb316a47977224929a6e8bd2dcb0f60bf7f186e6acf3c902104d15538e2b5e5d609be8f9c1b7099c843600ee33b55a67a6045498b01ee51b2b619295b86b501b83b6ddb8f83be1421d4cbe4f3d6495e10edb910c181c54b1e366ba1fbbf78d3c3b9ac0d1c9c7b938f28a7673cb50f0a9c35471ee642a1b3e425bb4558ca45dea3ed842b9e28ec4eccdc71ef0af8167b662a434a95baaa915cbb9465681391f46bf836f6ee052cf81fdd4c53a532e105a90c087e2f21d0b1e6da7f4afa7a9bbee89e1d5cb892d156414424a7e13e51e95c68fe87359dc93d751f938e3fee1256ca98e15bcbf0deb3a5fac0a67645206be6d8c5887003da07bfa060b542854947b3bc386f0194ef21b1f0d77d408a69292a24f82f8f1b212df6443a5f496778fb50adefd71a364480f2b5816b8b9741935c0b6639cfdcef6c83c77e98e16bd9ceaa9be77a9a981a54ca4bfec77ee9d0a8fb31b8b8f9ddb93471e94473e5326138d97a2af1b3eaf76669b6e9f4745cae5959fd6b499f72d5a790f05d49412c71b19b60ff4670f315f57ab0c15931c1f277b590dabf3c78a486095f78a51d1675c11998f0a6609185da5422f95f87306f0eb9a6a039f5d8bdc6e8428f12e10223e9453b1c22155d295b3a582778e76d49bcd5a8357e5922b3ee00863f365c5a2e79d2e0916f00aeb3ebb0cd13a6e030d1f63f03d85c495f64e3e1864880b821e93e678a979fa70984e70829ee8a3705a7f6cb1fa277ce6854f63aafd5c1668df1bb1ccc1b7555e11f14daf8443f52e1bb9fc14a0604e49dd97f6ad0c10f724037bc8d8c0f454eb96d46ae5e43b115e374b368c8cfb3baad47ef0e77ea5682389c7ed0295651a5be1949432368be93ecc790ab6ef045ace29c464aebf2a253733ce47c4752b4f0ee59b2885694257d20ed9928f983c13d9495f93ed6ed57b9baa2a9cc7e2affa09d22529daf639955f52fbff1ae57f6323bb550269aa43ef556780bf08db8611616a6173462ec4530de5d04409851b2e6b7c811c8bba376024ae72e3f832c7aebbeaa876c097a06d447e1edd547453cbc9be80a5f8ffa9fac94c07f63bca3d81284c4df9ce4bbbf42c4c301582b1cccfcba928fb1b15c539802e8a49f19f9d34a080dd55a73d435d9bd09a37e2ebfc6322d6a5b4128ec064789c555fd3f9b8e47c65a5257111492bb330d302df238af0739cb80f1818af632bda1e6548ddc02b69b4cb0ff8e8559a02e028ad8d0a74191c00a69f52fe6176308b54d484195621f1fb86e95feaa14121c535d60def34a6fadea351b1c8808242dfa6f9cc9987893cf530b93f5fe1b105f20070151ba956916e32b43562d27b851aa8e12c3d9085acc4c2d91ba96a5d3da414a1aca026c832ee6be0ce301b3d0c996c191ebcfc87e33899bcbe81845c67add1d7cd677ee17ce71db0b966e0d7171a5dda7e368f7bbf8bd5bb15d9bc0d71841907e830156c558d06e65fbf936335043102b4877ce47304c0b5b6c8ac2625be824c0db7fc4d4a9d3d3df96203a89c96380101520cacf2d5cf7b91913ecc3e8f5248a091eb38d9346fec9e8988b948de277c07b25cb2e6467c60d96ebaf3d608288f34703a3c4102b531c3aaa8552fcb6e235a08d74a975ff2a31dff9bf11aa41d48bddbaca1813ef2312a0e2d0915707b7c85551ef8cecace30dec29334e41bca6d45590364b3f611c0d52ddba374ce776aab376d4a61861e82b2aa23e86d4c85b3482f5c60a3ba59087b97fbbdda5feaac432cbafd7f5d0f7afb5d7b8784960382282ef82f6ec0728ccc4ab9eed8dad9fd632ff69fbd6ff336f800dcaffbe7a598b5677480497135182cdf130a4832df10848c8ad4b4938e0747ce4b703662ec24b65daa173d8338e3e12baf4d9a8361a3c891b6435e0af280ef8090d3f9ceafdbf6610263e4e73d9747c318e187cdc328805d745c31a32268030602418a7ef29ed3ef8df9262f74e862dda39dfe37fdf67a5680cd9deac06fb90293a8958c5cfd8ac9654098f329f172ccae9e913fa1dec98bdeff97f80e6fa218d462bb244f0b1b5a00c8f6bad601dd6bd6034b7080524a41c63b2162d42e40824d8b4ecd3c2fedab2860495b957d59644ec3107d25f975880275a138b63ee1ddfb334c3682495c19fda1f957795bae5ed94ceb0c21e47c7905350419d47c68174f59e9bfe1004b565b9e07356f84c52f0fa7f0712fbbf36e2ebd20eeacafce77655f0e461756e47bea492cd025a4949c937acb0ac3ce5bfaef88268f24a0c395a57bbe44585e5475191831a924acc8af4b52f5e7b87f1dd66fdc317b91faa5908616ff13581c507ffd1ac6f4083f23199358470c07cac803afd928eea8a9dc78f4f90d3c538926386cf2e4a366335a48665c0c944767ffc59e2716e62ee778e69d2b14b504a756b97ea48942c93e8eb3b43561bfc6cee4788ad1ed91454b153e5cf794729f5c0f8164308329d408aea3a01fa94dbaa2072e753cb7ab64bc447f498b75c2e2b90d9f43db543daec2e545f4b5a3a5422c38cd9476d519a07c0298b5fb6c2fefe90808187b9ba1fb6d71992c6fafb27f877c125df654f8317bb108a834fbc11087b4399a942d5e11d3e65dbab212cb47f2f9b2a720db0b911580aa58de9d07111c727cceab470d41c7d0b46904ac3f7f9087694ff142004fdbf64ddbf686d4c2b1729ddfe560b0c185f3a4d735351c79d0cea9338b45c5dd443f1e4e7fc225d7e75bf8e39820465a64498a77206b6f814f5c99e1315fbf47cb4abf224f9a4c9ce83cc3ca7b390858c85304319ba4d77892e340de6d099467222945123c7bc11a5452bf16be4548e4822556fd6eb467666be0eb1ce48855295ee82a7624a2f268b1a86390d1da26787edcb8944353065c6c72fe17927196d53d42b273dde63fcb589838c1a1b247d1a5807bc753e6a785c7d34b7cfe4648515c3d29bd96400064d5a1374c9a7f2b5f1736c18a824c88af0814fff107cfc53ab675f4985e6aded5060af8c092b934942cbe05b86bd4fa3f03b07836612a324e65b69baabbe26d1d55c73c0dbec62d0e137df4ee0c4cd0bd150d9f9a4116a266f8da3f0a92c96f08d5301cf28421aa666280b025d6af402aecf6f07c5cd3c1b8d8155800c56dde9e13ca8b203b79bc64d1bb9c9cd4f4732cdb4649fb07010e70aae10e39288a493ca9ab8f689985c1450dc2e50a6110dbd1a5e2e4e01ca428c5b69bda6937c63e069cec1654099b506c32ebe463a73d2b1981a254cdea5f1244aec53bad50683ccc142e82c5e0ad51548ce031ec5a39efabbe7887f4207f05724defea1d6115b4a3f52b129ac10963a83c65eb192da0ef0549700ce1532ebb9e26daccc81decb85bf0699f9099c08670d46d6a33f68e9fe68156f9864af270939ffd1d3993bdc7182197183bc7d0273c3bc726d9cb7bf5ba6aa3d7e802a326194517b99f179d982a7359acd51dca8d23fa5351f09d0b2b59f473a1106998cfa89e7923b548100d94f9426eb5315cf1244ef4220760dfb2338feb55ac95301e70fba2139dcbb7232ee4a238844521bc52b719da44f4f7694ebb68e04c15e3b7f26978d3f99a1f71389e8bfca2d9696d46802851da2f7d0dc2e091c2826688a65d023db99e1284cddeabc7bee237326f911ca0c06a68c85be15cc0fe9fcf8bda32f391ef39ab370cca9e5a302d6cd0be3d35791c03a7f78e25800b588087a055ebe76a04afd046e62e2506b76b66572a77a11dc051600f8ae2ee223b282cb478a50090daf263a211ebefc2cf4fd77312c338eb880db56967b64280d23a33ccabbb982c6a990ca6ab0d5da59010057fa8dda1742083c7e4fe86a5159b2726278ebed90418160d6a251c2936e425bac5c80b2b3f360273862d2bed638ece3309a6759cf3c4a35f5f68e1302e73175042cec8c80b72768793117dafe963b1b57ab52d8496e92cfeccf0b704e715a901357136dececf50852fb5d72c78b0f973a0c2738d368bb5ecdb40c10549e6441d003c3c799cfc0740f543ceff9f56d3ae60d0837ca26239bd08f69a7eb9c36ad717368b4f2c268b1a104f7791087fd94ac1f10a550119734a61ddb388fdfd875b4e8bf79957522038855fb5086302f730bbc068ead60a74e9cb2b6b511399c0f0e764aace1434498b9ae744f0df21d5cdca25d275d9f72c74a9b77b8c93d4cef04fba830e10bcde65c0cc2ec7e45e2207d074a48f655d257e5fa5121a754ec5fae0b88bc109aecd3b6645f26f77a8f1dc656cdb66e4739c7467e10ccd2004f42ad0d110da00d3d5369ea69edc5b412174d783e3f986505cc12868d621eb180014975560e8e0a90a0f491b528b05befb0f2be7f5e75e045722f62d999014305fce4c8ca6e7d18505c0c08483ac8067d1ba53f33d60848a7511ed27ce5b13ac7bfae359aa44c5b95d16caec7f87e43a14d77a328f07640006fbc422ac62a87bef0b82d8961a9f0be6cfadd04cf1bf6a828749c98a52854286d050d68ad4a724c06c70ad47917b84b1764edc29ac6a117835a47103646307eda783347a6e2ebc6e2bbe43172b68f22c26b3e5803497e70fbee8f0e87ee06cc781e15f7b1910526d673b66857225b4e0a119670e55d42575a0054fff5ff78dfe85f19d22803bdffd4a3cfb2fde2e1e9110ee7c44284eafac965b53af671babbed85fb295131123de4acc661be87056d5bd54fcd79cd68f488b4588c9727754470eda18c9e8b2ca49396ee8cecee70245ec4bccf6af43241a313f69f8d82cab1877fa9e44fc80fe6b61dc738a200329a3bc5dc6c28d32e50aa63fc367057a835804944feebcb0253cb13ff59f413eddedb155d73785bd49a27b483c316f0c26883e86508022fd867b051f6a2b8ea0f42d1d844b96cd09589a36a6107e36f1146fbb1300e2af31f51e887a208f5260923cda73ac2e004713318406f02a3e0ab303c663fdb810e919fec5f4bdde5782b4195afcb0fa208cacc5f69ea5c7e93016cc2e9eb9fa287820a0dceae98aeeb0bcf58d8f99d54f7bdb6710901fdb71cb97bacee618a70a65b61d8a330b603a07a9441c5659f25b135c4e0aed78ad797cccab7080268df1f0344fc5da6fc9cdd7d1851ac4ccc987a90f05824c167b71075de3b74f82f7c16f442e454598e1fc052d831ddfa74a3f9a6e663fe91e4fbf94d796f8138488cbe3cc6c92faf6a25a8ccf64f40c3d6b06c907423acf8642daaa91b3bca95091168c6ba9066159fc8f608c7dbd02d2c8a2f9bbd261f8c06d6fabdebf8eab9191a1e06310bbd98b8a05f2ecb692281a4a6284793742d6b31582be50d70ca252354d8535061df351fc294e535978d898303261725740d59312d08bdfccab594cb63a2e513ad793508308de39c986cd5c7da8a78b5904fab71bb5e31102122cde2704ae3ab54186ddb3aaec699cea602a31e6cc2b4e5254820669bf59b9d2c19b851e180d19cd54f56458d0f724ab3147aee8d9a7a2aa9c8fc2cea715e84b6a871d9bad13d411e352ee97333ffb76fa0bd8a168ba4dbac0cacd2cc14679c8e3ce856f62ee63ee52eb06eab5e901d8554363298c65e8fa192f2fca221521539141ab1c82fb9c4c661a6127bdd4875f92d3ea43b0653cae60bb4ed99bbe07db50392d451b628f5abb5b4fc16f63f976cabc6a6029bae8713554c390cdf62e917adf00251df31192156444e48fec0b85b9b025462ddd11a08cf481e2762841eee0eb5f11589a0ebef889625464c8c71fb5f9dcbec6400c96edd51d5640964b263462c8827f934464690924e35e9ba76223a6dc1f01f0104f90e0e00c64634054b250f4fd64194d8803a46eb57b61a3b981a09f69bcf710daf55e5d00e2d109c088ea0869c80ba7b19c6de43b3edc0580b651c04c26e0239388c40c3572038668a359b78f5cf38e649be7abe69a91d245c043786dbc69e93906c95f609b6960113a8410af4df7b06d65c09e1725c63e72f6ad90ba198ee6444dd4c8ca869adcedb0f04dd059937f011c175e364528b6401bc10a32044e7806e918b97924926e3e79345916f8ce50c0dbe6d137f3418d24b3972140fce0dab0afb30b3815276bd110118bc45a07e825a95b821e1e0c035be68439cdfb273cd3c162073222def541faafad7a05ac07b4f7d366cbdf2cd54538e97e68ce215d6877cf3ce715637061c8318801da09098bde579b30a108a44465495c8f84507a6b2296c42f07867821beb479793e19515ecd6f6b423b5eb1f099d7a36a3f2a181ce175721360e0075ecf34f82ba87a85b9c707be14d89389806620310d27fea6510f5a7186fb76b52d2ee0bf70b6167fe9e6c133f0f2623366032b1e9496c3ab64cfea3aaa47641cb07669d3bf0895fd756a7172279307d545c4302b8525f9d593f7567482586594caab01b5a3627a0582ae21c84ce02bbe9db096b2847a43e30d216077ff76e85fc59f70bba481d8df99e4490b55557986284a0b0e1a2360984e3f169a11fba4f9e5d4c0ede4f35680f06d1c8953d51c9e178ea3e759a4aff62bd5c9fcbed0ebd0c43d60783ab60abca7d6a00c59c86126a1a87fa3c4c59019d2f2d8c6e9a4ceba5f23c9fe7bc0e59f982add1570884e2d01eb7a825e1ef14f94092f46b88b3eb96f5a1c8ebf628ac0f28760a0fb09039c8fe3082433dfa3ba1ae560e9b2603c4dce6b814489fdb9768816116d4726c114c4550d6e4713c5e2b1682ca964fb3d9397a8aeeb056b192d3304a70e94f077174d4b2893cc933115f17496db1f4ce1d81dad938d5ac851374d1544deed83f3256d80cd8b4158ad41fe11b9beb155db770f80eccd0dc35b7e719f8cb9016c145a238f72098f7df8296a01ccd93f7f6ca19d399ef3bfb7d200ec11e5c17f1bd239fbc4f354342c8d7bf060ee2aeb0f3fcb30761ec567ef92059a34757ffd770b9fb9fdad6598b2c6ba1a44ce26ed1ada9f8674daf9cba6ae7348523840c660c2aabfd58b462adae9c2bb58c9e31d3709fde3be66a4aeffd218287c5186377c5840d088e89637dbc8ed4ea728ada70a848f922e50bfb0a0fb108faf4697cbde3426573c3c855004650ddc5509f1fa3e4cfc7bed91e9e696b3072f9a5f6263de04598b4bb4152f4f56c694c3dbcfc4567d8329af53600cf4ba0ca67bdefe3d81d0996c1686d06876f6458e7ea8f937adccca68ee343c4b45fa8050ca9d4c6e0d1a62bd71b3eada491f9c7b2158344246c85833ffd1301c2205c2f172f64815d77cb84b3b67749429e4a91cfd1adc853c8d3be2fa44664507c3420120cff8735b286a6605356d96e80c8359f148cde37b5d325a329c9ebc6ea4b27e6df14bb7fdd9a25b65fc3d6d85e0db1180f1c2ec2a420703677bb23190ebf974c3ba2f34acd1aa0a5621ea3ace040c4935bdbab83e17891d14d77481b7132fee48b9a91f09de1c9389506e2861f8bb4deada95650292282969d31377956bc2512d498bfed425a8ef553f3c00fd5d7ff11acbcf687d20276f3ff5add463af786d5b17c8005f2646d8a561db6bb3c28f1d17c550536513410d0b30641e0469dd8ee900eeb13e372c38e244704f60ca3167273c26df889e5a27b71f2910ae2e7699e43a205caed67bdc23c4ae491d349b786212bf852c97f8f65f656a8d17b59b47aa565d80a863a0c87b662843c208e78e793687104a730326d59faf0f4f1fde9efbf10f5b774aaee2570ccbe48f371fa0e9c70ecf179fb606007318cf30dea4fbcedfd7aedd76aa717667239f0a8ef98b0e9bb8e288777676b77c86786e6fc421f64fd99382cedbd7975370b3ef35c2271fe9e3501edd35d1e6b047a32f2459e52909322ea610a28d3abd5b66e09da6e6cbcca9161cd87a59d22577ac80bf9d8bf2c09aa5852d0d11b0b318286575404acd5b21902ab69ff3a1cfb6eefc7a799700d8fe454d0a3373b415dd8704e10e175318c7a9290b5a07395efe9dbe27ca9d36ec","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
