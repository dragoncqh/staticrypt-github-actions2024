<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f639e5f376bc7576f6525dc2a9ff518a21c32e7defbeb75141990075d86e3d9ab8ab543d27821d500f18c0485df2e099d16874171464f21c05b4df4702c3dbcb9911c62c62a36551dc3577a9de0c4f979c7de5640983b9add390fdbef170824620fb867c83b770b4c0690e57db0c2247252489e4090ef045829e58449fe31c1e17e6ae4ffa59ff4c957abb370cab681f8c8f8f076afe37f1b6666697d2659015ded65aca26aebe0b523343c0d4cce2ab40ce17975ebbe511e7c4fa48d29f1d13f661d115f9f9d2b9446ef4a9a18b0e451be574c208208953b4f9bf4ef94fc96b98e312f1fd5a01031c56e3900adc3271f1f9955acd437266a80591c8cd2158d92b3705f366d74be6ef2eef05cb656707405ee1e6cdee8cc02940b0231cfa84acbf7f18c2117abd42c1c513022eb3f05c6f6712c7c84d9a397a3aacff60dabc55b15efa566009d68e367d25e17c15de87f815c4c70c2f23869043aeffd6a69966c4dc16b08c40f44739cc2012e5521996eefc285231ee7e6f2c604f78cf03add5a76a9c4f5ece3847bf543c0b24e5b6f4e3d59c4209789e118cb536022f2dbd5fbbd2995dc297543846f95a7e92b5ff2a8f9b88f7f1a533ca3d594876232d588717ff6a6ada5b52aaaaf8a4cbf5f39538d1df64a5546e3f9266bdd6ba2e829ddd9c4f0926127c97e507af11527830d57b8e5f7087eb8e31e08e69274790ee7260b3bac9eb7ac7ada1a6a02bccd22d8d8d9216bca7c637ede4b36ce2fff6d34c638559fc255eefefc1a97c0fab97f820c6e9dc07333e24eee0652d3be36d4789f928ea426ff987854192fe0642bebb2f53e46fde3b4fe2c56c360361b8cf257a7b88e9e46fbf30227fb7c9d8b3e7c1ac898ee9a0678161d420516d3d1d82ce0b6d69ffca7db663b3865901fa066331cadf0286bacb81de11900cd02042b95b19c9b4e3cdd522d0bbef1092972f96322e9d7227776fdbc523627e8934482d8662fe649b0ca23bfa50d03d97cc88f9e5564dc69dd12fc49f4b5ab24f593ab38134e725622a294ba88866909cace7927c536ef4fffb1a8f12205a28b630ed38f9d2edc6f392c099a4ea67fad55b777a383d58c9d27c9f526c3157f764aa8f15334a33b9e7973b4a2775f8a2bd1f3ae52990ce59b623d6b6e90e6348b9e543ece3bd648368db837ff01133732988f7a6be0f4fe14009ea9f621ffe1ab64e4e796b4a56e9237e49f700b1e131728636ed9e2a6032e6ec324a5129ee96b2eaef56eef20b9a75faeeffee0902d83eb123c63e42a0eee1bb51d9d73018e6d3fe8ff75c38128a40d2936270b93fb167748af784723e7f88dbbd76c43b32624e161af08a522bb50a5cb953be171dcff5b54c72f9bd26297ce57f92b20b3e45444ee9a0085b8c04b34050230a60ab329512ca153e1eb86655db72b956ea80457e05272e609e790aa51cf73a07c27029f577e73fc71a354cef1be7a0994c357a274a8a9111d18f5100eeb0782e7706633c9d92a3c1aa956ad8cecb11cfd8ba24a54186cec8a00818d1dd165d01b9c35557c0732fa7b07b7d8fdf051dcde4dd3dc0e9a6dfb19f523c1999a06628651ae8abfa69e2e6480c9b83e9026b40b7182277e892b64e0c664a5527bc5ef508a1e8a8a7592b19b2ec2d767c3438025920991be9bb28bd707635f5fad3e7a8e80f71496df35c88d13001ec559570660ec21ae084d6d4422f5ffc5dd0b48a4d8e1e0da753d04e0a99dbdfb73677a2e0aee191f67cf128b3bcf748d97677eac7502326319ec67d1ce143dac7d37382e4ff9248886c91a62f7a0ab6fd021a1b7206b9b1a73c44ca6d8bcd12ad55cfed2dcb229c70b4875e6cadf9d408ff17e9b5e82c2fb2fd7cd69c078d6d0dda82effda31aad460d28309cb391c60be7bda6e413561790030112d846ce1a3b872615888e10d8dd14eec3ca108b29f610cc9197ff103c5edba1eeafc11e4f4345028f829f6b5293597e5110afc34cf38c622ae13ecba68820f1d02c38a37bb064772c67ca4276267b36aef914db16752e591f069c37785bec7bed1f680ca7ae86ca486366433935289432f0fac87d865842626aad747073dd2af93d15618a3c63dba5bdd9ccac43632101507b7ff1c83ba102125b135f7e8a9e11ff83b203892b5aef16438b24af3de2f8ab3c9cf36f147d5e3135fc90393de201bc052c4cc69d5fc494c6d6169bd65dea1cab9ce9d970b9846c1640eda36677aee5374786156a258138305a324bd4f10d48d5eaef9c073e688074d11a7a6c4381881d3393d306dbaf009ad5d621dbfcde4f6444d7fec7bbf0ff5699186bf606c7185243f7d898fa64ba5d7bcc5f293cd7aa6bf51c3fc82e554e8135c4825ee49ddc1c650810d656ff471d375fbb97e621045c63b9f888ac7bdaae31a0f62bfb7e6ba04f08eeed51aeb4e0f06e8b7cc0e2d7e42879d07f05292644a90e87a0c17523434a8711a8e029dc37273f4f275de92a805bcee83a37546058b893a401f7b87d8f8d0b36cfcc9b0c6322f31ce5ce32c295c6a826c3271cb515057f88ec6f24fc9819c6db1e47fee66c05e63956524ca70fd731d60fc6bf91444cb0f1aa5d4ff181a800a0545989cc84a9b606bf43ae899c48e469da74c9caea3a011a9d496a5c3596ab87911f572faa5c8aec3fe879d71b14414d70ae73c9439f5d24ffff043d549ac29a22ddc3b23b3fe1cea378304c82ee9033681aea7d0dc99862dea694526cb60d20a3e592777470d8930a0a6fdd155b3c4c93f1a8313f7371546d16d2636e562ce4f5c5904763a72bec5f620217c761542415c77bbfad3b23427d5850ba6d8a7be2b537f79f50c030927f82d73ba43b575d819838834bb770960caf692bb27d52077d8a78f58235bdacd4e97661ba2848f5de034d03f7d1052c24fbffe122335025e05dfe2340a593bbc5e09e8aaf5cc09daedf6f4a519232a8a5baf3191f93c41d708e96c5afe7a6dae464814b9a80632be708c0797989e9332ac7a4b71705f6a970b800b564b84fa40e03e59b65fa0d5d3c367b873addbaa6d0e255923cd0647a9dd26adbf5c56eefebf924a79caafa4b3bb60bfc71f90242e70c73112d82db69d8958ce8f48238a0f73ff48b4b44f47f68c8be2b39957e62e554cc48e96731109e43445cb03bc6c1f89887a254ad8ba16edba5d8a8636abeb8cc15471ec4406d46c13f4440cb602c2123b7423f4599aa5aa7d8e6c8de4723d1051edc1883537dba581027e44243913450a9d5469de431a221e3a1fceaacf049dd7251236edeccf7043dd7add9daef8533982bbdc1189f3bb2b9983eab0d94c55c66c4ee238a8c3162d97ef398698eba70f2a0c85599f4edc0de23d96eccd57fb9f27291c224803fa1d1a77f33ac9f7ed5980345555d46957f85329e30da17837f523000cb0391e121ad90167f11bcb713ac9531116022ff0288027494e7d16b147bb7d10156bb7f197c2b736088f9c42f8ea227456355029fae889a9c9f400195f5de7435dfd96c57abb0f051b6e2661bafaeeb0d823efa378e88b4172aeea82a48f631377fe9350ccf6127517f3707cc34e23aa99eddb2f7bfb921100847ec4c84b91cf499d663425f06ac06d157f086763fa8992e22f4cd824263a296131fd8910d3a78cbb372ea98b41b6c91923b25034dfa8b0f66a97a0d64c0d6234ab6489918cca159cbd13b699f64b5dd9b23383c5bc782000fe5cd49bf090339ee47095ef2f35095bc66abaa4a6ffe3c3726d5e7670600d8611c2f2fc5879894c63aaf3d7c1b7928f586cd08122c1e25de04df1eb2f9c4302d2f92212b142f1bf5ed65a626ff0e9d3328991b193150fd0d53691eeb7a5fb50e407a3fb166e1e6f961672ac49239d56847ab11491f67adb92ac82813a5850abe140c4141bc7729f2949adcb2428f93c9b5bd34c2070f27db70beac3fd0769fa7f57cba0774f9ed7a08d6c0ab31b4f33ff315354be07e859a10deb05a21875f10811a16e0d057761010f0b3d50bcb07e1bff3a2bcf4da36986d2781ebbd5e066c484ad935349204716e13fa990cfd7547cc94d24f7b5bbf99bf0d461d7b76aedbbe696ada19f7f911a5b6029f5f1811087488562e2a603162c929ab022161d1bb9b4896be0521c67c74ab094862f5642dd2e03421ac92985d7950a8bcc9d24ebeea3f232b9f7eccc9c063b2aeecf999b8f944932e7f43a1fad78e892e41527a5d85d0adf38216579a37435e666c7ee13d890827d0645061e7dfdc4879c3fed0465678aeafa3b4d2c31a8203d679cef34abbaf7f562bf43b43dc38bc308235d1ec27a0a9ac52559754c909fba827a9c5b35961ba89a617658b59b2bb6c3b876d1ddcc7180c86391b6d5ae2207afa1d6f0db62cb414877fab3e5a8aba2abb2da32990fb226f5d80770a7de307c3dd22b0ea5f779fb169c49e059ba01af2051b9f66b1e71ee20654031a0ea15574f7c22b76234323fd29686ecb93e172de54fb83900f5a472c84e7574d43a30b1bf1ec689f3718430e17b31ad4f5b84268552e694ad402153b3b58294399c16fdffc50c96d6e2323604c250c9b19e044b5b0f2b7f62370a2be820768d41dc2c69dd8239a3c54f4bd296e718f31bad3a59f629c45dc468ca0d2c8bf4b8ad31ae356a84255360844d91e047792f014bd82a33a78cede3345c74a922773810216826b7f11192d9d075af8608be68f8e34737276c9dc6ca9ae0eeb776fd36d5b78da3a8ac8000542a22f754c2ea7af4a88f4aa5953bb04ce6302593dbf3eff0158daa382fadd779b31af91f4a8e8ed3057bab4c617d3b102288b4d3c2ea1529b90b53077a4557b5397592589835b4e38df5bfbb6968b2113717c77c4f18c14e8f552f6972bd342e49528ea69dc55b51e1a41f4ccff20a8a0a03d05cbe91ea89e8cbede119e59fb46945d9f8591f227d7a36f9f23811aad80deceea7fc12b322bda14a85f7fade3b86e33a87c292380b0e9cc69fa6f81df8f6291a6442e5a596a4174db611e73e43795e695efcbdf85d268452db156b0cb8eed43f97c7344dd1c3ed9581c328ecede1f2ff7242b7c96444258b4a389f18850e2af2e706e97034861f52746e3dce4fdfc92a83ad0b7c7cd7a506ccd59ca0ae6920f1c4935947b6e2f0f6cb3637c97ac2eb4dff625d6fac365cd597ad5107b060cd63f5e67cf8a169e985ab4a6661b0d7a82fb29cfc59c18888e838ae5857067647b9bdcb3079f5a078bf09b23643fd566bb7b8bc1a66522d2b184c17a34b4496b9bc338aaa670bc1f811ee590ea8f4bd858197e7e639b06b18aed4a7dd6e89f8223be55a64e30e7ef1e62e052ed4d2bef37b46be09a639acc6a6c31ddda3dc485c5b18116993c970e96f664caeb4ec59be0c641d31990a4920966c94233127fedb61fd87742401fbd5c2880b036a1e91ccb11362144e08cd43adb63c9395f191e481dd77ff0e4d59d32aba3709b292f0f8873ecd12dbcf08190c09c4ba9743dc384dc0070694a8c54ca164866bd597743036666593b43e171f4d98b2d2ef93debbc86e46f989aa47e96d8edcbd2638c11c3fc60278631be03d358c4e6f90a77dc58f76b3035eefd3faa8c692340789e67e2f20a1ad4525be8983c190e8999e5a9d58770e829b5978c7723075e2d07a4d77b5083f907a8515e68b32d639770840ae327260d1c3ca5eb4931e9fe283e7f6bd33656e4ddea856b48db80f8c0fd84073196e29a5472e280513a64a19660af3219b132318f88315c33a0d5c69456588be864603d58a06b7f051a27a57a5bb3ed1cb945e7b8475e8e92520c3c8ce01698a45773b7130dc7208117324f298a5332f219cf60582d7d2bf13298cf68b4a28fabbf0e56928efdc6f09d80161205acc9fddf8a19990bb745a2b7d58e945b31cc31defb0301d0abc02f9be7a46a1ca6d7530e2b652b4e8f24cd4714e9c3fb2c3bce79efb1d1ccf0bdb76d5c4f68be74c1f79244a685e36647b8035284062fa9a197609f6d13f922e503889c836d4ce8e512b2280c11ea0cbe2e8ef520f5e8010a2adf4f7a47be319a63237d96f0340eb0fc64a67ab2e6fd7f290e17f2dc5470d277d5c4c48cf54587f61345337b3eecbb805d74626fb0d570836cfdf194ab444f9acfa53c027b5af569b37cb446e17e0d15902692dea435d7b52d84ef6a6c186b8f5bc572c81aabdd9de5f42e38867ca1ca262307899cf56e0d0c50d3f3932d139a2d5511338a19bc16783c033ad7c3576d8ddc761f823761bc9d0651462c3928e97660d19dde207791cefb6f78bd22af66093c63ea274ea2151146310175a28576ad4e8ea91ee1eea1b2179fc31d8a7b4337876a35a53f0a71c70e794958a556a141b6244b2bd708931a7f7bb658984e480a6b81d4848d6911b9673cbac16a6561a211906590f20541c90bfa21410010cc5cfbf2211fd28adf3b11e3d24cd7a69bf5445ced57870d0e88be96688c3df71f3169cdb909970808a19d88c360ce51b5267b22d78c08897adedb603cba0d20f343aec0aa184702e8cbfde28b9223b0c4a8849f2225a70a503d6d24a01953c9c8b5e0f991e43224017b7fcfaaec73e630cac4858d18a9dfc19a01940df8aa8b1ed7961e1050e5b232ac912ba89403a36094d268dba93dc283339edf2b8ac60f6941242eb57ebb0de4bc477bebaadb66abc54d632560145d5aa7eb75ea20c80e5b93a30b1d8bcf15086d74f73e311f70209f8bb4a0f45727ffa4dca0452b62bdc714a4cd4b0d5eafe6a8316b0ee19ab815d1eee49cebfeb0cbb060a428d986d452434fe9ab4bd09261b9e94e3647d5870f05099a65dc556ff1d623adf4fd6ada38a1f17a1cba9b80e740239d5eb7c501070aa680da94d36af7cbb10f1c8497cd9e1a882796ab1ea14a969d9fa8c4bea2292f71592eb55a801ee8712c15b72394851f961f025cc03087b46c907122a115ec2e94646e8ef12c1b6e075e586788ef78ae99bcc5623c8a777d203425b8f180f52fedc5bd7b18e1dd6e2c4567ccec980cb149bf9f15daffa9a22f1a598963738a2dabfb15064eb8e19dc4992ebfb1c5abebec6422b80ed54427b8e9e4ad6a29ed16fac23b0c9dc3b296d1e10656332da9befd228667a9c49edc65f49855b18be2b74884552414ebb54ec860064dc9d804619d56f43d76b22e20f12849d3410a0213b4d5332cccabd8d853aee21ba007db46a6a76e6bc26c2d7550396d2f613f91356d719847765ddbd62c58d55131103603c1241344451da4d62b628cd4486aa08b2914e59e10684a5c40e54729c1dcf8fc4353289768c52e4590aeb252f87c45467e88f0c4f85872f6c88ab568bce90d3c9033c02da65f4dc89db3be4d90ef4c1d128cc411a997da20958f84036263f52f28d77734387064040c8c0da8b320d456c8d0485e8333ae62364ac5ffb2bd78f5a79ab88c9a3c31625992b15437270cf6f4bc7357b7ac7e6d428d407e9cb63376bfdc3b2a8e7549dbdd85a49881b9ca7b45ed6855a740683b81cfb3c2106abd6afd6bb807a7774877e2ce65869b11db02c4cecadc576c32d962592e8f83345562bece8ffab77538c4dbd432a894eaab9c41a0bb9f22c3589689e69c11a90bb64d6434b0ca3cd69e1b0703808eac728c0f98030a22b9dd38398567989076f5d78ee7d8b68f3501a9689d9d87b6144e209e6494a5479bf15a653aa5c9c81f8e038a93fc1dbd989d5aae4ba24c4171fb71000be8fb8317ac7783d346e5ce083649363dae3991a4626f715484702ef16789e5d3bf0d6d57548c6bce2110bb0c7eccccc2a7a53a8366b0eb4ea8871fe5c4b5958c5a9e7af61fbc1ed9e11d98fb56bfebbb57c5fdaea011dfdb9f057867c5acd057e752421356da324c5e807d58a99f6bdb6b0c34732a2f8fa2c038c25e42c3e7fe394fc3c1dd94aa62bb826b99e3dd1399c30f7179715c6a9f7882fd847243a00daca4c60dd385b709da951eb2e164c6e9492d3819bad3c666c6d93a01e766e45ee7a7f85cd7d2c0230f963fbe4458ebb373e87591cd0ea616cf12e6b9fb158eccd3048258b29f32465b55d2d0cc37b36196562acc3d859aa124d94f06e44b8cd16f7d76edd510db8226873a3e882ea6a0bf8e09304dfc5f199d4a4190ad836fa183caa2e3a230634b805b5ac41bfbebe6e36a9e7e6b479d87eaca4929959259e391ad2e2a72087e112f829de45493130b6e3d9880a0b2e0ec9045d516c678f3f3e8d7de4f122d4e2c7269e1f4004ad07d912fb1a562784069e9d62179efd899effea720b581e31ee1827c106a2261bcfd3e4703f3a0564f5980ab4f872a2cd45fa9fde8356394dbbd8c004f29b8cf79d2ad068e10a468d63ae1013d94eff20bf94c1397b2b49b62e782dc6bb9a867abe7941d13596fcf6f2609e8317a6266edc2c3a9c1dbf1a733d2e4358abbe89683303983b136893f351e800738f7f99a169937ffc85d54c6126f2b6c6f0870bc9527d7fb9b1d3b4db1a6c2c5fded146bb124a586cf7c91a5cf6cd00a91761ed682b3a6f693c80b288eb98268ceafce34f85f5ba088bd9910d467ba4eea244f339838382108cdfdb774cd16256d86a20dba297800c7bb7623025a1e9dbbde670811a71c2b4f4afeba185e5f5da0b6d726557ff481196dec530d880ae80384ae402d5171b44791bd3cdefed3a02306f3d2d6e7507de384f3aec0a9f4be1fe05d890274df6403aaacc3a65b698aad2de87a0ba506e7b22640e8782d7a8d0e48ea71b5036b8b5e5a1e54a28a3f24d1e55c131b6b546fd80f60f52804f2d066b471258ee2fe345feb71307400bbe9e9b0e75811fe8b64d77033025b8024346d37b0d4c1078a90ff597a5174452d35fae253e815ea23fe51397bf75e28d204db1230ece5f9885eacb2f0c2f0fc0c50108b2ca0acee7674e1109711eb8206f10cc9a44944156f62943d151db27833a0a372820de86ff42da120829ba5788081ba9a3be27c3dad549d41cc156426891167a00d6319f3d2963af1fec425bae85628370470b7689839502b73f8e776f75ed132c23544521799e87be2ebbfc9191c39e1cefbda6276338268b85d80f82f7329191a9852c7097179afc4c28f368627179e3588ccbf759c91c431415049b63e447b9a0443810b135aed01585634a14852667000f1c58e988a22fc00f2a2ae6c593943a67874c37c91cd945419a76933c5955f235f37e6b61d8937aef8502fd350c9d60959273afc5501fb0c2c45c4ab2a2114d90963955af14f3dbde68dc2b859f433acba0d5dcddef134cb93625a355e41c6a3243c28f9154e87fc27195a44bb7fb656eddd6d4ce9c71877d0dcec4d5c49607e597d69ed6d91ef8f60e4e3804e3ad0e759662654126b5b202ecd444221752847fe1f103ad635bc3b14b109af96ab31c756780e5700571bd4ddf5ba1039b69fadcdad906f587e8aca4a4c90e4366251a5fae5f549a992bbc9d01b32cda1e651c8cb78d3fbb3edef47261073683342696b48a67a322c5718fcf0514739cfa1defaba3ae9aaaa76443e115f9e7b5db5bebbe1eb3b8603cf9efe802cdc37ee8041c506f0a2de76d0334e8d8ba5279c532af9ef16624330ed293676b715c81df8916fbe54cfc8f8a47c588ad5fd91bde3c48f8c7e6ba4224db5d5d790fbb3f265c0e1dcb5420a3e67a2fbe34c80a81ac301e60ce89c69b8b1fbaddc1c7291d964ef69faa09dbec89fad13288488a044679b32858d78bb5d3848ea8dbc72386f9463d83288f590a1666763a13edfddc12a368e3c25fba37c5cb09c36405c4b401a2db8b2bbe8b13200fa1bd5f8687b7f70523f95dccdf5b3b1c6e353d66584edd299a3dc609bbc49a48d7bb21171d47496e4f93ba1ad996fa2e315a3116275f9fe0068295cd2bc8f0525c00201d4158d0644d6d7e040ab25b59091b4b5b1a7db36c836705b82462e0eed280f32e4d8d092acd287450ce89742b9da70749b28846d66649b1b123383ac12ccef1897f2a13e6d81ba9c96af7190e5b08748398f152e431496051c1b22093f37a3e857a2d74d66f4ef145443da09fd189d1605a4d17954b94cad546334f852fb9a6937172fd7ddff0bf96fadfd899f501eddccaf7ee35f52b014dedf79c9bf4e82a30d831c313c0e8b988678257b335a1bb240722bfebc47de8248ae15fc8b2b56062e9c3be3e1d55ea6b94696fe1926f636e10c00994543ef6d649e7f97c955ccb9582d4782827955c8d525788598aa7e4ca0ba7ed2d697f3ddc7574703b04c89df18ad1545168f63daaea84d1f7967c7d8945f6a1f829a50a41380b386b1779b02ee219314220c814812920ddc148fc6d2aa364bd5e5812f0396c1839f78029de8db5af917fc9ca6d11d70dd0956ea3f1e8bdfc9489b458895ae085931c5d596ade73a566d4f4e7a1b79d9e09eadd3f3644dcd5d5859107e8f43a0270cd52be35ea168e21ada30cd173dbf210082d92d69c83080321079f06457b48c9b10d6ca91bda766e22cee0d7c45a8b2a6f2d41cbe1e174247a9b7655d6326901551f37cb1c7fa54360c05886162106c0f92e683b6e73d0dcaabff1a32d034472f6c8c320ac53e98d24c58501da26e7f652fab860ad8173afa5f7f633e8c5b793363f9297ba71a3787830dd1b5765548041d5f6293505f5957b48606674e1c81dd9a2c34b91d8961b4c24012ad935148b42610529fcedfde623daf366d79ca73032a6bb65012c436dac0f7e569251502735b09ce42b412ac4ad475343a26ed273d4c504f52ffb0ee0d5670ef6c93f32d8e903bb590e0e08a11a337386097e04759bd82e763906696ef10554de6026ef6cdc72bf75a5fb7686519dc3d64c8273826b36cc84ccb95b3b9f4e33b9522e0622461dfd8cbe1ee4661c5de4d358c2abc60175e79246c3815ffc1157292a52615b3d870a0c4ba96d08e5af63cdea689bfa85bccfd77a776ff72ba1c94391db73573bc480ff877f1721c385353f1ca622348471663a467bebc21201a44b94efa84c6df3b369cb334a779d3d6268556e48b5339e8e6180803c13b59f72154473273d43f5457a308724c9f95cb077b08d5e5a092322b8ec3e459ccb3e802064bb8db03f02de5a22efa3039792a0cbab9e469fb34570eff71e45831cf2717526cc2c9bdd2bc163f352ae611da0b33a4a5dae54c4bdcef65d114835b00a276e850b0431e233b1d3ba13cc09c25d17cacb6e6e9eb4c669e1416a14d4094e9d2cd86a019ca9d1d9e04ef8489aae3ce330a892e4450572fdaff99cedeb5a6de1d5e3b0d2f3df958701657cba7ee3f50eb8ce4263cc76c211f3f0c7fcf5a17bbcd12be7f978fb3273d80738e526e8cd24470c12302831720582848f61b549878b333f80ce8b61f08180b8a83a91ad612da547352b5fd31d08d5cf515f4c5f9d045a8c1d7bebfa52f569da2a21aa481336d308e7cd05468ede81593c48a11e45016dd4b76b64b1a42f6cb641e2451ed856b1dd8307c657d38b8f046814cb2691ca2a25535bc4a9f49b444d430b9e95c865cf878ec1aacfef56a2b2559f5d48762962573bbe1bf3b76ab0ffd59f6df2c3545e180e1aca57fe03aef774743f0b86eb12ce44e3ab5327830e898f0420d657d2c774f3301b21edc639f5f7ec01fc2f98a1583b31c11060b9695db870a8e78fe7b4e87bcf290e17225cb4f49c076a506ab1e6c277e1afb393bde789584d72012f2e77a105cf53e546a0b0d3e591e2f2995ca4e7c9e3a943cade4622d809ab9fe06d684a270d0fed6f6843aa30b1ec2c651510cf024bd2f34d68f0177a2ae8a4252a4e5d4cb6a7cbc57b81571dcb958db5ddcea3c24295f4884886fb63c22fefa82bc9dfd744251ca1b3f6e8b64bcd667fb61c1b541e0662325c0b6dde6132101dd90df284feb9f5c93bb7055882264a0be6c6e4ee72e11d74c170ad398f00277e69c9559006ceebd294dd4b70d373a432ce34ba2259a9b31b519cd65b4420754c0e0ecd0931ee9a080c52480a1e6c95d2a3386032205650d561e94d90501cdd98b5442e7acd2ab0430e9cccb8da84bbe511ee7f6708c7ba4b87783e2ae701505649293f18bf4bff1e9f03477aa9e9b45a63a6a1bb6bcee1b6f742f94d5e754011771b4df9a0fd35c98679ea07ee1ed8e55f23e0e52067809a2031b395b50d0e9171b33da19758cd527c559f862c4b524a40d23b9bb00361728b1b215732062119b02a77feb3651725c1aa24f74b839eeefdda353e2d552482b0b1cefeee0ca164a4e3c2c6e402b432180b23115c30250d48b47c54b99fe3f8cb2da6650cda9a7715fcc57578c70975a22d75c26ea14ccff1e30e414d64b8be31deba33682e294cbb9aa565f31499d36cb5fa80a5d360eefce15f9bfd364a39f5e85ed017ce2a37e5371fcf4d86d2983237591ddba57656f69b32d089d011296dc9e6a68bed3d5d4d098ab6655a442d76bd812ec5e47d9322a1fd5d83d6e6f5e2a64da5744548f81f5b5a40a7de571caedd74ec182fc4a2b863f93f577e0b17c7029f719bc90b79b07cd85b8fda868022c80a689752d41eaba4106fa8c089dafaefa5dd48e003f9f4df6d78d1e7ebf0c130f5fa3cf3e8d84eda591a8b82ad1ecea408da4a87f079bd4852f67e4edff0d64c5aaa685c1ff218a6502db426bd03578312e7c9085255609828684bf77632623a8d933cb2392c9c88153678acaf83714b7cba215011f4fa16e60c4906178e04417f8af4cf1099b98ed1ae41e4969c7403a86d4e1e9c7ea9e3b0b4976326bcc845e24fd09ed4d660b992863f8f2604af47a35199796e7e05bd88d6f2efa8802f41c101f645409e7d15a7cd53a44667b45a873144306066078d257a749618f02ed3eaaa37930912071acded2534773c70f0039196dc425fe77718e54303d6ee77b1b88cde273a214024006c8bc9e28f5dd37de8ae15c9b6920068f6a26a459cf3a943d5e4fe2b9487d4b6e58e407ad8f912fccbe7397cfcf3759b337019daefe8c617c235fbe77ecc1b8b3a086bc61e0f7150d96e73f1f464e4275b9a80fdd00927004c7d435857a4549f4445636bd4fc6c83deaf6cbeb50bf5a287b19a0405574d6b2dca49ab794ef1638948701153adcb4fac6b5e62e257b48d489fd066e1b846c303213cc1f2fb23f4c3024c04e5f0cf7d0b65fc4afefe8055ec786ac350b6d3b64cbfc10a99f2befc7f9423da05097be86c0d3e18abddc4374abe245dab9487a537d3c9217b784ffbe361fd1f2de19c4699b45e81cbc13a6204d59e9094b88efdc0ff11d43e521f50f914c460cf8fe3ff7ea9a33661c453e80cc97d096ce87c38d792192f8815c3e787220c53a95f683796131b04044df457c0152daf851567f4f0a570045cac1c40b1653f30d97cac96ce6cd34abe517dbd49a0c44ad7a6ad2ecae003a5cdca5691b62fc578f2c8718edefd921416fa99a4ae0b1794c489bf1b69bba494454b5acf5de1e4c19e8b73828a3e8ed256d34df24f7740fcb34a72a583ae602f8498949a1f5f98ea2d5ad178c70743afc55415cdcd00f11881093ca74b364d65ef894ed30f6b46c6e395dc09003946847df67c12ac9af629df55e2663953f39e23ab213d4a98b1abc564cab49ddda07f5c05e090b1956e3b0e99ec9d070e99b4638b7cae360f308d838bab2d01d1e97129c2139d2b154d399081e5db49d07d9486c1ee62fb899d56cca614f6c12deb32f122cb9b578631499278747fbd6644477a6fc2c2b206df3a028edcec5b94e61a15a88f1012334b6ae53ed4d34bee0189d5334320d2048aadd9d3116a0caebf6a0c025acaf06ab8099adbf2735b89fab96dabab9ab3e13bb713383f51eca0b80a73df53b7cf49ab7a49cb4ce8830d7248eb08c6af35ea9967a7f958d496fb794c10c666c2d401c9877a52d866d30162bdc635602ab334fb36dbdbdcf54eef47fb1885e0961f26f350beaf95ac76cbb89ca47b966649bf246dbac400ebdef3190078bfa890df2f557312ab247f4a8415f156f4c2df38246557e6432699a4e8e4a56ab82fe239d1d948e1ac8005cb59a38c6d776c1949d9069174de46d4dd36b5a6f9f1fbc0f6e786a4642165b2138d953bf41759ffed0f4505218f425ff769f2577c4fe9e100403d71874530399fec47d484c2be6fc8bcc1c71c6ce421bb60172e372ab60602db0d445608512c6d4e6f124b1e37c2218d3aaead6ea2b11ff5062ca5d5837443c73f243250ce718372cb675cb646a7c315ac77cce738ed6e382ec2037ddf75195c55e5c575278c32e1aba3f6a0614be6d67e7bc180a229cca3ab3575cce46a6743a91be91a7d02d515356f878fbdbb75fdd2dae520539e6a3aa9e0e0e14b175164ea1c736061f0a222fd87e91dc515cccaf9557f6704debd229f38ea3b4a16caecb489620df848e0d5f8c742ccae42d1451fdc7f16fe0a1d46d1af132c51ba8492790769b0451e2701b448d7f075227f681a68a9dbd9d86635355f8b4a8364992c46a12d4936a3d5f08efd6ab9c255fc9b0d4201fe6fffb5890af1ea5802504503b59dcf34ebcade63207709311be0a17529c59c27ae8aab2ce18156b097499ea4af7ced9b6c38560571b0381e889671ca28e03681274020814adf33fcb5b61faa11953d0545a0d754344be24c397c80bfaa2de58f0a49071764182c20f6a838690fdbcb4cdc08ef32ccec0f680d755092ca0b2b9ff2e5bb25ced13c1ee5af61cb29ec61e5fdfdb7ce940428e58c78f642a6a95cb371a2ab6f80b55348a0460a6eb381b3e1fed2cc9377f951eea85426625701d87ee8a2570863fb5c1422efa06cf4ccef8e9a9fcb2cc604bfd522a3dc3ad183321db562f7cd0c6093def79d01f83935d7b701ee71d9818d2164ff3378162c46f815243e8456a27f49b14a9a63d9a01d7aae47c606f716187b0b3ea76b1e0c35e40316d2bb368565e7785fe944cd5c40c1db2fb3c6a59fb81c494fa2f6e11dda214dff392ab57da1bad67f0781362a06de3eb7eddd05f5bdb2747e357255ee7ab988bec7f8f04286cc9c52d501678bd51a5250599a9e664dd3a997306382a071b2e917c9eb97c6b3e7c6374bf95e4eef461b5c04c604409395490bf1ad75edc64222b9d596262621232eaf1e51180543f365ce644a2dff057b0a60fda9c930af7cd74fdb15481cc2de59a5d9349eb650f05a2d2637d2448fb69d07cbc878fec2460e30507f4bb745e277197c748521448dad74823e6c851fd666f2ac6e0822a45042e75fca8162ea517e019bee496d5b0b743094eebfe279df9e60caa864b90bd96a02a5a232daa7925d775d95cbcb162a4a5c3020905e5d2a55a440e8968b20c94ae1333c7986064956322a95c136272151127712ace1482e480f5b6019352334b2cd7a1443569203c8dc2df9b5b6e3dc5ca1961ab8c4c9e3acf46fc256c02f68cc823e97a2a125a6f72979dd16b0d907c02983284bd22c37bf261b1eb46309c93332ebe16ef951a52d105e7fb7dff9014597089f5711a2aa1804de025f6162ccf8d67adf72737fef287ea5a31379e220c85e8c48a8e92fbddf01bc4142f5f3a0cd64d19087defb71eb5025576a03ba60c5667a2f3c7825c900858d98da568cf043f3824d1e3f67d1f6906b6ab31faa669d7da175efbdd63120f1c2505569ce49b4b21e3600a5539c93265a7901dde77cc1f0ec059ab61b759eca17323df1f6add44f7907716e326d24ac4a6ae04b92131838eaf665fa23c4a4600cda988261af8b66a46d8851b303aa33146b623ffebcb0650b48f05d8830380e18cb34979034cfe557b2a81cf99842d9aee07f8ceebd5d754c49c94bd99430285112af91c0f095b28dcc758bb6a36b3c9c4f062db48b70877a5778a5d605c0636be100976c7b39c04fe84d64ef0f3b33d8ba54aa56cd75b37fcd590cc8d4b2a5a2e23617c25dcc2de24e8f70c4bc3afa4d45af5a30037f520adeafe421cfa26f3bf3de1a303721c25958d2db33b9c93406698c9cc07f00bd7c0aea0ece58e46ad1f19672e1e4e8943a6ea483c348d1c0c3f43bceaaee9ce3a84d3a60429b7410de1dc423d438039816ac4c7c54b8917e93c68835c7a460252740f089d807a18c8de6dba5fb8ab0bc2a04b30777ec3067c00c82ef98b8015f0edce45ec5d8243c22ed50a94066e861db01e9b0270346b96fcabb1f839ce7d9b51c1caab88f6a46bdf5425240c1f57abb0787e3ea728ba3acec5da3b451c6a51347d9e49f1ee6735fbbe28112bd2bc3681402ebc9ebca703f17e81b9fe52a311f583c701fa27e470ed2c8689f9f5d173f4ee6de42c94fadf2269439d23abf3ff51fb480b089022a6e2b3c17eb8ced5eef58d0c7d3b94f6d6443f186a93cef7158a032611bd76055328cf37e9573097c97f79ebe480d010621cdc8550437e1e55c9b860c871f53660ec57359ab526e5d029d6e321ebb9288176295e8a21735e6202d01877e138f74dcfeee77fe3c0ac85d6dec8e4c50d12b009034590b15c4d0774a9fa72ba8e18bcbdc26dd5be55649986167ce13288c4146cd7b3f00a68e9fb6b904f7656d14b30d357322899f51d53858c7394e62e2ee613d9a6762c96fa8780ae0d50da126200d755c039d932dcdf675643923bc27b1ca475938cf3d82c17b367a0e46ed30462f2880f80d7bbe1ba5311cdcab886ae77db26c3e89b2e75b020bea8436c333c5c5e9c14dc245dd2b2731216dae1a69508c625cc86f2d71aabb86c63e3d5754ae319b8e346dc05ae6cb8cee12c01fe59a5b6fe61d841d94a68c02ea5582150d4bc7ef901ed4c271eabc7f59d376821a099d4bf3a4d2093f394f664dfdc43584fc6ccccb59cded25475fc7373ffa802b0291bd324630741e8908b224fb3e02ccd27ebd51fe664644dedeebfb772ffda16f5e193e92d914a6c0b6ef35f79d374f1632950a2c81f6b4951d8967ea7140e45de2cc8210de7df7d740f4c87c08bc8f872f0a21696a1e1ff945e6dc83858acb5393539b44cff5bd0c8af6e08679fb31753c9f6d7f7563e8e084514d33f51a5a4a992de2c4d4bd8ba33e72fee7f96f4a439a38374591b92a86c6232ffc3b6958e1174d1453f71464672df2d011117aef272646a80dd461c9be26562826f399ed5d0708b1fab3bf01b1bd7309cd7be0d024f48a4646d6bc055600e49b5649626e3e0efaf07b20a72d5404a8e0a8abe87c6da345de97ecd047df62d77ff3e64a867a1c3f907415ced8bac2b0d5c8b285ef0e845abc16c5c53e02806af7451c1e74e15d9664d5004407466f9b5dbd13a1b619511574343932c492211e7076905e37f39e946d48a6fe4cb95e60e6df042f3f05ab2c45da998d2ecc0350a100ffa4a016cd328b8065738df0ed495d67201f7b74301e6c3bd57495da03ae6944f39154470a4a39053d6aff9c5ed27b226524b29d74cb17469d60634f19db8455bc79ce9b2670bcc74e6c8fe4ffe0b5ca01d87f0574d76b5f5173d9a353f56a1ea18cb9ebbef04bf172709fa278cfdc736bfa66103d7d82fe0928a5e92f840e2ccfa718aaa522525ca08606b0afe2dfd336738eb31ee38bdf791c2fbcfd74077a7fb669861bcc75f078ad3bbd3e9614b75062b0ee43baa75c7bd8c473849a6f02108eb846f1ebc288463c1761f2e7c39967d6b178e4aca96f24b99fb04432aa8b74b764de4564d5fe4e55fdae8608eba4fdefed532aab701652cc4c411c525aca3502612984c48cc71c4b3aace363d598903300a298818c623b066c1958c3ba79cd2f5730ad59317539a12f143ca8ba252703ddb722b73aebcbb426df1055241d5b09e2dd8f11a1ebb13a3739624d0fab41e54b83addbccdcbd8897ba8723cd6b9c0802da7942e41f339ac9b1432cc4a13a3fdfc858f8f58ada839072af6090e2e596b9ae52772e3b81da385f18a760072210bd9b3a6d93bf2a67c65c48b88f2eb81d3cc59d3006fce83e0cf5a9b3a415077406c45867689ed1a14e22557513f0e87c7cab1d423917c82e0da51fa946a5451d70a5127a41ba12f9c66fe3e816b13ccf502775cd68390937576ac5149d437fa42e89dde564da0bfd56c27cbacefebafbcc57f757589ede9f72173712f1bd997623c3e1b980cc43d3bd9844b3c83b3cac0c3f6bbc23799a2eee84016347de314d68b365836505583fbc8d31f9c19228b1e734a9082b6377d33ef4abc06f4c875873d65bbf2afdf3830dd9e16a737c039b252cb0492f842b94280aa4de7ef1cb71d13e65e91fd30139e222bf6ad797ef4b45f5e62ba270442f725981afd187d8a9aa07b38d566fa9948cd9f8c1be72146e7053179633dc931c2ad23178b923954caa1dfa78c92be3cee9d6fefb3f2449780014a65b4015cb84f9e8ca9cbdb432d270542092023f6bd22d6731cc3b96e223579a3fd7320868bfdd7a9b1e336b7a3ff327789740e0ab8860e6e73dd343810f391e547ba7e8ca5d3169be0ac179c819260d69457c9d4859d4bda918a2fe800b24a7af1e247829c63fc072074ac8986abcf6cc122c9dc073caba7e3ed79f23151d44216f680794f6650a61b38fe19ed5f36728187b6e9f8ad335bf1aa4e1d18c7d383c68dcd0b241e6248f04a2441404c1ea3ec27f92007eeee7bb4bfee410794030d45dab1eaf45b27861a5fa83be0d5235c394d8c1ae3f14c8f1c6ec7e8cba2bd8814f1a1ee1a23f5e12cd300f3f54713b270c066ce2a189f53bdb3598125acd0a2a0aa6d4d8f1478bbe58e59d8f3447e30f967698cd4ac92e8aed7d009b29798b290d2f55456ec8b987edac2d82fa30799671525328aa665dc4669033c999fe42b5e07f990915bf92caf74b199068c670d4a4ae63c4cf2eb8e8598e33868a7e2d7c2220918fe679543d0a1fb6d90c33e0ff46c6a9f1b307b6a8d13373d5cf63c5ce991e073f2f0f460a83ec7ef15091b472d085314e9a8ba078f8f47718981bcfc6e0c4e98553fa31a541b8e9af57a47562648fb4d9d1a5a3cf844d3a9483e45e1110b17267fb9d7ba7bcfa39398db3a7265834216fd67660a3c5cb252919345cdef2c23a35aad7ede1c5f57067d0a4cacab7836510777dae3cc2eb465ccb16b9891d260952d3c2f208e93482372f508d1d39257afcede88d892630f62831e7c190692e9033e07c32ee3f9c49933acd97045b7131a9063c9cdd7281c4e00f768148a46ed7ba5bf36e8e44bdcf31fb04f2f7d0fcc32b719ebefc99d31d34839c95fb144f5469586e189aa1ad0d99c2fc9ac5c3ed92bbab56cf2ee5d179785b4aef6c6eecf4c35a5218c07dd31545d550242a816625e0ebdeb68d339e6bffe77779945efaad854a19c3e44fb3fe61c30b7dccffff858f006c241a153dfc27b6c508698a21dd0fd99f9e565cfe41db53c8d8d7888deeed5e3fc923bb437534ec9cdc4d93871d436f561642d98cee94005d02ea65d1245869802d8d04b164e6f21499a9b19b4f93b0a13d098b9f6cd460648d0b6c2b1c5d0336254e3a5f1a2a8d03d0f455f586cdb7f59d6d64132e7fbd72c1191ed281cdf083f2c43340cf1a799dc3e119be722e54492a44927d780909d39c2e0727d5f9c838c9baa37e67221fe4c3aa900ecaf37ecebd0083610cc915b4c05108c9621cb94354916f257591b8ef03c4fbbae0591f03eac74d9a2e067065e2411668f5a96965fcce7a54d5193fed913b2fce4d6d413cdc05716de655e6ac5d58ab483d7f1c83a3643482d93e9deb7a5787337d985a0bd86065e99b7c88d14012bec2ebd273790be08a5c5849eb2d1df86f7f8b51bdf3e5c817e6a71331c969502685b75317f110bc0c48366e7965dd7eec34eaa4be0ebfadb48ee2dcdec832546881b465f690e05d8644c9ab3d12121b738a0eb1d64aa787a96d04e128b6a24fa66ab280a26ad18851a66d114112fd63cd6913f95133d4bcd59985af4f5575aa9f4b7fbbe3af5413d3b222370dd17d52968d448d1647005444b5a66cab1322cf65e1e9d253075e155bd7c436ebf0f2e8cdebcbff856d959cf992f7db6ac6cbe92937648e073be3b8fc67914724cacc46df1b7b5269dfc6daefb725834ce7b1dfbf1ddfea8d75fd00c8de05424a0df1cdb3227f50cf8751fdbce52acad78bfa2e8ab060167f5283546539b3a89ba89002b71fa5e9b85ec30bc25488cb174db9aa9487e30fcac0e7e8e549802bba0938df23f2d00f1d83527a537171e78a55488d15de815b4404c6568622a9d45eb44754a1f366a3dff3d85b41b3a84ba8a05832d4a5d889c11299a10426a08029da6439341f6224229080445970e9951f26f2726225904b20cb74e838ec84ade62f1e2f1bc0e8f2f457797d2aac2f6616d37fd9a980ab3d7f99c0f6c5be91ee5ac92a988d61cbf7474765a00c61cf8e500a860b95b96c6899677fb1be231f691bc0a3d1bc701f892a6dbe7f16a3c0078154f8ee19e82ecd2ddee200c565673b3c044ffee5c71889b4daef8877f3d4c2f08441a141bd8a8bf2ca53bf6fffe2142b68b6b5823d14287ab1cc364aec75ff7bc4b3027cc72c84c9304f6db1cecffd6935aaa36ad83c474530415679ed5b6f39ee30676f20eda4bb8544c4cd5858ca7c757a344a4b11893ba162bd7824a7c36a7e9ffc05d1cb3a68fc6721853b31f0df5b69020fa1075528326d664346112f2bd90148a3eafe7af17c503dd3fb6c71849ebfa1b421b5890b85320fc1a1432c3c8b7eb8fdc06bb688b85f09b4c4479f22fd0504c73e12b447d0d4d0edb7d64e63cc65bb371a1b62474e0b07394b9c0f9ddb7bd244af9eec4ec1b208a5d53e0341dc85273cf0453db26937135ca9c3876350bc8edd02106795c18f88cb77acbef3296af590d419cb3ba381d8254b39c5ca8af4c8e19f8d12548be90fb0ed13fa88e8f6d39c41ed0124634f6e2482eff939ed19336b8ea5f406e10e05ab3d08419c46920ca150b656b6802abcd72ac5fab8a8ceaabe900cea4ba5626f97ac2b8623314c7054c30ab69a32e65eb648beba092266fca63f18d9852f2f6bab271711371f44e67b529949b388477ea13bd892bf28e2bbf1e1bd6fd7e937851bb31210f6ea1e1958a6b4ee56cafe5c58672a81f200db68216a2dd3cd80814005910d0fc44e8527b6032624f2d0a2c9d54548b3484034bdeaf44e22f34a410efd59477ad601488f7fac1f03105d3919492e45e4c3952ec5497534938f86f676110004b07327a00de95fd5e91fadb6e47b60d16ae81ccdd392b132750162ae2df73e1e1bee363ee16019d79590fa3fde39c608df1a307aad513691c11c36faa9a927288667047b4cc904ab96d3c990ccdfe51e390145925305d93ccd2921289580c2d4f44aa4b62676173db3793c33a391cff5326b24a8c8268a03a7c4cac9a65c30078c3867a36388cf0d07c1000257a6e694fe546c024cbcebf83c072bf521d6b1385184548d92281f0c617c241cfd56b1de428aa8b45e3d19e62ff9bb6cdb9f7dcb6cc64de2cf057237725b17b23133de218de26db21ac915476ceca90db6a5e4f16e11bcd7bf13e735f5adc18ad2a4fd015270cbe5204a3aca0b0a31fe96c6eb987c22ed9f7d0d3958598ac339eb61b4644c71fde8c8655baa9cd313ff830460f050cf326513503bb2eb74727c9bd209411112d6d218dd3ae19fac573dd4e4d68d499953152d3fee817d78ed8d2b86975fd57ece523d838bae1c0abd73c8b23764de9ddf75ff1d7c8f7da86139dc6a3ab0f5e70409164496c4d931eb8fe9a26224e652d6940845a0650256905c56aa3cab266a0ed0eb64751fb7ef5ad3df7d70f4a00a3169e379723862ef32c1f9e6d6b67300702b025d8adb1faa14d191b8a97f8d815f23a05e3269e9c952630339d463ca161c284782718eaf74bb12f7f2624c58a71410905f1554b43ab4ec0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
