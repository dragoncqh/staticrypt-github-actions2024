<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1ca0b296f7f3986c26e0a46b61272e7b1b6ee5b466f1db165c939dba59e542c16d3e1a9855a7174646d328c399b5fc3b2fea5d9b9460652c00b45143a1500600e1065a0878f9bc51a3265ec4fea89837eddbfffe3cce6e18ce41cda9ae09bed76cc6cee56f01b1d2eb9218806752d1a2635af3cf1f42b1b3b4e62a38edc05ba98586c97c3f5e2af1880f7b4c331a01f9068341bcef1167bc6c6712fca58009c91300758a1e7e7fcc38a7d4e5f2c96aa738b86266c95a18d192f9416512ad3dcdfe90398c042c57f5ee0c0823d50ad05fa2ce70184dd29476677e013f1006905bbce10fda1e92dcff95a1979cd3600ace24daaa9d9c19d429aee051ec7b766ee13568e0a33f3f176351fa554b94c3b6829fddb77320149ea14525f169a7ebbf41bb3e2510c3bb94ade34da76087a907bf671d02e931e332d4bb7be98975c6a4e185a0e942e83c4d2c2a72772de286d44a30f6b4e7a26ea93b56dfdc56c1d9eae391aa18e1e6786e321be9c53da070d6e94dce21c7955a23583f9860591c2ab6359db3d8eb4c8cf7382b5f2364c5a69ccac10d8161ef1c640b7e9493c8ec99b795e34c2d8921644cb5f21ebe50fe67c5b6897d8c426d03c614fbcdcf57208c8c70be75da025bb0cef7aad4d6e0ff673c4288003e74cc82cc4cafff5314e43e458151bfb543df0f40e7958c41b5833eccb44919b93b562d5488bce49d8e5353bfa9483c89c55b144db69a68379a964d624bcf4566e4447349b70c790ce36ea60c3e4825e4f21523d2ed412ddfee03cb6ecdd73d163a7a5861e1ecda7d4478b0e902b6cd7a0dc8c98d81542c461a47673f7ca72386e47fc37543fca9d4ab6a5148d373a0709ac22074300301482c24829a86d28d7a0dd34ecc563a90e581fabd8f2a336554b24ce404854e0d49fc4e89448c88dbc33871d71d19f77f3390289567eef46dec38e54998d8220589747f59a01e2b0fc4fb619739dd85472281703b005fc6fd11021cb0a7f7a899f990362892822148a704c33031a984704d67d6e2490e51412f880d25da664877dea6912a0d232c89adb90ac9b8cb6ef5094f0acb46c80ac03ae2db83be779de55bad70a53def16328982c5a95d8b872b88158f3e24def2be8121c8eeca23b84b59dd83d7038d2b74eff8859808302950c910a09846d14d0230ffb9b1affb3c91b1e28f970bf004a5438e00e761e5e456181058cc4e02e721d8aadbae8d412c8aa4d7e4f35657687d3ad2b8c17a9d6ed54a98f2da2dd20a0171f388a5cf66f19d60a60ac06a3985a6cf5c9fb66adf6017ba22d92faaa8a9ee99bd906bc4afea54e3d32d289f0d14d67c9831d2e9fdce7469fcb8aa121760d8a8fdbd4089b8291a900629e08371cb2f09554ace4f0baceacd076c33dd4200c926a7072e897cd809f62dc95f13865eac6de6990e18938b15120a01c9a3a4941a696aeee01ae889c85b32509147c2ca78932a528cdd98ab0687ba175b609412cb3358a41190cfb437b501792f625514de792dfdc24a9d5c0ecf559edf07a3c7ecd9e8d42610a72aee35f3da06d84fc7789e20c17c2576e0252e61e0e598f7daa65b5d409a833291935838880ae6c2c69274811adc6f913e55706e72e65608b60c2b0ee83f1cb01965154836747d196956b65b399fe8558f9e7acb21f7c3394884067123776ad1e75de59fb00359eba5a006b9999213dd220ae2a92d5c2350dbf2530a6cad9b8462e05c36ff5ef038f3a5e31e60ed1bdb0e3953898f3c138d44b62e99a782ca0aaadc1edd3f1f55534220f1d2b16542dd72002f449a6376919609509a326006abffd1aaa31a0c3501b590b6da730a5731d8021a4b70d87bc56f351661f62684d2248030cd3e5cea58d9b01c63a35e30185d77ac9fd3a95bce193254eaac02ee96f28e84128fdb4f516a19dfa764a39d3d8522beae027468665efcecadf155aa020b9107d444587231eec696acac9c826b403c66808c9aec6267aed7ac648e8b18a99ede708699e944573fcaed1a7b240b04644e8f537d4c3b1e05f9ccf7091ecf28793f7c942d3367c8bac7f8acf45058f5dba52d0895fff71181216d4fd45015aa460a5798db7c64de7621d60bef1739d485b8f3981ff05f0b541f2221ad0c525f0614a481e65974433fb4525c840b9f645742174dabd38c0136998c292bb04b774c650be43d837c41e57d3ee4de50d7c537cf41cdd926e19f76b22a92cfabb51398b045fe2fe035db1fdcbc8f67510100d542504a929562c306ce27403439c8d5c2f6e13134bb38e2cfc724e062a6d3faca8b49402e144332efc3fc0042472a594c267f2f8a93021eaea8edaa8c1e366119c377760d2f6386aabf414fd6eab3b3784937cdd839d473232f188825830b9a5c4ffab9bb0ba903d44d7a542fe6969a5bee4620ad3ab97db7f074005508e12dce866c5bae31dd1f04ec501a015b87cccc71e21e1b89caa04d65d5e3dd5ea3ff95c94e8f88605e1a0d6f61cf25690130a15b1ae34fc4d9a080ec29c08f36cfe1cbf3140d0018a56dd553e713d1b3ffb8dcc5ef072466f9491bab6d6b9018ecd49ffaaaa1f2b1177fe252d6aa04a63bfcfb4b7b8f671f14b24bfc49e9e1b9d7e25dd0cec546167795b3801d3d6c5691619b6e9ee3c0b9811b5cb857bd1379b6325efde9685da4b1be311289c08803d91b8873bdeb576fc7c362bf68462baf97696defd319e3387b577a012ae0872931e165fabca8c25ae5c92bf6561325aec5242f7729f16a74727e4cf1ebf187ff8875d4b8bb59bb5a2db55d107df0f109f4a4725c075b2e8d5ab0c2e91bf7afb137c530b7a0ddd85a2589a670bc9d818a6d730a651ada63139121a2bf8b1277476c4e752d7231258655571949d8e80792c6da2a36df2ebe2c079339c9a8ea0aeec257193fb511c2235a7471c3495dda3d9f43d474c2457ac840d56ac5938e3c6cbd426faed0bce3de0097865380cd43055c2551188ce299253225e7415fe301ef3159e65aea67c3b7ae39fdc95bd9a624d6c3777bdf76505b9c9ff7b7d03f9d1bb2815c33d424c54fe7f839d6dc9e3aebb6c54ca4800d2e93feb3cfc9a6c0b553d05c42780f981c66f24bc9e1d752df443ab512697a3834a92c98b1a8d3e4542b497b2c57d5aa589895dfae72809eb5d98d70c70292a4d27f3cfc955d48b8afc6cdd36e6087f2ef3316b8d4f7c30dbe139e5688629a2c3c70d86a0ba52150b0a997a43bc8e1fae278c9882bf300ddd3db478305e15d954a7885e3b3c8f67b2eb3bf8decece748fc17326bc490f5daf422840253572fff4fd28146b27d3cfbc7a46a3c3b577ce273388574d7b47878ed478f71066111b5279c4d6f57c28fa0f2ee710cbdee0d987b8ac6995e05df88e6820aee6a5a55e30b8fa7668b0909cbf25a31c48e895e178b44fdf27f8c24ce81eb8e02f081dd6a94a3bbc9f1669221273e9b6654226767ef1bc902e72d84645c17436bc2bd3f35f21b0aef99e1896feb6c7f6f9314591c2b153e7bc847dbcedf6b412683d5c4fc8050401c0919f42638e586174128272586e00291ce67bf1d83ca2a18d766b7e0ef4be6a813238ec6519536c3c12185436ea2005e15b76939bb717d06bbeb74e78b9d632e794ae937468dda592e08e9ba920373f4fc8b22920be301924e03ae07104c1189b4f46628743bcb5c9d0134800d16ad10d6ac25589f83ac9447d671c85f1ef28168e6a0b7fd0cee2a536225670262b5721730d11982208317367625545247535e080a36e541cec200f59e277b6b188aa425a939677f951aff15c529ebd5f9d10eee495bfdc371d4aba15f51819970217df4a419961667acfedc997545dc5cb76d8dc972803d62b002d3e9f3c576b9dbb324e8b3de1ec730a1e22d98afd934c5ea22e95b9788138ff0009c93309ec8bbb0c65469cbd2a09bfb79f23beb227a50ee6af80723a3ac64de3edfbe54a10f92c44fd3db466e4f4d9449d2f766617b3d9853601cc594d89245af5ffe7a67f42e160e821fcacd32815e9cb1daaf52ea202d5239bc521e15271dd22453c66d20c544d925de20544e9252891476901898102fd15229838848024bb43bf02b4ed4f32bda4acfb72b57920644f5bdd4a53024c8e09a933cc93aaf75a1fc2cae59f52c60352668817ace06045670adc4999ed3deb9768d09473d87878197f297439044d78e2f8d34ed29798b0ad2788e20ea510eecc3c72422ece3716eaf1aeffddd0a0496dfedeba8f4d22b87c0d5a45243af02c091c20fd45163b55b2f1deadbf4d89b51da383b2536abf96b007401a1cf7ada2901da046c75f83d874b8dc023bfe795333d051eaf137e80dfc3b55e73b3527ee681220512c2b979b84eb158d481a6cb4d5af477a06f38cb06fe61df8b5af64e8ad683b91c12a3b95259e244bfe67eabf563bf40c2d7db1acd7889eceb5d3562e4e7d634b6e1f5c3c22380e26f7a2b62064cda6d0c5f1cbaa9da48a020ed834d85dd7331c88fcae650fbffc893c142c50c8dee86f48aa23d5d2507eb8540bf121620a1b57309a137a75c0cb993a62cc18b17b9f7865443d91447a2702d90ba89e7e6ada9e543c6b5bdabeadc76b39273dab24891efab3e1b31cac8f05595ccdb74605cbf6511036e82625f208c51edd2283ae05dc1010425583069d9212e08897835ffc0708c6d960ab857b78414e5b099202bdd002765e986cec9cc588a6ac77e5e7e96a251b701d714ff2486b1dfddbdbcb6ebcd62853e86e49410560ee9de9c2fddcd2b1b190509854a147b8b959187b87b43568446f5c19cf3920ed6e336058391056721f1e670786a53f037350253e19a884defe3caae190df31072d1ea0ff1904f7a11126323cb7595d54e2b77c42eab5f51bb2ba91f7b9255d97e02112a68f6d20c7370bbad08cab043f2a5070dd9f71a7d39cb3a22e58101cdd183beacab00824eb7e58a3315dcd852e13b69289b5ce1be70d9896c61f002f24eab877f25f101ac7653a594dcbde2578ae10b463405559361d9246a911312cb64afed320e6386da51368bbf991455dc1ff8e78f85938e3a305889beb3459727a6af9f90bc2b01d13e444399a56a1d431b8adbf0043b823375faabb693f6a80e89411dcd118a05ceb4d3287bd6146e295b74da7a46c1000b45a5a7889830d3c20f52e44efb8af7a071c2da127ce785b92ffd03a0b6b9ffadb006721fbd4765fceca1dbc2316cd046c438958dcf154b4a63a672ff43b7cd7beefd36a513b2dacbc2bd9a0c27b72d59320b43b7eb8e22b538d5cc7650f99b6f2bc25539b8ed0f352ecc42778bd090452514e51c1994a497ad523f829d86cfbcc490d3b8818a27e948d870dbd8b7787e5db0e0a3cf0dc247ec7d319a536633d11e1d64974464172ccfde9b1f486a69f0d1f47a69a928b1a8c8d9c8d3afc1cffef3ed4e55dc72bd216b2dc9b7e86aa61326d07fc9b07cc1f59b34b62e1c6701c734c20e254588c50a1387fcefc8c933fe712ce7c53ce1f1728ba63d7ff1e0938a072c6b663e27d3a15bc7dae1783ef2970d3e6988149b4ed3614f81f56aca164107776cdb557ce9a390bf949425c83c8ee0063d6f602fda6dc6c81b0150892fd9a3b9bf8267e7d46d99356d2a9e3f6e59edfe94f5fea3d0d0fd4f1956e928d898f9730ce36387e58197c74c9bf84595eaf68c89c605b982321f6202b7519e9ad35871410d245c68de776adcd11134eb6c24c7e5387bbdf55e97296ecb2b2975250e12a3e8d3f64636fa43b8544b4d7c3a99ba9f66e09454a8730b5b25d9395199d9cf33f34274f8cf2c43cacfa3e1a301f9f3e5d267f6ed302218aca0a9a2d7f0dd77bd12224e564e525ab96c9960fc1882129fd38edf0b0ad61a44c2b38f192b56a9ee8b30a3710d82fd593c5e09a358eeae859581a816d5ace94b608a5da0f229d0a43ff51e215ff67df2b6954a5cf4ce121e8cd53eca58f7f8caec8b4df4e413b9310d477aace92ae55718b87c7422a64d3f22addd8fbde7985f9ed921a5df0892d76603f60003702ce261522544a44a35c2d20eeaf694660874e51b0b6f1f1a5c61ca9a686e85a63fcc0668c7a941d8eec81e6af82789f855305b8b3ab2f844bffef0175ec58b9b1883ead6ce291b87985bb3e84a5e054c2a77de57026e7fbd4bcfbf91705059c0e7353c5806d054eeddad5273c14ba214a1482f4c98fe7b9a972b6490ed4c3885801efc34533f4149bfb6cd3008f47234f733259058d650f07d65378808c7e97229de313390f43feff9bf5bb1164965160699bbf95c7133c80d6cf77b47bd0b7fa57761a1d80aa4c60de52a4f9f42be0223be7c530f72283de62c14943459a8fe82c789307631d12bfed42667b463115c53e45047d1308553e33963d2da6832346f806356e765de54774f5f1f558541ad46e90046f304744cdc3d3c67a89038b3c79fc76563c17e218c1f7d3c1140ea789816274d8bb5ab4206bda8787d196dbc9fd6da8044537a77b8c41b44051aaebb22471c69fdaf128f731560f7d89eda9ae57809912d79da8e759c7c5a0c08acde7d6b0d9b565e3d3da44e3bcf7fa627bdb64c26be7e9f1d97dfed1dbc014c841ff08bb06181ee415569c4d648a54c0cdf4b38dd6b79afc89409b5a44192706368cd0dd31eee48490f1d4ff8f86c222e0684f5caac6c3b8ecbd3c5bb7f9bc51e47238606c412f953e55a9589d6ed9dbc8166fd30bb7ea1a41e12bacd0e4610b096705ae3b49c91c9276b81cc1c5b9331e1fc62b20e348bb4942c8781a8f6985c39b005993bf89c4c03098ffd2c6e444f9c4aeca1e8b3898095f9749ef0e33e6273c435e819edba734771e35628b6803e5adccb8c810cf6e0c7df3f0f8a9591b21f22c4f9f555829c48d4d5d01e681a9169756d22e47b686ece421fcb1a3129a9019bd006ad2db5620210ee992a4cd769e47881849d6b577a91bb6feae1f49f0b904eb1c64283d4ed2b7c368e2ecf51306f1a995c769224261732f28348db885c030f88ee521b02bbe1168f654c0442a89ae169954b58ba5e4b918260bfd04d4a083eb89de7c4a62a00a4fb9f2cf9d21b487f16d0d3a2ad62b6888a29899298f51a00a7a6f65af2b8ad09d5bc612547c5d2e385c2235b5561df1225cbc1e2b6e9af24c9564b422799f7619a41ea1c998f8ef1821410b01b7090fda74f717e0ffc950147d6049f8f0f5a57dbbe926476e0873b1dc3ac1bac8e573cc10e41a94a79b5a36019d420e7a8dc1a05130a3309f3a3ec627688dfa0cd71734655ecfdf8ee81e294426ab15240871ec71b05fccd16ce90db932560b773298392e0c95a22cc1b39ce26bf0f44a247e1b64259147e8d49bb04ac9ab468eb1ec8b0f4db115eb76baabbc21f18ccbefd3e532fe3148132246dfbb3f6cc96fc9e631f5e51e433936418e1e5885de974b0bf633ac3ed39b466bd923c90fc3db793b042fe107ea702060b7aa23da44941e5c14cd4f2e0632d06bfa752807c74e410abacd40da8e2ea4e497a2f5ddd07df9e45017c7a92e1ef25af468dc7e853311c76e4e6d0d0cc130bdc1634fcc49953bf5f10cc844cb15de5c743e2480b6cb879da42a371de99bafff06f6892c0975d66f06ae73618f82f24e959ff06c0607f90637241a0c983c303ecdc99bb46eddf8a640ea92970c9f20d2a46b802c815d04fe49bebed2e866fb64c675be4a42daa9544a084b05d2ce3588d32c3036f42b4ef46c417869c19ee6fd189fef52dd8077810a91be6907968fa8a1b5573312e7a33112214736fbf800bd8b762946159bd481403226432404909062d0de99c9adb7a4a71e9591af517f587cd0bdf5bf2f4d531a594946e5b35229497d76dbdce6715fed4892b406d0896abe32d3174f2fc207fb981f981315c1f1918950821d00e427f0bab253f68c5e60e80ecd1d842ff6a37210325830550371f943bbab732ce62286190a20696844e8f55234ad1f135a364efad14af84d68b157470c5ee52d706533f01b721bb4bedf8fcffaf89b2f0cf67417a6b724e27cd19c02f2cc2f6c63be27e21ee5d85f5d88c7dddd694b9cec8e96fa767ae1d0e8ac4bd7dc4e0f3e1702b0632d6e7caa640d67c716739e40902a79c73754bb5265633ec72367b97daa00cca790d9b12972ddb624f3f82b57f52436f4d755b44409a5751640cb4b2ae4aa119f639bc70f82c1a0c42d4aafa7cfd03a2e11444e72ea300a41fe025458625d6cb4b7c0a203ea67271d82c0525e4653435bf4faebc9055e586490be654871f7a0275cdf15d123d1d7f3aa0947e58ace526b2aed9a710525075025a2bd593724471359f346091b7dd167a749a1315ae68ef24e34573c8056f3cca993c18d95ecc73aa1ae02580192cd3c284111533599db8368e8213bd3135bc95f70fcb7c5556c15aa2bcd8fb9dc3cdcbd9cf3b8210bdae857342340b4573818a6f6c5f9f9249a04bc1baeb2fe508a4650e132577001442141f6b960bd0ebeab1ccddd590ee9c9d4af3d45c67f8860fbc75ce52175eb541c2e022fdc45380280f6f14b1db7e0f7ed8a9f23c01bbaabd9d8638b61bfc7c88cb0d29a7310c91c72c0f42f86ee302a32172eed00349a6e308222f73208c2d81baf1019504296a69bb661ee45414a47fd6b53a7eadfa7ffd50f657e61e57edb73ad438261efb353afcba3bc057cef6a3559dc13158130e21207edf95c698c7d398eda6dbee9261134c0fd96e4d0cd68f4035153de37a44aa8f01c74294203c05bf695b334cd75411404ec5f4dbb88e47f4b404564d097e5c31c77901f02fd92b6050ab15c855b713fae668e6592c1ff4c846b99809e66a65aca3e89d83b4c0247e9a05974f6b66f82b5312b6c3f946315c43d2eeae89574eaffd22f76e5aff468042cf43f614cbf19ea71daa88b38831775bc38500fb1976002a72bff74f250be9b024250ddee58b56bc956673c55e438d7044eaf85d5af3f50b2cbbd4512fc3d5faf9b83586095a1fe9b5ee9be2907c3909ef95c72634f52bec2a44452f966c6ee864470e5dd964fd849dc2d0ef8b1249e1648493fbc1fd05a2b1b077eb0d96ad3e09edb6133b8d544bc833548b0067fa2837797b49751d8539a3820235f0f9ad88f3e5f86a47eb694e31b1a3848364c56c572b68873a5f9ae673de1120247b46962c27137f4fc1b4f9e638f191b9b1eab2ddccdf09b6ce05fd07650e55c79a68bf1d20e67f83e53394bde6fdea24f5e31f87afdc61307c3a29b02a4c0ed454ee9c305b416e9931bb937beae1f59650dece3230d57664576ac39180a546fcfd28099744baca7c6b46ca2e609027bfc3e05daee33ea60bf4e2f7c17b863626442a56e79da62479047c338103183cb4af222d1e0c658d311b34e547c6b5a83b4b6c1aeded17f4a387eba1228455c2fa2fcef327426516d8f58bec15de47fb785556d27b38f4ae7f3e8304dd7ab83bbe787d06f24c9ee960c35017803c75defe22e9cf38ab9626d30cfbe870350adecfbebf450f2c0dd8826f24a5762b8ba6de191be266d9e67c7f772d5904841cd78505bdc24dd813d142ea6d86c8d51c88eab71cfaed3603cf6abb9c97dcb6c8effb8b6ec98d2859ce8232d7e0311037b34ffefe6dac651bfde14a33f909d3007f84fdbaacd9f90ead15249bf4bbc888eb7dfeb01e2cd0fd198b457981a847e71b93060dc02cd10a08444441eb91f384e149cba292dec1f478b2fc281ece04c100179156dfc08481428e310a6b1c546373ffa5804b983c50f92ba5ca202980749413833d7927ad7ea84b23714d1f9081dc19bdcb5fbb469c5c95b7c167d7b60c3bff46a50fab2dd00ceb4c205b8f04fe536817abbb0cb8137ab316642c26965812599690c662e691e4754fd57d707724ca1cbb39987d92e8aeda6c42cc72ec4848a615784b100982a5714f599280a82ed25e3a158a08f789e78654ee531f0b694e980046f11cf63fa8bd838354b9d988dd6190c6d68ec8666e897d361acea5d765b880bfc7d61b0886469e336edfa13201c89700d78e8d1fc194341120d3144f3072f736a9f9f4a62fc144170315764bc0892da42aab1602ea41e7a87be039be27a9bbfd94da2de65dfc68c0ee73d4c1201ac06adad5af1518a7a66dff4f5a2d67ef9d5ddaec6629a26bb7c685b80c4e10a39a40e1c88a39d7f7b46be1a53ed7298fb761588179b0015e82b9b25494a0024f5cfa320aa9e002bc0783b8aad06ded72888f0f50a2b08b8dbf2203dd89d6c68b88c1fca2d574f609389ac2041555f91595601c3e66f19b7d45a06ea0e41c98ab1d3c607e7056e856fb1b8315ab60e161f00437c7fe52746e1c080e9a3822553fcf412ae7cbddad7fcfea1f2297aa884733a93e5c94dacff5b6549495ae4413a6535ab4d80e14ad188cf0a98752f37fc3f533baa29860a1f65aa86b500f8943fcf23ee4f4d8af3cb5784b1df74935743086203f4e43f90ef170615b8943bcb5f7e9658da2cafa6ed40f80c89b07d39c1ef89eae234244b1e331c9e52f0a8734aa4ab34b91d6a621d5d2d54510bb72ebea69a3cd4a560c80d79f1b8cbe8d3775da2a0ffb67f9ecacbd8bc6fb9476bd3d26ede08bb9d72af8695b725c14a9f89e9918ccff4455c4108a8206fa11ea387dad1a1fc68676da9dda5bc64c68eeee130dd2d5fd6770b1f3da2e351401cd189a3ad243e4472a396f299d11acdb4ec0f836271fb3cde88595efa230c2b5ba0227e80d97d1f61315bfe668143cfb0b4ee68f72b532c3bd0d933d5ef342ea2bd925056ecc44df49fb91fa77c35def6dc10e522f58df26ade0ae841a0363840531e997c17094d3c9c5cf33b1d8e9d717dbdc034b246d4d92a4b99ffdadba8ee087855eb31dafff41602586fda874d8d38a4fca95d3012ac7db613b4591bbe6af7852331bdfdcf07f25da8e7daecf4bfab5e92ecd71f735554b556524ea1bfebc6cdd09a4f2d6cff89c665f6416d7aad80659cb7363f183db0c72b017b835377f5cb8263ff62cec16ec5afaa89043516567259148017a8395f86dcd6907b1c5bbe460351bec11e9863b0f805c03fa874117e7900b59948e0b80a6901e2c7546cc6b6de5064ea82af8feba16b3c515cb2f674a5a5265ba9837c1f0ca4b40657a3f88966e2237c3d71b1259281d1aaca60099599edee05325376de13c4a6b2fcdc54255132cf92bbddc80b7d2341cb99d2cfeb4ecaa0cfbde03c829f45ea475ee19078c80ef37de836006c3bc6a36fa3b923904b97759ce1776d45aaf121c0de38e0dc3cb60ede5605170209b7bdd991f9bea6a65217c5ef85eb5f2a714d7521ab02d967d3e6252a0a2cdf8f046da6965bc0fc3de44c0036eb53b24da030b31369a1f747733bf2227e366186453b5a94ae026b9b8bfbedbe4316796f728609b012d32f293efa958d0e7b4ac45c3d20d72a5ce57769c6db74807937d5c412a14bc1b7b9a6d794c6ba39b8bcdbc9403c9858c82bea0207ff7856e3561ed1ed7b1c2a815ea1caca76875a692fc2d0fed38e3a223a46a63c16954e6d9fcd65fe20a581126c00f51f65a8a62bb222e89b1858e5e668ac6148e06d3af16b2d2ab109cf682dfa9016087c207338a922b0de0c5c2afd4b4e0468bc9c874df146cf1fdf9f55f5626f9ba4889e6c8631b3087fa4906fcfe3982b9a66cb43c0cddd53cfe3e97815191743d73730788eb39b9cfdbceaea107f0b5436c0a6aec24a47447a20ba9831e80108403baeafdf06396867671d3f6f53476fc1cbb2b4f1d7fd379be8cb1f0da67b1c42c66d8ff04550e98d5e901c39c049b0f6c53025c820c4d039743590abd636c3797843029e88f57f3f1bf13cbbfd0f2d2b90c96a815120a8d56718da0644e0e1773356d24706171d456f5a44d8fa2001ac56e46241ea10b19b01d8895991df3705b21ec1e40caf6b1a72629af3c4d046abff64ae73a3aa6419801b6361ec22baede171cce0265485b77dc5122cbdc7fb49b90c85d06a3c10b64964aed7f283cb8ab82c758c1efb17d3e5d473e0fb47449bc01af8aa99997bba7bc556aff067709d5c56a309f7d81fcb1333192313dd39aee19aa02ae89228c44f7e0b9b39573d37992802fb58499bcd4aa0456eb0b9fd0269a2b67882d2789b3181b7061a5f1f65e884be98f1a6ddf163e7a68242a246d936bc2fcaf0777cc92437459a6d5869f5c205691907fd94ee64007e07c4bf01496387f32ace50f203e6aaded11d92feb1e80da77fecd4b6ee725ca5c56e7e9c2515fc04067da5493ad2cf6373409dcc0f0e7ed34434e1795c1cb2cde26857f378caa95a2719e5fa4e598336170b0a3876fe18b626015defdfdc045cf0bd5dc0e24e806ad6744f03d674289a8f45994b788b8511c4da2ee002bbb1d79b4d18d84950264e86e37e758f4da5eb250e0bfca263c86c5e88c29ff12d4cc0f5a50c002297a257827ed13b5447556be9c4eb21274c6a876b8641838bdaeccfe052f2e61f375c80db141f1f2f2c969019b10dc8a58321c0b55ad37a1a4239ee93ad11b3f8c2ddb46719da3e87039f83fc3c0b88b8584a5519745cf76b20f5af4995592b898291ce4a4902badf418c46de3a0e8a665dfb113614cead880dd12cafeffe745ba5807eafbfc2cb7a5cef1472592625fbae48bb5e9b915903f908fbba5eb50a5ef4d221c11202804f6108b4689b29e09e8c953bef9a625f2ac7166da07df8b109fd73930adc2e0caf3863f3421f0ef6f744896ba4b69ae5f3c167aa92f3ee57d2146a08315ae30c12dbf746c7d1cedef9e1aff115f273f06c3f8f0478f403b3ef0bab7c7e9682d092abd1c1b01c06ecfa43e2ae52b200b81553ab5b17be4e04d53c9f9a70e6e9880669498e742e221ec561be0f15016629a9acd699d62217a9ec1dca8949804a7d06655c67c9def199f8f05b2a91fecfa2d825e27dfb2f841969a4b7185678a587efe1857763af203b8e2bf9461b5a1dfe717738ea767b470e2d1dafd1591ae7bd14f42af4f5974d41c5d7964d82f48a7c401ee357f94c29afe8e9504c497240dc1243f11cc23c38b6d5791c2ec0839e45a49e910827baa13febb84f2f6cb72eeeea1f01e6d931da876e81d92ac09f8f6df1f3fcb06293adb028e5682de560eebcc6ceaaa5f363cc632bd05e81276929ce0764170b21f7511c3246b4ee1444da38a8710c11bdb035c7c4eaecda55c90704dd4acc374278f27d582e7a788f64731d8cce53d41938733370477a087776af9e54acdb1267d02c74f1262036125e3aed1fba89101326ec1309e736b5438d71b0105e1e1826e94e5305aab7bcc45bd120a278d24df931f6da10aed18b206ee9c8d465f05cb48e6c8d59900c557d4468c369bcf28f6179d5b555507889472d72c295e69449483f1b04e36f50104a119f1ae178ae60d1bd06b78c73c4b86224047b6234cf7111b599fd429a85b49dfce8e95e33599bf3c298d68c0fe69d78b8e6a6305ce209f3d24c51142623cf460cd72880ac03e399605808c10015b46553fc884371d1383c121c72b0d6a31206ecccf34fe34c8e2cf25f131c425d71089e0153ed73510548fe1f4ae039235133f9554a232653212983037ec36ee4a097e11a79388fa231fd432e6deb399e9140181b6c4d3b1310ce764e8ac66b2bdec4509544b6aab7f99a43e1cd72fd1ba21303244a53258e1e37a7354d81f41a3f0af1753037cd56528e51bd985e722acf8cf3bb1ff6e05decf9fdc1648db5fb50049e9a6e9ffa88ad68254c4f3a12113918d6a3fa0019952cb81ba96971625a3281f08db715296031aec90df53fcc8f58f6d6425ac2b9cc3ff651582b6b3c62262e9c1793ddf85e72f98bd9a8cd93f4e8d154cc181577a70b8e055e84dc9731d5ac03ae24b37addf6af7f54cd3e4c6bbe98139870e2bfddc973a59bb162d5b38f2edc303b71bd7b4319391ccf897f93c20792b7d77a1f384aa5473e83a2ee86c698f2723bcd8907356c87c6556ebd039ea18f610d10cdd7aedc53eb95e33b0c14c231872c03f47a74e177be3cf8bc44e8cccdda1d6881d0e2eaa2e8d4174785c9b55b9283eb32b273a049b8c0d5f2e470f71da05494f5be3249f44e987897ca0d66e0d2185f2558a39a4c80b91f8ecf613d0c3f09b7019b25a21fbf96e6e72600657ec058491df2a0a25344871026ab435f0886a31b7d2d62cade76f0d5c7db7228b969d0e752f7b947938f6b91bb0689c658a07279456dfcbec559d9e37292358e1a3844901f084a7280d6e943ad45b0ac49238e2063512524da6201a29d0b293911e2d52f299211389c3aac1d3f65ad3549cbff2de798dafcd1a0bc20fc9456340fe675831121cf9a0765c6dc98c14d5fcd365577609c34e417cf654fc3060308915a8f43b0a20c9612d057a4f792137775e729172a8c335818c642b63bd4bbdf06c5c81040b01a849586cddde7afa3d550e267ea7a512cdd4e23795c30924c9a4ca2851f3dc1bbf9f81efff4537d0b537444e0099c128fd7c49b1c0c0b3549e38084c31a8dc8284a83f6c9470637f48134173804e9d9c463c1bb4597933e1cb85899b224a4a1624b240fbf91bb47e5167db1b5d9bb1154ece4667ead941611b66453249757a0ea6437e8b703aadba2dc40f876c154922f290e0ef70c6351c219946008e9d1735575795cd8c9db032fb6a5f4b40c872ff6d1e9be8f8bbc0bf5aebe2d64dbd64d2ce8fde4c61b46b3e7133c0385ed04caadd7202a5e04869d792756aac20a0c0575ab703c01564eaf0ed732b1deab851e5517476feb2de781281a10d0cffde59dafd79c94cf92f379df26986da6cfcdb087e1eb7a5d7dba4e3a5578c0e0ab062ed76273b67c78e169799a96a8104e7c5f98b6b4e541a17ad36945f187c843bb57d2537faad6207b833976f9d6a4ade9f0724b6462501e29a408ee972f8c5645d4b88f111192b85c89ed8b79f58207e5066c262250b24db6de3fbdce57947cdd9c3bb342226a65519d5f89bd1cf1f918fb5c49c6798c822a098519976877d9032277f7af6ed1d3cda224b2bc6b165538a27e4b8b43234f245371eaf172e38109122e2fef53db7d5eb7227e64f2e9c8b89e33c061f38a938c38ea8537efd531ab11fc5af98447ae25a54f1733fff712bece0acd25fe8d64002e8088bf0d59834328e23b057f129ec179786fe1995cca4f391e8f4a3a54f825610c13b39d1f0ed73bdfb0f68b56c5123b3716274868cbeed90bc74c6348944c740b0bbabeb8d3e4512134b04a754c68e023c83cda4a941dc7c6c26c7fc91762c65f37ce7f66835a39a4448752e2eb1c9ba91e5fb937c6ce96b36f275ee4b12b13ad85e7cf780ef4d007ec058c0b5c24a28462c29e5841722ec2678d5fbc412020d893295558ee066337f36f090750aa21f5f36c1aeb2f372a4aca995b8a1e0742ee784bb6bb136e8f2087f48870d41962bc3773ad1e885f3d2ba9079c7df50d634e26729b655340dd99a2c9ca946440b407ac16ddae53aa641e9b4141ec018a37b600ddc03cccdaebfb9368f04c990b6e7c32bf2ac73a4ae89def91b02f56d75cc89012e96a41a92caec2d7ae80f06e4a2f632f1f043446bf780fea7775232118970ce94a63c566b518d008a38bcde33ae0cb9fd0a8f27df7842b02df5ec6b6e1034dbc7787acd9662c26312fe9da65f31e4a4228f8409d5549a6c560b025a152fc2872173fbda6e1acccab4b87144d8c2e69ad3f69f8985adbc65c80f47e93095c9070e78e50b73a7a6615a201561fb7d3f9fd513800c2a7b386c28c3988a793570565d5f39d8db5212f332c9d642a12f97b3c78d293e2035590872d5a4a87a460b8059ce75ac100bf3ba83ad539beb37814133633e53c333ac7b11059eeaacac014d55948970c84d29f874242ce575d6495474aaeb11a35193ce5ffd01b545be352b33caea65f535c2fa14f9fd92ae90c3b86504f74dee7d09e1df495db428b628a0fa77d892294a2878302db7b8fa90be34e7aa41c0d30c035bbe640157a78d7c6b00167f80a5fe4992f47088e1a28f4224288e97474bec62a66c1058caf0c0e416510e9df62937fdbcca60d84752ba070e78abcc03d27522664ab7e55350261aa47734ce943eda3157532064dbbb1e2a00e1343a17e96d11844da1e1661a2a8e7a5a5ac2afa724a20b7dfe056a36e73aa597ab23d2af679cfe1cbae7036391d1645754689fb286842d036ea8d99a57744ac69c15009aa80d3436aec1b406e841d90857cd22600202f6b09e762ba73b7c8d65f3ebee13e57276f590b0388c5a675adbbe959f05e6b27092e50c9ca9d4a256edd1870b3eb9e07448cbad7741035280b090601caa56b57b40e6428fab844ce5c5f74bd14c5806b1d23b618be18090a3eb7bda4aa9867a662265b38d79d2cdec859381b62057ddaabd1c72c8272063b6c378445da7dafc1c78ca8aee03cde2ae995ed87309d00c54d8f79c6fe3c22e1e3739c65a96bc96bca45cb722fc4b065143e02db31eb18f8d03809d1d4305720a076e46114a5bbc7b0e06d80cdb16b12a9b2da2bc185281f81a3050b46627637f977d79ba9b94418e21cfbfdfbd6a45bd8ed4e433dab4e810f75c862eafcb694107255f2eed841e0474207e991773545121a6700cfbedcffa2d45adb54ea00c1ebb06e39cacc4a8ff405fa24cae86d62edc9a141f3dd78c895614fd227893b8211fa9b295b1c41d6d6275316d6b9c9f2860fe1ca397b31efbcd422c70d99e0758051aec4044581a845ab30f0207c2ce38e46fa40a7672ec996880c58c26ee8757e4d92cf08b618165c626707d04ee1f5024e605f672e9a31c6e154f42bbcb1189d03872ddfa7a9435b0f41e7782da359d66640e90593b409132d878fef0ed092a1733fe56819bad2a7bb9897483004478512308e355a42e9f189cfbae653bc93aecf3b98d8dc9bb86bddc763dea058f822fb06e0a9ddd064d1128038643090748c4de2b65e0baf5f1b34f15df9baabcea6659","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
