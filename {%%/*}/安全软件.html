<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2ccca8afa66c105707c9b861043a227960841e984bd667049e2fb6bdb597ff29318bab6589fa8222e2263c9617992b0e1c10ced6054ef43502ab6c9166c96ecbc939d44dd2264b2fa2abe68de8ca6c33464557a1c5cb0d7ec30b3416449fc816746abd2a1ce708bcbf27e8cf9766dd3c346c24c5084f98d968550a687334499c8adf5f5c04a5b8420408a475f23e21f5519d57aaf210c902684ed374d01c5005dd41f4a0c91b862d8a90d664c48afbce16dabe7bf61d7e87ac0f0a95965a6565161641cf5f50a4409038dc10b2aec0e3271af3f4a2f76e2e3288c6af70752e612bdb86ff782c1ed917e8245b7f0bd65505e9f77a2f20dc5d3ede39f1f28ededadafe9fd3fe0efe0a94b0ebf954be6a3c0faa406b0f128a49f0cb8ec5b3021cdddb3819512afa14ad78976f50a5f0b98355b92b07a36d6bf6958ce1fc9d0c8e6e07be865a689735bfe2c3c6cf86ba601c79596c5bd24a32ba3f9b22866b8f99515f625d700b3e03c446f84512ea58e5b9762085f672520396ef00a48195ab3cddb76366c9b82d26c7751fab1561f8add231fbc5f7fff322b9970f40ea76c343dc3c9290dc767fef06e5953b99d9fd24e1a78eff943e69d89bde0408edc60e8ba12e3155900aedd394a5f95bedfb0093ac89ec0b0200bdfa3873fad784a1f4f0916a0212cd3a9e7c727c8999f355c6de8eb1d57b7b1c881e7502e9c0ea0017f4b47243fe8006483a460679f3bf29242335477dff49bf1c70a0b738c7141f4055c7ce84035dbcb9fc0bee5c84ab2f4c06cea6d410e980237abb20ef1de8b79dc5457b4eb3ae8614cfd07243d94b3798b926a975b9aab8ca3f57e5d63143933177a41a9876c955d68401a3b22ee0bf58544865a55c22efec3768284525ab0f24506bc4de55acfc435ea07bf3e0b2181ba947949a592f5c99937f2f857d00713f2d322ad38681177feb28a8eaefb11271a3ee13df900c2c008d8cb8d00df44fb7663cef9807632d5ac790474acbb5b0d4338644c6859adfd788ca69537119cabad0c2ff6cefed557afda6c14c3c6c724dad3cd64300d25cd385afd7f9f35db115940251a32938cf34ac5d4605e29197d32ef72a670b929b57c3e0a50b1eaa348611184a84b745481e2531e592fa49eebc82f489627393bcf7927d7e57be255fa6b02ceed101046b981d1c031fef69868957373fc7b944f16bf33c9b8fd9353c68525ff5c977996ae6ad8626f5b886fd9a871479a87e1f12efa08dcf654bcb8cb6faf3b9c2abeaa99ab479ba467d32472d3b5eae9634c24b88c35e3e0592ecf9b33e21ab4df532776e5f8021d435ca4b942003c05e5b233559346a338f8d18acaa8ffae86dd4ae67b36e5c55d7f90f9202000460e279ea0d543417b261182010b5d968915311ea2fc5e13535c31fa112fedc34f7d90b9526bf793423a8f9177609adac4cc4cef1eacd9555b530714f755b8c42f25e56327a293e5500692ee61aa15f4d303f7955e569c07ed5fbde814e64a43fd58f582b89fdbc1bea0e6efbc9301d2eab52c075d4ada9f8f1abcfaefe9be2237feeb80b85d2629aa205f2133f0332fd6a96a0beebc3d3dd9faf4245be017565cd09823ed6bc5d2611f65fa810ede1cd1f2691016268aa8a16d6aa1c996f302c36b60bd67a4a1d0552eeb442c88e567052eb287422d64cc85bb63d9bbd073951f3352e99739a7c9e280943b86c3c4721b4a03b0e11529d27d084b87962e6ea53e8bf9d54c5a8424b51e6d16ea024bcaf7f05b068fe8ffaf78deb3a049adb4c9f920f657bb1493fcce342e97a5289260f473524b60d9e523122e27a84e3c6b9860a6b0add7a6a8f9274d81908a81ba424d74fb8405618dec6b127055d72aa5ac095173247a9bd33f885655b269885bea45feaad93174ad67a8cb6ef81e1df71379ec55e5c04d02323f026e837c5606c72b82b600da5502aa31c0cb534cde28a5112cbc6a73a0d3d46705a4d8828e5fcbf0e3097beca91026b204036242fc16af5b1c6694e0cff7748963f1e185f9e3ddee3cb3994425ddd6a51071f640a93be34a42a3a8ff6044f3008247b282a9ae82003d6c5d25c5481f78825057059fc6e0d03ef82a5b135a4da2f4a99aba88d8cc85ff143978817582a9cf98ece8f733268e794dc73272176f96d5b98c73099d0b51640e0764b58345a35470ea42b8659d81d39d541c3422f84b92a0dc81f6b92ab5bff41f9f60a4472c1d23eadbd573a62c2e90b3bae34fb4a4bec779819edc2edc53d2cd4e737601f5f8fc83697dfc1df56ed94cf72661520e7979e2b2fde4a028ca15ccc273f03c0c15828187f48e41acadb42024e29653b1f1522d4b3965a5ed1ade02c9e3b3f9b5b077d71c19e861838930d9581c1a5a9833350a682988e7977bf50498dcd12c7babffa66d75b12f750e428822a9e03a43dc14d178748b637bacc34c3997c50c5a6eee2baf53333a95be474b1ff7edd8fa7c02e598ced985e39065e5493a03904d736ee875d58c6d543e19a0523000e5598e08e160e1b04440857bc3ed7026afd346f8359cebecbcfcae52c2b90028fd97380c59121a8ccc7b737e6ec83469096ac70f7fee1958fb2e238b516fa8dfc5f27875a122fc7fb6da51dfc6cc1955e85f5f86308cd399653f794fc3dd77a32d8a6899c03d34f2700f4ff4d5974ecbe68d74280a2b4a332002471142149213b6347a3cfa569f3b8b79cc466a145906a23841f1b959321ff940ef82d59205b159cd84b5b5ef3006cfdcca4981e4c264f86ab97c60ce6386a772920ecd0e79f016f8ba96ab9ead08927d52aa44d78ecbb2c1ac7d6a10a07f82b62db02dd1a7964416d2a6ddec05d1c603be121ef658e21ad345d159081030b457c11b74f148fd129da0c5ec5a7a9aeeb747af369b15a7db79471301ce400aac50b10c12ceafa8841dcecda2d4640c2b1465b464abe698c57f59fba9f86bcac3a90caa5a308f2af8ff1370f498ea7115a4b76aafb3ab07a3ec0b48dd449ca3854bc98791ad05a68c34cb4ecfdb5d1e09c79d92f133326502d06c9fae290450cd79236903b568561444b4ad02339e5455fa8ca021d0f682e97e0dd68d1fe56cbe300b781c8c17c617c68bceae19a81c550f34cb6d30debee73129c70a89f87740d7e67296d88110722a63de64958bda895b8f07b6021b0c1441225333c465af61b8881f08d347f0d239bcf79eb6e10bda056a643337514eece0ffe5c212dd29b9b2c5d65a9ee91bc493dce73a9ee4649784fc75209cbe78890934c6ba843a80239d9948504f3c5ab576a3d73a4662007c8d28190796b81751dbb489588efc89d441a3293b4ac95c185c3127a6a07e221d7d9f6d94bb405090c2c271d782533f06047be85242019364fea8627fabdb8e8cf346a237bd21eb71dc59490dd27f878bfaf799c3b2f7da06e06fd3b54495d60777058b710f62d2dfd2d53f9da1510bd84b06e9e4c63473ff547cfc538d8a3967892b6968b2a4ecb6e3c0cd7b85339da0f1cf3f6a4e618224ee123b67c5589dada3cda3590563f9185de3036f5efb3d845b49956dba7272ba2793fbf2ebca922181336c0c19361a123893001aa7f96bf079c9c610374524da3b19740c36db51ab3c10f8df8c36a80c3730c3896a82c55cf19c0fbaa5354e02a8dc3c4ce06039848f866958c7b4397b39469a7cec111bcfaf1855a4951e90abcef4fde8d65dbc983bf17818cf8152944b23ecc057b6a89853926a4108d77aeb3466b54f4284c4f221b408a1c43e1fc96877357b9ddf307e09676fda5b830c3d5372448ad27035a845a0f80f0da1effdae18370b5de6dfac78aee002fe4d9cb1f5be12955634f2698a905980d00f435bef89a745f97b1cdae23f2f40e53edc719a3387984cc25c8d268d01b9475bef14f4daa6f1b5dad0a2745ae86a1808227ce7dbc41df91caf0b9f53b13222541ec0f9b0864139e3593517ff4f64e47c598ef80aa6ee5ce6bf0e1463e67eadacd6ad5e44b9ef33252c12425b7f617af971658291812257ba45c288c06fefc898a28caca571b5421b1404c2c3064a1a76f2a7e8042198ead830d29a64fc932cdb13f058425dd236775e1c2567960c207e42c4bae0fe54ee8058c207b3d66ac19d5a26dae5727db97a6a8c00695e4ba494eab97defe777ce68498d1e5d2b27afd4ec1b162637dd8cac107f6b516e78ca2a4d7d1a42eb4bda5914035b5f9c2a61fca7ebc67e1d8c11e8b5f0f555672bbefbd53c6228a473ef9c201f57da17c280d6523a7499d805add41d5c81a68e5c814ca7c31d301f999379ae8f4c990f35e3dc9496f7fa7f359bb8178bd38920c4da7c3c993fad9ad87b08591367db6a1d013798b2d3034b029cbf71f2a422eee8d98011949c4465bc91a51478ddc72ffd2512f7fb30972d70c100bd1e692c1d9ffbccdc97662b7a2e484c9c4aa316f808d4e77b62ad51815a22dad94af8922acb9b6153033568a6f82cf1be03e8486b5d9afdd372e4b15441123aabe417cf98c0983a9f22fb0a9c20d33508332a954da1a164860873241b58c357dfe4571ab99474b7453d790c59f92caa887f04618ac331ae50fbf645f5d701733dbb4f92092b4f6195ee4aaf351cf3f3b2a98d31d684ca361a8d17f00b04eace7020a9591e7f306abeae8f3be82a4ed0789112557764dbb0c590b45f835fe278b6354424697f7745610f9ba10055326f807dc325a5ae92ae253e703197668cb1ea97a6b6cb387226ebf218039470f666dd149ff2b81ff9695eeb35218f87b1a87ad220014f74389974ec56e697a4ce808e9778562367c275805db3148d521946fa6e300408cf54d1c70536572069b4693935b9661bff50aef5d2e4d0228dfb09c5b7c01184564aecc8edb696f84e7234913a587130a5bbdf617aa4daaabd27a0c13bccbf8a83e94936a561869b0c79a69ae73ce0cce3d99ea0effb498ca54e9d9413bc04d7e10ffd95fff9f3277dcbf4af7c6b7d336f4a502f0a151cf23204c2fb6da82aef26f7a3cdf5ad33f165920840cc7e0772451479b9e7b118f4ed3ac19121b9ddf905b305eb25ea5a6285f34e7bae4c268ece5677afff21c351f76155e18d02953ba86138b9acfed2a067248d71cc9c7402e37a3bab523ec0b3406f0ef2e7f405e33946c9dc84311bc96042be28f2bba7d1c080d78a99476b5130c6821bd818807b54a5b6650dce761b0f2d819f6a91c214ef2a18c10153601e70afe1945ec91ebac28f32505f3a774c03388f71612f81619073432e782b361984c38f332d3e8e1e538a750a2e1e03bfcc545905150f87dff7d778b1c144ea341c62bd4ba18570548d2fe4927036a129907217716211df19dddd2752c5ab5acc6417fba54905377d4915093b26acccafe7d98f76fd4f824f711b2d4f5714eebc3762c98322af2d2c60464266f55b52a67df0e51c76295f8ff75de9394303eef5e1912b140174731bc62686a6a61d26aaa55f5953734ae35cbcfe680975f69b4b8954404ae9a881692013e9a0740693b161f64f51df7cb2d9bf229b9c453db9bf81196a21b60ca14f311f2ca6c92c2c0c36c4546d9b04f7d73bb582a3e7f9c87c4e1702bf6611f4390f0048bef9b0741681028427999a69384573c8a2564b536b8ad058b6843f12924b9c60e3b7c5febbb1cc2e5c621083438c16b68ec86ebef5b25ca7441ef7862e969e1c5e6bf892e863f46a1263012b547fb67cc58d131424f2ef7a9a03555f86ff1108c24959c256b63e1da2756fa0d62886e35d7798da489f5be5a4a729834dbb80707ad18e12dfbf1e1491cc5f8c58ab6a66954a62a894f18c8dc3d7cef2c46d796018fba1df7c21c61513ae3046446eaf9d1580185261acb799875d9768a8b28dd73f498a1be2f9360ccd3d1ecc8d25ceccf5397310429b15f43df53acbb381a5226eb6cc8c416dd4e32dad5f3cbb059c8325b4eb7f616dd332a33d438d2785be2b86f63da1debc47f09f44baa9512ddbc6e93d8848d42110b49d2ae4ce0d20d4b797032b55d814ef0e2f75f887ffd3c32d5e659c45968b445b8fa492a17c1e11fa5f2b4f62a79ef0d12744955c59531a7846da2944a439730196281a6a2f89d88e49a940c412523ccdc6b7917431e059f56714e7c814132c89e5682833bd6e2e7415321549058278869ac079f5e40f8c68f0418f9d152c3e3c9adfeb46916488302c7b2d7ccee4fc7c16033d35add226cdddce1f1613cabd68158b65e83ec6e27b03666f4cdfa507a8a6ecda5f1fda0f91f43c858b5ac562c7ff84806d0d00926cc17b91564d092f5250a8190b2e35a25f7260e1f5939b7b85fb7c1b5bf5a1229dfab5f70f8288b897979caa7953e20d8cc808d40ca4f235d338cd21168642e2d4213861f343b841391dcf683b6649d2c5fdcefcebd5e69549c94bf6418f5b5e5ee6a3c39371712f139587fd123a6955f47eb32284dff532a3f0d7c2c02e6aca961a7ec93caf72c65590cf9da81e4917925b9eabefddfb301243b845faeeb91c7faba163fa098e9a19784873e02d9f1868dba545c65d2c8de8f31c49b85354cf50d8062a0c3b9b827ade8a2c1a0fdf66143183219be25d378093e8a2491d1ce167e2ae1d0c1584dbf86d8b3c42c774a4d760ee7e91512be838cbfd8b60772c8571e7146b2531095cccd76e118de6e44f8b446777978369e011b2c475ffc696b8f5f8c5c1b5d4a5942718cdfb8c7d788a637501cf2c471a93ee504a7f71da4ad28f9e039bf872b86630c32693f391d649f87a365a867b233c6309521549fde0f692d0280843d93ebb4f50b3e9bb758a9b07d8c2e8bbac34e4c175ca271ad1724e317609625d427b27a1c37ee41f25f4910acf1efc59bae30df966c22b4439579aa72d6d8e584f690e1bd9403bea2947e0ad4fbd5d2fa9e77f3552a57fc68e3316ac066f88ed293ccb23fcd6197fdd7dbfb9f17d6874ef659ee269c25f3ec945473b5bc24a646a3f9ea0b940a79904f181fb312fd06f506c3ecca8bf76e1fe14665cd6db2c9a8bcc773eadd1178ba65139cde29173a6a32eebc9f687a94cb7e4a201bf955f545afb01338cdf78e9888cbac8b22681d85094f7c87c245cd0dafefd8121b4f840046414b19fd23ae57939b1d7704913a42f1f41f2029a3498be292dbe010396d48de2acb4bc6409d5662481b7039ecd4802128ba8f2f1ff5f437d745d0dfd72c4eb44e4feec9e81d3cda887e926c6b1775d2a0213a0c191050c427ffc5f62d2cd5d88db6ea0c5b462f6c1f1b75ae34b8232b97638cfa130a263fc3d9892dd5c1262373ec3a91374676173c8ea58395d19f5d722325460582d04944916d820a451ab571630b405b8956332d0b43f82830af866f8ca9602975130b60e6d608e92bb9e0c0ed21e9489b6e5b08e6e68114c2d06609fdf7854a84eb06dc9f3802b4b131c93b6a4a21f65489a672100484e37a4c8f1e216aa0efbf84352d502d2999b1f1fd5d03cdcad6808a52e1aaf3115687081513845be384716e6eced430e8f00cdf14f1c701a98027bb2a854763421c5c07c29f9e5f644fd0804d95c34f22f444685d52d3121e48d7e063f5f39d60f6b1a8804b3b9f0b6109517e714d4e4fa8e2db5f575010564ed89140123678fea2ccf8161532274c535c2c7e16fbd0f9e3dd6956dbe52de6661a622293a85dd6448af653b4175c737ed44b6fe035fe8d70296211ab5d1c0b6b07d182db30a246a6c5e0839bb95359dc14aa74d8cf5fae5f5a2a596f5720c5364da58c8c3ce93fab942d1b16fada402a88e19af72d10adda7ae4cc1b4a6a8566d056351f27ad018f38cfb4d4ba3f9e8c7ea79db2c21706b0edd89a67bdac1a2c40afa7d9f618c00abf9ba0d0e2130e7fe259c94be74ba6d4b4fa2827074f4cbafb108dd8e16963b6d8a77e3fa3ed6abea481a8c34be886d1e72f71c436aa8e0582727c71b8a33bdc47f4a5c266dee45714bd4887197beeb97435ba34a14128151e871ccbf4087f85ab709301e4f5fb305d18bd54d8c0fb2d6e64f83982b2bee9a26ddd13c3b252b7b6ec07aac06261195f7fddb0d96a411e5a5d794b417f1466764b48b7ba92fe2b4960f7c706b291209701727515e001caf6713432fbce737133622b0f52a543f9ed7f9b22474076aed41d4d55b15f2ce35ac3ea4ad05b0cf381530104bfadafbef195407ac22e0892f0f73a6a6b91a516e7ce50b63f698387f0e6f565253f4e1ef1339337fa0d908683e29ba243d270dd238fa1ae17f9efd23238ba4cd59b38408044fd3e8f391ab6b93f1b41aedb5ec9d268cf218e329c53ac8ab823ebbe69379c0126c1983ff63029582eb22ecca1b5ea4a09949ff66696a5cdcd528e1d634d78ca4106caae9cec7f3f5ecbae617c0cf179f169d917e5578c9288f4972d03ad99986abdba605c3eec07471722dd1626f8941b451965657675fb4e11cb4d4a831b491d73a80f9cd5229808b467cea6b26b1f9e9a7c279272391b7b908bc0ae10f7e7b021391d78a76eb8a6cdc49db7b2bd04b9bc7d7b2e3bed36f88d20f8c3507b9d7e253224bbf1ebeca84e27c59ee9f975a88b724b48a4b804227b67b939d93995a3862e6a9ea04fc1b97ada21c45473903410fd039756cd9469ffabd047a600def56d6c189d1ca8e38ba4c5b22d37f497adb454b117088b446ab424bb694db8e597d04add0aee53208d49d30c15b5290505c8709a6173b923bc31bbda3b7d3f768c293c2760238c3f6ea87330751f24f8a4c83f750f2a4bde56159d415de42aeeaea86dc88af1ec5d3a79fb36514d017a43ef05f51f64cc38385fcb1c5d020da61b2e226146de3037d68cc4d89936c3c6b140b423405f317c5e21d0cc0e0a1f27d7c25732292673533731993dd7800ef4b0813c3d9f60c2b16fba28ed2bc371095d038a890b98c350ecbafb81c41c160f66481a9f747e68b36e6bdf06d7534043e146c937217370b0967383f76d2bed622a7eb2925503b5101688e47f557697d891b625b4ab5dbf70c4d6b44f16fd3bf27ea24f72ddee06fc456cda56c6c650eabad4c421ab121603ac337972422f6a9bfa490fc659dc4c1ecade73a5cd4a023d849421bc8fa08ec00e87a9336a7f4da427632507f8f82e01b9c09002512d57e603b87df270ff80df79f84d73713e8f11554ec0240ff207d9c8b137cad73be2b2289f5db8b25ad1a635cd5757250ff564c705eee5a3a40063096c3af7f277accbe28dbb19d75f196793ee21c6cde3f2b2f2516277ab1fb077ff2ba266a9217c2f63ba5084195f1db444d1cec6cde2c92af2cac3a9332cd3044308ddc1edc18c06479efebe7ca54699781c3721d5e18f808e892fd198b0d89ca30a72f0b3b27e1c0f5478e13937419f893a0c93565e6c37583a71385f84fa8443f1c93454e47d1e6f7abc9cd0505aa4905411b366d57aee67f0a08b0d1f610f8924d4a829f46c370d2186c8013855540ef7ee879607b54fc63c287c71e4002572745b388af98173d5837b8200f800ef26c5c616225cccd3cfb5ea37cbfab5193b96b8b55134efe2bc3c42156552d2fd35594c31a3d22cec65fe6cfab6d582f507ff2c0eb5710c14365df0874a27d42e1c8c1f2dcf107103bf02c1ed342c856662fa67e55c34a07b85ea38f864d84bfb714936045023cd24acde6baee68f2de835dd3888c15b01d7caa9f54025a50515715cacad8c01f8e7245aec43e508ee60e9efc0fa9383b4350ca8d4302c05603803ee911d4155d192b85806c9777b5c54a4c884878577de274b0f545bed7839c8219f958aef1d66cfd96241a3a61e0d5da637d3064ef5d1278e926c20e381c4ffe3d452e8f110ddc3050c38d98445d5ad5b0c4751b33f635cdbfc6de951ed4ce817d62e8b371e3c06670cc4d9d6bb3465eef5db7a247e7f01ec07f9bf82a81c729695b81ef6bb06bd251fab0f8f64a269b53815987de1e69ab85e8636f1d388183f3d5c9d53ed3ab967b02321e41f65ee046267bc13bda7a5de0b53085668c723bd7dbc09192c979bd2231dd0ef0124dedfc73d0dcf31f8b5c16dde5de8844bbe95b16112f39a79bde3594f7bdc70f32d856ccb7f589a2dabdac2b53ec0fa89fa1408ebf236e86fde33bfc9831b7d681bafaf511e0e6ea043df652c94ba12dc354b81fc7fdf691be6de1819dff046384a7ca0825425929557c405cb6866eee60b85aff4a968cdc1ca723b6a3976364507203479e8d2c288b4bd7dbeb2a4080a844bfa9a341f9ce3ffa735e750cdec16ba3d95fc66f0a4bc9830c191284dc2653aace474b47a9b646c70acec3d484b731db3f3f672743f3ee22ba38b73c0a4b3790eff5f78c159dcde408f9a062c25d383b8e9efd577a0d144e5486611d96c7e81a1dab06d1dc09c450d0391f07741e51c996f2c4dd3931352f72d2fc69b8528b2383ebdbbc5c551b77d7aa64cda6e665e90680711d8dbd0422b0a1c03bc2ad65f111132ed3c9b05b94db56948dcf54f7eec875acc85b51abb70b4d445ec2d623df928154408655501adfdc894a212121bc3279595f7931ac2e13f25dabe2885643026638e2aeb6bc2405594c3ad84cf050c95372535d6b50c64ee1573f0034ca167cd98436532abced9ee84bac51a1298fd53a5d509112f52ef217fe67035f7e94a6399843369a2fcdc229eedb4b8103ef019c1a19b94596034863cf4cd5c512fd7f552bbd389c7ed2fdc740556f5be90a46b0ff1c10768d094018a2844897cda85e830075f7ff67bbff86798c45ad16d69226a1993ba2c0d138b41ded5d57122a22b38bfe5d061c7ff252d8770ee4635842f0ca67bf9437f8fc44a193136d359b55445c5322c1a82dbfd32e0ef5f36d423e99078b7f87f19962adf9b626b22d4e8d28d1dc4dc31dd098b1651e058cb487723b9fca4deb03e167980875cd7906764728e28a4d721368d58bd4af461e7bda02352fae612db0ab96350ae4775b76f1f0c0b0a3e63116027df6605d5bd08d9d8e3946dbdb0bc2c4f7abb719bed9312129ce532f87159cee6d2a794e94a3a4de4851c2fddeb2ae244f8d18d1b9ab60d592af2cb0b05be923a52a2ecac9cab282e9a97683fe875bd997d17f1269e273c31b46f25452d9a7b43580cf68320a2a3e244c6f41803d620fb0c001170c051d9abce95acf4f5a04511bfe41cb2b929828ec95867b3c0ceb7a8b5adc182dab6e234c3dcc8fcdf63311398ee12a1ed2f8b14159a3750cf701d051c07043d23e426f889038c65d6df1bfd552c8ec971cd86bf59d0df445e73ea31fb0f4caadaf318ec0d221c74f7032586c616f4a1d87413364a6752340c30b84be98d9b144ede1feaae72aade1ea0c50564d1a7396342b958174811f699a69e66fcec63560e19729cd36b9e0b82f2482f99906d5f156dfa3f9cb49a3c33695e0242ea5c373a7563d7d0c263d61802b0ce02c66c368a3eead2b31127c2fec55c8e9fc21ad33205b146c235b7b8fbc93d151151b053182cb0891e35737a6edc802a6c7fce0d633d3154e1e1dbf15ba0df713ba708266e989dd7ae38efe6c70db236f98bab9a854a4095d83f5ba5df14c18fe4d26530ad2af0e2750794bb479a0546ef36a964940578649c07247df215cce04fa7fe176a825ec20d09e373b6a8dbb86cae07ed0fa35561ea88f2f2d7904300e5d9b0767e568a77131fdefbf0819e650a7eb28e3ea3bb2bb7dd0e6c42aec98b20d4f5aa7ee33c660a75d336fcb3a866d347fcc3456d295077fc52f755907ad99980d6ead2064ba3715f7d5824cbfbcc3a112fbfc3763f23795f652eff6a85d0438cb65191e2b6933893fb75176d077446a5ad0a78ea70da65dc6c6e797e34b1982ac514ac3d410a1e4b5e9342d296082bfd9abb9dfd609026731a574bc235d8db6d1953b0d198eb2c4325a527d86baf2975abde9d23e182e2f8b0cc2189b557b9131997f08764053146133a57885b9d1c66ad3b2b995fd64fd28fbd5abbd3fd8594b9fb9c1ee40920ac6075538ffd1d6327451cc8646b643e928fe45db6b321e70ebffbc0a19f8a93d1c6202ffbd3b879f02a774c328f5ebdf9b897a65b299cff85b9b94f97ae5ba75aa3794922db1fcc22a38f51cecc2ba97b70c099eb9692c02d3785e8d5a0e5c4f05c3a8dcd703fe2772fa7d81674cee5bb4525f2c89b2722891735b1e9c3787f3afa7a9e779b1657ed6c734a871abf5828fafc56710332e54254b8ae5d51a69e434c83f01d37f90aafcb18ee42f8da4509f962ddef6e7b09a2fa12acbacce27c63789c2076138dab60e420cb79b5113c56feb51323a3b64e0410a3618cc623173a509656107d3d5d83ac811b1f5ec6903b42897f4b6d7f6e210a90ee2dd38f77fc6ae584130632d48bf0982f280d0d2fed7c5bb9dc2b8b686f7f02ec6cfc1f4c8e176cfff8b100ed283e384f6dc9d196bccdb24b2c8335cfe646948a84c53b393891947fe28c7966f6c2fbdc42dcd575a51c0869dd0ec4532d722cce412437715df1383781b6058c6baabbae301f15ff0abc8fe437bcc8af900fe7ae6e981479b10bd7b997856e2f071657ad13cf6bec0cebb906201d7c8f01bb9846a2313a86abaf9ed0ed2a41c9cb2676b4fc5d7d12b0e9e42e39f9abaf8a7aa105732766720690e886c35d45b8dcde66f0f194397c266bde4bd03de55cb8abe4ea3a17e079e83b78f2fadc0485a5c62065dabbb01487b171dc1e5b37f2dcf65316c52dcad8fe403022b4e97e9f27932d71bf542c7856332df3f3e845306075596a2757cef08d67da1b2186a13debc5e381be1296836ce436dbe40a34ef7109ad6b4cdc6871b0e794fa636836bafca4ab53f6286bf15370c077873c0feda00b33ac2f6cbe465a6dc157383da38e232b76dc6107a895c0c755ef2972ff08d3e2c61a6857f06e7fa0ef65d8272231d0e6c54448f084c0cabc450aefaedfc08cef85688d7ffbf02d0a2794a3711c7e9a2118dee551524b9f62d4c1c209136e3643ae84a56610bcb6d1e320a87b7fa44a5fa88175946b95a9f29df34cb0604d101448716c296573ee2c18e119921c2fc0632b9eff4315de4ba87afc80f72e15d84d8f8382fdbf0953b77b8186808d3f91ac3515896ac7052953079e4d043ec4d44857feca3622d49734fbeb33c54ceb89a7b5f590ed69e50d306e5726b7e4dee0f7b526996b73c4cd474d2116c650b9caf231fdb48abcf7d027af63d442743771f947106ffb6946a4ac8b9d5cdadf79f25156e68acc452833b1732ada133ae834d3e7f610a76258bc942102b81a382ba42a996df0f9a7143f33c06a793356fde1e7e452b92e25aaa18d962d4dcee771fea3382c82439b3b0db930673896c09e4a7dca559ab45afbda1ed712424beefa50bbfdb9a6b2762704c365502b0579d4f01afe3c7169b6f50d36772d2c5e6471dbecdc0f62723076c51e4c251aceb50f1b7d134d83ff52aee33db64b6c66af3c5fe7b7a9bff7ead4dad5af661b9c7d474dbba040181d6961f5bb366a5f601cbfb7fe7e2913a48525510cf79fa911400f218d0ae61d3fb5d3bdc9e3f2139ce7580a329df5e69e0631487dc24251474cfae445e6fc6400ab811c9e9d3d12dee87bc42cd751fdcad5fd29eee20cc6222d5df0e19b7266f2a2b2a8941689812b5c88e6b0fb6fd46d55e368f9f1746a31793d14e313be92c217b2a15f259314227b2bea4f5cdca341f6cc780ba4bcca7086b6972ac220b44aa40c48c7c1cf49589674ae7fa596954333cfbd8ca9ea226d0dd4b37c171b8cd29566317153b2940ea8330532d5afe29e45e68cdadac7f1914d4bd1eda8d7e8185f7d8074f61e4e7e01ecdaaa5b6a903d118929bfee1d8b37fd0e590e546adc864fd188092c9c3f35753a44a9c53e4e3319be2fc77f323e10cd911ae3ef377d5489a6cf2247d9cc6f82736eb317e01f909d2e99c572f601ef63274b92cdb354dffc24f5312c205935621e079ca41d3d836f0185dffb569bd77df38a4b2ad01114c37806a26e817606785911729fcddee37569e15a1059373c7f96746a532f34b38673a52c03c8d97689be359d7e9408e88110285f27b33317cd559636ac8a51749bf850ddddc9e50d184dcc3082caf3d9ab493ee11cdc13a400d722b9eb4013b2c1e7018ed11d93d5b516a07c28ee81878f19e581122971c35393e29a237b4260e8e11bd687c30c30129ec750400f309981280db9c9012274b7a536dea33582cafe99dc712c76630755c7075a3208746ed7c123d65d2adbbb69aa409d97bbe01ab65d775f0908f5d57732912ff60c2de6fc2c64409c82485ced024959ebf0dda0560524eee32a8855ce4f12e4fd2201679eacd97541f162819ec3991e7cbfc6385b8c2eb8afe6140ce8ff19dd749481224454ffb163c25b515bae56b99a517268ac1ea0114dda728da715bca956905d149348adafde21886bf8a1abc0ba16b4bbb0182caa920eeeb2797496354441aa549d65639c32dc389ff904b7b086e71e5f6a01856c64c1454ca3a5dc1492b3acfb8e7df41ab815655cbb7ca24e8a7a018ccb56e8185014a8fcd8a01d536c054665e25cd3eb36f95e3ebf82115c29ba290da17e3efe74210419298b4ccabea67d9de1865cc11dee0da95632565e7bad05eadb562f04f607bc43e9494e6816de63f11acb9a29abe368501cd50bd51e5474edfe0e31df32bbcb6669d82ee7a4fe23510f44be08f21e5d45fad70817de5813d81b4322ad7b41dd83a4c110cca086a22ef846ee50b9d5d1e85071bfc2fca10349d3bf0466a876743f983819b69f9c9dc6529a699194ffe28743775077eb139c371e0637fa7ec2b411ca4ae6968091d69a25098f8638ddea2a5d82080228f22cd36f214f6adf661c8f500f44512fad19bf9c374e5b1460e66d654c94d5a328ca5053737efc2f41f31ca9fa589bf6c2a9643901c1e7b965e2cacce1caea4bdbc10f2da983b1d32e5a591cf0a5dc9b8d66444b40e0073386c405200444acf1fc6c53e83e21e3fa8c183f70800bd5061de89ddc4b373d5845d56b19d14694cb90e3414bd6b796c7093d31c1dce79c74f5e7d2c76ea2bd455675539984c9d383c5fead8eb16c9388afd820cc087fe657ec80d15f669dff88f7cbc3a123ca23da6f085f6aeb416751a313d883628c290c156fb5182b31592945104ec25f19d9f31a0bcc941f68f2b564a8cfdd597f0bf86d47cf08cdf2aed9a4ff8a65d07a2ce1569bf3862ebe0d04edf72d295abc0ecc5be169005a7fb5251f5024e50971ab4c641f501d948acf4fa3b4d08d129a4fb001ffaf6b04c45d4c805ceb6e2ac1d1d3f8f5f103d1dfe65b6788a1172ec6941f999daa89f657d27abdf9e45a8c205a67dcaee0e45b94a2c704e889d1ff43aaf676e9170341efcb584cdc67e18716b2f54fad346ed0fe01283e421694bc17d03dbf5ce1f2bd12b4eb750389ecfa56f7b773ab84f6e8c010431106acc03d5be049da792600d6fb430f21cf0d7225a6952861c6aba413115886ff021e5b9213336f49ef2b5e0fb099b4df94491d543c9635cee7e82bb85229843fff5ef0f18b1d13a05c0aadb89719d9ab5fdc5f91f883cf1d4144c5046a13d1ea444b2f9a17bf19b2342386d84bb15806fc17f3750e1f7cce3407db820ea4730892c5a44731ad08aa977b415fb98066dcf3923bc4d5c32b718496772650e73d9eb0a610a5b3893daadb412ab715dfaf495bc6e0a61e933ac0d40857480ac267d64bf32b738fae6933adc5a8edf1ed5babb2c3881c9101f69e0ed99b50deffea11b665ec0aaba5936ef91e3ac3f6d898fad086c7d600321920375eaae96c69e8b502f128b64e36ae186594f5e8025682aa020605ccdff1cfa2e7e709ddfaac63e54778269deca4136262d7703895803f27ad64d551bf3f4165ed252137b1a466d7547c00f38b8cec1aa24250357143696892e5bcf5035eefa43f142cdafea4dfdab3161143a99c040063bcad2204c637254d4c98e4a502f7c6038f38bea523d1d696ba1e85e76f8e844bc4fbf50eda14fb69f411deb29582866cd63d5b9453ec47b43e829521ee21d03397312407bc77bbda6660e93178849683fb9be563ee4c314cf5f89789ca5de76a8b7556def126b195a4a12148b2eb50c753952df5bef773b22724367168bfd3d7fc0de6b44117a2775e61f86b164248686c88e24596c6939cf1be2202eaa0ac46d7d46625c62af10df6e17088c115ed43e9b51d1745d8a1d782cec0fd81c891e44fcd0487d20429de2b93071bf28c1cd6db8c0a9b5e56ec8217ef2f41c13599f1a04506fa02e9b25ecc779f87b44d8b14f5893159997972de3a35c61fb4047e1a465b8cec4fce589d549023d1d97ea63a8d0ca593e315e100dc9d83736e69b371abf1bbcc24349c0382e535fcbfe4d9e52b75248584a8c9fbd6ade8bf1d4271d6fd49d8ecb9ad044bae38cf81e496fba43e6fc80b639d7df610017af1e7df8d7c7115a376d7b2cc843efc3117d87d5682342bf4f75596e480cdd0c5e75099f0d8cfa784c8c621749e5ab0cc41f3f28fd9fc2071eb5ade77dd2989aef40ac798877b5416af53e65cb89c1b0a19324ac77b2cb609034b7ba279dc583963c3eff261b0b589efd2cea0175fee678dd0d9aab7fbf691a5c74b47a3add3aeed9f119251c4d528d0008abeb7f37a132daa327b6b6a32c82d16209c3a0eeab4c28a08c05f897aa297a7229901f4f328081122013068c80a809c2d48c9bca234d91bfbcfe097351c2e1fb90440318e6d0415bdabe464519ad018f766fe3555feb31556fcaf4f58a6bb222cb05b3765dcc91f5772b7a3461c7fd641fa665b6efa182d6e4ad0806e4a07ea868bd8ba66acb71eca8396abbe0fbf41bda3de2d97ffd7d252747cf1ec4a6f8b0a7eb961a65665b9f90533c360faa79d55c8a2a435fde4660cb0b2ef503972db18a37d2334748a0a535da2a83c2777136ba2ed5fdcbe1520635f9528507d1e9df62c125b8415fa68efef21e8029f35c7100eed8823da388b09d955a29b6e458cc231cbeae86c742da46fbe04b30037c5ccece76c07798492ef58517de4ccd70b580a28d4ae6f064948ca321c52c89c7730109e378ffbcd99e4bb0dfa7a7b32da827c7a2b9393f61facf4d679fed146a4e99268871473c34fe77b4e8f6ad0020d6abdeb63574ecb4f2bce27d671da0bca44cfdfec44a972c46abff4ae125761512e848ffca8682be89bcc3832ac4d34304a4294de25ee262fceed2fb495a691087bdb88838feb945b21bfc244f0fdd98cc4d332134e56451f49b1055fd1cbe52de077db60a7cd7eefb8df4ca21762154c7b0470764e148d909d572444c1315231a07e1598d0cb258c48131812a7beaa468f2074a629b0ee77997a3b3f467a5ded3b2542332bb8aa5ae40d46f1714c9e587aefa2f7635566dcecff9e121d8692117720898ef9e16b92e582071eae7d9c813d51991c5c3d55e0661cf9994cef1820c42d1241bdb6a95222c42b4eba60cf11b8346f9b0b5b305cbc237be0dbbd87ab1e7667894a6d85eba5681aac897b93b69b6c8422fee5b490050a2c7cce2d8336ea8b8250b7897127357f52242175b344b3067cbd5ae2c4953aa490875c68c5a5871c17cc2e358e325c22bf0817cf93323d4da9de82e4c5ee7eb75637b93134f3f9fe405557d170d92fa9e17065f7b1981a713e26da37f811d471bf524a835de46b193c0f7d2ca7a5e878b876300a405af32b788ff3b34bb0c025eb858f231d6edfdc616ca50795b4c9493b1222c5a0c440a8c22b2c8a42cf242c64208d419ee51c04f8d34ad4db7817f0e6a355bd76167e5f6945a6ea8503cdd5da742e8aede3bbc8fc26ec0896e316dc7f290accf78c29329d3cf11c36a7301f960e2a56a2cd71181e46086fb23cae5d321ca5f66e80081b49daf81c0886df9a04f15f84d0ba307f12520baade69e589bb2f765ca076a0605afababe04777c565be84fe6e47afdcfcbc838f30e76aacb76c7bcd3db44e6bbb0bccc68fab04c3f63c17759e748472f8dd8ce6071f143d1eb55e02d87c47dbc0b62a82ad86448bf6c8a06645e8cac3d33bc9f60c47c18379b90d98eb99881352d83ee9f7af5a51704f62c9225bb0b585172bf766d9f092939c59e2d94a5043154d01262a48d05f78811ce4d02c5a7c7812184ef3dea980b0095ac005aa6fa523bf9d337fb1b30fe939d9e68e536ee267c2ff0bb1a3335c19862730718042f866f031d2a08bad9a4877b7a667109d89c99935941dfd35caaa10089a02830089c9de39ed2184588aac50d9be9c59ec625e70fc1a1cc66ccfcdd5373aa2e311ce9f654124b1a0f5583f31dab08655138e9a1d74384091e44ddae888a058d2925ee4a681bcd0ada539b099a12da8de0cab28368edd60433652c5000384205979ee30277186349255ad3dc10fb4a60fbab913fe76c0e9301414c2092149011a8e566a55aa0fa33d182d80730d31ed1e77f628d951abc0d4f1cd641254587c559b694a013bf61f0bcc88482df98add7bfa7963446f386ba76a57e7ae55d185bb0ee45ecfadd556982ade59bb165dbcf9dbeac05eec692b01225238b15b33565a513a2fdb2052635c335b11f4600321739e9b76387c50f7524be5c66741f4062df3c253a234069f0c5ffb5228782b59241927c7334dfe9322dcff56e25b463a71999b0fb1014d0b45bfe3cd8a0179c82a709249390cef3fca253e706f88aee50ca6fdf1ea5396f45a54b264d9795f9e495dee9716271e1c7ce290178b0410b19424b3552bcb045d450e3747972d1995e89b3acb9400b17cb842c6172409c0dcb1d934cea67d24b7c1601a8db7c5daf71d457ec338bf9b14a12a1ef9a3984cfd71da68d6260034301c35653509a204a5a59bad8567de3c17fbd4e08613a5e0fca46dba4c5bd93aeb02ed71105714f0b9f4a9a76a94c230d5757c1a770b0642c286e2e707cc2382a555ce296139f82315d48afb663ed15618b6b083c4775e447d02c463bfca23c37f626e176aebe1fcab78dc90da614e2550bea39aeb8aef88ee5aa9cf4cd3b59627250892c5f19e9ec7166227ab76b36eebdfd245c714b4e4997e1cf9bd4860400d3baa8225adb41b86ab5d0b72f63c04c3faaeccb04a01df036fb1b13eab779885afba05a61c3b088cb1cd51cd805b540ec0c2c71190c73615415494b5cdb6eb935d37a447daab8507494b0ea000a97d6b85ac02b6be683bc68400f23a5c519f95d3bdad077c0234004c26132c23a470a659682157c967dd2bc8d2c86845df261149364686c7518e880c5f6669b216f9c647eba016f430cd707149a5e6bb43365a2e7f181da1889788955a3455a70dc4ba7a9b7c5ad4e56d96318c0dd09378a74b8ac4672e5e56f2d831c6d4451ef8673e164c23e0f360869c4b344d4c3b9d865da055589d9b506da4ad1221e9bb946094b2287ffe7e3bbd131712b462b476ef4399aa7a500a03c008ac0a6f08aabda86209368dcc39865d9c03f638c9ac02a459c3710329734a99ac31d8c1d1ff2ff9a1d9292b1b1653df3067bc45ab66122484de0017e3e3958f7e4252aa2963049b2a9087234e6d51a354947e6c188229ba400b7ebfe2013ac47c672954019bfef9f5f05a1320b46c32054cebd4542b2580aeeb7b016a91d02fb8c9db217d0692e2e9c457f75888dea574de7e99876596b966681ee837ace1bd93f5488b239a2f1f21dd76fe986ec2939e57876d29d1af5a52f7e7f8e674df1750a1735ce846042efeeac881de4f547f705d767efb40de2be928ac418f9b4a07db36f9ce0143f0e00ae9b4af772295556d3307d05505a691e695998d069f76b63743e63ef4ce12550b4907303852a4d839f689d0ad3873cc0db84388e20765fc3c8b0a559027a0337382c627f0788928a94e03839bd8f53e82a05f732761208becdae85b5736f25ca9cf6d4ae76449e74c4a3286ad8a9c00510a126609e7daa6fd8087e6d1906655bab45ffdd39aa751e23fb166c8a775e5923db6bbf761c19ac6930b9ada6cebc9282c09c4914dc0a90d5484f500a4b0919d6463ce82bf951a914ba48d1d0501d990c27560f856e164c185e127c6690ecf267f9789f228218d8f5c32549022c2d3a25025103b672115d0a685859577c59c45c9a8dcf51afb778ae5a6802b489ab76e3d47b992696d09c151fa6c9c5bce9f8e165121dfd87fe1bb74773ae8896e6bd9b69467c78449da25a0d22d0630a111a21a9e24f8480783fbe955e2dc6f1460b05600257acb7181c8865d34815e3e6bb9fa79117cd4c67c41d8c161eca696c25c3e734b66c38261d2a8a2cdd59cbb53d8e75521686a2b7bdb74f49aafee2a5425e5d47de97794433f50296d3f4cea287269dac40d1e465c630bfe9d5fb5844995dbec7f14a494fafd226b91f79ff2b769d2ccd79564b4167f2ca6e0959d8b8f46a01c4c3a4ab8c9e4c6de42e150ac8757e76500ca04ff8b4faecab34ad7e9bd2fd6c8ac59b7b8308852b964ccdb6fedc4d50787e136267642e32fcbde210cd96b9930eec77101381207cf28c871639fae1169b5b8d84752b5787cdcaacfd812d09077283ffc0bce2e45213bdc099519ff36ae85638287f7a1362cbc9a9415c373fc3602593e83c638f999e1864738696eae2126e22ef1c74dd617c252df7894a6d2d7a6151020fb63594a89a18da6000751cf14f47ec901407783cb166808a9e2e6cc6ecbd0ef442a47535ef9b71aa1109ff707845a215bba86d2424da93692ebee688010677a4c28bdf7abb880c73eb0f68fd92071366709b4caca963a2c62f471b9d3af9f190990b57e0db2c83cfdc634389bff522ffa0cefe58a7c0171b2b595eb7666b06d4727c27fd78f40432e30e3267c83f3e3c4f946cba1576b52f6a0dffa364a032e9b5f836db800c079a3361c1a2b579cdba89c0ce1b97b3a3349d160bcab359c843c18a31a82cde03167273baa90d2e5ee4b097c3b2f6cce09246c6c96961036800a2aca532620479d5534a229836eb73fe1b7fb6c7d5aeeda01f307d27b925894a5ae6b65c9f4a30cce56da38e05f90fa59442e648ebbbf5972bd3c346781da5e6ad215bee62d2e99889f4d8c0d0622fd3ce2a7dde8061bd42b60e809948430b5dd5c4c7308d65464c1b03d90efe36a06e9bd4a2322389369118015b89c0daef15ab3c2c133e46707cb60941ab74913518274167327b1501154d8e762d725d5265a611aecdd998b57b56efe538d2429b1dc2ccada76ad86317bec4af89a63b0d7928d338ebe700cdb91fe92bfe1e2a2235f0ecc21a9a8ea729bfc813107d5a5c35a1978c6094d88abbb1bb5a61fe2eee4d7458366cf2322643e547421b14020b9118c7b103549e95c357f5736e3657367165eaf112d18dea0ae55752d388979a7ab75835c9a39fab22720bc9c6f6b6d3dde8e42207c99dcdbc7a207cab4c877d873a42738c37e0c05df278adbf0223f7850a1610cc226c4f79ce2004b5d0294db53ec9cb96d75c5f18b6965ec173ce3dc44e7205414df019070820cee3c23148b7d891c42d6a9289982dcc3b7aba10216bd72eb85ad81a366309c4418b4b0004b5e213331e8b78ff5ff095c53516896b633631f01b5c3c6160eb49f3f5f32b54c3f9e384080e25499d4cda65a51702d89493cd0195675473595c9620e55e064186b269eadc211ec9d0d6a6d3b3d7dfa55c6920a47851f049d8d677280072e2bc32aad1016aee1d70866e055dcd5fa13e8857ea0b621073e654dad23b23b25a62c1f7dc7d508d42a4316a05a4efdea758a57b27224a507c069d4876c2b6b4ec13ca40fd6be34f3b7cf9696937982caf10a509eda9be27646d45d3fe8a25ae43e07edb46be7b497ad41a3084b182592252c7a325ea6f10e36e409a289ab8a5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
