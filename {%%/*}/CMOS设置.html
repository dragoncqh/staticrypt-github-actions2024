<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"81a52ba9ed54f7c23787700dcf7b38cd86b1bac4c23860dba5d5bcd68e4146363b748dd6710605bdbf4b9f21e1ee0579461d83521fe7501ee87f2982599d7833a5c93f0632d3aab8f9f0893be699213e02ad36e5bbf0921c514d67687057a280dd874d36999e68236d4cc7515a54aaf6482c249e9e36eb68011d486b9250f6765782f6f7fd5ed96da73f987d18ee2eacc53e97867f606b4264a0e252b00b66d4505501b96880320e583720db21e769ff26a2d733d1cd8ce67ecbeee0ed2402b280b849ea75273f9912c04e751d421cd199ee663b48f712ab98cf90fe484891974fc2af284b9525bc6abd8c90f3913fb77387f5d70e6a7dff22cc7f5c53d604b063eda4580fc7cdeff6d32dc36613bc0a5eab4f6ef4ec9c07119974f9bfd7e05a4753f8609c589883ed75190fd0003b4c7ece77221e4a1d0803040ef9a200e26a81e39c2e14457a9138901804f83df1d0e099c728d7db7acf5a3997fd555780424ac3f2a7502186c4b6612a47ca370ace10816e746c85b62635bd6f60af62571af70e11880967cb3c9dcfbb8cfb37ccc8ef07e8203350b6e1ce0dca0dd34a0d2d485733c2175db8de3b38335255a717e89c381a23035fc05246b9ec128fca9399b06986b2cbef8cdfb7df9e18b50329950b3d70d9e92e7bc56c0d79bdd29b3c7570584bf2c7251d785987aede9196772d0c08a38d76dae1e3617652b42cd6e41b7b7b1d1164f17c7a2c2e3fc9e954613debcb12385435729c4248658f92079855f11001c83c20b7cfa45e2813041e4de193f16493e240f0611bb3aec2588f16c0babe7e75b3bf4049c36a7e80040cdeede5ea34a2d2356f7cb49bfdac44216e62cbc6f1e58990ccd401c3ec211dbac4c3383f3d910a504db92eb33d561c4833987c8ec81af012a375d0c1ce0dd577ebb715207c9c5b9c218200c9c2652f7f844c005104d3402cef7d0e3c1333f603d2254fd9c00b2f85536518a5015b5e75a38477c4aeaf3c92e384b2ea7b020ccc1cb975ee252778a09ed55a35e31b17567059f96f99e606e16c74b84c47e6d0fa6c074609709609641cf35ca64240a51ab7d5353ba71eb31258137cc7b3f0b61405c182d98e2a0d2463d7a75c82adffe37dcc0cb56dfd9f411f4371c4836e3d9f18a257db0bc185b4189d1bb3e59719b9801937c09f91b2c15a9df34bfdc5e4575d5c20d5fe7a6ac0f5fc772e53fe52b0b2310ecc6a97adcb96da45635991591b53a6b9c67312aa03aca815a2788f0dcd9e64ba551252f063d4d0077673288ccac211d2057e304d295fa1bba3d40487a24e1f774de6fbf56f8e5052a9b506e88f0fbaa5dacf1e2d342f74d0aa5cb523a8a84b292a85f0b96f7e34adf4fa39702ce87a944be2c27163188be425536b0bcb6e54e759fbc6a6080e7c8ebf6bd9333941a11358ebadd84b4f054f27ef395762f6f4fbca80284ed7d3776be2920e5f5cf3bc3c5a6bce3492fa19c5bd3a64e4125735bc0734f2381fb18277c941432d113e6a06a5c901dc5cec83e3543ed9656ed23cbc5b88cbd57f04d0dd72be60ccc97679e2623cb9ad52c41013eff6a4c5aa487b09540f6e07dbb62033c9acb6c8ac626e64d36f8fed7fd1a6747efb95ed564b24051e937cdf8ec5c9e384cb4db1c192d4fc29b192a0d8d6979866169e13ff326762fea6afe84db7a1508d53438b7c296e887163038ac195e5def8babfc030f1c1dad0519451ad1840484f4034b5d8e7898ecff0cf8e63d22892df7e5c1b5c56aa927276f69e575ef493d3caffb079493e94aa43a3d31432df0526f60be89a569fedea1c0694f2ab5283862e03e40a4f6c22cce18e8c6996be3f81f4ac3a0e34c12facbc261c4afdc330c676f807f3ff80b17f02c4640b883814bd21389b381d74ef4090c62b24b49044c88ad67cbe20276f97ee199550b9d5bcf4a8bb27d48f65bdf7146de27ee2411139b49a35565dfef27f08f44103921bebe8e2c9b95a69580530f4074e6c9e118f9dc76e92dc7bbb70c6eb89a8afcab5f5ec5200161825f0452483747969d15a5027158a543644d75c1f02180b32698a4da1ba0d98de2a8a78345e0cb1fc60ef29b7da16871e79b1324eea3fb9d92e515d36d3ebc1fe7a46872726be38bc8c5c18283285d5319bad795f0e7a946da4d34cf180ed1013d9ca6ff7fc79608c1a9fa5bbdf12b196c2463ea2989f209ac539f6ee9b990d5c56fce37cc1b1be1d0ce68c93ab6f69c15e0ba04751790d17d87242a4b57e00161d5e1d5ee6e72ef1142214b0d688a9ae2730984239b9d7512033a50a07770c4f57e63c071b219df0a0632519aacecd99781cd042ea0799a603fadb0090160aede73e4acb50d9b14bbc78109422b694c8dbe38342967f9c1d4bd91c8f636007a27f7cd5d648677514d385735285de95d769e0e9b542d39354064859284c33b3a89ef2f8bdb72d7a183dcf9654cdd7a2b78d19f590a9e0c59fbe6d8a741a609e97696750f6b1d8063ca681a8eacaad79beb424a735db805db4ed5fea02bc6084b220cf6aeb658ac4c8c67f9b09200bf16e09f0b6b5953f6124592dca0f9186db8e5b47e7274f1894e14f222dd88788605db3ecb3da265d35922b8cb93d1c7f08afb75162cc59f78532b240257269487c30995271427326515a93aa09567f4602252f58d120f3cf4cb159885739919b5d54301162308520da7b9907468fc959a6f73a797381d5263a9e4fd93beab5283d19aeee3cb93ec72625f39348a2dabf88bbe031fa5df09af6d9277485a7fd2b1f68bd71d08603bb6c0365559d7fd596daaf263396e1f5dfa5771a3a04204a6ca1bb4b721e5cf1cdf9fb208b71d28b427830d8c0752ee861d564f0b5d5ed1015ecee72b8dda291ad06fef463711c55df95f7c9df363f200d2b02323887bcadd3e18d2e941f7839f506323d7986906874d408166b51abad7c1cde6b2b09c2e0d2ab2ea4ef28ab4fed222fda5543b2c56604af5406b7ebcd23bed00c08531f90eb26ea7ac8354b04f3341d83acac506dacbdac057bf0f839b0b336c71601550aa048e811d0852319dde0c5977b597f310f52151024dc9986d0fdd4e2ae1542e4618aa444b5df4b9df1ca8d6514efa037dead55c1f5c0e6dc864328fb9e72d8f4b3e44468ea271cd778127d81bba9c5eda4db42109c10335f7eca90a776d2d79be9983580fcba94837c58057e5255a8180e82504fd1cac78990476de7219800c5b8f59e62d7aecbbe7e7173f2937c2254faf703388b50545ef0f7da15f6a088cf087519567a0e558578ed31856a0809d969d2d18f395d0cae84bcc3c4cf89de4ef8d79c31ba81b90c5ee10ceb854eac38a995955004fe1a1890d34e03440b5ca774f1d45a90c4bc62aedc4754d7e746fc1db51b5939225a4544ea552aab45945823ef275945788c57ab0663730a2d3a0bfd0fdea972312c5517ff5754d546d3bf8184856dfbd450ff68c06b24428f71c86b9bdae9a6a44c1946a91129586692d75dfc85f0a6e63f7bc107c0ecc60b975faec006550633032f861d4e9e65dcaf334fbe749d6ae0efa4760c0e2f812cac6c31abd81b622551d9570d22330e2e935d4b99de58ab27dabb55ce80cdd6602bacc75e0003afdb9aaf0d5e58bfaa77fb1ace9355de44610a28d6bd03b4337db11df46e76cdb9988d223105c37a8627d6e1db2f40c9c293f74509d34c948eaad72562db3ff6889b76f7d0b1cb227b3a2d6cf00555a4fa495fdec3101ecdb2e9639e7e6a7b9bd398747bb799f94f8a13395089b96331601499f1095e81ed705b0f736c0588afd68284c58ea35865d4d3851fe2c9aee5bfbc085b63892ae26fd13e754753c94c933ad28b4d3449e2320e4cc1581b5941251917dd338e3d2c9ccf37e3d24d943887c70fce5c4be89fad07dcb7be174097db09a2a50d39a60249c0a49da48b71ced82c91cb9ddf7b982b60a4b8571c75e5fde6240b0618e01f67f1e3f6730bd8e8c72aa421690452ebf498cb2cfbc73593d4a92930b3bcaa3bf6e740be5b3a30008f39b352dcc1bb18cb6dbc1632bd3d374143047a13bef00ff82d8f340ab2076b96ca7073b9fb3a08fe615a189807b865d3d53c60ecf6c163c44003f989c9390b4d38a5378b354263bb3525f69748d35a9b03ec29496e1170156ef4b6ecf603afad66b2036fb4dd577a570e88f19678146c9c667861cd38e8be6b6541425500e49e51af2da01f7148e50375799905dec2a7b4c84e16d6fdcfaa59eb8d0562bc970402f7906739bc61c53ece0f1d597c37f189619398847a89c828da0710a3b885ba7af46d2efa57735616b39f71285633f3f0e0b8f0f23883ec1b2bea1bcc827f724a5142ed89b8bd289513cb608856082a8d4102608f6f90920a66372a8ed7930eb3737fc077e12843f0c2b5466dc430b37cda066ec0173b0aaf12fe066ddc9ed4427d26c1580892529b74716a0d9ab6158cc307eda2cb8fad837fa0f18c37b333341485cdc8709548d1fa80bbbd09d194f625a75ea1172f237d778562d62e9cff1c5c2861040ebd8a57e9d3efa838f1a9ca2207dff4f9e5124cdbf2ac87efe65a84c58a226f04ea431a31ea703e27e692cb0a1340a93823331a24ee3fa518337de7cc6513fbeacaa5aa3a47900d71d96836eff088ec7e5ec10530d7c3b3a71eef8536638162be2ab1d83210ff11682fac338f610c88959d70f333064bfe21d4313ebd68adef4deb2ec114cfd26192951f62bd9259fadd4fe7ed64f7478c3ecc8129e11db19938c0a7fd60aa05e5eaa72258d9524488b184cdb0db4f998d375329d84372192d9f103987de7cfb4f680e308e84d466de49e3c780ebeaa459f43247f36c398d2f96d3c6d81eafbf9001e72ddea29326d68f494f6c3d141e4c3fd86c42f7a40e91eab5c123750ca0276b6ba1afaba2d2ace8e5bea7a42d8e9231ef130eb4312273f3e687267a4d364e02ebd07563adee5740fd535ffc58ef84cf4e8a17b398459de5ca775392c35e88a25b6873bb56ff5ff8b5aa0c187707460cafb9234bf2e027d380dbe2fe8c8b248f1418d3c51267726de5bcaf50b9194d653998f6abbbe0c9c1fef25fd252b99e9567d4789d4e418d0cc5438442db57665d57ac6118a3aa875f3c33780eafcee079aab4d95440a8b07cf3c8e2cf43fa73834a0950ecd19e2bb7c424033117cd7075c1bdc040c56947419617320dcad21a1a3c36407bc14b59c6a3ab91feb298842a16a8dc9da4bf9a301d7fa1d3ad59572169377d73ff7960be55b916ebef75a06f720957980fbaccd3ea89e36a8e543845c8d82b350e4a41bcf5e2b309bd61cb8b4af82c80000c7e0ea0d3660b333eab76914b88e7151f7bd1a70a44e5a02bbde5294c61ac87941dc27e64ca7be8919338fb817aa6c07ba9c3d4c8211ad9a53f2e3473fa6809f5316b1225d9969c7b9e592f351105df1134dbcdad323878c97aea5b881e51a73af18d1ab5a80ea73d60315a55f67f20492d6dfaa90aa8518e4e5eb6db7cf78755e80f8880ba63eadb46044647552c6a7e0e18ca6e505001579f046b63de800ad50f22db89ef3bb525144181b84162bb74c8ab803fe07e5bc27de87b118917f25c6d947dc2d80574e497c21f04b7ef9da37f87604483c6c036a05d01dabfbee8756a925bbb21e9231826a8293bb0aa0a43d64df481395fe60a140e7675e47715bb8bdff5c114551b3c76a18100ae101c9173f1c88ea2fbfb800b6c40d510ca6420a7a14fef95e3fe21c57cf68e3d4d784ace98469f88d23c394f894e7151e031c33be33db6269769a16248c69f8672c4a9d3794a76a66fffdc3f27784daee032f97e98377cba217c85bf04aa20ca8427e671b6bb39ac6efed0d44d324e1b34dd7fd8c0347c026684552124dd65f74d9ec9a5c4c4714e8e421cd55ea5c730865ba0b529e3cd9b7a2a1d25924b4545063ec6e7049f5ca0ae60f977fee1c4cdbfa68d1c60149f160e9ab9c6dd5cc0bcdf28a4efa778581ead4daefe8c025dd896f67fd3e1bd9375d1a56728f6fccab9364a6d88fad08fd2d2f63f1a84f91c7a8e147c4a9218f96f868efc9c8d16ef98a06a9c9ae34b329f68df4dd379a42a59e0f0bc00791d07a6e1218bd4a734c44b3628c673da1013b5166afac7766497a0f402aafa7aa4f7298c5a90614e499002d9db74657e19fc1b9e7b9118d1307fffd36423339638f9369c61566816574111c5cdfb5d71507472d8c8ddb2d97061bf2d7ac37a5b32f388e90c5779dc6b695ad32698145f9355a916870cc4db198499bb92d63e8b8bab31f769a6adf415014b81a5287c24caa4c2e9e7b343fab7489c7521ffd6ed0de947b74f02b5fd6d09b091939509ea8b5e3531b3106146efcf2c1009cfdb11eaeb6f88045e06196bc4643c4d3eee9a76f9e9dd0d72e45959b26ddb7805fa44d3b0e4a55ab85a00024050d9beba18e806c5afa0920f5d4611e08df8a7f3459de050018b5072d33a4a5da7521abaf00abfabd8344d5cf81a3de99d402660da4e698a79da96704c3a76dd4199f3b8e3530b59e1dc25bd2007f14b2d3027f1e2b4d2911fce7114aaac48425a0874a338dbf73b58dc50d3ab748bc506190d4af12124a6b55532664cf2effcb0bff94719d4c05601156e762a65db3977026f04b95d806b8b88c9f80c9d0ad8d75c5c030b650c38f647169af07f66c6b70cc1d740d61d69e6dbc8014b52332daf7bbced41bf96b46589e54eb5cb8754aab588b353f499df9b75ada2f01049d521f94d4aec095f644c7133293daed7ab73bea90eae796a02c033db285b53d05f75f7492f0af93cbc50a650139d93398acf44481eef78bd828c60b0470774c7bf0a2ff5dfe51121e0e91a4e912ce8303ce235263d373d831a50dd124bb5d390dcf89234a02aa7d0281583639a3eaa08ac7c26453657a4d8d4d5f0d7c9f4ce32c80c6e3e3b290393c7a4eb9be780b569f92f2bc63c60e6f79f1a45accbf3c4c689ba150ec59e4c1ab1282368bd7a7467a8bb358d74d97d584a5ca4e11ae17eb9753823e45e16717999bd929666450355abe97a780ae8d30d181c6f227568f42e2ddca5ad1eacea9155b6af2117718772f74562a1e28faee24b32d93a4b533e52185b0bcebfde48e559e627fb0f7249d6331ef3fd8242b82675990ac4b27347d74a80d2dbdadab06b37a1295a21bf720042e13540c52aebecbe15a2ed6d557f898796d519b541ebc9056b4534f7a1a3349f2b2ffdbf0b7c067157736353e26032a07c89972caa62e879f8f3f11e7a731173d34eb511c1563597f29edf275d4c5c78697980a2477f76f61006302fb05cbd2d33e718276800934a4a3def8885984ad282c27d242d50ad90489ec71dbb5444ced5eeb7893a55eea176f9ae0bef8f538ffc32150bed60855b8a5b9bb97ec2680e0e14898d791ab705536cdb7612c26e5000ecd526c23cd34ebfd44941cf2089e667a1cb4dd4f9218f1dc697c7d6f19741c936821ac4f2c9fde155a9f42637e21e2bbdd7e860d68ea9c2abb1905d12fcffffd98da41581ca2be4949fc376f52e2107fc4d17c1b0d9ee78017322289363f08336904768f32289bf9403b283419b49e1db1532c01a890538d8d23399192cafb4cdb4c77b6b33bab0bad7398489cd7d435c39013a89b37db8a58ffbb350bcba810af6404225d1ec02dab33a089a4e04a28c8b2402a3e0647496e5433030711462ce2e66dfb819b0af51c6eb9bc61c446e6080fd69694e0b73ece6fbdf5a48d6485f50e3a6d11a5e7d32b25037c83afaf1f9fee1baf9f91e8d39ef3796efcb0ffa14b0ae42d737f328b6ceba877c50f3523dccdf97ac4191ccb2ea95b151602846fcebce88cbf5ec1ed2994d62346f8ae76ca8ae06e1a2aebc317d3ec2ae64a032544b220a2f4197cf5ac9f0438278a9eda010604b9d1cb4fa4463de3a0df78b0aa565b91ec81d4b8dc0335e3f3731e7654a8b3b19546000bd135cc2de848869e0bedc847b8989506f1a0c36185de9dd0c0ea6f8617910b370e4cce60c4b92f2c496729304372d0e2e2a3795d5a777804e5ddb2aec3911771038ec1c3eca3296dfa75124adf5e6d66d06d8fa959195d6242a402c6f7243fbd83c5ef9ed37ef171ca08b6b04201ff9348357ef6305829578c6882925a6d9c77e7613df7cc0e97b378f9fc3f404edaa38a3bce8ca2ce919a723deca1d43c5ed22de87260feba6b442c56a22eed4f6520afcb805974691a8beae5cd93b1d8b55b6109fc836cfaa2f2660ae08969f1d9bcacbbc54458e6dbe5c939347fff39e58640767ce3b51c482275d1b91b0e82b96a4c26264188f0277df34ec973c2293cdbd598fd59a0ae757e87dd89a3dd4c2ee09cb010ae5398c160574a8f38c5d87d566b8d2c222818a44eec9500a1d8aff5cf8ea412fa0d38b71762a72d11defcf4ca11fc39d031fa5c72293823e505b37b08a020547dfb818029e3f9d281d550c812686078b19285e8b13fa209afc5ee849e89cfd0af0712f65e3e5ec02390fb269ed490616f2af8063190e603dfdda48bd5cf5aa5bfc5cf26eec89719add14efd4c02f898f803216a09dfd2921eb01e5f359c52e2a9caac219e3de130736f2ed1b58908ca3dd06ae8abbe0a6ac0628ceb9a1dc11b8a20d563ccd3f398c3529ebeb317be9ea5b0b8d8d20385e4b2f00fafb53a6f9b579ebbea8d59ab7e13b666db031b141911ea1d2959924698241b1e5fad014499e534366b208512fb36690bf49dd607b47f2b43d7878410080c123f10372bb95f9fcbfc37bfd8986d805d145e9bae327d4ebb969000a324b9f81f51dae977cfc5103684a6cb4da3b72a3caf04ad0a6af4779cb39bc7c5f5cc9854e75f7eb49e13aca95927d68871b445ea4499ea2e9b9cce457142f1acbe188dc506fb03c3c825f0d292b2d6af90d9ebfc063f5421017f9f736bcd488eae453dfaf2aa31b030aac6c53e55d69892bd843295f66f2fe3e0f3fd1b7fc408387aae33e3553a25362018ab44c73ccb9b193ced736a014a7d9ad39fd11d8bc7ed7971a0981b209277cbff842850b26ca4fb5c8ebe4825210711a8a50e601ba1352485a811810e83d84483f1fc90aeabdf62d8f43b6ec4d74d8659bd5e36c654ca77b0fce03c0fc111ec4cbcd4b3081dd30e9f6a88e984d66b5a1c9241f3bb6a6ef4ec0947016719a3a632b02e8fff5e2f31d1f8fe8d653424eb6b614a6b57cb2730873c6b821c48a005353a178492bae67e1396fc5ea1800a82cc0039e0ec5b35db8eda93d9009233b6a11057ee6383ec45439c1c82505494fd8cf2a1f37706def4057b332d3bdb367d2da4d134629171cd34547078a893c4a5da2e741e97e9e2983330a9ae25f948cd625f7f9c9e76b9f6b3c5a41335b11be87918802a2a16381305c38ce5b722d34f7547bfeb5383988ffb9dc1b21667c7ab8451cf084b33818092d8c3ea87a4e8d1a80a587e99af11067d5c95c954fbacf7cce9bbff09062383c856379e7b189c6b46103c8a932be063d458059b07194f24f582c044767c287b139fba1fdba471aa082cd1a1a50c25e28b899e20bee00ba4070546380926ad645b88d2a1abd6bfedc91223a49f833fc4474d74d6154ca24a6dd0ac223929b7cdef86f59650159f8bc5cd1d6628e1f5eb7ec87bcfbac38678b36ed68a9872200d627dcd4c5acb5978d340418dd94ea392ebe6efe2f214960e80b855962a75608a0335c55acfd0803f6cdab4a44030409c8b53a35bcc376491f4b6e1add2f3b1623dadcf44d8789a0f1f3789f3c133f179338465b2709a2976b5b22c50c1a26b1077e065082ea3b1da2c3062d3dba7376398027ea47449f90fb3fe10f48e2aa72af4bb1b7e29e7ce753671f329e149eb643f99d494af067a60a691051c0ed8927b97421fa9162671ffb7b03bb3b6e12383dbbfc88f2550ec63e763d7ef8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
