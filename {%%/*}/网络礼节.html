<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"669523600b572a64ec4e944f92ed1f1f4b37e1550928bdb2e0ab6e7def61939dd2e9d1bebcf3a2f0bd4abf31f5f6086dc38ce701b4cdb4fcfeb1981e1936136305351c6e112969225530fd1daf66bcfad57e92649ff142591423b8e592966de1e9d2d3b98b5cfef3aa36a9e392db02f39c2f94c858104472d1fe02d202188058e611b032963bef75741a02198a701b2277d28fa33a1cf5f882d436edd03295120a2753422af1f60951154e916d8bc677add22cb4c11826a681077b2a2e9ed054f3558aae665458cec54f4857a0f033b403d5f839fbb7e72a7fc513ab6e22a5298150fbe6927ca7043a59ad0084acf84266de28e5d9b93fb6f03a2d39d6f42ffcc011e8cf0f60d876d3e9a09ab8f2d2aeaefc657d9c7d2300418976309f99899fe4ba355aa7a47c8be33cb6778da479558af9b8a1701b9a7ad6d451c6f6b81420cf44d9e3a00bcc0eff099d23764c6a553a1e05b561a0b5a9e4c825e898480487b9be7836a4bba46d0979cb68452b522d5f55c8a4799e9cf5b64874c4bd41b1bc8cfd22fcb49eee7291c6613d891971473492b458917edd1d5be970082ff283c989ca1ae5270003decdad8e7f9720c32bac08684fccb70a16959bdef37f602e67df19ead123d05dc40481192a2e48d23479a627949e67443c8b900ac4aa7f7c396bd3f958d4abf1bbb6e582eaeece52b89561fe834a2aba1c2972864c261210c40c4dd85ce630c7c989eb28cb142881bb084e9cea87bd97fa9904fb01dbbf84e9363fc80230d0035eeb68b76157f3dcebb8ba19c4f00b909b27d291a50821f282f0453fdaf2be54f1cd889d190a881cf4e8c904154327834a1ca6b3b1f74cdeffc0499f82fc33f41c72bc08a2cfa3a8b8f3bc8fa52d5676fa5d78ebead4210426a415ab5062de319ceef6081cad271d4a42149933603dcd7484283b67c51d63e44cfb1aa00aa823eea3bdb29f52efba4a8630d2ae999fd8504a78b3467b424a6479031b9c8dfab8c028ab2663be40ec49c63d207bd6a8d4469484ad7f842ffdf6f62e086ce6ac9f07b6fdb75909298fcd41e34c99b764010c0e2c7f4b5aeb76737db7e5fd611b3760f1f7a75ab1aba5fecbfb7bfd4da14d37a0d990d5c22f98f64f7e1be87bbc39e3d93fdfd056f9fab2117495f6509ed12c50e423749676977aca48ac99ff27ffce777dfb3d2211924b170d6aa5254e9c4acac65eabc112d25b2db4b6476bf84e66d559795373e6c49e7fcc133073435d11f100864c4f7b6a3bfe9cb146060b2573a9800bb5312d72b90d55540af1396747b3c582f25a1dd740888acea9f2a29d0f88ea636985aa8c2a581cfa3ff817c99b3450a511d4777d301a57fe6fbc8e64d340c59814416939df0bb44ca03928f1f8082da0321f349e2f1308717bdd37ca6124947d2ade3c8769c5f1958eecd6230eb1369f63701e6c9d09f9591049d575d577e1e49bdb6af1765f0830d62266fde8209e66079adc40a300fae7abc6c67929ce1a322f7850e70aebdd72f3138d6a967870e7048b45aabc35004bf79404fe52e9e5041cd9c647910de657994908a272951abef7274c79cdd050cda661ee6d272e2efef975807b3867739d57bc3c5d8897a550ce1ced04132948de2df6d3d66d3d2e8079ea8fccaca7a13b16a8ee96497753b4b1ceeaae3bb0fcfaa6e6f7f0b3fa159038b29e2292aed5a6ec73f523a9a2cc2891e7cb13db21e9051d4f54cb9567503faedb38bef1053dc337e77986967c5f9eb640e83d0109ab395026b5f37de9b790fe2578b9064f9e156da9f5f4fec18e2c30eded2dd26fc87e4a4580b5982fb8e6b06fc7df05bd64d68ea647dfaedb8f959d5c29709c9e03ca6f08ef34d5ea46defc182687f71bb698719e2590714df9dd707868fe92bd3697a7b698e0540bc6d513e5067d7e7d357843dfd66d6653ef2b2c16f17faae8d76a34840fccd8fbf5a5d875a074aa09c7352889354ab51ce90b7839847abf5aaf7d931631da1171f60d2657c93734ef78e559d447d0bde5e823e79efa8ec1e9d1635a307e6e779d2db3e46420ffc6758cee01991a75e96335631ca08a2a1ee22852a2db17e731ec79e7712450482b815e657f1486ad003562077651ed6227795a19a94d03e6aa755bbd50a96012b361a9ccc0109837f70e7000a75d37ec193541bd13d6d0810546c39cc440630421e12078cfc3fe0f1f067ddf41195236d66ab7c6bcdb14d3d84c70467675cb40d7c262dcf6a21c2ec08ba9b198d06204ef3b6900f58bb14d493a0835ac63cd32675ae616a297764c9eabfc8177fb24a39fbeac74cacc11b9cea164b520850692879b8a9fec3612ae494dc0b2723931e3c0cc6173932c5855ff0e26de51a862039713f33023872f24c640c51225a6f60d508c39932ded2aa89d9e054306611d5d55848f2f0c4be37774b26d5ca497094b242be4a63697ecd131524904bb0fa9f95bde2b2838e289e80dc8c7f2fa5a6fe718b8733e67aa26dc5c57a8fffb7d8bc948e019137b8c19ae3963cbbc3b1fd0090394cbcb649de8c868c27e9a1c069f69514c2c5e3f65d847770cad4b15575a3a4a8be14020bb60d0694ca0485c68eb0711e26020bbba16de8fab2f4242691cab0d6fb12d938baeac0ae047ebef69ad78d23777e1520c0a00c069e98e5752d150cb09e4ce22ca0c304b0da8200f16dd936f1c3f5014d5931dbde329a3c993fd7bf5cf59aabaf68341003108a7ff53eff782f7b712be8de57d08bd0f84c5eeb4a07426fbfd75acb0b9842f49fc4bf14bb33c01e600e3f02c59a307ce0a42dce5c648b4b73c4ecc4db4856058703967284c4b99af995286146f171df5c26c2757bd113196cfe31915d2ecacc7d92b8f594000009b1759cef6efe4c66b4dc4a7a7a668d71638fcf87e7c2d91c9fc19f4f6bab0d6ec104e16c3a13b9eace47d3c9f59be80da104ac3d384f1f7dc698c12ac53938dc8426b6e82bf37a7785047ec74d1d25aba712fc1c1c04d58d479a52aa3c2c4867183e0e0e6dae1a933b71a41b68bab0834e20bcc0f98999b525612d12ce4b257f78cb11f200d5f7cfb382c7644f3dfaf8b5c56079cc195557cbd4fb38bac36b4985ef154839cf30b8edb8edd7164b6951503a8bb62a86571e0204defd84fe65dd5fb5ce99ef699954099f2782252aa4c19e6c3ac905146e9fd9fcd24a6f609464cf21b73daf5fb40edcd978614ebaa627a3d35d39ca33a85b822f96ca4fde01ea8595a60b880ee90aa7ab0fd44f053233ed1490855ddb79fcc917c5fc2f449a1397c99fde8081b39aeaba8d6c73561f6471468465b85d29d8f6e51a5285e6427b7aaa51f54aebabc50040da136d2b2013c975a8aff027cb907c491c0bdfb593d17168a3a0a8d7f109cbedced20e8b5f23678e6345a80ba78a9aa912502e8bbbf324ae3160594553c47f96e68bf76c75ada96de59a7d0fce39da21e3a356b2bb68ad02c6c0a12966f3bdf773e4ba9da7dce7782663ea8b8fc0773988ad945a8197961f6395e950d0950f97c36d60398279a36378a827b6b0cb673bf10318536b6312acdf84efc6d99dc31dec087212f0349ec1caff8d0b90246e6a64115315be81e7f0f0b920ff20c3e19eecf8c4e6f1195a150bf693c0879666c983273e4d144963ce118a651b571227ff5c3f4bb070ab171d23f9bd2dc4e36ebb7464dc12edd944d604ac2aa63d6dfc35db07e97f3aaa344c61ac450dc42dae435f9c8259a86a035a17f285f134733068c60e75deb5fd4fb8ffc8eb2726011914b9013798f82486fd874cb2b7f8aeec8dde0008ddc4a36de2b1dd5f4dc32a8262ec7b39e75328abe42abd2c6ffef30219429372fc25ae9892fc0f47c9e7eea8e7ac40b9042568ee51623045f061647f2007add8b1e3ef02bff63e4eec4082078ed76aaaa269228a289aafb24fad994620587ea53b88883d4a15fd6816efc1007739b69d81598f927cadd64aa12c21f7dd65558bb4729a58c63aa4009ac3b92e9388c3f26db6a5b5ec04c1af55008de65d2a9a0eaf0c364022a7f1281ebbe14d895f5a211b729e63c1c6f80a685e57afd9ef473980e6803435a13cec756c63613b9aec78123eae41318646a39e8b449244403d4208c256d94b021cf45e5659380be3687b4bd3b0f3f2003efc760b4cce964db368be9183314312bf00414a6526b78325c89581eb31996e0aac76a35fce7bdda107fad3fea8e526e5411425fb8a66b617d74d8ab64e489b1abcfbb003250599cfa20ebca3095a9a8b8021fc26c53629cce5dd3cd8e0050f85d2ecf51579a924fae22e8fc23d32fb204234b9a5c83e1853e8e6b46278382b4bf06b36c91cd382bbaffaec35e3c415a1e3a8d865f5250680460678973050b3d001c6f86951365eab0afedb81f5e6b344ee65bb61efb9799a1debfe42b1c5bac26ec82d4b1dd860e8949e47f3c7e35ebd6e6d3fea49b43d21873f461de2ba054f0070fcd8179d1340003207bba705b6f910325b74d514e5ea9f5e14bbc044d13f81799e0f67a7058900eba6275e9f19b06b1ddff3d489784916cd418acb8d835e2fa98080b516df0f2417a246c0e8a7cdd84acff2857e859a58ce6c67a7a6cc1aa88874dda2ced7524f665f87248902d29a21c7f31ed855104f44aee447e52d582e3539cf8c7f5354754da8869a8c251b3e4685fa23b94c8164d4db78e42039f5237a9bd158c36e638f728cc32c9138ec0e448e49a0f9269c9c1581b936302f6cbcb8a307d673340c4b36744912d894d274e8c9038c22112c7133dc6a8d637bb4f05a44c5746befdb927b088c342121a4563280f1abc02b565c7c58466987a4a405dcd82517573be84165bce6dbb14a829783530f2ca44691a622b4c5c71b0a07f55261c3caf8f23e55bfcd98ee03252e44dc3a3a7932ff84eb1a5f32073271d7a50bd78663eba9387b47cf586b6f41c603f42ff9e2d1cbe33b5eeea1dcedcb7e73472bbb0e2873f8bd4aa09520ba2082b81952e6e26c0f1cf649ce3c2418f243a515b033f707cdc5d19a02cc50a532d00bcd5b313ec965fac72152a0a243cf338ad95abfdbaf5a0a8228c8c020dca1f6abb66d405f4e7cf52ff923450e301ea437ba264359aebd2c6ede118c93729700d65d5c1056c7f93a25d1f99acfbb726f68d1171393385f62797e294560c2a5529fb32388cf2eba1b7fab5aaae7d25c3a152c7183e616ea4b36bac80e73de24194a3f999e2f7092696dc91b2a9903f02c7e274ff7e6133edf253622f033ab04e9df68173422af39c5360df650513779a5b80a5cbc1ea201b7b2743f670f6d6a5a64d7abdf8feebbb278f03d56aef35cd4a2ba1c9bce7bb53f29355072ea7cfbdae8f397e4acd23bb3bdbd4d56069f7eb988cec5e6c46c2feb84df63536e94ec3890d3a2fd86a42a6b6174a59a506f59d25225bb4bfc56cd0dafbeab66f2617bad3fa89c363e692db08ccd62d05b56ef30b494ab722ac97eaf4bb331d3f32d3be381da975c96ed60ce9665e6b4dcec52e565ab68c32928b619c4b819ce24b8490e140319f5934697d308f6145180938028e0242e98cf8ebc5279e020d7069aa22133de9a70926097a2415552a93f7732eee7d1ceb8626ca3f5a76dd960d118eb201e0b99d00a071dd70021c36989b29c27602cbec2f87b8d31409a1ab4a8411c090ee2bdfe1971a2483537482e9f9bca68f21aca49110d827cc4ed3bc9086350545052c175d33a48a580e436ac2a7c090f740c048addfab87edf9e8272a6126871acfd495430a941a9afcd28a1422748a968017fb6ade19503cba3039c95fd223fdf9b52832651fdf61f2b90f230f294db959d73bea8ebf6f74e6c369e5306a1f27e9b6c213c0a56b2680ee4258377803493a78f67916a6920fc69525fc84b517ccf0a21a0d198001cd535c863f323c0681835057c5a553462dac3acf504ec9b5f181a5c1bc04714ca71872a6d1866ea5ad9958092ac485b96ddde471e4d905a223a05fc75628da2354b4f3915f2c70e3e8dcd70add5ab98a7adacd778ea627de4b68b3fbda5adcc4da5747b6f3cac098f94c1a2013dd8bc83949b4cce8bf42b4042a2ef266c0b0c6ffb0d6224ad6faf867fddc9db7bf27d1b62f05cc6a0282d6bdb0039ccf19311c1bd83b6ac762a43dcaa0cfa16f74da2157e5f1ca93430a25fbe41d87d710797c0402b87ca75115b5b204b9a05496c2f930c38ba58a2bb10986966441c4c197c497a3b272f864c616ca1c29e403a7cbd95b6b7bd7244ae9c50c1660d183562259aea285d6fd4c95221e9d3b100dceddf46e9412933dd43aadd898b2e0f1b41e74bd7e971102c8e3022eb7097039851b12bbaf2d2f219abde85931c117be8c27933ab683020bc13d14b9686719545b408576617644fb7877727f3a101be25edcdbcbadd4ae8a22223d3ee5e5e81753c44ae0fea1d7032fea79046d167d94d6cc9443e92baf9311703792358094d7d66a3463edf7090783f20550c6c6abc2f1e7b8d7206376b1bd89499656b230809fb5f6d25282dff82fafd71556578d196fea3cb6a14b87f850039031eb57ade6b244c496a24b77f1f6496a918f9cb15698a4d6d7c7b79a2bf0a6008b27f86d27a95afe74fb7b497ad85908c9c85f6d41d49fd030c4b86093dc18eea70839da2eb401e10e6c5907bf99556b956c5bbf3dc7b609663e30531e0bd04813dd9b6c8bd954833a7ae2879ef16c793e85c850d01b2fdfa03a9cd1931e8de9ab5a70cac1bada2f4ef37e9ceb4b721a0157b2e63ec0659103d0a5ff129c66dcdbe4e6af0253968b8f544683e2ecf26115d912c06971be7858f044a6bd2db02dd91c5321b2b779636527358af4ace094ca02cd6d5854eaf93570edea47d681c34e2b9be67196f5f694ed70a63781f0e477ab0e18428508c083992f9765e6f15260ef4405a8ed3b9c77c87719afad7868290024cb6f9d509bf19cb3c95bd078f3c99db876c58992508e0d9e887a4fe49456cbe8a517c9c99acb33ebb9040d0befe85f47eadbf0fc04b70021e7ffa8c3756a48e0c59d743a6f8b087e4e70acc89012e846e1de1f0f2b4550615cb31c7b2d522db4df5fc6b9ff4b28cd8c90a371e4887b79ca77d367e1a4fd2f48fde9853c12cc0fc3ef90c15a9463eacbe9cfcff2758b836e1905d415e8f7b52d14ead87c2434fd01ab39f8ec5ad9c899d276021d3d7b0068bd5647eb51c2ca0500851d610ab37141d93d010d1d02508c55ee004b9eb3b86862149870326980d49ac44f52d3c86bb5c930f9e2ee6eacd334d61a8dfd2bacbc0091805cc66e8750463f18c25b31b36404b6e356efce2bc337ab262e83b2d71f3458dd6426567527750af452b9b385fd612f0984a14de6ddfb2ba698c42ae69b7212145a2902aae4df529b541dd446a9d1ea1c41b7512e85f90f48af774e974f7f4c97466a4c99b7b31302f6d9abaaa37eb3797dbc8437e1134438003f9b9d8f65ba807a313e5cc4a872647aedd3e0bd7c65127751d75b75ca28fc28644552ca2f121f0a5603947ea59208ebf5e999b4a83467bc6120c087756bb730cc550d044f04a5f024ff6d871f8ef5e870c123fdc5b9b9c949bab98d1ca1bd38d5ba0d267a6cdf13859f855d6575d77befcd6e068f3b1cff42a68415f0910cbc87417cb125f9b2f28c9697f09c03fad957bf848fcbe000c2ccb85434b1cff33f353c7b6ce23eb333557c9f3a6df569ed32b19d3d236c93a8ba5b06cad18fac183834be6c2e0cd4b32bed03bb664b07ace27181d004099981fa01683cc1f433de0d3408ece97437f65a836c29254a60c1b129e0af3631929e5dadc9c6a8dd64bad9fd97829d7a0902b092b64ac236dc017974951233ca7a0395f9ccf1634fd392c0c58b7253cd1486d0c4698f0db4b5566c2840a89627c7da8dbeae3c82f2c378768303b6e01d618a132eea0554b25c4f3ef61019c55c8abf2dfa8ad9132149914f24d569e57e44d09b177912b0cc8ec571ce214bb3a3bbe18e27852b8be4f6a36f15d5a9f8143e295d77c92c11cb5aaf1b2dd369c148e82bfaeebe795f5736f9a766a52dd18e595a778d1d62ecffa57bfb4dcd19717b8edf7d69c954ab6ee2c322ecb5f3d4ca9a14e881098d980f3887e46d9cd8d42fc40bd3da3471b1c2b767c8179ce16470a21ad03509e0c03cb4c403a19b3a61124676edec520159badaacf99906e5ac9df1f08d11e2e3a1a987a3c211715c296dc068c3a34b78118dd68d1f5dc0947e4468da59a65b9fa6a6fd02d611e30cc88e8c764d6dc414997eb40378cb9f3f9f10fd6e0463a3b476ec9991597267687ebbfc4230de64f1da5a23fd5d355aeb758d68f3a758dfddb46d8e38166c0749dbf134f7c972e33032a7e7899bec6d2cf3ff03b9f03b79dedad981929f321189af65f13259e5c231fdfc1951a300328f74c66f4ae3d0f10b6e8f1c58eb4b18ce09f841dd66b44e067a7cf089e7e2d2c170f7e180d72780795cf7d565329e8e9754e707670df2d2cc6efbb14382db9375d192a66fca4a77029454016a1c58f919934b151083c4c1d5cc24819a5d887d2c6786a285a53f5ad0509b262ebbf692a6404475919548338bd7141e7080758d3eca05db86725375a47e000ec6dd4b0555718ec5bbd2b4d0fee2fafe31c1a91eb04163f9b4fb9622dad3b54e5cae904f89e5938573d52978ecd1169924cf4e336d018284d9c3a9ab8821f724114d14427cf8e1eb61c2f4acfdc0da9d229dd1f3c0d40716419e892e90558067fd94d06d0decefb10d4ab426821d271bb3adf9377e57cef20ec14f689c929970025e0ca2b332fe47f5113979f41c581447b47e662313f5d751841d166083fc3614f70ba96924549cb262aeac07b9c4e9d3af3e822628bfc78d01708cf44d2bc2c891eeafd6cafcf0e4617b1cbf12c99d6af3189f91749e9c70b1e1c96178ba46eb69ae088227fa4c40fe15724a155cf4ab219b6f2e5f952eb529d45d955212062f6d7b9778d9752cd89e0788a5d852088d45f9c1d743563e70f549aba32ad5287ada93b8de6841141da90c0500378198759f646c1b035d246a3d72b3e472c90c496140ba27e28730a3927b4cc3b8c586733f2dd8b1faea59c5e1d008ba2127539f4d28fcd5bf59661b7f0b262752174d9e35824d90f49dc9684936059c94e526f622d33c20e94d214ab95dcf48739a4c315f525fd695e6f358295cf68de6a30b5c59943f54cb33b7a0d35cc9e83701a380ebbd92337db60f3f9ddef468bec3577a83c820778562a81cdf924a58999a8cf1dec4767c2bc10a0d52944634b205f8dc9ea9fbac32298360a13b05180785e96b837ccbcd13b33f31a6b00d16deb36b1c24a87dc41e931d40363038a51a47b3a2aa5132435831c6c105c9c354f47bd344a2852448e675125380b778a6072f5a86c8fce314734210f8f1f736d00d376052798c47cc7f308b7fbe01c11ae5dcf2c38007e6fee31e336ac9eb0a9c2460bdb1a90cf511b457d88dacbdbc29c2f7c301023de9f1a80e44f1121b086b59385e024be7aefd25edd95a9d7a21e9225efacd9e01dfb3423cf643aa9489102602ffeeb6069979fa97026a2eecfbbb00867421d11ca29bed7d5cbe6546e4b09c8cb11dc14af274b3c8e85a64968f4f6416aa691a37a630e97199e91009e687a751a8219afcc1950c91ff85bae16337ac98a5671523dd046a6f918ecafb1a7a242b08f43b3577707441ad22829779899f4618283aedb5a4538b642685db7d45acf339ab888e516aa2fe4b53a39ed83d0778be62f5f5a31f616d507d1b7b5c17e0397dfdd666205398fc92e6fd95c71e35de9cb424c28e4521c51611a7635ae76e3591dc487d0168f5745892c6687a06b556bbd4da68cdcde5889785373ce7a536eca67bf47a79c4c492a4843266f4a5708a08d168ffcb5b3f3a086521fe43dd3950d9699e0953e13e881748f2f4406d3c6af1188f199752ec7dc4d39d3191caa208780a62b8fc0237001366867265f451a14d4102ad7088e9a426d61b6a7db2754de9ec0ceab67efd5d23a49b35fa7446871ca5d674dfa7d4f565042f2ebe8c4899390ad3a032411b6ffe8b16128f206cb2a461aa67ac6a034a9f5b241c2e86b71d9fb2d99797b6640c32f82c3a868026fd1e43de50b99807274956641c3853235bbd594d6edbe47e34d47119322f826f2085c770efc65c341d015b665b63f9524da06f9da8fb9a642614d9e92b5f3d620be68f883c01b2de1313605d0f490063ed5c1fdc080510f990707c6dfb123589844a59908b4339c223b74e1894bd6637df38964218c0ac542c13d10ddf4d345b6069a4b35d9d0d660ea66ab3d5dcf855ddbe20a01d95fafecce480ca2ed787c2e26c3c261eb82bd4d0c330da8556a6ce9b12690c63887399dbb9cde4f9fcf099eef80c3514952d560f684f4bb692a7edb2ecc979315744917080e07a59a50edba9e874805811a8118543d26febd501f2be467b7c552a8228526919958fa6a166e949e68b5579d1cf09a103d52c134895c014c7e38f63d8066b77dc848a752e6e6977ed021d5fe8a8af570d49f45837e8c8c54a9203bb8bcae72fed95b93ec035eeace874ed595bd0e98fc9b261b7a6e013cac8cde4779e032cb484e20523e010169d67c90d63d93cadc6b8982494751d8f78cab7ef47cc1fb502cea1188561182656cb39268049e01b9b3bfda0fa936b0ea5716df1dd84129ab823df4af2642a257e41d267d2fa25238ef1b4616cc9e6813d9ff66c15fdf244e6048e5e6b4fe77b66caca6fc1da01581820200c9ca49e5874948bb4b687d37819f7f4818773ee07c010538d26815dda1fd01ec65cf518496d08504246d8a3303d959cb897d19551bc8826e0faa089c0c1fe64f3fe0f9183a3afe77e37f14cd64de7177debae98c08dc2a2405f2e4c886adf3f24f7d25b6611c65a90a44400f666f0d04db351b1ae5f63709b4ca464131bec30c7b2ad31dcda56647d639632baea720956defe76199a7bfd787c72765915c73ab9454f5163feb7d8b4a9061c0e0e8766732484c257c18d1af9cfbd6e94ba52da4e5331602d68e4294082429e61ebdacf624182898970192f09750629bd0b9a32729103d9c60342862f0ed42bd0ddbce7552fb3c702f7a8dc938bbbb2634e2ced5b996f4d33258df7a0564a26690093e7bdb5285aa1905d671de1bd8c067cd39fecf9e75b49d8070072add9ab85eff42cdbe49638860538bac6678b1fd8f2216294618a56e11c0d2ab8e881a7cc83df5d8ed361c52ebb9956164e033c05b16231e5cde11ca0b87b03ae6714336ad9879bb5c82af8812bcc816dfd228b10a8c9cd2af9b1b3b64f88ca5cb8125fbdd901af90989e5bea7a7882359dc0b6695aaae4ba6d1fb7ae25b4e4b21f6697eed656815b2676917cb51f652738a3d1303b1a130a9619c805a3fec3f3708e055b9a0c29a29e9790c2381fc98ee1e20aa8cf2b4e9023b959dbc66fe26b755d797f1a7174e129713e86a6bd7cff333ac33b592995bd154726663d0b7668538d6716170120104c8967f8f1a37e4867d42904db26507562f2b27c8087ac2bb61027b70b921c365ed075fb9bdeec4f5faf64b15de6a948494a1bc8f52210214cff45f92e8d7591a8a8577ab99491e834a6f0f1544816a66fa452b4c33368ad755e6a7f6bcbc9a424b65339109fcb823199a9c050dd47a8abf5b6d8909ddb4447924b4695f185366c8f5c4894c7809bca0d600a61299de31508c3a0f0748f3e74c814fb04d2920f2c5773591f3f9c08314b39a034a469f56c7b7ca1e7c11bb3460e432a44d96cc6ad4466e7646bb1321b0a588370498322c4e70c54a499ffd84550c792f2409e4b1951963ecd538f2b0b81faf0c2cbb22246d41edaa06014de75b7e0cb1a913b7c96dad4480bd1bdfc32dc42f4f47d3cf3f21ef237e64b6e0bf0b2e618a978ee982110ea86dbf8b34056e6de09bb527f8b6e1dcef964d6809c7c21a8bc9f8690511ba64c178274f34efd4f0ef48c3acc923953f9f2a80203735af671b5b56d00824e33cc4f43e3fcffeb442248c1d90b6a06c423388dba3482ff6beb5a428124acc68014e8a12367f6bce7d97515d54809aaea45037df3cbbe7f4241613bbe79abf80e4bda9b6e641f5d472f2bb480f321d76aa1018cdd53891502d36e2c7a301dd87d4b9fb260bb7d2a505c0da0bdcf9fcbbf1e1cde50eab56c5d81af9aff5e7ab974ffe7524f0d01b93139e4aa2f52a43992488fae730735aa5220c4fd3b37d023dffbd9b2115798c370cbc1f536973692ef6a43bea2e9105ffdba4f7067151de8c54657bf9c7e3d93d03afad98683f9012ff21f14714bb3dc55f2ce5cf1b5b7703d7e4e149eb0de7ec016e5e55dfeaf25ffe4d9a68161f68d2dc1998c769569763669bba074c06c22e5a7f11783fd0bf62eaa3e870816fb06f6113b64ef913f35c73ecd81583cb6b43bc5dbd0a292e0fe6845c1b1363286ae202fa62725d559b422cca2577b53baebf34d82b66c776a75bcfe3d599a952d4e8229f72e11283b8b8eb30da67e6038f5937a3caba52c3605fdeb70979546272568aa9af5d59c3e0c92c8b0c038d5a385c811bda4e8fc7519c9d4060466d748f253baf41ebe10ae5fa54e992063c093df3d1683362f88e1f4d76fcb6d09359d3e593a46c40fc8bf84cfc825f6288466ce6d06a8e4ffd0aa9ac032b2737722a14058c3f002f26edc182dd40f7cf985379dffabfab9213d3cf09ee8c0fc143fa3cf8802b6039a4513b271692dc4823f47b63ea1aba9ec32eea9f22693e86569b89ab1e49b030dc28fd1ca67ee6e98ab271b56989a90dc9d31e9eab37cbe66b23bcb52706f910a839ba84e95182c71ac1cf4737ca04499af230addb3f42698556aca7532206568e3b2d0fb6f7154a218f97bd6fd685ab5b9e6b5d7e0adb07c7b20d4008e9e2ac0456bf855624b9cf9b6c9212b85a2cb5d102ba3577ca089473c29203152313e0deaff094cbcc7e68129748f855964b211cd9911b6d97ca30cad9d226686d2d855f84070bc232b6da4cb81cb66a8c6499971dc6d74c01926be6dcc4043dd991db69d5d1863038df03c33358bbc17b58340c6660d9f94df4f530cffa21cd29f98bc198c30317c29664cc8f1668fd34c067b4268ce76bc5ae00e62f18bdd97d4f36e8092698153cc0ff9843a7a5a4059bd0b8f8047d589fffa94fc0b5fde7252dc116351e5bdf8d11cbedfdba9b0f720ea01fc545e14d72c5ce1ab2ade60b98a6a97e6038a6dbe33ed7daa27c5e816c04722dde9a14852612fa3ec49fbe1c1bcd1ade1cb05f461686a837d106e64db470dfdbf579ffe3f856850d98b5139feb342d6383fb35d98e1d0cebc77d01599277926249790abb035aa1250cb9ff598e06e4973bd28ec040aa3bd54873f788834c635a8e6f9ac25374742bf309300d723b8c4bf1f502b72fc75adae230bc2e429fd5b2181d1372204e3c8c3c5025ba34a35bc0dd35104353138fca2ac460696026264c72a4b5691b3c5b1cad16636095cd4d6c8b0d406c1755e80ccb1442a4e307677dba7286927d750ec281410443b60abd2c59e1df13c4ca924f3278c66326a09295c612401fe29a0f74298dd201f33eeed68b690504d3e7b10e1e8c3e771d5fc09f728be8214d5706518c524f453963b6cfada738078adad7af55dd60d873f59b5cfb41f2bf54da00620b7f1e5fe77301c3d8643f5d76bb0af62ceb5390b71923042acae8ccf9bc97a0bd06e37b66bea34eebfd12dd46a3c64b84157c2020961c3d89008256f5ee03a6e91c9fc53ac2900e0de0715693b40a17536c688cb2cdbc8075d3ed15b1825d4e21a5a7e6fbed38129f0ee3b1bfaf019e66ed675f4d8bb9242ab0d72908470f7ba1e9ee6aa71c4a2ae38f35961ffac1f724412fc9b1a5f48b90e252a43ecf61c7c839b244d1290946009d5bb407494bb127fb91ccffbc5343f158de1046e5fe8c328d4a058529049b2f18bf3e8806686dced40bd258b8851b5c35dcec63f7ea9a4033fb7a400800b7f4f022758c30869c18451fc03ea091ddc110e7d21e73d34892ec39bd30eb49dc4eb10da000b9ed50f1a7f846585bad7ae32a463a970da167bb0b544165de21f55f562ffb4295f86a151c074bf5568604e9172baf474b332093df814421d6a056e3dfbddf1f2d9b18cc2166d3f0c115899cc5d9a6bfa7ed9e28f2623f0cecc738e1838ec27531b7e6415764dcb0532506135d18c0a6e108559e9774834f22778199a9c9d7744d41f6c8a93252aab8575fb693e3b2ca8a2f53eed054007eb97875da15170d574830b6d9c618d04beca2fbead1c49bd78b26106a2c9250c431527c1ac9d4f1e2cfa4df80f6c2211917ce37cdc56c404d881774bca04b20eff2169f8a2b9b28bfe899f4ce52a96945fe95c865cac580f4422c68135e4e86b8a9bea068fb87cc23094ed04e10b58bff04a94bb6887d39ae272b69523a941488418ea5b71d6c69ad07ae55627c7f7efde6d589f711cfca4010e4ee49bd4ac2f20158ab73a0f352a843e4716ffb3f52fe92561d0ab1fbe006915ab8ae2b1e09b5c0e5222abaea86d4a38357b43f1490af4e4b79ab994e07e72c2510e92cf8e1944df2f41b61cc4475e3a41d4f3741066b13ff9a23c037f51b45875316b31a365b1111ff65a0adb7604b0f30a5447b41fbe4b91cbacd5f74e9919932d38fdb104a6a001decc06c9e44fdf0496de4fe67e71f62554191f7fa23f6d46d5162d51f6eb3f403226e8112361af7b8642484ced99e3bdb1c2375dbd8a9f908a26dea1832985567fb09a7bf7684d2055fedc197c3e14afcae1a6d8b8cd083068e9397e891fadcc86987b371f9a6d98aa2e9bccb35a21fe9faa2737926e8702214c818129e2e774e70ddbb8deeec763222e8967e9a645e9797ef942ec8edcce6a8ff4c85fad440f1c9a3729a0c54915551efb3af06d672c69dc38e259b7614ad2ee63e7c14645d81eedd092dc9731caa72d956374194acffa6d799c5e052202cac84ae0d381c7aa3616716d657fc3377660b373f49d30347133357c3a8d287aaefb0f4032f60099bfe92280652d321d05ba4e3c6a9959ca9f45a99eb4041773291a0ba5d8754c9b4a8567f42f70ca4746720978ee81c6bd425c8628cde1d551f86edda504ada037119fa6de5e45ee06dfa2a8e15cf1f3c4b5595ce22d64b15aa63f976254db303c6f24efc82d9ffe3032efc02b66c9754e081e51010219fe1b58c9a476a6d5a9d043745ad84e189b6532874ea5d5111e1be5d5237228c9d1e6ae0bb7f99b96b4c3462dcf36dcf5e6a3f214f38fe5768083a62daf28e052a2ff2f24fb537faaa9903edd97750da7945f9b5c35b85fcbab6dcb8bfa81d29a1401b99d17a0518ecf77bd58e34f505446fa4a893ee9b9922a78f2797065d77af4724e96cb3bb597c951cd197784d6fcd61f6079261dfca29ee59b99624b4853a73677f2038602df6f21731f6fcfce3b6b79d017e3b10a3a97b803c426abdaef4bed52f9db9e4c28252bc5eed03f47274eb76caf5753492eab93e854af45032c2f122910554496bcd3b0464ff5026d4bd941b6e32c5494c25f99b587913905b28ee46e882f1c0562e746784f397adec77093d1e8326206204a3bd8cc8d0a9f6d6d5c49b830c3f1d91510804d5f8be60c1281146117bd944daf3294b9a0cfd4866379f6abd5de78b999443b6549589dae23ed71596684e08bc83121d8a12ea401e15d7736f0e8ede6b5957eb195106aa438d4caeb14aa95eae36b0258ead5252096ef3260ddeec422c9711b39f91e611c29a9032500b2f531c22f9600bfa72ab7341798b159d0af0bbfe1014f7e0c2e0f4e4b53339a4e14c7d4906ba24141cc95a7b09afdb927b211b021d05b8c8c9530abd56471989ea450c4b1655bd189ff14370a591ea6e5321cbf5e8a2c495a78fa4d29f191719285a3e50c9fa75851937835aa8333bca4eec46b85b39331a61c7435402234dbc3adc327b4261725cb19a2f59ae6021b1ac259794a30002cfbe4d47c60f5923d7d07dd1cb3bdac0ab0a58fedd1f5ec447306947ac3e21b77d2e20375ec06a209f2e80a2b74f9ef635978c1eceb0a254c3e9aa862e0cb1d9d6b071bc62503e96402f210df0bf058bd4ebbc3640b5c9a3126973c83099693910a40915e7d955d3fa42726eea9de9224d21215e407e4c56e1433688e84754efae9ba3c7ece280ee0a8f907c22bb9cfa2365a86f8d0c1f4e441a3b87130fa6d411cf416f686c362cb55a31340c21a0fd925794dc30e87f562e7a343e8d54a48aa82d1c82d6f4fdafb33813319115ec4aeff83d0971767c7a6ab90b0728d302a92ff0ef52ebabb62f682529ed908654f23356a408b26f054410641386b12422e7b226143f5307afead0ac31c055ddd855c4082a4d4b4080ad84dfe9d0a1395a4b43520ccc34043ca0ef1e8927b069fde1744f46d783d6170f6fe78991d39d397d905eb83a60b2b3f49a9afb1a527afab4ab9a38b0dec60a0236851db9fb6eebe676c3add116d0b07c48378f93773634ad59605e7983063890e2f6ec6ce7f1acdd0beae0c84e8cebf1c17f7c7bca0e9faeb05893d32878e7d477e8aaa485f99c1b8dbad69df6b468299c47f7adddf9a5220e50f77fe484d233a9856ab0db3edc8ac8b4cb7b5ac6846d520719e7b82cf41669359c65d674d770854bfdaa588e089cb1c24f3089ad01a12bfad4edd920475b3636a1ea6b17d97e98b0a367e94df168d775cf558bb0dd5221ad3f9817a4a330b036f4b56690c93dcc773341ef3ffcf202df48c76c99e635aebd7684f9af9ea90cd6cc9c842e51d4073fb137388cb9849df96038cc02e9755c84b5adc4730cfc6119d280091d469e05fc24f591e82b2327dd400d91803850606ce72eab7c24efa7c14a7b6251d3e442618ace3d5af56956cc0f00f963d30c8bd8486e322c2cfe1610aa82fdb4202eb3f0da4b5ac066e7526d52418dc4e640caf46520ad37aebc17dac1479ded7412772a2faa015ba8a35ba334657a4cd7f2197bbdb80ee5c7e3d33f552db4a6c29c7426e574646b11c55207a2262f15461c52e73d5ce922463a817cf627125083100a60a1fe3c79afee933abb52acf3e92bcaffcdc5499c60038f14c9c613f9490428f26f8edddfbd2da4c8870b4f3e46d78ddda0d396418f3675573be336cbce9bbbd6f9d28e72e8931e1ead4b9a5f64a9e5c3441bb011ecb07383f409021c5f43baaa7400e1e8bf29dba51ebd5ed67df1ba2a7207963b49752e6a8a8ceb54f729ed0d7e04de09a715487269d8d8e77557c02774b705214561192b92637162b362b03b963166d30394e13c9c63a1dbd8de6a9dda88187d9dba6dacca2aeb9f69439c2de57daef0fa32545d9482abdfcd8c17e1a809936a505d6a8b4e49749884ddc023eb8b71d615d6a2054d84359b631c47b8334185c1f718f2d9ac4fd36e9fb268411a6ee8eec77db291c63dade672b37c0de26d479fedc65ae5ae19593ade30433b8938cd5be46026c5172975db1404675223e114a5842682df99315f5df3044049352ffd99a2628fd57698126187fc4b8f8f2dc84778c89091eb797ce3b2a92b2ff428b26211f7f2dff0376517bd92f45d7c3d7e6ed48fde132629dc8a72b6873aa265d433fa03d95aae8f06560fab9f8ad97506faa3dcd7aa021ea8fa45c6c9d90e138384079b18e0f54876e8929e30ceda94c7987083ada3bb4db0139d524c1af40252408d7255d04876f081cdfe288114173ae03b4ec1d59dcb3ce032052da3b20ea8a5eb796d0df5b27c4ab792f6b57ad087f08140a2172370209f2829ff85acef3b8af35d3c504bd664994768dc9f464f9a084c27dca247809ccfc44ea162efa7f909428d38ddf66518d404763573d3d391fcc2cb4b242dbebb4526b16fb5641bc5de9f2ce47e94cee59307893ff40e6692f37204bfd562d0c1d8e16235b8ce777542879d1bcb0b7fdf5ab4f43c4b7194374714f422fb18d40287a101ad24ba3b97bf0b01b2f475addaab009c323975e869cf50c7f8a210dd0209728c13039a1028772291f99d5307e7972e13ce82aa5e3cd23bb1bfddcf6635db9ff32c3800c07137b0f210530a733dfc5a8b5811e7dad0312066836672d346a8000db04684b610465cdcdcab5197d5cbbfa5eaaba5e9c4c6aa0d10624efa3c10fce8d30d819320414ea787c91074d63d8766745ee63699e2096a0589426f820c3542c6f72cbebf5a9a6422387a05a47f0d906438be7c64b545c3f78d8ad4011c2071fda5f34446cc4345e795ecbcbe3723f7bf1046dcc303a4a07840d3fcc9dcae1f081675edaa8c9300f5cb549712cd7c2b22bbf786e15785529022915e7a1d43181240ccb493427194252d493dc05f4b1de87084455e3b88be792bf50721436ac090d4f95f1792fd28da7f0f0250de452c0fbccf9927a73f85c8fd7f05fe05c11e3fbef308653ca869bea343d3bbd9877c3b8304696201002279cc9399ae87bdea128c0606464b273ac407e2bc37f6a8af27467e979bbf88af67a255b6e6ad3b67b515c5f9dcf44a1e465ac85c6def703de47e91b0c53f67645413b4e5838bc947314e0e4e78aa7abc9ebbdd0ec9a4d028d3263582373ccbf71193e1c32cae0690325f8b64921aea39b6bea76e04de9526b1c2b5cf3b8bb5ec7dfa820a24541f6e32dfaf244a831fdc175ada26fb8115a4dcd142fc80c54a1e654db172f92966b81de5601c682cdf51c481058f3b15e17ad23903b61b6527489145fdd44b6c89d220a355dc110c076750d8531dd3f5850436d81eac27482f04c73628b2715c9d2d517d4202c4c10b682c282fea7644b59b0709742888484053647c2d8d1c9b720f2ed972eb8649eaa4bf64942834e14361b672e6356c40cbec14ee2d184bf015577306b3c37e25ce0f1e8c25c1911e031f7790ff5fe37875367a0cbef6596695a4caa0dcfd026939288f7d756ba11d132d6e27797f477c7cf6e7a21013c41b32f613b77220650d674ad989f13f4c235166867bb79ab4c295bbde1c8b89b7b94cc06dc3cb6a6f15bf1f37cd7bf834f7798494ff31df565889509290b3665d641ff655f6bc29ca7366f083a90f21453a3435704e92842b9ac068130331343e9b6fe26fb0f61f747829f2771f7479f34f32321e82c11ed55060f8067e9cd3260277b4cf18b2586acb18f71e8d9b92c1fe54eee1510c5ecc16ce5595cbb0551f5b994eb71919d52669b50dc6fad02ffd449927b3e7506e847f817007136d37b75c6254374036ed7a0f866d9984d02650a85fb485eb7eb1f9bbef738dbe45dcdbd2daaaa12abf292c5d945d0952c2e04024f2ca79a818e7d9bf703931415fdaa8bf5210b955470bae858c1d4e9d2bec3627f384b4fb56749e39f884012a122fb27b0f209e340beabf5660f8339d4e515493315bffae4bfaac0c2ae666ff3878b460d9539db98f2a5cb1656b17f83c68f6d160341a07b06a1174c5bc2ccc5ca25d21d174cff5c1510627bd66aa13a86cd359d2c734fa97328db0a7ac6df7021db9a29a9c86538667eab85d838d7ee9626c2ec9c43a84e2931f9c2f25f7f633ba6503baae0cf3243dcd34c6340d2f31888c67b7c962f2fe782f2b7ab3c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
