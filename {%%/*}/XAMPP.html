<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"78db094044bfb4d129c78e1476a5a7d9ae225183e9829e2eeadc62e364f895ac4e1799eaf69217895f9867500e7d4ceeb77f4df649f8d5838950fb79f52e4fb704df2d1a64ab1a644a32902c2049291d1dd35f642adce6691024bfff3db55880b2dfc44fcae4772455704e2547ac00f710b5e57e71eeb455fc75ad44776cb82f8a641418562ba8d46f2d81b453f1e8fa37aecb894ac494f005c31898584dbe9d95e20a01ff481c33caa4a32fcbae9d66d95c09cc228231354f00445b9c51c2e2f892e1e1efa53f02d0f2200e67d490ddd0efd9a537795913be825fd80071d5bfc07fba4c1001ba1a9cd484d6d70866f3fef6a166b44b531723184f6760df1dd6b27e6b358ded55f0dde2acd3af64dea4dac625b4cbc9a369d5e1b7ec21e38b4dd2cd103d7685f60426e01f5b4a6413c63adb9f47b6a995f15f22332ff5c76e46aafb0cc1e0d5ed82d919a2ea1c4e530e87fdd1fa45d285a66d90ce55d767d87967e18aed7c9f1e844849c5315c42199f294f05d22b6141f73efd671703bca8dbb448e468355caf44a96db70cd79810236cb873826b7480b8226908329938f44ba6b5bb2e1037f14274f6c0ed4edaa76a60ea35675c4d38bb1e1b9970147499e473d7af5f3be0ee763a1896abdde93eed325b0b79bda52af1bb937ce961f22db9290c2d22dfeed08b2fafcfec353b18946b1965e8a57a9ec43f6f23d76b290f527322087dfba9ba56c7dc22cdd51ca58c4e7ea6115807130e83d394ce6450f012b90700b44dce36dd97ee772e0b70a4436fb71d9bd242607f30a454205674203ca9a5121c3a33c0a0a51663e847cc1791ef16978c2c51dcc2d47f2180576bf0447a2fd43442244240365915fe4cca737c91dded951580717b19d0ae070448e5fed159ddd036199369dce5ef2d52775333f23aec99f8af8fdf738e2503ff156ad34d68f3faaeb15471cdfff67bfde21695aaec71b97842d14708529e7e7b2b5d4cd62cd320903fdf3af7af0305c4768741169fb0777c0f960e0f7eb3f21615c3b523a3dc92be3b50efbf85201bed225a020d8f0689aeda4dffd27c84366656c2dcf65020b16eeb57b3cdaf7ba43da94de66de933ed168d0909f210566bf3ae4b4e7f12c0dfe06143b5c0413582771a6dfa6f6ec40dfb7f7c40994e9c8d079231389e88b90ea4f38ca9b2bf508f453c31e16bc007f026f8820030976507a38b071ca7e85e8085e4d80e75a9bde1c4dd9713b50e3669086c75a863f861754cd6f012eb102f64dda86aff2fabad17801179fb15df9fb8efd9deb741493fc41a7660729bec2e7b04646ee7d886f5cc5a24cf674c485f57fc7dd00ff1ead7d9ee5af3c95126ef483fcf4e3ac32d628e6c6b98b04e6319f7c7e29f5214a2520349b393b18c3bc4c74839246d23b93b50fd9269c1aa95ae88da1f6d0fb4ca006a18e170d1b9599611bba935b798d0a3bdf3ca3be477653ddc75839d0f6afcc1fde07041291d1e39e9443f77a526e6b6294b449ec28761b6d8a879271065c7c0365c0e33c5f9982377a797ad6d2b788e81ce70c6e82098a6dae17ef64d30b7c8cc14a61baf4876adf3af77a6a39643557d313f5c4dc15cc4fb731c7f78c5994bc1d76a595e34f279b87d14f24d417af7abaac3eb2b59a58af605022dfe389ab04401924d88e528cd34ec6c247e4c38aa5464438bd6c39c92f8628e09f539643571bf585a8f97bea2e8b0498ad23bd1467de758d0fd155bdab8b4b03cb1ff904ac3b343471ae44c81e455840ef7e3a8c4ae925e4091dfa000fff1e5728f23bab3e5ed8f1c6135a78c6a677de467a7cb6a77906eb01dc18dd9d85cb24f0c0814b48b5a264166e60bb671930bba3e5adcfe31e9d5041dc1b901da03111a958a6a6fc660a03092c57f6e4d78b688bd8814577c5fe83cf0dfc3c3682a38741093539a9968a8984c64e5639eae805502a4a4314de5f4e935eb2e6c8aba7c37eae1d0cbf40d68b93d7b341d0bff69ed35862e68e5923a1912d5349009757d08ad1dedd9d30dfb298615d5f06312e1e9138aa34d792fa5acd97c6c6cc7bcffc1df21d16638fa39b4ba991193095b8417915ecc39705154cffa5cd3b1821d67a03cd4b792dc33aeb3450856360a7d4100bc516716451ffc487b3cc3c2b9d5dd3099d9170f6f153a1a2962c723bcffcab047e1290e690543cc3ff2c877c9b5196ec5cc4cdabb7c3cd15962c4e99c43919a91664d01d776c5337e2dc9b58fa63d54cfbf2c017a595af06a6091731f6c5d6727c9868214e68501b78af525fa446b0353e5fe0a51b1f6601bab9d39d8220d856945d13cbca551a9c92f6cbebaddf2de3c287e58414ede8f54b272f648fac2c664e2ffad7dda67ce8acc40f76938894106c088b7bd9a1018d16473209fc372460ffd7a4ff19d8c7cebd574e23485f5800a795c3012afa47fc767dbe02a3c54acf3fa74554d31492fd219e1e8ca7d88e9a6cb0d74ea1a04f67302f1e1b3dcf4be46a54f3efd93e887c325fd690462dfaf8189a33574955d38fb5704f266e2df6ce3afb500b71b252eb867b9025b27dc794ba08500091e971475a9239ed49314bd766c9a7a4040f1f7ba5647cc85d625f30622cfb6d46e3ad3462043c926e0d63caa0cab6f30c43faf7d857aa9d26d9a8473220d7c17350ad467afe6ccf027d397c3fdd9e31325b18c60b534a01866cb7080c24a31362c09ec687eb164fa4d4816883e2f1b7a11106f72041f402817262997816d156c80d09fad00f34b2c7e40405d582a0ffb7e2b4ede0eed8d9f5194943373c18245271bc3feb8d38e4d81c3c4c212340229f92d05f676d62d90f17ce59b9dad74ccb9b9d71db9d3c711eeec9a2480c738390b72e45911ffbdc397aa32d7f3090810afcaca20def0e89feaee0ff1abd0d1312b2d6f3d632297a640064ff9efe4dc5f906570dc883d95ce2b6b6584213e12e4df8893fc46fab49c9e8d498e116ca4aa8fa6a8906f1daadf6a3162e129d492e913e6e7b1d9749cfa76ab2c8d183b9ec5d379b675f073093279f9dd4d8952850cc52a51404cfb18f94219e4f5d785b0e75e0a9e270fd59c86af08e288827b60e38c41fc91d6acec373c38e95b254472f85ff1d5105e28017253a15e118a150c150981eb050ea2c96cf97c97997bcb95c76ca6a5e67ece6bbcbb12b1f6be59a73aeaa7ad2a8bee0e230aaaf53d6a2120d426f6c85e38fe025c5acdc8b49fdd0463266b482b241bd885119cbe89f4affe51e8753de0dfa19a2a352686350d7e40c8fc68f7571dcecc2fef1b056b9fbc6dcc57aae8a3ac6b84fa01a82591b68d6a955da2a3e556a99f8e953d86d7a09d70889db0835d7bae28035ca3000061ad6031eff85061f609e53efc794bf050d6125706a48b88032969419843d9c816e1c0897530cc8d68b6c72bd4441da9019a0b0d5c0f08e9127453d7aae78768baea1e14367a6a729a85a90ab98a3b0fbd06b978eaa520ed1b3fc576e854b7b3f67d077aafd5e17d5a4e1ee6819a34bda45400a079a4bcdf5972c182e92000f63f95429c7c0a773ba758bfea7b6514160582f8f9538f9a25e48502c2a8c9342b2f78199b281a203bb31d2de9fbfa9a96b25e5c3f153549c3db0e2787a583a8df413c5501019fad0c3e51ad2074378f13599f8b8f9291f2bc056c3cea9ca20b06ba4aab938b2c907e73469b43ee0bc053e11740dbb4ef4fb5587a2d00b1f60269c391ae8f80c6b2d080ae07b444c3fb49b9641e8ca6907616d6422f9385bad6eeda167b14095c230819664dc7536ed753e09568455d0dc0ce0bf8ccb3e2f8cc258f2a3cbb01a8870e7f11c4b2e60dd84f022b4dfc66653109bdc3cf4239db0816cdf9016ed139a6f233c6086bc4cf39691a83a5e13395a6a7b5a826c79b4db6d8726dbbb67886636e2e4b8f8827063dc2327fe892a6adb6a4be7498d5441f3b984b7d2764c74b46c53dd5432e4b66db9327cc134cdf13b4b4fb53e9a131a15a52739f455109d4203c432334ffe6aa8ad53a38e992e7d1300883982ed449ccdbad51929c81e53b68924620774ecd19d7e1804fa8d5bc422610f284bca1ebeaa50520c7097dc032f3c7c171058b790f003b35f87fda84d7b8934e814255d69f56553d3c87329f166fb123d00d7524a755b73a147f984e373007a268999d103fb4f30b302c97363629eff39f02b9b31bf3c8f7664a5191c8fe7270fad0ed65a08b9e4a2c094196d73323864695abc9c4bfb112207ff83932f8e5674ede5400e74403a1cadc1ee28476858d5d331d57e2d09cb06cbe9de2a3affe0afed9ce7d2f0acbdf97cd0ea7d24c4f71f2786faef29ac85979759ec46f0022bdbe851c6d2340a02c1f87bfe619c0492cbe0320752ddc8a570803ab8625650775557758e27c6d3545388470e9bad7588539f8b8d1ae4933e4a37ba43d3d9e7a5babc3ce0256fc647d15ab8dd359dc8963a1ce78b1b628c17c3e0acbb9d8604a68f21dc4a4920f8b9eed68063bf7ee453a7d847b0182b76e6c8ded5d4fcea68b7be036c5e6d5746b5c2850e33087d2bcbd5e8dc164d835bf80e3fa3666ff202c482406a24a926c39665c3a5fd36bed20acab84cdabc8c3f064ba4d5edcadc79d72e6a951e688e49ad9aef92851e6a539654602cd744414d197f9933a8e5a4d477a4b9d46b8d50f449289c36fc8d55543c845014244c38bf69a9c52eb55959db82703242811e34a51d00e869fb424e5690de5ef0e2f1c9153e78c90d509d0d3a2e76922bdabb6e3f9adc05fc55007c9662ac05244c9b3c5889f71fd898dd0ea4fc8f3c6f6dace8a47ac422eabb950c18e505916c36c796b9679932b88d4bfeeb87760f872cbc8040e6a4dceccb630b2731a49c289cd7acb160d1e6c5eaffd5a306094a9364a438c5bf686fed5709235471ebbee19f9557115648a45d35d557af95543bdf1ff26704ef97eca152fc3152f3bb0cc2f4c4cdbabf8d7fcd6f1840ba4adeec0c0ccead08d117e5afa15ae889968670959229c4a363acb9a7e65658a94fb18c7dbd65720194decc62b87e2be3f78130a259819c96100baab18e9a8ad14d4a8360731cae6a6030052089966d877852b44c75ecf23b449f5967e9d935f2dc994f54bf1795f42632ff2aadc68441ca3892f45a64b4f321e3d3fd1897ba7d968f077611126e32917a15d90ca6f3ee07842bb1a26b758d0a0806df7937f57347796003ecf69aed1eb2409e1f3da2e9ccd5b32c75045fe2487998b5dd894ace072c111e9f257086e65c35026eb6318496c2ae62f1bc5923fa76cb5f7e33b414e4d79de4ecb314664822b4e689f040aed8e99169dc1c70f3ab793b368bee2736bea109baa37cf5f2fbede791784ac837f80e468031ae1fef25df0b18beafddb324a9ee3997f649a9db57c7244db897b1fc391d306434035f8609b22e5da5878e1800d912997cbce8dd2d900b317f9341ee80e5eb4ade7c2001c60b0ace20726148eadd2a9c884b068189de945611418e19ecc6f7520d05b761c56cc563701afa1ba2c0895fb71837d8dc9b88d1b995972348280f400b84ab69b82e559322c9c1790a5c35c344e27ec8d6af75e4b0efd60e2c77fae218aa2260f3bd8cd68a20363d87531eb519edaad17f39b80cc34cdd7bc37a248bca49c3e67ae93b9116c2ce10d686e426c7ede23a47bad4c5c57d0b64fdea61a9ce902466c0fb9c75bac9ffbe44699d509e7ad15d13d884f925ce72be703595ae3754a5efb5ea2ab9c60c0991e0ba7bd673148a73052aaccd9a6deb74dc3af13b18c718b74bf9e7528db377c3b521d388476ea3c1e9c7a6dcff8d4a51bbad076d299c576af7380f1c55f2b0244cca865a8e40d2cc187f6805443ed441d7c5a5fea76b6cf52f217e2dca12b05005230304ccc3ade966911252103046bb40431814780895e1ca4cc0742a8610bfaed0cead994903269fa10ad79e5dbe6728f5ee750ebe058eaeaf5487355a25f769c416bd7e49d0afab9b822fdf8941d0bf61ab4dc629f8d823c0d8899a92e13fe5f6bd8da52ecaaecadc761bcd33fb270315c311dcc374c15a590f0ec677a58ebd9224d2fd3bb6db76f68bb136a38551345b30fed4da8b98af6d98f0913ec041c88b7e6fa6a46d62e23cf8647b125021ee68a3df946def890186487576ea45618c6d15697d31b6999b1ae7334f2d4bf3bb89e65b419468abc3603be82b33a0b79e2d75626c0e1110dfb08058c0f1736123cce82c8dc5df792d40b50a73af9e2e0767ba0f1bcd3328a38271a917ee7785b548b03d31f94868fe2e0a03b0d77aa9c701a4c8a8b3da8c0c8c72e01bf7d875deae51f78b6baea4fe1cc565889d3123192865ca2b29e621f46d2511a6e553423d15ac5c197c027476aad45ada032b352b3e5587854b180c68bff4d735fb1c1c1692d51a3add7f05b6d2bc795749754dec2e670793f51c2c4439f2fe877bf3c883f28a12f1a92e0429c6ff714358bbdecc2a2fafe54ee81d06730c4abebf2a11e24e4b5ac2e1a21b50c1e16a529a0d6ecc97a3231a439fbb89f36bec9cf83e4b7266b7812b24d6f508d73aee6ce0a251c668b1647a708f2bf0c3470e41065eb00063b82d43d43678928f1249c665aff3e189c184d5edb6cb63a9980818e77b211c2f8c0f0f65ce276ead42f130c3a92b7a71187401b2ede2ecf2bc9ae29f949a6b1f14aae76a244825d2d723f0a08e75b9b6766ae469433c3ac088385e27311d29973868269e9acbeba79b30462b2a44bfeae61f0beddb5ebad159ee74462e12a131ea50c27c7db0c9723bc5853c3d323b40a5ccf5038d9b8cf2c6c73a83c95238da836ca3d58607d869904e76667897100ba9cf02dbab31565cbb6bf9855ffea9e795103a3db3f7b824a9162a74182b6752cd7cc097b385220a48ef047fdd6c367e2149f3ba8db03c32b3f949aeda582f5a2e1d10b3c53cf84bdcf8e75bfb2de4fed2419dc8f535909029496b0b14f566e8c0759406aa0d5b689602c7e7683058d68e1802f592a6c785d0cf62eda4ad52410cef782ed3d1118def48a412daab7d078ec599952c5dda2b0a826c34908bbb3794207d0df1e8c14323fc032c335a40bfdc01d582b1501f5d5375fda52972b39d6f9009670009aed0c49d9e512a412dd41a98f8cdab9a5cd2f540c193d748d37c26a3453b318ecb69f52127b1429b362c8c027a8622cdf7bcb9e5a8dc88a85eec56e2f54d22607779e5e5508929e92035c0cf31b9f245efbb94aee5a47ee3bd6d3160365852ebc2d8a9ab5e92df8e25701a8e76f9d064a4b9e206649e657744ecfe55ba2dec0a376523fc5ede88f56050676c88ad0eddb37e5bd1a0a49718ed3b45d86f8216b49bc9340de8503d267bf7c7fe9c585a0a1c88aebf067e4422780f5408684c1cc21e4fdad7f4cbc316c22b33aaece5501f080100ba4b33806ee5ae672ca7e110d75b7690f7f63e599a089510ef6faf475a6100ef6ba49636c9ecdf9f2a3223c30c2f2ebbaf2faca300d6bb7a2f8a8b3f824dec64cf7ffd2e4960e424c62740830535df784cbac16a586a3cd54b8efaa578fbf3fdda8ff87c29e1ce088f7f44d4460a8049568264e7d5ea956b7fcc7c846cd655f77fbd7bc868cab72dae28f93d7329677d4f715ccc31d908a69feef456bf6847c2901176d1b2199ad95c512145e471d2b8b0ef2964f19609d9ca58257514e6d30053572ecd5ae3667f3685951b1714904cac372dc681ea852c0895a4efb3bbbcc3ecbb2111499a60521171003432839cfab5b8778c5a5da30b6d6d5f54fa0966ad3e204ca337bb0cfd19632de1f83b3361f7259e2bf60265b4b3ff51c0142abf0a2bc8e2d87daf158e8921705324e49bc5d8ae187c1453b9de14e96ed354a9558a39258ec4c612cb2f00f07bb9237045c24091a9abfd46af57c70be0b031d360d5ae7953d05e80c9cfdbc0a5a9c7c2773cc36ce020223f4a1e674010965571878cce71fd731a87b5c297043a9ad7d808d64cd74b3b89814cec3ec00eb926e08b7fd03139738a2398df4805b98e5ce93be5e0254096a2340c1e10d8607744a8be0879b033e622cedefe005e7ab94278cca194954a7f6d7dc004abf16500121dab2c0ffea43ac28112249846150cc556f3963a359e50e892cf1bb10af9b4344bb3fafec691fbd5dc28ee9970a4b112d081b9ff4a2a81725ebdbd724850cfd67e6b46514cc3892304a38a3af856586b49ef6ce8be21dc7781c6ae22d67fbc00f9b985b9315feaae00b0c081abfe96405e0eee4e65a8dbba453c618f022e6f0b4b6dcd3760a467300fe075f26b29db96c52e8a10dfe344b4ce3c2c742a9adfe97eaeebb3cc595bd74842d5d05316603ba1f7caa442e2d1e3ea1b469dd51e13a84ca8e99774b206d75a2b16d74587e8f33db8d6c566ed78d56221e0b3d6de5139c91f17563cd16484187484299d141fa77af7e8fecf7db4b43e5e9aeda344aaf7bbeb8c896b154691657217eadc17baba4d8029e3aded391a688de7423371e462e85f644f1ccf2187c11c91cf9fb48b872b27b865c4d773c25486244696f06ebc5c900a5e80a74b9aebaed3b13e3b6ca4eb279a92ed784495146f99cbc73377628c64b996524c6eb38b62c643db33c0206f513d1bde2c90c970f173c9ba513dae58760f405a19b0fecf62af06336a22f3a8977cfdd9edc34f18abcb70f5eee4a68877e641f5be311336b9f5aa050ab36f187d4b92ba8d9d1b2f22a14066bd9f419fe4523d472c0c3690852d2d74fbfb8ecb108dc4b880c1e32c568e3cdb39967619a1bad9a6d06c7e8e008b7f282b08bfb983b30e5fe902c552be50b08f0917267a78bb43ddb25bca59b239af9f36281d4cc3817ec5f74d5c092544f6d527be0284cc17aa0d1b20858e8b2c203bf555e8dfc2a9c90398f696d40ee1301c407101ca7bee6c926b3b3a264b1a8ac3f9aa3ee688fe976baa8a0153c48b98bd872ac6bb565f4a95d636548e6fba7ccb900e6403530a3c76f18fbcd55aad7a991f59b64ba4beea848a5998d7391cf1c3d1bfe78b4b33d57dc485f44ac391be852f61deb9e95fb241837f1be97847fcbeb5b301c0e7926a9600e3239bfef7cb9b9c3ab5c7e3e6b97e867716bd5f44b383157cd7587bf751c4706c15304f3370379da215ef31c39f0647ff114f10f7b04df0994172194c1739475c21441ce6027dfbacce647927398d889be697aab9310dde357ae0575c55c0c167b8a607e491dc0816e0cc5b7e6bdea51256b7b278c4ffd8b4b33ea1c32e3a7cfee8644f603fece7c5b3210bf8a8bf872a627392bdcdcbba77173bdb534c3b5522835b82dcaac365c603d348b3ba50a2a766bac6f3ba0f49eebb62bd0519c61177c472da52777e6cd87612bd4164dc694eeab9364dcd1f3e6db3bff243474613e44565b59b30b5dd61c09168c33d7292c22faf5b08295b45e817de1f7bba43764223690fbb92efba36cd08e691ab55aaac4063b7a5accfa4631331d422fcecf20c768f13d9ad480a06cba55d4c0c76e42442028dd0a5ecf84d0730d3a53ce08f345661e5d483033c4e251faea994e01c47edf161d99f97e608c7f17987664c7fac6a9d67312bd98f8c894acfbf8efb6848a59c2f3f4d89c20b1bb1a6473337b3ea3c19c685b33a11ba7f15011c550fdfbd8266e4839c3ca4fdf82a6db87565d4550bc11279985bfd056d05cbd07d3ec1df0a5ed20f32045139e03b90b518289b7ff822387d87d1398c55d04d029e3302ae9c6663660751623035d5ce98653a8f148c25a22f8299a7ff824b7904f24eb51ca2c7871cb2ed855c3e60f550979828ecd38fcc5b7170ad3749c782631942aebbb1f5f5028c5fb8ba6893e1417634c0d84c93386febe44fa9fd2a94c2dc442737f718a1632136e2d2f1d4df61c6b96fe5335158c2dec91e2568b26aafcc7a912a6c9df34e830784fc05af3c67554d71dfebd6efc65118ac7279ccc4b25b3309a2c01e76bac42a9bec485ec8db671fd812d19197096f76b1105029805b01e48dea7e5ddd14d08a0dbed1b343c745c01eb8c4ab77b398f6c79c4fa17c3f6d06a68316967b2143cf4d01a0a4667729f7198a4dfa5979dd0efbdeba73681f0aa0138b4a3e43f0612d481a3ffd4dc536329ceba85d3d491529b21a87dc8fe9bbbfabfb656c93b8a1269820ebf8457cac118e3384c34eec7e4ee5210b6df0bff420938dcdc72c414febba58f9861ebedd389f2c27df56c1b73918380e57876d7a675896665a96713aa505cc08f3c74e3c9cfe38682aea1a1857365cc7e6bdd7f4611c85872bdc23881f31475c83169047c94664c06c587dd7faa22fd7d3c199753a9bb8874f5aaacac9245cc911fe17c342d9ff774a7020b30997d54951dfec1250fbe278fa2e026ccbae8bba9b879174d3718d126cd4430e8f716e5505d90b4150f8d110448ad7d674e3bb1bb81b162fa9ab02fb56a2c8771e5d111a20f970dd02f07274a7583b1802d6c225d6c0e4bd5cb418cec6eb27c5f0ba3c5af96a17b22e636ceba377945814f3368f1dc44aa10d97cff9ca0acd0f91270bdfde4979af137e5d8267db3e02098412c6ed95954d0724932fd96ffcf528f6e4955eeb3903bc24797f2756d587573e7f9cf784c8a33d7eadc0a56748e150e045897527a49e9a075a88715c07b6349d676601db7ed994ae681b066fc3362fc499fa46aa6eabdedbf715143a830ff8b99622d6fc1a3f3266c6ffd92d629cfe19b75cdb49b9739002732904372f3279180d1b709647c8580f4a95359a80e00e9359cb5c2056323271dc893682b01e907ff5391f4935ab136a1bfef98e5d7688fcc4529e1c1ccc669e52c55c76914bd1697466a192b99aef4e0db72a721239ecaa957908242ce5014f4a6c51cd227cc70bdd4c6ca8d4427c3e779d34944724b3f291a48c5b9356b3e5c3842050cbdc92d54a3955abe248792122418cbdd72e3c760d4068cb7eb27c177c823e2aab28ed40c4326291baa10c9e25a52cc8bd5f265b5d9bcb2b921d3d9e64c52b48c55cd052b940dfb24400754101afe634c57dfdd23cd406be66d51e2668408f025b53cd74fa8d966ee098538407484c26cab625f5bbbefa3c279ca8c01caaac7729b85f11a2347c53daa6fccfe9a8ef0be08acc62e2ff4a21c3ac0f695232965601cca6ce13d48431de222239c1eee433e2f2637ed4d60f001d6427ae91f3a9a4724a30f22516594d058e46e4cae71dd56b4ff6e58233219cccd002ce7f86ce5ef95b51ae7dccbac3427c95600f0c7b42fb319a14fa8bef8ae65f9a5b3a35f663aaab0e2f7d611a5cd87ff838a57a06ad556df9b38387f12ad66d0c47a868d31f486db12d0aeb197766571a8fd08dc2055200ef07a7a87f9a2efdb5acfc5d678f01d01a9ea7a90c31a478c975a1c717ad41d28d11cd78a22c44c38fe38ba975d7027ae9a889c3daf8cee4b08a0649bac59a482a409063406d59b222c8b9e66e78ce26da0f642dbd6344db870c3283c1c404b331207f9bb78718145aa82e95e4af61556e8dd6ad457605d556218221563bda0bca9bba562e997dfef0081934eceb9a9e3c31bc90e1fd3199dcd7fa6ab565a9f5a1c16f5b78ea76097e630b1a2d393443089108e948559e1203f20682e6d0b11b40c315232fe9c9d5191e07b9c89d9bbe077eab131b8e1f0634b691b5a4ee31e681a60550645b8042e1da1e18465a28731b7eda1402159c17c6e3d960b6ecfa6631d90fce4f04cf928bb76ea0ddf68826980c539edbe72a020985e67bfd31a75c62654bb16313b6891a23f9cf7a4fe8e603d8d6d3c38363a4b03f67663dcfd098a05a9b979e8aac11d63b63760bb1674cb2df2b7d2e2808f06ccf6c683adf5f122e092144491b72b12e121d639e51f4ec86bfafec53c34662b720880c8b5432e87c777f89dd6faddee3a0fa14a70705c61f6ae36d54c3ddf06f9010895ff040af4561d019b72eff9978b576ba24c72e9cd5f7390a4d383a6ade5c223982e4106dae37b92952e9fa61ed30d52adfb0fab3927febf5281a9a3bca5439fb98d5e625df36d36e4363b6c58ae73e1b358634cb382a36524af799515c5148bf62800788ab3de2a311b33e80d6aad803d0985ee78789c03135b9fea633cf284a3316c14d12055c66b2249d32a5e7ea459a5da40bb14a361db202685b31ec1af2e02b3cf139bb885ee31d46ddbae60447c21ed08fc1648fdc6a0a35a755def00bf222ae8749a8c4f2fe34f5a51bb6e6f9b76bd641dedbcdef826f25b94f9c74ac59444a8f0873e30846ac9664825dbc5a571f566acccf8c30394bcc3d79588d1f5d326699f755e2ac4c244409ffd9a90fc59436c9d4470dda5d5d8c1e1dc4e6d58e57210b903b8ce464bb862db1d63850a770566b0c38de16cb0cb813c0ae3c034e6ab7670f9a3c975942a0420d2e2d7c0186bd5357b44c8f5b34a8a7d9d385bc18409721b0fbbee7ceed14107b4140262d90d4159e8b7ec4173f41ff5ea5a63a6dbe78146c2aafcfd0fa75cd63bb8013aab82a5e1e70c06205aa5905198d116563df951f2a4814a094a015fd725b7172c0bd690513e66fc37832db573d9ef4fdb6ea3a3051acec9be8e0705914ff58b62e5d559a8814e51ccc172a42d75cda1823d69ff2a24b6e9263a0c4be37c77ce0b4f0316ee64ffaae03abb4865e0e1e67cec8a0e0826d8eeff7142673875e4651e68c3e4773788c77681215a69fe601ab6d6f22ba0c3d36126876f52fad7a53cc08030631ef5560c2f0757137ec681675f67e0256cafea38a48e2a6759f9e0466eafe4385185c6634f405a91ff8134672f975b4725b55a8296939eff3b76acd08898d7d3682be0c21d27d56bd268b4b74e93829229561ddadcb07b5c3bf0455c5167d82e5a7f3c778f7e230708015226c06496f4e4c8f4029e2ec76de8517b44c129a92888089c5ef6269b0d27e9f1d2aacd419840521c0a71dd74976c877e91c051e0990f4d2ebf1ee0bb7403a6bce426368f8744d20017b03fe7b8e99fa473e28b5dc6b2c7718508189b97c2b7a295db5d2a2b69e50fda5a2223f38af77b6c028cb733ce866e82a7c400b2869afb11e097e7166ef290e61cd2dc4bc0c6c47680cb191983d51aee8c2deee316c6bed04a2d437d73fd689f45e9bd430e9225c9f082d4c5410a8ebb00a0c7965656d5ce7042b7ca7bcea9ab8b06c774be8243b6a191f04eb081bb05175af0fe380ab6cb5da6a1499be1f62f8f25efc89b4a154cd48cab5367573f0fe13b382b55af283edd57b4923f81ffe092af868de2f7f4b543b5bb9761343a51b25534082a7efd6e19276cb46187ededed52d549e505e68aacbc5e1e89fb0f8ca57c64f4cbf068e329e24b9446b9be225dc1b6094cf23b84a9262e8228de77e72cb34d5f5ffc96ce34552fbadf2fb6c3ec5c147d1f0e5aac538329b45ff74dcde9ca33e60ce78d2358a4a6006b321986a5efbdd8d40074d501d4c8010e581d75ca7f5f494ab71da19ff1093917ec5eceaea996c59159d33d07eb4bcf648586ffd9e8304291506d749a1c73f074b289105b6507d6f4e8d0e188fa7f868d65d3f44a20d4cf96c35f77503c35e25003d657194c59febac3e115414c649fdfeafcc7be3fb4c1f6e988ca5387b4b704cd02d05cf78879e0936d8f05dd781f54e1c97fd13eebd300431f7aea20136305816dae185b4f133def8ec58f21bdc865e07ab506fdf611a8f53027763ac937065ac203e6de8d0fb0c4d93fa314e0ea3ce39320171e80b552e9774303714b53cc46f1f19a97883a8b79159fe11ca927f19579ddb5fc1cd18562cdf97580d6b2a9cda48b80e52506c8496ba1990329babc9a4e8f69497e4c2a1697adea51219324fd24f9f5b6dcc25773647e0bca8ecdeb9faef3626bba2eb83814072735200071f3b03d49db3d027cb2b0766f95ddd7a80546422b38f9752c8def505b3117bbd0d6aa473e4595de3b4e238e11ee88325a9ae9aa28b9d95f1ac9a1db027bb4a1e8d357fe4ec64b40fe91a7e5f8ef1b103dd6c28fd6dc807db855a5af7e6d71aa60a677d4b15f6210fcc0c7fefe446084c4df25bc0657aab1a68a191134dc0da25a63815db7fac767bbed47ecdd6d9485be2483fc1c859fb97b7cb2391f396ccf03f455a2378b9a7ada5bc4571d1f4acd0f3d05c27d46b9c0d1ede4c7134d278180d3e66c5ae7adb838bdfab8467c0644195e298344f519d624d817e3ef73541838b9b9a59dfc2cbc5f62bce738a6f49f2cdf036558d544bd8c6679509575577ebcc2b08bd3656113d47409b50284743eeb5d37d0c2f4c3d2940695835b5724cd90435bee5479f8f833a89b5d1a09ed22d6ccdcf47edae336e752492c375160422f99710693040c010d41e6673915cfc1dc7db4fce9f61ba67c688a689dd4c1edbf3c40f64f2a73acfd1951b4e843bc4f841745025c19044e1fe99632ee64ceb53000c140783ec229b5690a57e567bb722bc68e1c8b5a0308dc9b69cebf45a5a026c715f407aadf1958f5ff2a034636f9ece47eaa5bece370c540b28abb224f4a98e0eb0af9e8d278a58ed3d7f75472d6125a502cada5a35c482a8eca3965f41b6863a45a972963b336fc83795d1a948c3b031f0677fa1c26ea4fd26c91309a2735a2f904da265eb6371266f2871c2169f9df577ba8ce776d1e48333b9af4f3eb89a60a3415fe0646958a7c6bcf0e9e9bcf426e73c07000b59b9ecb19540bc8e6c9f5237ca5d1adee5ea1ba4e24314a4f80451aa44f53c196aa9091d494de5db251e44d014256f6d6ec3a4e4052f7ded935a73615b9806694854f3c64b37f265ae5c5f3494814e316e235e0790fcff833c5fa084331802c937faaca3daf3ac288eb624b60e30154bd963f0ac0ac9daabe118397a11f6fe44ad9506dc82bb1f4219b58d9e75003b6d40ab319db6a64b924da5437f8be5a8d20c3c2c6980a015a09685da373e663806e2e703a8bf19e4a9fe883b4ec3c8e2a078de79b3850627d4830cd4229e39686368d48a229d3872c222895a69149798016607d655d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
