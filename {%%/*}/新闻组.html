<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ce6c3313454b2dab07587713b2861f0ec323e744e0a340f0a46d755405f5fb9795e6f018b57fc1939880e1f39e66b8df535d16139d54c0433c08db7271e7257b68180c2ce492d5aec774f1ac0d26efb80b513dbc874fc9f225673ad90245ec8cde788e254921a64988fec36848d7cbfb7f78fe1ccd847f3fc337254df06c615775289197947962a564b476ee31558081089004a0d6cf3f0d837d99afa5db5956001eb4df4cdc9007ad7ec7ae32db1edcd67da602456ab2d5942e1e95cd6943d7785ecd93d86a281f4a03390030ce1d3e905d7791d7c048e87ea5bcc20a7041603c40fe0e5d075ef2be857c70a6a1aec0b8de9bf26039bc42d125c4e4d3d5822588c3e5e7dcbd17258ae873f713ab96780daba47828d98b94127a89a9a7b1bb0f7177a4c1efed9a3df72f2282059de493b0e65dd1350fcfa427d5cb12ff1a4bce345f3ce3dcdd350e98de445126de7d4ef687eb80415f3759e546f537473634947c0fbe67838976ee88a9210582f75b17f95a9a53806a62e162649b3b141f6c21c546826f162cf8153655d3b829a82e7574be4fca114fb79dc2381d744d35d58440ecd18f5e8264c7af45179b9d2ab29cc274b0329735c329fd64e9c49abfe1b68cd578ad6b3bd1106c8a0486ab4f6533b2c09cbb2c000594e523a7a44fb812c93d2afefa3e08aebc834bcef0f0d77a4c147e26d270afc1cbd6ee7687eee6a30dab2f49cb35b959232f7757073121e6325cf34f04a43dceefd1bd006c268fb1a5106da1cb57649e0fe235a3c43ad736b84f40419f0b1a5548c761d48d6980c4836ca4b1d3b19b21c23bb3f2b8fa9601164e3b193a45b4e8a2d8231f4fd3ce6d9a08738a939ea8fca1ee4c92d6b87587e987cc154557c080d15b2faf68c1a0518192749f685a4e672bd1845c2762ea3fbdd447fb302c68284be907e40c444ff149f57214bcb6b981eef24f1185c22f5ec79dd7272e6979b6b41ae7ecbc7912353b9e930fc518eca620f9780186309796287d5f35c81ae727a874f7d54d8da6d73f5fd20cdbdc79a2d27f7c06297235df60004be308c12f953abb2e1cf01ec818a313c7c58f9692924e420940ae275d67c382a2d9b6aa285e46d2d65eaa2b581331c75bf22da440b841e0c2a44edcb73db2ac23d946f16b1420127d2fec0e59190254cba089188c434c01e5b157436c6e36409e5ec78d99a3bdff2c2f15a810de0a65377830077c5bb4973616649556662ab8c171a5773915b8903714b675e715690ce39ad3dfbcb7228a073a6c02f2ce4b7388d73b162b43d7c9655d75524a85a240bc3ab695006fdeec16ac4bbb84a396fd7a884b31946426af07a7d06344a69aeedfcd2dca9c8b2ee1b23badcca67e9170e8c3cbe285c410bd3262a836b8c97ad86316121da4210066fd5bbf2c8139b6924413db819d8aee15f6e187e85a762ae746a6e26c13a2c0e8a5a7fa99370a748511d2b9648d4acde4b4e939b2efe93022eb4deb6c419d6c274c1bf6b44178301abef62dfc68e72d1e417faeeff49363fa6fd1d68422d70e31506b6bbe6fe91b09a582c0c2e1f78db711fa77f537d1f52e3ae1ae98f96366c61eb38c6dad046f740741e094152526a2eeadc6d7ee6dceaf12292d88a849c509a040daad2ef55851d3fa9faab1221700e5666c3ac9d037b675ab3dba2f33e0e7fee0f44e7e471947e8d7cf846fba4927bbde632c738f9ded83f0874d29d59e4d4a2160fbbc8bcd29641452ed45abea7f9eb113b425fdf12129ad78c4004f4df332f90a1c2b802ae9031321bf5ce1e5237a3b59d2e6858587dbf73adbca06415bfc54105344f92edd5fbaf1e577b53ef3c342e6517df64155036c625c8dacceeb2df660533777c0abcf81ba1121383c767b6b39c9b57cef4d61bd490ad0d9f07ad7f7089919626cad00d55c53316769278c09624bda099f3a0a2c2ab0c123da4b927b07ec43877d2487c5832101c38ac988445753fb08af1fb79f7086bdf6d6126c8f5191d52b22acbc8cce0b01ff13e9b1bb9aeef86b3576e97e0c7d9312b77d8e7de5095e8b7ec7d70847a540196f97d93b3586f1158619471c956adacb1d6c2b55ab8b51d11d99a8d1bddb345d4aa78324d95f3269446e2c2df50e7c99ab92e77a24b150e937f854d069aabcf9d113bf18c35256b11c503eeaed2d4985556db491c24d0f644c2e37872f641a2ca53f5bd1b40851c29980b5bb9187f94a43bcfc3692b85a88088b226a3ff1d726f8d06a8d0b90899431d04d9d0bb7e8289df78b3d75aeb6bc6aef69e1b77b80d925e52fb5bc9c9350d8ae1e930ebb36d3d1dd79214f57933f458c85424dfc70010af2bf22661ce47fbee6b4156f966f11592f6080839886c30ec118cf89be846cd259a5fad0697a1e8d1408945ef8c5337627ee6206664fdd48e2e1a241192b8c2b00240f0f36ebc2f5319a4bcb80dd8485647c5ae64ed4cd365f24ed461177c01d2a40ada766d906323c00e775d948ea17979a84470da2f9fc9d8c40848816046c1e166da71cac4e47330fbd4c006a819354e1b2b3205536f40d8dfcebaa9f6ba1017008f89325e45505b3a25328a11cd61728ff2f67e106a08c075033a23f4d136e0706cdd5d64dd4efe1b459cdb7701e3af5c02803227338fb7a026b2461370b5a3f58754564de3a7930ace64312667d2725c685518c1db94b8bb0b4641fea4ae7c8d018116cfa2a8e371509dba240516d812b3c95341240b7ba4569cdd08ff902816e8f0eae67020556c41567de4bd135c94dbafe04b120ab81cbb657f0adf027d59e4005e7e737bd208aa542825ec32db73b7d11b0d30918644948a570a665064ddb77f46558d473cb5b3f08279e7c1935769b995e58b65361f0f24f3a8010813bd9966126056b5e10233c56c4f742b1619d63973103dd3a29ea424d38355a3272300aa37bdb334c3562a7df848023b29183085ab67885ba093d5adef9e0d282a0618b4ac468069155cbf284fbabd372e50b8770e268c94ac437472d7aacc4ca330bc2a3ab7b2e32bcc33509489fe8c82347be320659009c7f5361256e012025bb5b980ce432390d0c8055926a491ef28885c462d4e0bacaecbc4dec0b10707166f994d49c6fad4f89cc2a67a1ddc73e932fdd1c7aecd879ca31c8fde5667f2b46d2cdfe8f13e19ebe7845685ed13bda77384700ebadb3727bcb851b3de253518117901fe4bcc350786eb58d8bdaefa5e22a6811dd7a2a81b52d719b6bf68c2378e64eeaa309521f11efe6c5688cb3c30435f943fed25be17bc52745e27c22de377e80beddf00d17ece82e9ec16fecd74a7627e079df232c8dab8fc273204f5186974d97bf8ddda7b034494c0eea922951616bd27305849305ad03edfcc9ba47682d7ef556fbe3b53c9b0b166539f2fc68e91ab18bf6a5d0e0f6f0a70c2bffdba0593c98265a0a3d9d38c384f4f1da29b14595bfc335c0139cf56d26728abdf2b77ee5bd53ec7d0c8ce4792e9f8f18dc532c187988ab5abe54e7e9b6d663790a65cbf6c94cd6b4730e240febd89d1d2736e71d1ef89541d7542cc60e02a18e9f4a194eda3f65afe69125ce921ef085ddde62ee7e0510ef0157ea4d928e8073e6f7b54005ff5236563aad39e42f121410ca357ba9b9dded20f88479e46aa28106a16db7545c627599f8af3d1624b2700a440bda98c6cff10c550cb4496503ed8766fc95b8c0b33f65629d61aa6099924866e7f626d50f9e1706a16a0cdc45f4b4c9d114eef9ca305ee57b8eccfebed6c7975c233ef1e052d002e717ff849f55fcc9c97d41f1da222038d8f7a849748c5c01fe386b6ff78fe7fbeac08bcea96c85e343cde111f47aeb858eee52459569fd1a25c402f11db3a8c805d4e9d2262ce1d86b131974f9e6007b85297fcd22d04beb6b8ee6cb2c41e5c4fa97dfe83dc70833cff270f7c18963434d0df6ed51635e885a0d68bd432a39194e9156cc638628d325fb65e5e6b8d6a378205ead3bf3b7325d62ab9d0d9b8a0d8fc5fd903ea70dcb6ed83e952c43b017506631da04ab3512be756c6f4f91ab73288016fcf3d818582f6cea52f01ef323f6c9ad6936eb373c584c87e2148b1d3844e779cff82a114f618535bb70c5b0ba76df72c1e8d2df8b0b80d7a784bc7c4a9f420868f2938bbe5c3da2cb43dd50447e8194b0bd68d1c90adc1a4b9139524d411567c9b530daffd4181875c822e9b389d7dd60bd1f7df7ba4a577aa846bd28bde8e1e29ace59434212ee368113fc0e4c46d10340384e12d9a3f2be99a24dd6d0a8007664929afe50b471c54fd91b65c31a9abaf6e908347e9f10d7d19b80a6348749c469c2f5ff3432fbf9e627ed9d465b561a25d056447f081d7c651fed2ab4e023352a71e9f75b9e80b6185a595e9b21ed62d722da3f9d6d17caa2256a407c743717c5adc236a529058381e9cc728243feae867c73e1b4552f75c6c767bf3546fb17d7ed417fb27917acda32e8283d8a799e52cc0d532fca099d70ff3361b41d81ab01032be0005f21f2d99aad61bd619bcf6087cb1d1168d1b9f09f4909c0524f7f95b10d826e2e433e006599ed9d0ca19c39470ec971d62c43d1fdd76828df8859c8508fb852c23bc9a01524878fb84f0bbe83d21786c7c596b38283adfdd73b4d11684a027aa15432323f6bf02c6b939f65efab42c2be80fc0fd08d8cc6029ced6bc870a7132ea0beaee3f09c4996ebaf14dd354493e2ea5675856ac95fa660e48a57834eaa533bea81bc4595338b1de52dbdc48aa20d68adac42c77de9617715e2717a713338bcea60c309efb52048ac497e8c19f7dad632b688a6d32b924121d8261218e4af2b8391fa96312de966c31bb80baaeb862411b0fa9717c821fbc31ff18bcb16d17c7905214c606961142b4f42dbf7b7f5a38e36a584156c13961477de8c967e12e4bd0a1cd2e9fd4e2f8e26b3d7a43f2401113a92ddc01d39afcedc67efb84fa62fe3d70a4c98b8deda2b784bfb24dc902c01c465e4d5f96f2e0e61dba55e790db5e60559e3a9b043d1ccde2bf48680beca2a29fdac11b2e77e1302cf21a68fe7a3d1731e17175de356cb89aad9ffcfc54c94b0237de0cba96eaa99791ba83dbacea2ec87d1771593c2b5066b826ffe68095d6aaa7f5373db8fdc3f117aef862c1f5f2a602978ce8dfb2b277d598a0d1005d964f0a5e3e1ebbe01734c811c4b968181b889367cdcb2345acdc28f7c933f91517c0ee6c2ad0ff9fac82554e741225f54942795b53ec24b43bc9abd328a79c6f721257362d9f7570e0e97a957a8bece436ef1925e5a242da6b3825bad5c31708365b70f33bd75a258ebca30771a68526568e9f82bd4c6b2ad78f45f0ea40c558c4f9967cc41ae30d689f3e81c0d3a510608e0232fdddfc8ab1a0717f10f9fff20c5d300803274806bc2bf68fd30984a1fdf4f62cb80ffd46662225b6a457ef0ebcb22dfe90da2fdaf650f0d77f876c1b379baf8282d62559a44d9ae7a5eb43527ca6b347a4481468c140e32639101d05e17d43a776a52bb185784d88d004244a8f32f8ab3f1b0dbf0d2b0fe1ccd07716a8fad1621d17219b2f00a4ca25e3bbd2156529ecbe3c5f8c1fdaf6ab604d4c7611eb274791ebf75bcd59055692be9acb674983a8c60d6632b192ef847afefeb8f2b487ad97428df7fcef12ede5fd2b6925bdef23829b845dac3dd7db0027dc54eb351fa83cd2f841b4d23820100d93cf32c95e6d414b620efd0a0e1023db478b79d2b4b718c46e6515ba61d8f69c129de863d54fa06986ea282ef562b0cf6922fa48b187932c057ddcadee97712cad54fa933614b0b7e058fbee5194452bffa15a0995fa924f16872d54ca0d317e5e5022ca2174cbc66e3d64ae6f510db584749fe966950760f6378648590227383d309a2ddf1a2b8914973a56a5e4b17aca964cf419daae448ede4271b41d4fe6d25a2d02d1b239cd40cc2ef7732215dd173b42e267f339696c4515abd362e7fd1c66ba06db6642cfc45ba5b79bf619378c87c0d10b2036940dfab29a4cb0cf0d397a8263ced09e1e2e2309037771c89017ab54c4f6ded667ff80c49d8db69e9e31af82e3e59ac91f2588af5a2c5985d7e6d24c9f59ae8cff2fcfe83accb1ab4664db02c519dd32237e9e9aeef10cdb957fb05894c1667fe2e84d4c362e4433769b56378ef43fc4c61d7ed3b9d7400da9bdc907e588d4b100f2e0717781da20e591f3e60be58487632ff254188ffa7b0217fffd7f417ed36090464973eef0bf4f3119e6723d988c95ec3e31680f2c819b02d64dad7449861f09c3abacb0f7c90a8358fa4367e04228db88388446040e8be29057642719d7dc8c6e9a39731aea37e64823744021940475417901600cc25359d9851c1b779f3cb6ad199444ac790945ac952af83d3a90a8c12adb95584943a656bba2261dbe5385be17f543fe61b7472a90ccb574c24697e8cda738b3669c2384dfc3c6f679f0377b4cbd7f51e953713d2ee57afe8a1f29f38cb9f4274203c35a4ec0c621ee0ca2cf56523a67bf0937201660dedb66515926e01fed50171da0a9461c3bf5fd884e99e8c8535fd5158a88c994f772f46cad78ae0fcc0b0b5a8c48b217ff25e4c2f4fc450875999082525f018a88f9cfefcc40ba7ac938bb47d389f0926eb5514418e97480ad65de82e7c9ee840bf9fbc1c65147a780a1025c3afe590e3fdeae510d3147a98bf714e741a4de05e604486db0531e1e587b4f1073ecd3bfc079cc5420918e75a38b7186ed9846f396c8902f3fb040eae929fcd6a1a377c6bf479503528fe16348a689a751d6644a2281f8138f13b71d9453374a23acab33617fb274578fb2b4689bc21bafb1977191f826c38940091c6748ed4cad00f97d250f6309084b319e34262c525cb95d8cd95691633641cad43859ed1fddb9b7e287b5a92ccf9c3a27371b2251f43805bf52d5505fd87152d716bca4fb7ac77c7cfaf9fc8a7576bfb88b2cc43de73400bf6135a695a40302b0f7fdb2613c1e979e15060b907d120047525c5cddb61805f74b4bff1abf626fac950f7cb2b67285ce6f1eb4fd6f6252d7abe2f4db3e977369b671a1c95dbec30bf6f66f06740f278fb00bcb51501450dab5371ef410e43fc81c5c34e67a475e381ec3b8405e330d31532123c94feec17042f41335997bf97e11999b4bc091de854c61bc3fdef8ef2bbb268939dc5d42c5ab384adb86a1c5917e01c64c9d86ad3385cfbc40aae15745ec67bb16637ebb028c95fdb21b5a9417f5231d1491359f842578240fc7a345204d571fefd14fcd9df98debafc9b5ac137d660b3522c2d19a7319eea3f866f52571a88f60ae0dd23f53d3ff0210eadcda1ff43afdb1b46937004477041487b8d480c416153fbfa59b9b3c6f7501226f31b6d8aada06b2246c9b9e2809a33eb0dcc7ea4e6417067c69cb498b867c25eb9047f3f684eca624459168097da7b6dd119bcd901d434ad76e56303716f390d994a50235b0778371bab4410b50a8a2a16de41ffdd80fbba6c9f7a2a6f195a06c6e34386db44c2e960822f4a3a49d0fe1a8775fd899cc7477d8db941196c02a1cfa4fec015152bfd13afc5363ec7b57d123a1ece1a6508ce0ad3a25bfa7230e3e5cab79421b786edc11af8c956c826aadd6448a0cf8bdefb3ff4ca73c8b7db6579e8f1488fcb8587dbaadea69c9113eb1d671e6f70b3874c0895af3c134087e84499fc8d46fe751facc75a7d921db6584374e2edd9cdf6d8f44e0b9175cb100d16eb75a149f3072da85fc3f68a9ac7701b5173f4d3bdea1e24dd28b9741e5f66576ee8198a7a3276763aa983f9318027efae5bbc87ed27da4d0c7bb1dbc0437592357ab1b6f16bd33d8e306e2e37b6c97674a1ea4637d11c58087cb1910aea2a65fb70988c0ab48f6eb2be50c0df83e65e418886f17d15e1a769a53d4302f84906542416f4f3633eb6779f50a5315202684b059536846aa7ecf273426e9b802cf885dfe6f000be853d321accee2bd537f0555fec000b904bd2c6c91f2b306431a606b3151c08ad30a2f2558abdea9ac7a3626d1358bfda06eda06caf559bf63621eb38f71e1fc04dde662ec8ec553979637cd1fad07e4d380733a906d02adb7ceb4216c718bda4e9a1cb966012ace5ed360c7e9f4081e1be4258ec1e388a741a42339e223a506af4262844acbc768959de84e0eb78b65334d6647a59bf1554b874c987ffb45f7c88f3fc07122f848e4602715cd30370fbe756772662ad7ce6ae3dc7e063a9b7185590fafddee673490475d7de76a614e24fb520f42b889b1b11744ab3d1aa958040f01b8962d17c8b5daf65665c553a295b47e7c21f8e0967b72e4aeeb7ddb610858072859e7729a0d975976917aa8acebdaffbdeecc5e8e8056a7e2075b8a2c4632712c4daa5c23bcab8e701ffa7ba0fccc7657d4df1b1b86d93144c01871b0e71478022bf87fb582bed031ecaca8f766f2d5fce5ca2efe6ab78a1318f226b70f519b90502223b9f053d0243b8cd8d13c6db3bf153a8416ab892a9a7f207f8f9cecd4f98a9ec8f9d2f47483a0e1b0b1757fc2e22f1ec4dcde0aa6266d8aa92903d3907ceecdeefb8427205af6540e867263b5301d2bd58f9858366aa564c1a976df8568041fee9c1c1fac266fcb14ab3d00045647241115c738e9b5bcfd26d6aa8f409afbb55b87774248b03192559bb3fcccdd4dc5928a5935c499ae4b8db9d310e0c5d56545327cb6f2f6b3069e35cddd880a93fd91e333f673eb4d60984f1551a3e26c189044525e3ac0971cf35bdbdd964c0ded4f7e3cc001e9e3a641f866cb7ece353560d553304afd069b48ea72aa57535e75b7a4c69c2661bd82b5cd4a56ae6a0eb73da6512bff467d487c164af92930cdc0a2b4a7a370ec77d2a668f56998db7286615f19000e5aa13a108ae388a8bedeb96225c61e8b2ca8366f3863a5c776af92893068ead708443003dad3a8eaf0438155d1ffd90b01cf510b57e8a12fe13fdb4f75bded61346970a30a8a1ebb0d3c767219e8ffd427f90438987452c5c6cdfa67193d33ab30ee363bf0e63b06ba9ea4e28e7ed6cc7b8032766e96ec3c4f760a0885b79cbffbb3ed1327bda686b38078d0d9f17c893fa861ff6f55b0cc242789d9facaece537a20fc756466ac00f19a1c0c74504222d08a71d9e19453f7f81e17c75f01955954d2c9523670f59f888dc2ae5bf8910662992e45e6cd8ac183167e33f23e91f13a89ab9273fd1ab7f41e322f5f06f3a93073a17c6273eaca66a6827e0a271cd9a1dad434967c4ea65df4a0d72bd0bbee548fe76300038c8d7878ef013527c630877d6e1f2467b2175fe7043e18dafb0c52e206ede99ef6f5ad114b5b9b6ea6bede0578627e51161fc88315c1a35bf2b574b16457d3a3b9438b31b1eccb3b9e6c30e5393d50ed2db185043b32ccd5291155871c11ce18db322cf115ea33d2f85f302411a524bded2390d0f2c7648b1b4347388cc962f1b502899d6d3b4c26734985da464fc35c5bab038cdb9e49b2beabb845d04218ff028db020e1a4f8e6d27ddbe7ec3cffc96690389d500047d5728b3117e0b6ebc5b87b1d98c8b55c28dd4ef699230e6ef04f01432c0bb440bf209522c54bf6944cddc4c566b762a4a576f16b0a8e013fddc50e9adc687c58c8e0f4bda44598620e37ba2b824e94ba02c08c158d9129ea410ad68c7a8de1087a7cef5032c961dd44317f705b864abe52dc1fb960f609c49c70d6fc5c45c0ea6e56282e6c7d63a46e61c9a3349a9fe530cced","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
