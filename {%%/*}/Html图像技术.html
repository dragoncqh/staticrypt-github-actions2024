<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"75a02771d1e07f0a34f55e797c45d96938415a35a0a0de37db35129284e2b0cc4b1123961386a72d5d9eeaf596027ba0146e68bf720a5af68968a895519977f045dbac387685c842328f3b473ca04870951a0e6ff4935b0d02105b73880ef7adfbb08850b9007c3657a37a3eed301a7c8146d0d95048043bec61738a303783f677a1afd021dd20f5a79aebc0f8b6dc51ddacb2c1cc3c486cbce7813127e5114454794ac56ce3a0011fddc26611a41dd1b0e5a6a0f8f131fbb9e006621a5c385136c67f11ad76ac857407c6dbf12be9a1fc88012f2c84a09f963fa2045b81ecfd7746527677c4fe8b15ea9c0967236b8138af7ac658c66e81a82346145b9a991d253aa02d4effb35d47a957c910d532350e4297b2c674d0534678cb9f93e1309c5a01a67fa854e0412894c9c16cb937565e9fc4dd6b458b30609f5d4b76754bf54e2477c61f962346eedbd7a156956bcafd342cc81263a55f791d504fe370efc57b138d67f482d81c6b9218c61505bcd4bf0ccc6a452923d9de9ac07f988bf313900b7a642870094ac42747a515437f95a7f48c7c1433c86c92d1cd70ed19573607bb0b9d25397398a97bd28aa103ed9b5a75a99eb7baa39038bd8711d1f566cb5c63eba62c8d90e9d7ed305848c0b6dfe7917dfdb9455412d4f586e9215cdc360d892c4cd1b98de473ce842ea5f9528e0d95aeac4f010478dec277fa10b8db524e834f7a5046c000f92ecb194d7c7f393c3a6a6d2d5ebd1bdf8c0e11e7f6999285a769020d634359610dcec519728f7807a25ace0d9fd227b90e186ad6ba9192bf7e4cd2c0cb19187ec9110538e139eb2d2facc7419cbeaff6d24122df5c216018cfc784fde8d6f66d866eda16c109e532a7e64067d0e3a69d34971d93197fe89f37b5c4edd2e6ac497e728d28182d22db2b33068152e7b1d1e28cf3f854690c0b3e28db50606f1bfb84ac18a4640082d56738c69cb8b2a1f3ef62d22a33b6afa8c6b1217aacfbefe96a3b816384df96cdb45a745a7ba4cbe4264ef9948b45b3023741638cceddd286264be8b328922b7f3ddd16214ac26f06ecc7e89adc930a6fb0400bf58473a22ceea1c5021bdfb83609472b58fdbcd901b1880374e5a15971bc57c5fd6357a75b19ade7a53ad4638206916310960e206a06b15d75c3ccc0d989b2a59a3ba0d7759244c956a23ea302426fae4cd87c8a75b07d98b450846560b34d5bd5654081a7e8da43f4b85a1fc55a3270b138f91d61e3fbc54eb51dd88531e47e2f406ac1081d16c17eaae0d4c080b0e87ba0e71d6b610ca44dcb8bb1de7c12e386185fcd7ff376e86e8c8c5be45280a3987fe5eb78a782b21457c680a055de75afbd00d60b50246e70e271cdddfb501bc709242a318e80ed95dad0b017b631d3b0ff23f8146001225fc3d01f257ae82ecd8933c305efc77e188495941a9a5bc8accd4caf42e9d82218941fa916d9c175af3e8935f98136f5ca9d86aa9be2b79199155e20f275aa27ceb83106c8e2f8c9a22cf1215909d7ead214686ffa4d2d37959421f3993651e0e20d637598693a327a384f276338b923dbc403f9a29027d77293bd0561d84a5025806ba8f6ea67927d5cf4ee7d91d751cbcd98c29d9ade4076dfefb3fe78cd7aedb527b3cfead9a0d4a83195f05fc49b8c1edd6fb7e49dbe52d0e266cf4414dac3d02ab0ec2ead291c13943c4de4f4d8b34880be32b92bce842425a37771191a239554a91fb932084a364b7681a5a0011a777a303115e75b1ccdf2ee54ea260011f353ff592ba3973517b4f07cc97325ef3dca50b78d0b2e7a39ba423d12c2666a7f0c8e20ab3b076ed605b21dc72ac14285a9946a12d1f15bbd35181c8f3d6eed5146b095bbf63d4374aa5423d75e4b92ac4fe8bb574a0e1cbed830c7c80aab4ea3f6258cb78a4226678f8cb02d3896ca3b82fbe0892111c53d052805cfdc3ff60be33acb3a18568b89983a31a3e7aea0840dd35f1cce8e2984e1e5749c568dc3b9db49dfe0c832ce3246ff16d7876d02fc00270e7b79d91e3845642fe678ed2fb6da09084dd277e78fd5b6dc778cb7e58cd52a7ec8a32c41a00800203ba0d4dc7191ee62e907ebbd4599829b9db484d291cdf883f56d453efdd6aaa365991ac52d635275c75a0f8102b32b506237382ab23836eacd776d24a94fc844dbafbf4eb8a173dac208b93daa9a8056641fa30dca828116d5aba68204f4eb6a45966720f5789190e3e7f2d7b3474d9f36f4dfdec87d1602b28072a8276db0b124e2294d0c79dcb36c81ba9934f4450d02f9ee8a117ddcefe435185b021428843c85c7ef6751f1f697a9fe1078a1828f9b4f66259afb381c445368fedbf9356ab2c9981b6bc86e7a338bbcfb53caa7d32e060921af7a7810211c9732cc4fe2a2b3d5dac8b77a048693e4df5509d0c13cf7e6ba0770200345d37887886534995ef8c7fe98585ecb759fcda47cca00b7468fad15d83396084661ed3b84fe42f5a0c7b1a6361794e1f73dc2946fa8ba396bb7a1cb77f88d57520e28197e1294963afc0630ffabeef5fad887b703693036400cbd41fd116ceb5b27d9f49713206d3f9f4ec8ea02b3f0c5357aa9bf8dd83ff7901b18f8fce58da8c455e1f54949558526e8fe7a19a662e62638aa2bbff7a7f1a4989a614617a2560a7e7d99e01727f32164eedadc8db55f4fc2c380bb61b7b1629a0a25e6a1a71b4a81d19270e2e4dc7b597421d7251a13855197d5c6a4c4d657d4fe176b889835f996457e0b11d14d8182d2d345ff6daad003097c40fd620166c26e4b8ed1053bd878edb3180d47a8ac309973cf930b9091726ec69d0ceca7218ae44565aaf10556569384c0d5855930af1d90c47a3a75453ab4e797b1b32ad55c41f7ff9e776f0d8efdfae79717f58bb61693309ce887cdfc6bc2556a2688bc6fa2b6c84df99e826f4cb5cd10f8005410b208a766310af773c906505c3261e1606a95ede0a409a42bef536d3122451d1c97ad59bc994f5798d76619abbfe81960b0d6ef66815088e40efd458010d7493054afa125c916060fa431799abf39fa624941de4eaf3f2203fad2c87a50fa1896395b58c58ae5708c61a996707b335c80acc6a4f50ccc495f8a896d5f16a194653910d641387745365c6e1a7042eb33ada21edfbfcab5d7d1102a2632517ff344c8945eaae66bfeb0611c040921f17f5b3afd80bf98e2f347caa70f70145e90309727135d000f37e5cf21b33018886c93bfb2befc948c8e1108c56f3c9f0f55a401b240fcbfe713b39e07bafb05f17fa3f1eb356b867c641eed208d3c0aa37ab0868214a0bab7ffc011fc1fef940a4f83f5f6c33ccdfef45df987acbfd85ccb00b71d77c731744e19fb27ab2940bd6707816d12ce80baa64a6e12a9177a956d725b958fc444458368b888264997a4318c100291b0aa5df1938f29f7979b76c163ced6972b9272f463d24670a4a9471d2bba9f2be8fa01c73e885f38e565739882ca5437c89f8efd76a3665a743080830cdaf94d3fe87a6dd36da84bd2426f96a9de5aea57dfd80525640eba00e333d10ab3c96201d212e3dbd6686c09b572044cb510d5652bda58f6cbd3562608821a3ce906187ad27dc1d51160694fd77cf6b01bead062e4145fc8a0f03cdf72001e2a68aa9b067818a0c72cf06ea15f5550759d71b045da58bd4303dac4c30419636967d57855ab5b979f765d6119aa5217405f6b63baa2013e4e6743979cd2312cb585ef6847ccb7b98bc3e72602dc5e06fe5e691c1559471635b24ddce8d99f893e8e5889552a40ee2be3a293900a8e37911aaea62f53ce7fab9f2377099e7eaaabf76e0fe520f834f475ad56eb38f3380e4c6a780a668975d8f8c8af1cf842314963e2d5bf1da824e9dd8139a3942c646d8f3a51e8ece97018e2db219cff11df19a147c9165670dadd40eb21a577d7c8db9371e3d53f8125c678d9bfd4cd3d5e76363d3b50d110cfe92cb46c64b7b19335adca5b7b71140638534e5feb2f92e4359c4139f49bf9caa1a69e9c59f314f850bd7c368ff58a29fed04f5ec628861adfb39cfc6a770782c1950c3fff278d8e83096f0dd42a8235232cd3b4cbab046b027e67eface1173c5a8fcc9c04308cb63f102ea6b8065f10abd0901bcc8bc890dabf86ede2ff02062ef61ef423026318cfbb27892848650c99561253d2edd66628410eeb51215a866bbefd7dec79871466d0d9490714b59fa3bb8016cb64878e869da82da0b6ae9663efd746e4486c925c60f41a77f4c45f55711fcf94fa3b3ca5bce18a70bf72159288c1b997582781b70b71e36a0eb8f8ce5a5a03a7ebedbde068cd07ca9db0f14d1e1862d4d9576d2af90adfa5ab19af74eeeb5f41cb9af44cc26a87c6ca4f58a2fd4b884a8ba4fde1705eeadecc2b7e6bee319b40f1c0a4dd04a39f23151d29e711d689f8ed6b33b84f5124fb3496e733a2fe6d65143579453d0d8537c881bcefc45ac4673ec222e9a64c126937d1cb7d471baa49a193ae05d54dbe9c20dd0fe36321865fdae0ae042d8f3916fc2386dd15351f406e2504f564a1f367e320ddf031829a0ae533bfa5d3d30e4ba1725469fdd5c691a4732a32a32f885f8c81615b66b201fe44c633e1b5ed546c88b74d906b86574369bf81f8e3f75e951f3874d05a3975a12f640d4267005c548cc9a5ebd1b6ca75a5873aaee0e03ec6cf3312ca81f3ac007ff8b7e9a6935145641ea0ab1e9d9ec7407c9bd15d7ba2dd0d36d90b447e44063361fba31665f7c25f4e0692ce5473a9d24d213e8e9d709cfc87ec9c99266d8391f285fac2e8db20322cba1b7e11e17b68c1da93a8f8d8a85c2ad8a763cf98906987316e85ad92894b2adfc03a8cbcc88591865a41cd69837d24705479ad317af296d4b3df38d26a471e0e5755401be5f040963722fb703cd837527833831cf790cbe54d3f31a5d8229a01652c71f9fa8ba22c1214dc9f3374fb512108a41bb78283fb406d7bad37797d9697109f3d20b1d966418db52243cf9867a6b4386e7e43fb1fd2d5e32ac0e68bd8bf1bbbca4b674ea82a5bca6dde15424a7b4a20787b4170fc3319e689f4dc22135a064361758a52bc3b0e4f0326e1ca3978c5c0cb81bf87a5a38f4fa6b370ceba51487dcb50e895bfa104f377b2d047a99edb43c08c38c62f74dfa260bfdb0bb5a8b9ee110a5ec5100183db852d050dfafd417336dfbf78781fc5ec376d80ead96424764835e6b7b9a7194a6ecaab0346dcfbdb21929f9e71dc2c1642089451da390e48b8bfbd20e229bb1654cf41057c35d1dabacbe9979983537f9bf3016e6c5c2d10a1e38124d8a5023822a0a34b80ca6b5d17dd0ffca9bbbe5467e73695ac4bc1830369e562dd49c2d32693db534b1477b9f12187c4ea8f30b785486b197f0b387e8a155ef1c03f56ec49b46ff4d899f92a49531afde0b22970e57e0c340b504668bc7bbb42f0daf4f676df1340cd0b0695f56e244646ee8c8541a3358dbf2d72b4798b40d3ffe5c9a9de7735b8c6b6b5daa2132e4a2cb6562b9c9c733e70305711ace0940e3e4e9b64f91b3f13bbf0e39ba84c282ff0e4b2f2e66c5c2136e9f9b6564a8538dbc39b7494fff64298cc1c88af692e957d2a53901f4399766aa7e3f64ff2ba067262bcb1f442563e1f0dae92fb1b06d02b0076c56875ebe80af205742e6ea341a37eac4261153ea902204f32ea91f5e2812db0e5407869920dcfcb528ea8f99711f5db92736f6f9ce6000ad78930c7d81d96bf6ab449a5585b832cdfcd7ef0f1f5dd37b63c35fc0e598ea8cea4edc28f95e8ac3d0ec8beae55defba0b547ae4d85e6885e304b92ef53a741598b9806ed233612c7439c1a07aa27f98b1ed7cef195ace8ee47bda49ff7a9bec3a79005c2c7b552142b0209ff5ad3ff73ff5089b138b126c3b85fbe287a34b6e3186a827aa8cc4b22b939a1d5bb3941172f0c0d9c3389943efddc99fb43201629b56fdb8d0c19e5f6a7b932dedcd3fc862f8834f0cf4ed382e1ee79a73af40e3a58c102e8e49ddc93407c60cf4a43e6985634108e3256ee1212bd2f40cffecfeb8f787e202f9c4ae0bac606d1dd0ac47a37b3e45d5ef3555f1a04b9741fb3c0b80db88b69fc690291b683792177042ffe4ed33384b83488dd1882e0d311ddce8f5c4241f7cb7808b8f74130cbc5f794fdc21ee5bf4e2eb9ee3395aca1d59666a2eb262c53a1446e4019b8faa90fbf330a6649c47c99a2df1057f29245a988d30c93830c15fcad847a656717915812b5b4b8f358eb55a007247671b0e5b3e8562c623c0114db4ffb9e84ed5b5e5eef8f26a05ac56417bc4482bb15d0e51e3c89718b91dc021465673d407185394791e60f4e51cd5c58fb9cd60256ee0a0b53a843e6bd5454ede0f7d8a97e818647997d805c746394b8ed0761ece72c7a377752969b5521236771208ee4323f288b33448b5a79a8eee69b317a322f21b799d690e0bfc462c56e63f5ca0f914fdf54955836f66ad2745b8768959ae1da2306ca436bb4801fc4d093480ac9ac4439791c70ff27554692cfbc110d986744c26579dfdbd4588e6c9540d52c45b15cdc9c906b9e0cad9dcc8c6e7e3de731848d732ee7eec64f2294d9f7a8c8101d5f7838f4515b86a54c1096576c45bebdbc03529910b50d0e0628dca7beb354cbeb16ecf95c771a1292f384a797072610730c4722d9d0199d3e072db77cb8814c9433ef6942dbe37151be4763ba40ef9208e4db4d41d48253799ffba8e661e4b960b975e575b4012d67e74d8ab74480def36f06e8ef5675b3476940d9abfed8871c70ba660b2ba2ae7aef37af6145e2fc04599e9e169f9221c2310498cd1f8e36274d86d3d8ad67a4abaab166d472485377e84ce80afb51c7d07ab0c5125f7e6e8b227a85aa2ad77e6e21fce7a827989043188d46b3b5006f17349645190287bd8170a10f0f65426c7576d91f42bf2d39f083823f5b607bf2225b5650d9d92863a8e05fae2fddb50eb1014ecc434d2fce7f17ee7056ae8520b1fa536cf45fa6090e60fc60d47a3ad62d93404e2455168a5911818c376a0cf8bec1dc56ce7744850dae8e723dd317c95ea0f34e71a44aafd8e4dbd9590a63bcc55bd2ca95412174f88af8495e8dbaefa7f6de9fc848aedf18ae98a66d5a41b37e0ee2f60442b52e07f2ed1ee055d517510dabed6bf49d2f202167149cc829c76648b4abe7c97e103bba3ffb26c80184867c29ef80c2e32c570365409ed5b551a4f3da33250376a412df7916358637df8cd3ff685782a67401d1e5a6ea665eebd4b0ca7ebb8c468f21fd58f5254be86900406259a1628822fbcba4e88f002c53da46fffcb52e24106028f7e6431c19eaba5db5a501d0af69907fb90446d200a50a9a70d1013d108d25a8e0fb3cd82c72eb29448a1ec4f116f76a9b12a979f5f8c56e44838074527a8f2d1866bd250f6aace6955674811ad3e0f1a90adf8f010e9e03877ebffda0bbfef73d367a93e937eaae2c00659feacfbc8ba3e12eaca9de05c31629f56ec9cfb95aaa202205b8eecd98c8c7f37a09ccc61ae5428ac3b39ef853ec6d675d7a21f5e5def8ac5f9c52c007ba0591200aa2e503d6477a661dbea2644a272f7ef25bb7cc8bfca70883ad7e19783dfc22333724dbeef713da9f0cbdc7d26fc741a5e6542681dd98314306f371a790ee59ebec65400f70e155fd215ef85bae9c83781e8d7a122f4515263cf9e8c7dcf79ebf41ae4dfea2f97e5a431f3ea16ff23db8ef9777de1beef67cb0dc3ddf3f3c17a4bda0010e7f5b9f8539a144f68a719bfcbed6ee09037724e77664cf29cbd5bca4afd1ff9bac822b2ba7882f98c3c4b76cb5813e4750335939dd6e9b816824395f48568fd4106cd9552283800085d4c17bf9464ca7ea0c57c684dcf1516f5c34682cfb081de284289ad6aac71cddfac5044217d94c33021a676739e643479b7e11f76142a38a3c818b9e8d7bf1b93ce10355ab06c90d044afcc544f6e325d5989701d55dc61946b25270e2c8246ea02d9f69c49d3c54143049a0fd6e131aea796aa037596659d1ded474c7469949bfcd5262ebc5cd32131691da47d93f785d307108b3333ace0b0072b9ce8980fb0e6bc89aaa3dee810766812c0784c60b220e46caec4962f1ba96ad07ab7b71b36d9f34cc1f9bccacf24944fc13c69a60ed41da6b64464bea9d85ceca1b64866c8abdd7cb2b75d587a69d1e4dacccfc4c90ac9db7a2419781d2700e5c1fcc507eb91f8cc9d0e3ec7f2300eb9a1082f80a9b69889dee1a66803afb216ac7674dc371b355e2f747445ed8e7aad9bf5b86500a80cf23418b2f80efc5f8ffe269fe6a07d1f62d4ed560ddeaf2b449f2e2a95610286e22318e4461cdd2b534b53e1e9756a390e40c695b691dbdd635f04bd93fa9092192dd8d784a8e93bd9f5e90d28a67ec77bb27e78aa01e9cc08f94b8e5b6656a6dfbc3ec9e75fd84d3a614956bcc1981ebddd66e2dcd189d3a83cadad1079d9002b1fe7724a55755e829163f265d29cebdc6609c7cf1cd17a5811fc486b89d42c8e196e73001260343bcc824dee09f7623d0e4de99030a239c59e2ade1ca45d5a61ca39f31d05f55000d1e525a66516a73e285142534b9669843fde32775b3b73ec4ceee1c2245fad4c3d6ae19da6a3fdd779ee4f32336f8e12f724f2b6beaf824d3e0760fa79d8e7546a4436a27382304afc1df73c4028415d04a788cc0860754a54bb2311c584e158681481649c8de98b3acbd1bb8225673c70470afc753f85571b647571b20e60c012dcd67e1c94c0d745ca893870cb92e71b12c0bf24e0304ba106164af415c9b8d48142615a0514c2eecd0ef34168ee2bf28419c5227fd09777df636c79846780cbe68b81226c0c18b5d29df2e7e3a5ab25f4a09a575a9175540901806d7b51a885f6a08db6b878822cdcf220f2bb9dcb42cf821594a53d0a1aa51ea38490b0fe7bbc2ad5606b68d21f0a022f1f789ae627e46bc9944b8ea2221177452800aedd14c0d4db2205f2138ece6c0f60654a1fdcde4131076ff1f7e13b4b7b27ee7ba106c884c557218dd2ae210bd13d6c737924c244d357729e86ee926e6bcfc22f0a96822ef901a1e4217a2dd816f5f2fc74c096164396fd6a3b7f8831e95f7538b8c524724be64e75e51313628006960363273b6969e66df32eab6e6bfee2c8bea5ddd4cfc837c4d1a4676136b72a132b083a0f8ba5bf578d7d844340379d20b5d79a7f3f1866f0f43d17799570ee324cf97518e1c423c3f4c3f395932f18b795b7db46c165ca417561ff6b2850435ef54eaa18bd6d451058ec66fa7bf97c224317eafd0f43e9135e8ebe3ebb2542dd52cbfd11d404fe4b1757b50a02c9a458e57e56e3560df857684c94af18e4656d3aadf38f726865983896c9b18bb82c3ee2010744b1a82fa09b05131ae06936ccd7f75a38baf3a23ee611a3120a37eef0ac2221d115263e5af281d13eea7f587bc2956a402155d93d314b973c40fe1b83107de1a56cdaa7684ec038363435d6d8dfb7f0fbaee82009c243c48b45c176bf70903b078dfdb5aa1df4ba3c316231af7f88f68ab0a8b865a993e3040a9cdc4aa644c05f33353fe44bf744ba32bf2f647247c0710e20f1ca14802b4c869e3336fcd32b0b512e0fa62f76a4505b77da0cb89e5a7d460f72f26506f9e815e671d67ebaefdc6ea625e7facee964e6b3b58b19af59e179b95fd1a0af72d4a2988426996bb43cca17f9bd2718cb45284d6057d519162c21071e25758d7025b1ba37ced7ca104a1794f85016a4e2d17580430d2268af8c1a8eb117def2e12df7ee377914686f56e4b2a584755b267035c5bcc6e5968235b2440b6add4ffe82be4591ae94549bb30b422d5ebb28e967a3a3685b68a90905b976b96ba41e7a51042955a7256a6361e567140d57d5906f349c8464c17b226c7e3482c0fe3a91f10beb932ecd25e8ff666317c51c1189bc2967974feeaefd8d9469ee3405097f8ec4f86e41581f5f767a96cece1cb091560a626ac88919b72f6832d9621812cc3d7a9203eb3092304ed13f396f6a6c1307a06bafb2ba79e532a61eeba4979c846d257bb5742704833c099e88ac4377f6aa121672c4927ca720488ac75d6179047a48412b2eb0c87939133b311b5013d498dd097fc90b80eb1266b0b4fcf78c251d0e79e000a670f0bbcb7c5bedda1a9c57779b228c55a86b1612fa6463120f91b2b0383e6892ebf5e7641a4543c52c39b2f1c05c119a52870f375b5585706e1085bc7fdc563d4532419a40fd8bd999dbf235e92f32c96c25ce17d717cd0f80fc5f7ddad1b9509451996e79b975326ac6bd4cfbbf9703af26d24734603c54f97a1d44afe9f2a3cf2644df8d1ff92c65612e7a7ddd6aa3da6c7a59b83a33c4bd2ac342c96c334060174901c0cd80733533755df32ec37ad33e697c15a30959e5ac2b57415a224e649e8fd77a7e369799c086bee5805777d08b719fd5936ce00234a82c5eac893d50a960101675b6a5b56873e4e6980e484cae14244a429f0741834336eb75b621eaf288765e3670f59275e49d2de711a7636b20632dd6f22d024d6b345f2dee0e036633ae00fa6473b0bd803d9a1b4385176ce60664331755d07c3a8d988834b7e6c9e0179a1d11e3434fe62cd61ed8bd01e9dec1862692212409b175cdae876b56221e566e1b68af29215ced4de13b8e26a60d4aae54c85d789b9593b9c6c00ab7aac3ad6a62b51122d662eb8edce8c55ccc497f30c74e1e19669343d4c7df78dfa77288fc8c7733c1bd3edf42d33d44c40a67e7e7f5197ba1dfa9626e43117a9b37736232536749b0b94f97a2229a2496e7b30044c237b9b3c8d47df43ee7b7e6cca7b621785264df6f71e5bfbd4d4a0827910a3ccca9d6a3d47688a1fa427ca11dbf3600b544e9a4c2f2fd453523e06788d541b9be6c0ca979e4a52050de0a5a047c88ac662e1eb1ae8e863fbb68e2baccbc5253eb804a3fd5a959b480d0e7c12cfbb47c76870a30ca429e5dbcd5c99fce104f274d696c1211a0f05b5ebc0b2122dc4b3970423dc9bc063560eb73921c3ef218eba163c5b3ae4f1b653f37afa523613306a7b98dff0500364c5612fc4b39f5351f018e5460e7d0d6bb9def457a475914df6d9608194f346b784000c1849bc72df06ab7c15a9f79f4fba610630aaa1f12858183c7111960e75fe9b297185b8428b192cb536ec2ed9234395bc85408890193b49b7802ce8f133afbab160efe619f8620129e6f1179dfb1ebba1a0ad0fa145e9c0ea984f6969cb8cdddf4f71e56d6954552193f8d584ad9d396cfc7925a0d733cfd06f63f5ff12cafd617c77e59446124eb3f59e60fae17054bb484a96eb0dc07a35d1742aa7c5cb796c9d8e1fe78dc08506160e2d22712e647a42c83d4d6b7a4c179b7c8efd6901db6c0f8d0bd8fd386af785183b4860a67b3543a19a52d5905825ca3831267e435d0ac59cf2a057ee56fc87f2f0dfc21b197dd326505af8c0ecc3f342236fb7a9960f6c7918fbaeed04d459b4931877bdddc6338a5a1a9c382e1cd676815b334ff7ef67964a3a2a4f81a0af4f5d73897998a49d07f51caeedc2efd2ddf47d196c50ec563205ba1669c6ac893f1db7aa1d371ad1bcf2d89bd806349923d8f9e10b032382647bcc3391b9377720d9570c9d35d4f7e9a7f56dc8e480ff5dc7245e638d69813836a06d8d5e4942536a74f8494fa40e17c18103c09662090765420a7a05601823adfa54d38cb6bdf5ecd16dccf1cd70a5d44800a9d6ee6f17ddb39c55815c9a89a5f4991f5784624969005585a65f09db9700c73ee5127acdc48d1e18b728bc87cd688deed568bba550d8d9039384a4e1441b6fbee091002b65b0dac5f8e1689cd27adcf0c81eb9e9af1ce3cbfa01bafa6e107ac68eb14502a84006e70cbec471c7da627d237195660784b918a68187bb6504211e0f2e240dfc155ae656fa6a66acec448a98b0c62e74c19ef21a5f45db26722b324e0f70639e78854e953987ff9bfa530f13895aff14098bf1a6ef42fdc6b962c9c450ddd4d901519518d950edc1c0c186f3fb59ca67e746dfa78960b21fd06fb159140490e442d8ef0b28d76de1aabd545356d430cc9013a5635ce2509fb9462d7ae6bd475e936799c1db43fdea1d42c33fe6231f0b517577010899cdd5de6b4b8053d05b5f3c2db9981c03acdc113a1cd1ba269406f26f1bb424fd33c373c243c48ad00633decb48bca03ea870fec3b69f658c442b4c8fd2eb455cbf4a15a9f70b090f351d50162dc3855b5c07bce7d39694c55f4de166e2baa4e939770a8344a2071e7fda3fdff69f6c80fa994f655f283b2800dcc166c9f3ba789089941c50217e6ccc243a4b6f001e8bcd7db61acb7bf89011fc2abbca37766a23c6548a5a23f33d6be021175818284f300485578324f92adbd530786d22c77d454ae99c974767b3ca65846bc00dca5e23c03c101bd3180dbf0dc81ce366620dc03c118562d31ee3f62e9fdc6cdabafa99e4dc2b04d650b5a587cba079347b5a7656fccceefee2237e066aec8888d388a4c455171b5a157334266981c2a77ce143731969bc86b584e405aedeb571e5b55f007eff24977141b16b26624c0e8f171c6ba46cbaaadc76b1b1efc543bff9113173d55fd5486cd11fc0a7789e484daadfc1759133f32a980a241227710711c5ceb2c38c88cf20ae7948fa2674bc15bd082bb3f1722e23c5e83d66f4e689431bd9807372e7724a7dd93d154a7a94314f60931d23528f4b8dfc05b2e310598b9ebfe364f1116ab02bbea59b198caab86f13a71cfb4d533efa9eae29aa4c31f7ff7b529280e22b270d4a3249813d5581af0de6bfa554774856b64457028fe5479860a783459b7ba6dd7c9a319d58063631ed7457647689e04e65bd85e1fcd10be2ccda6664a2358821a0fd436ccd39bb7ceb2d9c948b60d42d6366c203fd903d954cc39af61e066cea56640ad532598ad6a8cc79f6be715a514208dee378524017db811907f744b240fa4ba9b1d731b132d75d25822b70bf05085744f6b27d210e90384d5d63575a8993fc2193e9bfb40e3572e4003bd108b6e718bca0d8d96b135d4c3e8599120ad59141ee2ad91683ba020eec659cf40821d2e8461a7b8e713155af020c3452032d927f6b90001744badc62dbe57d18e0628d593d55be192e5490e67b1a9a32e0e6bd6100d2683d78b3a406230b8de3f7ad63084d50f13c22a5c3a66c9036888608a4cab47584579fd15e08b8af67b9ddf9b398d2a4e90044b41c17a859ff3a79a79a71b175f1b0af2c7e70f98329bfb432ca951f0109f1466310a0ba5cada5691d11f3b8abc4832ea1533bde6fc99194d5f1ff8fe6c5dac7878533153582f8e0e9f5a26f70474842dd185f5af58cb812ac7790f537d8741f471fc844800d30df8c94720a0011d102f76f67aa5f7812eeb596d503b0439b9081db92d1e875118f120fab12226da28775c36282db2bcd120bfa4786b851b2b04c11ca6a466ead9e9efea4574e569049acabc08fba889deb918b411530b280dddc150948e880eb064a52261bfba8e59172ffefcd456d8cd134d34f3e444ed61bf0ac6c46e7763c5c272db8a864ab19c929f951df70229d6e30e751976ec134ffe3836e8d891924092062bf25ad04f224a6b6e8b1b2e9d13bd1eec3d318fe691eb63c977e65fe4596f02e6e21dda83e9be44973a5d714333543bcc9ab93f8678cb86a042313fc8015153969485143dc215d3f5eaafcf6e10a1abbd9e77d6379a4b06cbe778d94fe0a1c16c5c0f1b22889d9d18512a751f2c00b8c09c00e5032c1ac565152c3abc2e00195e77b148bfddeb02567ac229f5a67a3eadd2055dfb72238e92d5e70af1d0c316dc9ed60a2439e269c18144ad48834cd4f21c31d551a8336fcd56f0c33889ed32284aefbde4e4c1149225e99bebc7a29fa1c350889c73bf5a8e3ca8bf8b704baf4ab1732a089db93a24102eb71422ca12f9a4212dbf009ea23ab2b4637ab062a64e8521c16e3f28de610fd2f510004fcb78df38461f128209786a47d4ed5516a591468eb58afc5ab0bece0372db5864f8129424075c4e8533de3872efd3f35326850c72570f7980ec74d1d7ba1da1424f533cf38f5a2195add012e58c74264d3c7b56ae92e79505506bcd3e37420c64c64eacf025b71efd0ebc86275b5db5e80f5bbe5595fd4ab18442f7b6dd0094393898fb53145653765bff97238ab0588499398d52c0c7d64fef404a420de0948e6633cb541b02086c78d1e7f9a403ad158f8347eeffee494e554849c1934982054ce7abcf877a331ceea85222afdeb87f6b930ada2562fdedbfede636ad306a976cf9cf3e59b3e7a5116dcb7761d4732b9a54ccb5a30cf706aa0ca8250072449b33c6b57feb9a2a11ef46bbdb99ab2b79aba10b82f8fe7318ac52f3f55e713c8faadb396f458a42f8dfbc26f318f521b5609d899705894165cba964a44a5dbe889c83b2b52c9e976778af56310ee2472779ba2a3c596fe81bf77890eb3bb26e7dd838dbb9b7d25a851ce80a7d50654381fa2ceb261fbbffc760d18b51700d90dd54ffb5f02df5dd383983788ba7d051e59d3af8bc8aba97550744ac45e9882c4bba5824f823edfa750531ccd479d73cefee746128f774bb2348013123c7e81f506f621e8f61d25a64391abf16cc216d66b0083873b33600bf95c11cc135ff264ba8c6e8fef2a7dea5ab8b31441c796b0a30379e28019733e4cc36f58107d69f99e59b6d30ac4ce9d8fc0aa821157e15a9c1db6960809bfa19064b74e0c7f1be70d31fa61214a10934598654e1a5bc652d1af03b2780d7ba0f2953a2570780d794907cf6131957c64d429c17632d55fa8533626ae8a3fc4ac2a6bfc425261547f6112c16f722bafa3d37a55b2d64ad809cdfa647f30f5ac0c804084c8a06eb0fe2228e8eacc18c5fdf858595e06e05384358aff86bfcb7062bf826db3537a782200de96904b45adae72e222285668e962b7748170865169a8bde640a1c8b395b7e59072a6881e0793df6414be2462a565c4aac81a80817ed75c137241866c66856774e52b6946d26889a7da497ef71601b908057254a38de9facbb691fb693e78abe8aa6ac0c1d77a9c553be645b8a56a65b4d3edc05309a24cf4bd32e8be206b2659d56e1b8e21ae9dfeac5106b3f663192d03eece782540cc692663a0d2c9bbf96ba1b82d17341246b7a36ba25071c25be181eb3ed7b9e920cd620c7682180e6dffbdae2735513c3dd58affd736f61fb87cd3954859719b757093846e88123b75e829d70d451cb337bf2c858858e12b1fc1572b216882cc9b0c38821b49519eb8d769cdbb460b94b3bcc113c60249c7fc30e745ed675f95d1c26f70068408543039890c3b559f30f6ce5663e9ff67411fff9eb3d9842b68ec9fed5479e6ea75f9db001becf83355e148ff59477413ad5b06307700b7c2d048c8301e01a3e6698543738496fcfdc8dd56d8684dab1fa229c8b8bb11b5dfc1c9c64aec69602d50cf36dc8bbc8037f5ffccf43059bf36815dfc8cad4888ddcaf75eff9723f212bb98bc834ad9e00e994ea9f6c5e885448c842514c04432c591f386840ee198f3532e862b1db9dfc422922ed8e802990aef29a461331cb7aba210c242fab2f29abec3e3eb25734ceeb28ad51d44a70e72ac8cb1f4f537845dc9fa29d96dd68e351f85785aeddcb10645eea53189da67f3cd33e7d0977a6ad5b48949e54bcdf021c5a3b4d5a13c541ea10c10d5541386baf028ba1afb7273a1e767ef6179807c8d098bfa260aae7ce2c71d8033801d90e80dee8462f1d39dfc31e269523a490aff8a1878789fe0369dca1509345d9c53f6fc4df206a6444e6e9cd36e843f9c1c2690ae75e06d387b074c043a2eb115bc65b83720b9a1b816ed7a725879839f8d4de92812a3b6d714ccc22dda214b3907af7bdacbe4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
