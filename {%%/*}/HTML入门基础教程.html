<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"223c41c730458b18dc6a5c47dd1430fca4dd70cd77192ab2eac9ea3e0fc3a4989a37dac97d703425256b2bca2f6fca1facdd0d1f90964744e75b9761f8137778da2fce2466a7bee8d68220591f029c28928c37de08864536d2e74fc446eab84894b0524680bb36f61410dc08d282b0c94eaebaa4fc51a43b46070c635b5c6f224b16841178c1bd0f900f50c8ed5e82dfb27975f9139e071ba1aac91036af5bfc986848771a674bc139a0bc24549d2f5371f74895e5f2df284341954b3d3c2f6f5ea003005647efd9adbdc7ba66f7e6fad448a278a02ebfb36d380d05668d1d3f7012433f69b49d56022fe79e9732a3e584127c9d63757fd3f83fde6d94fbf792287bdbeb819f2e50d880c05b71e223ed043acd9c3b3f3d27a5f86d412848bf2ba6a50e69a379b0912b3fd1eacfc5aadd8ce22db5aa70a071d52165b16ef202352900e8116dd187cad7470bd3d79aa89a5b0d73fddc2fdb85de3885f00be482ea5c80cde71103f547a6388777afc5ffd3178839d3b68f0da7ef5485f1cf2d834008ca60c5bf6b60335e93a6d8fddc67852fba6bf9e02025dee5b6c612639d41357029379abdbc47047074083a70e3ad6b4fc34f26134b610439a3ec0b9bb5d5ff2017fd72901d48c9c5623c419348b4ab2002ee7d16e59ef8c47d9b5b07d4390a60dcc81a75a9a553de67e0ea7b67d2eddb903df29f6a32967476cea992a96dd5983c4f60c6b8e2a45c5c16facf19f70cffa941a03b7005826ec4e0237c1a843637826d271c67ba46ae94b1a28ddbfbe83e724dd3d53329f85db054fbeb20bd5575eff8bbdeef23b472d6798fcf34c7c5ce36b7fcab6d89df4a44af1db71134dda8373cfa44f6901b1984f90d2060bb524f0a6ffeea3afa1c0f287a5c24e1103787f806c127e717d8c12f65a48cc41fc0a627654bc21c1c431ddbe8966995b4d847480944bdbbca20c5d2b5681916e39c3813bb763d3db1637414b8069dae0b756e7175d6fb02a18e5037becc988c29549e7b341a0042204d517f8dbad46aba01e8b00e08d29a1d2523f70f3df6b7522a79a46a6ca516831b4b7044b4c829ebd3fceb82346d4bc9579b72d8d1fb79f768426def29b474fdf57e427d94c743ba63bf53f33f31154676df00ee1774356749323f095f39f0170cbf8b232eb7a6dde846be67b40f123e7e0cd25811b87e6da59c5635936343d767c6e3254dd603e5720133d0064fffe9a6337d924b04f91d2897d870a52d59cffd40bbdb1bc98fa8e2ee279da23792ad3f98f8e1cf5180d3f88487056a69e50018598ae4c0d554c48ee884f48b44d6bc3474102d3e15f1ce55c08f78cad97f56619f8f4fa2229fa6a33dd3a3fc23b081be0305b47c1982a88669a0f39e94c950b5d7ac5f2f0b26be82ab8d74818b8dd78b63136cf4e36cfa77f3d1c36ccbd4f951ee88170d92705ad68edf32ee04531300cadbf1ad1f546c71faef6cc5baea3fcedc143b20265b7a676c013a90df5f6116352e7d3d11c63b67248bba7c4d62aa01f81eff392ee0fb82c59e44b74a5fe19228ed31afac740401b60db4a8bbc509c988e1d3078376b7188ff70752828d6d41c972832d847c447861c98ce74ef27348b53522489268a570f4f674d344ca4924932f97179b0ad03095049f2f4162b244d4716bbad93c0c180dc2f5ae9adb3e6d8c2454dd2ff2ecfcddce59f365823572d033c70bf95fdf2d40f667776be44858583abf4f850cb5d8f13f00fef66667fb632fb55eacedb4a8b2242dcef1ea73a9b112a746f01b958674f3cb9822ba6ff50339b8efedeb62327b86487316cdc52219a1c3cfaa77d034c029088720835ecbeba62d19c17488bfb9f9860e671fdc1e468557928ef23f85d67e5353c4a5a76c0446f17835bbfaabc1c9d852bf32743853b3545a6161718ed24d467aeb52e27c8d43eed9613e60c688fda0c78ac23bd3301a09a0dd2e8c7d482e3a07b97fb417654192750f15be4a2faaf07cb68907bf22e7d290990e109746d3731c89dd1f1b7d89797827f0febbbac974cd41ec417e88898e103816c34d13208f322e1216f518e485f04bea9d4bf4e19976d5c613334293830a853aefe39b4457d78d7ea28d27a3976721760aa681ee4d8f987797862ba186ba8ed125468b507371963b9a6aa2a42c82c046b8c1c531e5e1a7282a04041fcae011a14761f75b6bdf44f852c51a0d43422cd5a4beb811db3fe51278f45f11cd5b0e7ca6917d9889492702a91c41f0f7ce83ba71d8ef2c0f21f07b3e1d87b9d3d9886c57b14b3ae76f3ae80b15a5641c1332aa34366ad9537c72e74656e19494e4a361c19f72d357b559542bc037ce2e61f32530d148ccc40f40ee325d012b02cb84598cb5c7b9ec4d92eeb7a5dde336cd5c6db161b8688f163072ec2c2daf5c1466aefb529534c4babd74e7479dcee6d6f3eda8bb2e748273023ef1f8047adff10ba9df8aed81c9863aa0d66f13561d49b5060a72b58ff85c145d83aef3b01962528b960913a7add6ca2939d7d279bb8ecc21cd6e29b09b56e03069236a444efb4c0a726345c135984e3bc4d2fed22d928d950da5f18ab309a31080b0cc9d84a7d996c017d23323c3e93d75f70a82e628a99743a946a97eaee3133e122fc0037483e8dbeea716fe14962c579d64104571fb9e3683f0acd415eab3423daaced0deaaf0193f92d561e000689b7995d0fd92bcf3f144b13b4faac6e81c6e82a154bc8026ab3edc7f8b93de75287bff6f4542ce6e042b853cacbce506a00a33fe7f9f69403c8c68bd643af9cd8722f3d8b7ac00e958368c750459f03dfb3d70200161eb257a0f568b9e2797ab39eac9c06dfbd81bf939e409084c40df04459b9e25c8fdc984ac1f968e6dbe55aa85dccf5c0650ccf4adf8abac8be39c8356506d12f46f79a8497b2a934c0d56d792e3eb5854c339748190830e81604b881d223fc25625084bca929301da2a5c08931a319c5fea690f420b019514f097f8d56dfb998a0e298db743a8fda2b19a896118bab45cad9e34dac6a1e9895b475a38343d955e6979e14d5502e5dd3e11b3d8a97a557f14e4dc292bffa3ac99de6dda5cf4cb742d640bf13b91f2533e106bf6544c670841835cedd18c4bf43348b3e7659283ac97c2e96129790d276d3da70b2ffb72cef395045f81786b50854ab9db89fb8afc158d9d2febe5f34654a64b55a4fd84ef0a9149e06d18325708b48e60d48bf01f138d83396c1302670a62c35df1dccc7915bfc4c354b1df00dbde8b1c192f48985fcd423c8b389f0a289964cda67ba0db25ba2e24a20edd0aa9ad3456b29b1440d8ef7192b15a926bd8d22419d99b0aec2645b6a2206b584ae2fe7b8d8e6d339e98572b8a0480a02f7fcb28ef846cb1dd06d6ac4f916ba669bb6698c5a696078910094bee0203a0209cc5fc32a705e8e63c0f06dbeee535f4e32582cf5e733da26912171c6d1e3e3fd10834fe3ee99519a5d57580e7ae446dc199bf962605c96532dcb99844150628ed5bc6a3eb53e630a7e865620efe96c9b3b3418c0f5ad9efce08262bf8773918b3b5c2532bda236620f1fb7abdf67e6f2d26f08c2ee7753f772193f49a1524abba3b97592a4a1a480add6c0999e2281e2257528a9b637009889167482f9a4f2a07ffc6f00213f50b3cfdfa01524a4510077c99295b250f3095aa6faeb8e59174cc6bdc411c8933df1b3ab877fdc183ce2588a0947b68ff77289a4bb7b0cc9404cc0e4f4fca3b800745d63256454faef7affa79b657399bfd0eaeebb383d8c2f445bcd9fee62465b71c75d9f7eb83b1587201ad7be169fe377e5ab2071e91ae6edb7f55948949426fb59592cb5e3ec85c3ca68466eaf3d72e2aa6047302a885f43de96d98d059fb18cbdf0bd51cc4c35db968f9302dc6449768ae29e0241683842cab9c1a7a4461f3917d8c92c0de4829356131f25f1a74fb003fd1661d70e298f0e927a7ab85ecccaddddd6a5f8afbe859fae7b2449f9028acba9a2543fcacacefb29c8f3f685af779e7bd43a94caeb57c9a6a71d791971c70fda7e1533189dc505e32fa35c0faf252234d7222771dfa3a50896eeb491faa8ee67aeefb3c979b1ded2357951d93b1eea7a66736a5725cb7f6e4f0955f69f9d3eee39d9bda41d48de4f98cb62804d5739ac9511b50048f4bd68f556e505a2bbebbdbcea031ca479352fe6a8c3d81dce9f663aadf42e6d90d3e4aa1f1a95d40b434fa856d2e45bc8219bef22811f6801591f53cf38fb107a0fd2a855459521bda7914ac638bccd099bf7de0d12babaaebdfc4e814e1aa3c5995efa4e6009f3d8310facdd0aebed13993ddc3876def12fe87f6029dc8e7069dbf56f5b353b3ddbbb4c5bb7f2a439d125622f7f47f2e71c64febe3a87b3dbcbbd9ffed062d4d6b0d962ba61b017fa6b287c3a010bce16e5baa3984eb232dde500d4c122f8643a45272839f8822e7857a30f41ad729eb15acacb96651c86025c28fe49140136743b21d38218f170ce796c0b0bf1e2b00e141d45dcdd3632eaea5f6ea18b6c40fb04b43eec91bf34df76e58186c4f8bd3bacdb433f9ca4851cac7ac8d234008101436b1ccddce95317e4c211aeea1fdb72a6b327eb65828db8c4b65bc8c1e8b536e909692874fc73e3bc50bf4ae98e15ad478060b7ca7dce7aeb31ecb2d5e10fe95dc4b38e345d18a672597421b6a69736963eba847b85ca396cc661868ccc5f2acfa86661edd8bcfdbeff5831aa4e0b7507058b7d32e47034e57bf887e96d256f211d91cca321e7161020f1481857778460d4894417516a8e5267b335ab078b6dc8acb0e2577595010234ec43b8c7b35533d3b3d7711b7867ce37c76fff09ad734bdc42040a54ef6d3146df1c469d888bf0befa14d8ac2fa3e4f0b880e035dad012cf2573f70864d7a9449ba0dbbf9ccaea4dbcaf536932c848d54d775ea52dab0d25527377e91620e058464973c1b9a2497d714ef0a9519019138a0d50bacaf37fda724c208a4c381dace1461a9c6c3f8330de00ca090f7e22cdae3837f6943fd9a95b9f87a52421f7f5a69d9cab2fc7d6a2ba4837f34fc7d3873264d7bfbed846cca7a068ba0db600d1dee245df6e0529c266b6644f6e466fbdf0226a4df36b3cdc07e1c35ba73526344d2ad27a7b5458ec3b14403e1738e79cf06ba0d786ad1aaae2f194239ce8a1392f925c5169f9ba753bbe86a4a422259dd79ee93622cc6779ce5d28fb23e14a22dc433f39cc99ce3b98a5667a6602a1216d281329bc6e76778a87b8d9851c1935229ba9049fbae8c058db8c981243a49fafcedd6df67980c461af397cbf0b097881e22014b92fee013d064d90da58a3558be71c6d15c8186374bda1c5524167797100ccee604465793e9d475af14b481eaa8eb21b21d8f4879dfdfba6a11e54130b5d5097c0dbc49fdbba73624d522fbd03788ca8d3485b913c73f172abc391b518e82318ac4e14a3241a02f4890df120bf617f9e7ee99a62c1fd3abb32be80b31a7f356f5a3955d248c105042db3daba61e526d94d405a4b08ae34e108adb02785fef037ed48b3b57e4cd268b655054e89fa92981c13c6e732055dcdb6c2f1f8d795182d0ab66807c9f57c314bd828e3642e67c5bd83affd304fb807e194b7db02088af2b3c590d9bdb4ef3dc2f91efab5fc66b28254dc5e7728ef8e530a87b801f5a5d188e93998c45534c120487119ff360c52c324b7908cce95a3dbc0d821938a9e2b1b34328d7237979f8c3bf27ef1cb1b949f9a57cfd66d759a211c0ba12201bdf42fcef0eac2219b91ce02164557557148be684a4c88a7cc628a936f14ae80cffab65d6a51d381e4bb32309e9983c56fe1abc8f1de3e33e82dd5f3b6497dcd7b207845f490e0c1f27a195c758efb17f66f8a0524a6f326b928244951872bf24dab855236f44d190801a544a10589a06b908098f2466a41eb1095ae9b339c5a729414780b41ed5833a5151faa0e5463e5575154e7f6e5c88db8c2e01a442c990ffa88987d2ecfd6838124c4579f511f859cb6310ee47941a58feeacb0e2f8aae677436b3e35bf6d486fc9fe698633cdeb7cd3ee7e055f6821cbbdc95962b8889753e4ba9ebb830c6e047f06bbc8ba27be7b0e0ade9b51bc323d990e6e0b18d9acd21728e4754bfbf07f2cce2d19af26cf4dd88257d12130c043b04968265481525b39e46bdddac4688b36236d12177d778277a4613acfcec638b9279559a81d4f12f067cf085bbc4d231abdf4f6d64c10a3a3c0f8c95ca310e8ccf7e469226b9489715c856f52a29281cf57fa9ff90766b70bf1f728c94b58b8d05eb043479136c20cbb81c0f1b74ba0fac764a9f40ca77b360c470a3f9cc6fcbf8682f4326d0a2047e70ea899e6c996237af77a8f72b587f1a7ee83d04f0473cf9e949d8e0c7406c095449045594111870e83fce14457afe6b768ea59dcaaddc432c8a14de7dc02132234c54c7e662983d354acb730f5c5ff9cb2072d8c2cd4894e4508655364f985dd3f164753986a21e20bc5c768378a84f670cf453a8e5f70bd1c21cca0e19df0f98577c5598a9d789f1a692832cf258fdfc0ea4bdf2eda323d0f5c7f69e86243f6a2ed8394703f1b4160e2e86f19ede0815ec59b3eefa24fcea50cfb5cbc6ab3cafed0d8e123e283de1fec3a5d1424d7776d5defe07f61825740e988dff276ee8c2983ad35af3ce667a24cc5d28262da86cff56fcb290bc3154bdc68a9533dad157b837cc87860edaf7deea82b409f1c58326e18d6b3a05a00a3661a341f04f2e4792f473fe069708792214b9ea3b29305998a7fd83ecc2d3411f2ba18400339079fb99c777d5df8a0c82768be8577280326658c8eeeafa4b4a68292aaf5fa940fde9baaee516caf901a440fa3126e03262d3d62883fcf26deb5c9aa1fe2d36e71eb04b8bc705064d3a5caa80f2b95aa918f4b17ab4ce703f3be940f8b6be4eb8c5850964ab436770d8eb8829b4761d685429044d619e4370b0aca12385edc8cc426115e13a1f1aa87e64663104af018a4e6268acda68f8821aaa059881086581e4a0e0cdf2209c5d4806fbddb075bf31c88f70481133b7b721fa7ac08c8a2be7ace7207be03a9070a53e51d481d40d8e3b6a97c40f66e2ca73e0c5256227890a904befd566b6cbcaf14c589ccbacdbb6657c7dd9e74340d5bbd0f1894e7f5793c71b3ae3d28c3ee95d8626e2b346735458b826ded3b090ced98fec509d13c990cdf653ab2ac576926ef407986bca4736652e398848dc183b6e06296719eb0d3adaf74d71396eb36f7c6aa6faad399605207b219d6140824eb72c5071d2ef38faf2a3c953fdd03ee99041d9562cca8ae245544aef462a033dd5085b0735dd79c00186619daac9768cd116900a37f56e9e84e77a80505203ad85a1bcc31df3b2d87fed1bde723a9d4d7f8452ffeba53f17309f42279a5ac656ef87143d53b15d9287895a9a11dfc06ffe3e0c34ae70c72fbe8270f79b2717d2bdfae3742af42a8fc55d453e63764075f058352f406cd61b9abf6512f4268de4db1b28c39dbd58ac3217f5f4bf2f7d8df72d1f7842460012ed45fbae5932fc828a26c927354f5458f1a8f8b0b6b66f535ed1f27b5626db5cb483ab130fe0418b3c2ef5b8b8dc10f918525a91205254dc0dc49ab04629d2794289971a5996be8c48f45c49569e40e5994b52a7fab1a6288362a6fa7231ce693faa2737787a1147f60dc85c4dc493fb072942547a34dbec5f7e652cd5ac7543f289bbe2470a7fe73586c3e9e07d06d5cf2e54aa4a82a57acafd5954d6092a1355215fdc4f70d270e801a46760b1536c9f53e0b8511d2e1b785164b8e7ad00e6e29d1ac248da2fe58d07b33602865673234ea2d1dfb4c1337f6539f867f16f800794965aa844fa972fe6458bace2a4529c130f2d86915cef93f185068b5ef797379eeddb0baa3bbc12245f60c9b64c3431dfd2a4017d92c17585243931884c19916396b0189b62a2b96e325c5533d38b194c993242a2ad4d10f82c9d902e2afe08ee7f2127f3cad0b991dc435be66362589726c55edbc4b86b4f7a31dda3692dee1c31973728ab5eae88993a2b268aba45f8c31240ecf5843b9db4a9a983e4ff234ae367e44dcab14ca7c36dea358240a0959c4e8e673f67dad794729c23793fd87c239163a737d1c4f1c7fb4644bf444ad815213eed602ae68513a468058bdc483dff71c49493d342820aeb2a5711ffbfa59771373321ed6acf570cd6ccd0bd174daa4c09970a6f9c747ebd146fc0ba4175e8254f92090d8475050141910b4c07464ac8d22224b39b7dc5be947615c57ec38c6bfc837db19924eef80a022365b02bd6a3fb570824d8614f656f62174e24ce77c743bc85ea30cb3828f238ac46748c013d14cec28505cc829dadeafa9a40aea3cdd683806bd379641f4bc35cdba50f10036dba4b37b78ce97dcf7e0287600158f61c750bce04798abbc0b7b6695197a525aea189510ca05d2aa4500079e7c3e0518023d1134c80377dc6702e25f7166e234c74feb1a83da8896ca0996e4aa77dbb582e7efd75fdf00b35660f3cfa448f8a60a0cb32c7643e9e44a696f9a2b761059f621f83815223c23a7e11619c79ae57efef93ebe93101b0ec532721dc3ddaca5461d5b70f74fc4e42bc1331de1d52191a070021d2ec4c1884d9b0b1ed440aed20f83445901051ae965d58c38fc302502afa853334b028b7684482fa6aa65efd15ed55f448aa9ba2992607478e7278f9ccf66d53219e04b4823446849365b5629b082806dbab3183c85433d75a9768f800d4969dca201fcad340cd384f64ff2a17560b30160f161f79b7fdc123b4644930cede111b3d23931c67f416dd6108ca29224a285c1ab0f77dcbef68bca98bf4329bd5d638fd60f17f54c1ef7ef16ab4c64663e564a61e50a180826f7fe813219e2acca918e5db3058a7749b67aa24eec6a6709b633c237b545dc194474a76a6b3c3cfbfd884c58e5cb0b697a56963605baf807eb3b9bcbfd156fb1f743dfc9407e46c68e1ceed52f516dda55276b079578b9820a282069c6836df65fe2a331578a9908c606db85992e231a38707bd6b7bcc1905ce78738e3b7ec9131cd041ff45b9b22d44ce85f486e6c2bdfbb625d2c3d3c012428baa915f31a3a24ffbbce6a221542e88e8a6c0029751fc9843f232e8117e99eebf9bf05e2ff0808418fd45301e6d9b4bfa5e6b3ffbceed8703fc7effe97f587f5cb72dfc9511e0eff39830b6c56d97f04c64533c2512449323e8bf396faf698ba939a2996a72b7d3b83fa873fec41223a3d4debab25820b22f31755558a8cc53c34108d3ec901176726ba7070851ab011ddf42ab612a76e18355210e6771b9ef59fdbd1ed8a2f5a1e595a01c4c7da0f470da67e26fd6fa501f00f9bf22e182a554b4d430cb6a39162f536aaf1fcb8b508f4c872b6872beb17fff4306bdcfd9d1c3696e8cf8272a1e2c714a44ac1c726f9c2ad00aaaa0d5a3d83d3b5a9a46291f52c9ca7d2f5614289644fecba5a2cfadba13d7df0342eb87938c6d5e5cbec23c2ea7e7e43681347302cbb26adf288dcc82308bb99fe73464084e62cb8edd179f5cb2e1da41a1f70cc986e9dde4a4725adf2e5cd7945db048311c820c8967d91ec5bc8cc80584ee29d66df4ccce9b8af1aacd882d397aa78929ada84fa5500069c49c4d3d7ea8a2cc542e25bd5498967df8a01c28eb07c59b984b94456bad59216e41a1e833ffca2c14db1fe35e0606ca08e1c0467b68ff036033715fc4700382bd27a5fa9896767233e0ecaf2cb0837c5f4a14aad7e6f4e941176ba1cb5bf9ee87d3d747f01ed617068b869bd147983825aabfe7b17538239374799613d39ef2399b80e711ad8398e4531e9f2629a87b66f5227c0c1974ba3579582d44c5bdb9337184574bc5d21940b87c28a1111f5f9428002d3f7720bfd8143b5ece78ffe7df9cdc99844ab7fbe0e0a4b001aa8043053bdad61b4faf1b1d046005e64167bf6c95096f967c26ff343b52afcccfaeb89eb3ecd3b5d809a3ed8700cf73233c5b83e2c1b95a9571b55c56b4bfcd5a53c5fbc8b13f19a54860c4e1bc86e0c266dec3606769be7c2673daf289f77770093dec99849eb2aeba76dbac325dee6d1cec3aefee8e1923d57a81a6b8df58d88633978eaff425dd4d09778aaaa77178bf8f3bde85124d813b56a56a7928aee8d00d46999c4b399e716a02bf6f4a44e30537cf804f158da603a0c54bb6d6fd40e515dbe264d638ec27d08ca2f202d440aceb2f891718ca7bf191837a96a0f0c0d5fef715b8f09f6fcc3ed71d22504ceebe39ec0db67280b46f6d556c581931fbf01a4df2cf2c75225149d44b6b7330b6b38fed35b06567962fc3d31d87c711e7f4e9e4cfe37d2d6a9f0c83ebb9d0e2a86171b547ff8f1c89fbd04b7c184d1a81c1eb4458329a2f386b54ee8d8b723c0a5fee187cc4df6a3600f324f53348facde2e17318d46ac2d303b1ab4e6d80de39496eba819de53bf566e09466bd40bd40a19aed50ab2845194cb8b45b7c668306f898ba9295dc6fbe3b7ec915f6b422ec06b293af1bf929acdf4883decb53ed5aaf2b29fd59c652f4ed39c9f5d66d670c7dc1581c2ed5d36bb8ef9856c6c3346fcaa950ee7d2410cdadeba6aa77f81bfc9648bc11906f4ab965665987440de4bbbbc531161ff81871d47f9436d77df726a3f9a5a0517cfa0bdfd5fa8c875c1138c43c776a25cf3143eaeb4ee11dfdd82065f51c72abd8d2641fd255841eed86ad21ec11b1b19396efbf0d78c8f42f9f46717b7216a1ec7ec79b35d187083d5243cb744af6846001c207df9f0607646600ee52d85879f965c12a0f7cb641debdf7ca6cf0a0e0ca6022d9d81ec57b7b8270bc756f7177cca1b3079dc74ad8e9e3b287f86118a3b88eb9039582e719797dc561e0e2cb7c6c09be59d8fd6af5e9d388bd3d4e8f24222506c1422da7c3c21c941f7e7ccc1998a0a01d9390d61d2f2696e993672e858e5aa75ca465b7533000dd59e63a1b6eab89eb32b026544be6c83c2f4a4e3b2433852b182a136ccb9228973104c4007bec168d46379d347059d06dfc88894cd2b4220a3c7ac8b8d33280eab47eb31abf63d1a0cfc4c153fcfc107230913e972836e9f3dc075d5bd29207ffeff93bace4d08ff7cdb174af0cb99f6b06a0c43aa314e3671fd3be0140ca35ca7db001e567906a8b479ebd89a718b34d3430c874be83b550b6712d4d853e4cefde157ac33438a274a8faa690f66aa58d60c3f0bf3189972a78eac7abec9f032bb890b54c43f8f3dd1d4d8134e88b782fcf90864a81cf9899001223b2ba8f8e4f7f942492650367a1ac57060f4ed8639ce4348c2ffe4ab6cff5184f4475de1529312b476914404ae2d9170e65e197feafe55609f973338656c754e5d1e9e19f4e9cca029eeee2522c202dc50a671722fbda9bfaee3e6928ec5d6291096d1e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
