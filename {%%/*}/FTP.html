<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2bb97bdff13c544cc856f8365181699221ac14c48ed11adeb1069c42c8da6f3746d8831069d3da318e9df140d5b2254640b136b268adbd6d9506615edf5e51fdc650d33025716d572b395891e7663e13426bc39cef0663ea069d97b59886a1e9036459cf43cf10fdf91036766e06641b3bd2d8562195ce047d99a770b9ed6fa7025ec1573ef3c80e5c904e83559cc1016e76a0e8b79b7ec760663005b1beaf59966059f798363d970a738f8d0e0d69094d8c4677ea6d50273ec6ae92e519bee66b1122c814af04c56f01dd9388a4cfb789e0887ffc368b9a2c73cbf9144a506efdc30f463eb694243c50360550dbd2d763b38f83fd67699130fe267b6fde24d140182de44323f0f3d8129bc98366480808fdba10a39d0ccd89fb3c1692c5afecc04a753843c28716ebdae5fb7db663aafc1e74ba64500d4f2c95bf2c21bd3bcf082d5fbbf531ae91ff865ffaf5930465205ec7162ccaaf3e34f1ffe94700a3240ca9a1be8a8381f13bda23bf2ee2fa980953d8cba52ca437f8312000299fc9908888b3ea5f92b390b9973315323bfbe7fb5035039a3adb65eafe8b4cd69bd07d3b7870ce73c989d8cf1c8970381ee5a7ab013bbd82f505d45f06dd3970eca67b549fec42a4d820cd5e410287e157f87553a36f7a9fddc011ac3615953ca9b66d16d63f0d81740fc2796c4ac33b6b6b876db0044ed682244ef7cc37d89ac1ed058c6b845cb88292acbb6d59bb48badc4c66be239d3155f37fddf7138517494c83c0ca63a89b184ed343a73a970a0186ed41503c5e4dc3451477805d3c8919189c45d5af1a6e8f20ee9417215fd46cc0c449fa0a3bccc3716526f739f3eb75222aa4e0d8864b054e6fd07fa5458981a19fd414a300e2bbf9e4a274ffa9e992bc6355fb04360949026e342b9261248c4e0e560be90c7c3d46c2747d40c4721d610a8bfbf72400cafe7493fc1dc06c0ee38f26e7d5ebae8f9b1457b0d0ec6a3bfb80badadd77b32c69ea73389ad37ba15f0bd8e2a1e22d3f7260e763aa79e3d011cc1c60be43a3b94a7439d071604b5be7d4440bb5779b32299f27131f16dfd0f2618ddeee6e8415108b1b5dc8d070719f243ee0d9533559ce3a3616b21b45f7d80fb572155be619f4ed7a5ed8bb6d23b197fcc03bad85312c402f9cefe877a7dcdac7e7aa607d02fa55626133de8caa5827019d86dab2902a48ce517a780387894f128c8ae6ea40b74b3e3479c740688d3e33d3d9bf102194a36511f38be35a0128b78f19970edfa1e7b1a8978cf514dd8ca85d1e05784db076271c784c6ef8c6e79081d7f6a13aadc6ea3e6a8d2fa748d55accdb0bfac1eb541557418a05c5ce985c121b7bbb431efcc5539523c98bd9ddd137122bba14ea68b6d7f11772ff89dd0a2771a61fbf2e7a85e3ea157f26c7eb31ccedaf9f58912af37c45f80a3e241fec6ad1e4ff24dc50327ec6ead6af630752fd251e03fcab0be331c8c27a04d41bb68b7db83678e93a6426f1fb0f9ba0b5c1776ac360784c105d1a606d63910e772f59f9d106307f425797b553a015b425cdbb749d266bad93893c71e3df85457bb2b28a3be1f0f7281c4e48e60321c8abd4ef1d189c9f36c541db9fc87ae6f7851b795a727d2bad7562a60aa21c133f86d171f4f121ad548bd3f60eee30ba3965dca54c3bb20642e0d264e9cfe9a40269fc6fba87d0b4d438ef4c0ef20370fa69ded0d33c17657532519f15713771ae682afe3c822bf4677c16d42a086af64232ddfe6e03ab9fee9fdb63459b1c84eadfddd1b814ed34f8789353be67584f918b13e5ab66a43d075048d5eb66c91b3d5c654e4061cbc910850a2c0d17d10ce750bfd21e0e651a8cb28d58282527a0ec88aaaaee38239ba3ed82182d109a310f7da38185450beee85697cac1b12c857de40eff4bd24c5b406ad4bfe36728c345b53efcbc0091f1ad8f4bbd11f56ef202c41f99b806c356e88f5298d31d9d13a99f1e3d13598fa8db18a4c6ff3df1ba81c81f83efb3960e837fccda12fc2940351ed863009cd210e14d575521a82c9978a1a645311b7a05455fb7949070a81b5ebf36260bdf93cd60a4745a3b944bc601bf4edcc4401ffebe0911a4ced2372e417bdcd7c7854a5416cb96365b41b48be02ca0150c317fd8557f3b44af9354ccae5c2a1f8caf6f3720a1f933d065158043eb75e9921fb74b7a3edc94808c1de5676a550c6b52759a0e90ac96a2498123b50298ebc81b06cc5546ce67ba550a4025c73495ac346f6cde9e655d9207530de0f0c3e8d6c889236eeefb7a238afb57633b5a934997d2d9a876a8a1014ec6dc3f041e0f41b01e56378bbbd198b9b56ef1c305b632054e2f969d02aedaa4db8cfd9eeccdadb76bd539c08ab1e05a2e242993542a9156d646cb8da6096a2b1a07ed00be5aa3b54b31013e4d6762a3e7cdc0b7f3b20c343366516618aa5e9261dcb45deaf5ad661afe32563920b207a76800465d7a43170cf31d455c0fda7bd27c19af77dcff59b887321bfb75d38c23494677ef4002518b7b2f7aa037aea16ba7ae383d568d733f9fc069adf801a3758b10626a1edeebc6fb9d0c7e6b5e70140ebaebb651dc5e697b32df69a376e8036673cc9ba866abe0afdb502c250df183aa80afca5030dea61b87fd8c8fd71c70d35eed856e6d053c0d444d7cc621846eb33e7d917c9a8313b1498ed1a2e12fde4a024f51168b87af7ea68fb8c4ea951a1e50f025d8901129d6a26aac6db1e9b3f68482addb4764511bc835a0c6a01e2a42d5d8ada45ca729c2c73f8948830791d510ad84147450454929f58591f70720542a3c6bdfb840bb8a3c553af891951de315eed0d216feb7eba73847f66eef4e1f23e60a5d685f6184ae5ec283bf380ca78cbb02c22be4289d74802d2f5554193e81b9c9f03825da4d856f80520e10e6c1a33748c67fe0eb963b3682f7ea1156e71f68f9d054e489d8fa374d349500cc71aee52084d517720a6105b3c6dfeae23f58ef1bf4f858b4bc871627baac5e2da5c02997d51e5c73a1630ac994f7402372f4710ae2c9e7e1b9fcd2a6897a7c45abeb821ca72cedee538b7a28e3ac4226c9e53782159a07f00ffdd7e26f5f4b6d4114ab343a2eb1e545d9766e5a37c32ea825893ed54168eab0be028acbb540409a8bc416fb065730fffd56fa8f834cbe66671bc970895c25f21668f26bb558675a73d88aa7833d9d654a5c99cd84ceab1902858ea5829a1809cd37e54bf75907d97b5a7115677ecb77326c86e963c324de725b9b81a670f6211c536541eb47ae048f541f036dff8b4a655ccc30ffd0bfbde22056380f72c79e9df1e2319c6d3dc0971bf7b38620dd56f9e4088c6b814ff6db291e0f5ea348a89d44f274ceca2eb1b01d6b2690d1e9b6de3c22d83cd62c0b074dc48c9e5024d7817a221303450914ce9a531dfd2a290b5624e5a2f55f83b5af14ea40631d75d1f3270709ea333479d46f82c751e27013727567bd3fda01d78eeab5636cb720472176e2d756b36527f27b166acc35f99cdae7d51fe441e33fda49b21975fe5411523c7a90eca8947ab1244de6e20ee3e6c377f6819b3ac4231355c4ee63585d4f0939f88d44fc196f63a4230f0f58a31f05d6962967503f3831e6803a116e9fe885092004257a97bc20fd4ce83a09f084b4c65af29307570a2d89633884b0d2ef8c509da8b6a0d10e55a1072d52e1f3182c69c61fc81a981a5230c0ffda9d06c3fab244419c8011435db13f845e5fdb23115e95a43e10cd0b3b36580aa9d618b0db56bec9d1058c5b287b43664946842ca7820fda06eee116c7d9657d8e6f5ae0acd17324c43a0b31ee8c7a7046d781f0377493872a445ccbce11f98f295492ab48f29aedf15e8d119aa7a6db6d108d66ae2a52474854bdabee5005a498b069883a4744c00f529ce63520238c07cb3114e075fc9bfda824a6fb4c91f6f92c8669e85d43fdbab8e05581c5b0fabe007568d86048185b711e6d3c14e680145782bdc3fa25154e748889d04fda8e4656284d084dfe0b4f7d4d986fed33b60e5493e794c0f3c001de0b79c40b1e4ffbc572bd702246d34415e11a0391968f0c0f452497b32c5fe0af963a6f369ed83e51f986821510721c67e3f7d5dc1fa0ee07a268b4de46a0232e170a1c29932c34c875d6e5fa944132b600d3d4615f53d3f54d0451dc56dbb666b14859e4e41da283f7339e68553943a70f92b6232699736b8017b00b103b7bc037bf6bcbb9aa4ddd6a589119bd59066eb3397ad1f42a5f2254f8cf7dd1b726790f56cf86ce90a262eec022f116547de194e6aca7f4946daa4f21bf298e051143b52068a6a2eb2e399e577baa3a74be44e3e40b3cf8899a826216a22b8f2c2fa9fafdfab972e15df7c81b4102ca299cd4f0e6012eabad957a6a49f2411cbafeaac7c7de3c3681109166adfd77593456364377ee47239cc5dc19ad4ff95a0994d4a7ce944746742ccc4b4ecaa6f0ac2d58bd21a1c6020e7b937503e04485f4ff631dc1fff3fbab3baae67af0ea4c3267845941eb8fa9a4b51058751115ba0384e9b127d932b8930754637e9e8ffa98df742c96d989172599521363d1f7c74e537a8b2074b12acba9bfbce278f0f9675d5f357fcce1c56a33aee47be1ca7afb127cce79befb830cb73343d77e3de4bbb2bc0efa65863c8d1314e56bb2cb82789468c5f18472cc323f0322dfbd1e05892f0308f838e6a16655cbb76670ae2bc916217bf7c61423efedc6850f5d27962dafbaccd86be6624e8eef803a6ffee69f29d25e30d24036c66184734339e2af12599154ecd2888cdf32fb464b423f2c0264c7fbaaff9218be2955e91553670073bbaaf7ab6c21730c79ca89890b599043c846e34b838be80b5c8fce0811c2ecc7315f009a8a8a02e4ea4174628bc00a8d663dac50186e7912c327c7f7fe8d508a7e0dc0969486b79dd51319b24b99f21b7ac7ce8c8c4f59245990fe5e9d69ab0950968ae71d3efb84f54117d538adc1ea76688149174907a3855b6f1c2ef454ed3592a2be48b52f5e75a2de62b0563e6d63aea8a5637e99b6ca26443183a7aecb83e395bf65fbebd39913a876f1985e353c3d2f4af348b2a28cf8f18a8a2f82067f33441eb7f56e3e381f1b5cd021487c892a7390fb2aaddb341eabf355dda35bc3ca64d5f6f2419a923e5cd6191aaa2bd688b7f7400cdf3f1f0753ea0c093dee2f56c817ae5d35893d246c1da723ad9a689b98882157b669e3318cf6a68d2c90a69e3c4f3b8583391bc495e4196d64ee46978b1888360a5de1776de33cf3737b3fad3e74db1736e3acd9085c557a896d371c258d6130712ab35a416ec99f415af27f9f9698b98bee739a411093e13ed522eb4f3ebb66d9dbee0a59313a35d1ba4bb997d10e9e37501fffb0b0b38002674b9bcdbaae0d00821d7b0db643db7d814a8f8099da4c501698a05f472776368b5a4341490230acb6c3df901aa8317f81584326db107a1f119f927985fdcb30b823bb9f0a39581fda3c8a818ce76a8b5c71ebb372e1092ee7ec6a2f56fc50259b45e48a4aee85166c98bd700713700dfe0e950db0576abf822ea891909769dc8ebff40698881cf7df4be47e925f7922d993578db677694f6f879ec841f9375ad860127ce0c87f42f42ac3a35f453df82d575599f35b31c2cbabdf5e9fd66690c61743a4f3c4616fbe1230750514974a83cb51d64fba62420526b6275d0549051487fef6c0616df6a4bfc174f4c6a407555094d7fabdabdfc5aac21ce774676dd18d76f046e9a6ae610bb32e58ee975202ba133ced1bcf66c01ccb236bacbd7f2ea5dcd8675110e3872070df0a36408e62285500575f07a7e9602b71d381f2efbe596609839f91ee195587b9031c2ec3ede96094554412df3e4c74512407b02c331384335ea15ac04d634e6c252879aa417f1ec534460aff99e2f9574996f04d960fc1575c0170be27b2d2b7d91d4aa1471272283a5e6893c644e0ac790a685253f5309b5a5e9deced6e531b998fa3fef8bc9e8c91311f09ad1bbf433cf2f6e79f5c049b1723fcd33509ecdb6174b116a2f979bf75ccdbd01b62e377638165423edfe2608b172847f7a89275eaa40cdb96e9e67d83b19ae2a6bda78e6f0105becacf682b3c816cef3c3cd00e742c2fbc26e02842ba779bd074766843066840cbe2069bad5d4437e9676b4eedacdef359e05bba75f0ab2309c872cc9f505bc8349d06a8f86ca96d72003e62e7c6125ef4db406d39a7aa0d541e91e806bb335805f77a414efe2e041ccdf08271daeaf2e867869dde45f25405781679893640691aa749ccf3f7248cd0cca10979fbd2f951ed3d97f088ccc98d11cdbf919b29cb229cfa397f601765b80a010f508be43cdfcf187f7bbc6873e5be48ee2ee293b9a7097e97cf9f2c633e0025ad0f16e62a51c909a5d25a6b39fe9947f7ea31c5b5d3a2669d2a341aacafec87ccf5e63a82837b58e8652f0a3b672c3411a1a6bdff8b29e0fbfcc4ddafcd7b90570b4b2980c80bcf257426c043bd1db8bce48114110a040450c82fe903a08f9938d3982bc0f394d55901a4ba75c5830f4f31f5250a2bbe99a0ffb1435c2a86af4e01e8409920397b8a22ede2900c6e394e126904a6eddb2b1b87a398cd04f7464f993115533418a63be26bfa8910b1f0c1d072abf38ab4be0f385745ab751809c4dd8252e760dec88b120975d19433ba652c30e1e04d44b9012a8710db059dd89e1f2aca4510153f050046c142523d6af570c0b487b1cc3a72bbd88d3d0cbe815f894127a9f256da4f026fe193e5daf406d2631c249d6a87971bc649db312b4cc646e92947d87e65792ca2bb4a7af6e75847563516d017a8c50033e4c241146b4c57345ba1386ec36136017e80dc815d2e50d0eb199eb98f735d3717ebe644d61ff295734aa2f767860fb0ef96ac1bcf4e086a3dab84a862c590d2a9e2643c51074bad02e5c3f2fa080444efe6a2bb10833aa0f8eff58ca143af5313dc12ec29bb43c4e8502ea36626810ca2d03441c3f5234e891b6b2af226f77d98f75c08e31d4744c0cb2a0351c36127c97839657cd781572c00b512126e927779330ac2cb239eb19813c428361f73e5056ba03b49b6e3b1951432cbc248ea26df5a3644fb5ba9568bbe8c1c8d06aedb5ab82d9b7c7852305837cf7f929072aa43ac117972d0a3fedf371ebb8e90acb44aefa8928f8c8451c64f5b06ce02e1772f273f274cf51a9b1975dbf23043cb6619efa02b8ff34c4cbea7715a181faf498ac8e9b3d0162049fad40feae8f4dfcd48effd19f851e979ed765aac37cdd6bfa8ce7bbbce5d86b7735135b65d32cff0a4f49dbe1e89f0d14ab98479ce47e5da1135c0809a01cd88a1d0170bc04a8404c9711af662d7b1098acff1f1f5e7a7422ab7e3133a8d3c659f40d18d09cdc93c87ab0d5c41dc8dc06dafc55eb1e5e2cf5c6641e2deda6dacca31f3e708e73991ed0dc67cf7152f57abf3056e5c342649334f2d27aa91852e28d42bb2a93d54cef0d407b6a950d573aa728f0b035645ca785f595a9b307396021b71c1a9d2ba3c0da95af61c3be6e084533cee0910df9e91e7056d4f9172721dddd23d0906aa2e61247556aac18fc2b82981a80405bc15cadcac30777c3718dda6bb3ef26f7b44ab9ef5df694a51cfd35a523c2587c1e082e42dcb745e782587730245b3b78b5ff6e80cf43003b5b81ec9226a33e9394651aac070aa011ac02b50dcbc7ec61843479008f05fb4ff148df8f5fb2f22821aec53f617dfa6c967fe8e290ff0553f39f6267ae012023da78f40f56ace6c6fd93595c50b713e32e4ff5ae6b81a47b1bb6614c90c5c64a757576ce8f8dd5cd490d6a091a2d2fe8dbaea2715ab2e4af1c40a41fd13c8cf9e79802d2cb9cb246fa35b22734c113a86370588977b3bfbc7a58a64decbd107fddb926f5dd37a408899165fd257457fb0d97555177536b98cacf24c850439153d903ed618cd27c51e5ccac7bddd597b504d37aba3307ea9299ccf318306a14037aa46447ee9698c8e7ebdfb3812cd2bb66b9080a6de30499c5d92441d47bb010a3e6f6c35f157e76ae7de95eb2abf6adb400aa56724861a23a25bfed0c100e0af0ebab3a088415405c338288c8ab7beaa107879d0bcb49177e8fe92fa600ba0756bde6d59478c6eb121b964acd73da019c2553417f1810da049e4b69d66271ff7ef84e24a03c81792fce671d6863f4dbcd8a3a0d9a0522198b2496fa52c343652e0ffb428de0d855a76fd52d8f3f024892798dc5172b79cc927600cda39507c212b8f932d65d3fd7d9b4ce66ebbc6a7575897deec740f557bc8952e111dc50ceb5ca139d9ad7d6152e1949e0c6ebe3528064a4a32c89045cec2ab716665f94824fd7886e5b485828b469c8f7e27f01b632eb8382b280044435a5bcd9fdd80c4468499832a92138520d53cd29464200d8a7484170660001eba20709976365396f996172a9583d5432061a3b5bef238a505f2c023724a93da108c1138586fe6d119739329a77848d8938f2d5b2a619d41d88887bde7073384d604b1fec25f1b3631be2e73c196ea52dbcebd102ba6a337a3c46257d4652b648e856a6d9c48cd9961d1cc851afbf428126a21300b30302685f56a1a3e74af5a5286cbddc9b05a630dabbe40aabbf5cb67a8fddb71b937d5b19742faef87690b90028f74729dfe9d90d432b1a76aaa683ad314f3827057f0b4650dcf28ca51e8b1835e79bc25d58b3fd8c3c7e5823a0c75334d4f00c0c46171f27e8622f4b1207d686033d0560d700ef02f1303637fb5c334779856696e190b054e4b552c33d36890596668d5ce9655daa946f1b5ec1bbc58728c98519a3af917223ac898f54f88168c229d5176ab40ffcd7e8874c2a621248ae047d0607e8c470582771209f578d6b1d8fddbcb7797662d8c7b1443006c19a68db38e17132057515de3aab33b89585886b6c852617eedcf1384a9fb084188c04c9b52c9b5919cb9ca1f5468c833521f99a87611c84bb650a3a446cd1cc4c975f9f270548ce367c2061d076bc3352f7564403c5c7bd86efb14dbaa4b2186158cbe34843938c78b8475262fa972e988bf2c41970d0c505c5f089f4e6c40d894ecacd3decb2552a685023b90e1404cd4fffca9af9a92d5fe09aa93bacc69cfb8c3f218a25b7e6c23a984fc92dee0c341ea7e8f9f40db3cf0b2ad3582c7c324042e187de5867e29d22948ca1f4a56c3644b6a413a3991c50937349c017d3b4f12172eea17cdae2c307134854a8ce7f5342d3fa34b4982474a3efd9c6c1d0fe96fe500793cf0038cb59db1b684e89c056fd077b0c0871990b655e75dbf267254c43e5762e4fde8bcb406fd0f2073ceb951077153aa05232d756561ef4f5c08e3c9d00b4e5c07b6a74216650e13ca9e83c635fba5b96a136ccd31fc8759195bfecbd541b944eeff39a081a419cb06f897b047796779b148fec51e7dffce70ee60cf388400eda30d549f1f529c7572b41cf7ebb098a1e43911bf83ce73ea4f833fe7cc656cdac4291f7653d98e2ae851617bd0e244ec584a23c9aa00075e33bf726e299b2e9e493ab4d69a7214d2b26d23eb50cd8cbfc8bba497106ccf211772b03a8c21c361dc5113e4024ca0c240fa919cd673a647430d5c746de82e544b6cf5ec7ca5cc87aa9ae24fe4bdf0d36281a69bba5f011aa2f49d37e41b51d0ac37bbf497c0647bf5dc68050ec75550fca6cbfbea608040e378c830690ea88c03d2794d09d00930816b3fceded59fddfa9a861be9cda16c43bf734ab0bf65ae13045f925ba901bb70d29ca155c90dc225ef3419ee652cc88bda30046d815c704da447524c4828459eda729f5668d604d5366fa43849b0b5b525fb2c8752fbf0525d3bc7482f81ccb7e4eab0ba63169c88fa2d4f41016b661d7f5bd72bea434cc5986d614a287ff8342c017bbcd9e36b12423e3a915b1564a251cfde86715818d13cc8bbd5bbda6f43c88d1fbb85207db7a7a24b1e20ba598514fda9e31eb0c5f1446c34a8c7bbfd7c239c8f72b693fc7b7c71e3fd3774f08844fa0a9d55b079e086c6c305e8b09d9b57a988aa63b0a71b7045d997f429a4d12466ac224860a5bfab8c7575e4a05300a133fc9f07919153bdd48dc1c5b6bd8442faa6753c273f6b2412e659b9ff7c393b5aa3c95a0eab4294c132b30c888ee03f7bdc645456739e47105387f4aefdd2c961c7b3293e42586631fd2246889ea2820ffe7cc01ecb7e505411111e91c54f72570cc864db1ad47a98ab7c6f559aceba42e5f3207d5c4c569ce4342cd9058f418d0846dbac999200d7803a940c496b1d7235a4c2ce243dee4eb96194a8e36dbfee032b7c5970bf093390a41ad30bc08b9ea1830b98a2d1f9dfb582bc75dede92e64dc9a739595217a551062d3ac7d116688a2c3dbd92a4ae96cf06be3c8d572af254e9e8692397688ef431839b29d9238b71d612ee5d311036ec914321379922dbdf8cbd90710993ac9c6acb6a77311b269e0ccefb6986be9b94cccde7c24bff85bff5ab6f7d96ebc1fd5ef601bbf3daa83755f47480793430eb885ff0e45c9b117060d0035d9e7f221f388e88439aac917beb5b1ba9f3b425304f290fea1013d34558718b85903fe682b7f2d5416ae631604e2126096e1a4b7032c943d2adec1e899d80ba167012aa0511846f62dc4348aec5dc0dd8e793f991d30b20f9b316f9711680aae22e6f632d57c0c74c7c950cc864b4edb98aa379f0d033c4a0a6302b8ceaf1b6663722b87f15aa79ab23d0545c8e29520647dfe6f6001c2b202ae99620fccccd0034abcd382ad1dae1dfbf337d9cc3ca8bf9378cf7e4409966f7645b8bb33b45821825cfc755b86970fd1f19a1fd2dfb8ac1b706ed2ff7143c2260af2b422bed40534b31d02d78e533e9af7b6a9c03b6d87960820e66306727814b3eea312c2c746a3a680769f20b1fbea9f57616d0491b6e071a163fc68797f78bb2c238ecaaac42f1a29a90074d2099a8c7954ffb2fcf1dd68b96ff4e509a7230500625433b65f21c5906ce228c17f0156887dca093d7df70de2120659018a05156418ea8e888475f1ba2726a987de65d9bc2150024c9e9c722a67cfcd8ccddc56dad4c4557222013d70676865b92326629194cdea6bce6c5e40cc58e882e3b76cd7d0511f43433a9c238f57beb3415a5e4a22b180bfefd23624348563587782c2fe1ea3f017e80c8ef171d66d40dbd9b4ce2974a246c0813631ac8eb201e3caef3731bf70bd3a0f3edb8ff654f9287628b7d184110617fd0d17ee1941f368b14be0b4283d847de03d6bc0e6792fb9818447a7100ff3bd0e1d47b65c9d853ace1cd8c01a5eff51a9104e6882d4398354920d7e784765faf630f0e6fda4288fdc2b5e0f2a752386d326f9ade1b0837e6349271c7eaebdf695cbbcd2cbefe69dd961a402f78fcbf6d84ced15f826a891a4e341fb676c3b822c90f6030a515043ce6179743fa2b7566f51bace4fa73bcf06f0d1ddda5fa1c6599266a52d80d2087493c9d7372f8eeb3fc8272a16f7a0d21d55ef3aa5d706f2d9af9faec6000c137930bc4c7924ad5ff6be2c72208589d0f66002d43b5bfc9f65196934e52bff3342f4e4b5d4e9470ddbc8655f2a053a5b5cfed13a5626c820721d2b6184970ee381b4ecfd2ab8e2e37437d22a097bdab3bc59233156d2037b80cd94f87e2b5d39457b2d826352e72ca5d75c1d4f6cc8a344ae8569f954cbaca6d76acd5a239f3632f8516e01fbd31b15154f87bcc24fdd4e625db71bcf134b7eb4a188732d5c923c5bf7d91794e668f4623810f0e50d73d3eca301ab1e254f51bd96579ed18aa8620e9cd0b28af784a5843e25aaa2af9fcbad90153ef02583bb23c8a3bfaf06b111e7beff9aec40e833c27ed4dd8ac543b1c76bfbb639dd950ecab1278b5a471ed196ddf307d795edb7d176a3a440d4ce0334cf615696a75d978954465a0632f5b0a8d22e6e1010d88aca56420b6419ddc5bcc6cc9b3cb974b2d631df692bfa0f3472154fea196e24d738040b7673d9b0dc58307a15ddee2cb3d79f00261755d1c3dd460f2ef5b2cca6cc8ad57a28eef9b8067a357c7cd65348044c3e2b1e20cf139bec16ebf7fc7e9dd8d6ca8bc28027cff75e95736bea4893ee5364efc01c9d3cdeacef2c479321e77a7e5b1211dfadaf49ba6f84be2aabeefd691626f5fb926ca137d3b851e1ca8ec08f5619c52f2798f9522198d93780c47cf64e3ee9e9c76670ee81e7cad1eef2cd7e132cabea4de5f0b0351c1e07348205ee12d4db65d2490621634f597c3e5e6bac9baffd34e57bca61b27086995736949d9faedbdf548798be6f6fbedc5ba2bdca261acc709e31b342a5a3db1e23f9d0af80a6c709e05647ec35b7c6d2600eef85e6aef915a8eaa9e0d8abf825470022f70f5ee1604d787bbe54c6c8a400d675e226480f1c4d03338de8bb4e006c0733a9bf571160328389ec53db7cc827cee58d330b65aaf4fba5a085a30e920b8347486d1a7bea3ef5c66ba554b76b53cff4b8840f1071d526803b900e1e7496cc7c9f079725724aa59874765913f3ba30b698458a92c42b5b54ff514be63a9a4a055095b9063e7d952122d16485a79fa01fd2a63121565a86e3411b2371301f6ff8fdf4cd00457a6d3fa1045c959df3fd09c29f9e77115cb7caf42f26b8357715944137c40f80e71f1c1aacb15d47daaa9883ee78d8cffee81cdf6e5b7cfc5d3edc0428dac910009844785697c45724cac5aa969dfb98654c5b22eb5bfe42e60e8a3248c7d9ee812264ea0b3fff5b863132b25e5c56ebfbd238f0d9a4b8d8c74003f48cf1439d797e034c44e23fb67ccce549c12ad3a1d1dc45158e199056ecb0db25c911b4bfdbe7f18f382a0818fb99d9eeb50a82303405d3c6a131441a84a36c0d056c95908069edcaa383356d53e7549126012183a1105a5d11550469034b1cb46cc79026bac3aad8ff53f24901f3a2090a0d1533f4a327d7a338e26a9941797904d67541965e56d04e719eaf2962aed5f672efc78674bcac716ec968533df74166516329855a54388bea7792d3134bd465272538243ad3f0a884684ac76a505b712e6c2a79ee5d0a11959bde32a9cff0998185b58267319dd45d650596a2d808e8033df0b7d82a1637767be872273b60b7544405ee653ddc5991a8eeddbb313bc41b36549728b3eae748a1f9489e39d35315e1366ce7809b4afeeb48bd6a1a31c0d29f95ffee3f293b2b4b33049672c7de2ae641a0083cf441e34cae6825c1edc78700fa02bab20dc99dbb8365ffb2006bb127d04c32db162a1c7d54de192c09e0dc169cbcadf271baf9a49546f7a4a292a002fec07c51f83f2569506bf35d743617e2e846810b7627962e851d978343de2ca0dd28997df9e27ab06b4e91bbe6457c7c8a1b5b046bd3104ef97927f78f9dea43036ada077763fcf472dbf2a00903f0a7ee983e65afce957bd3f0d6e6257ba21e4e108e05fdbfe00445aed0387857ef5d632005a302d3f7da8f67c7cd6046ff08b1dd96f026465ddf6e6d93752da3bb33739d84e94dd67c775452a0b47523b04c7b82cdb54d7079c8ddb08a94b9c4fe16b7b903331605e8de15ec8bc78fbeee9edfae4ada56cae9f4eca8198b886bb4b08b1fdd67a5a89d9e8f3e1489b22c95d196bc9481b442751493041ec85ca255e736cccff9f4e35b16bca5edae08b035983aa236d13af2e89bfd15f431ce9d73480ab42847d0fa54b200fb632f0704babbdc8f3ab275420f9804fb55378de2089cda05e86c41009147b55fcb27538ad5a7d29d8d42db8f0b8d71832ffd7ae8e45c02cfacf6205b4608546e67383c01b5744efa681009b9b2b25fc3e65a3310685ecd43e701239e99a466d735b07b195264cb6bb7021078ec2ea8dcd8a2346a36a52284688f488edbe4e7e15452de8ceafa924634d92484013f3e28b4d5e186ead20c78ac8c840b1a7f01feef4204a658468d1cf3d7aaed1a716a32a920e3a58b20712c64bbb253dad6882d93c2f98a83b38b960246b1986680eb9d0f9be93a30f8333b3d913675d03613e3ea2678da65bc4eaff1db72b7d8da185222d4a6d997ed18d552209d9cc4d5bee9e462e8615563e00388a8b752d522963479aba5fdd77b1206fc2117936f4020ef318608bd7d0d38fe5383e6e0a0ced89361bf5fed72a3e8863e889a84f28ef9f8e2b4133e79fdfe31e9e59ee550a58c5c9e2e59ebfb52c6362738747ea906a863045f76ad142450d0528bc02eb6545ebc166bd890a1f856df320f21def9365205e55f71432ad243d1a5b6dcf7b644cb8b8f643f76cc169978f216fb4f6b4b9eed6064c5e740e058f48717edad79246d98627ebb61df71217d86851e339f318078c3074288ac5dee6d33b9ee5bdde18f08fe580eb00f02c067f8dd82fabcfcf26fa3fd322f239eda820f4cc7aaaec9e30334b77acf3edc7d9d79c704a203c53385d72fce23e86e0e6326da01379cbbb94251f6afd021eee3de46ceff4875a69a2089a02ef1dc8f871056af5b1b8b9fae996608a3c0f0ba29e72b124ee5695a00f49ba57736ec4007799a43836efc6fb61a4e824fc3509fcd876092b6d112e284536f1274c42e2547244161df07f424ede7b182f09baf16e453846aea6adf4b3cf95025d550497755158e730da5dd1be8a2f9b054fe6699264f6e5896dd9bd926fb70966c73652eb808d095f5e45fb5b0e7f4d4fde0ba66d159588e91288dc514f9b5a7048f1456e6d0933b75570860163b697c5352c03fc6f6b9b549135fdfeacdff6a030ee93863de664fa7ea16434cb18d6fb300a7294d1638174bd668c34d6f3caf75aea26d874d9d985039ded630f576b08d2dddda5840c441ec2b11a98bfc651af1f992cff9eb4f726aa5f3ef0a5f7995566161d6d902e5ae343ba6b09706b4aca4aa8bed8b2aac4e02771406cd50730ab6131c1ab6e59878ce53d3ddd73628b97fb1870414b333de95eb3e7c314ba864381e3d624ff0e4f4af552d4b702bf16eeadfc4dcaea516ed21f3ab0e57a87583ba3a77c6df4d0c5b7786a8bf698886100bda218684d0bb7d62ff9f4c574dd0d21e181b5cd4e3538c9b6ba9e0119071fd192f0823e30f893191d9e6e021bde41f846ae8df99952c8f98295e44b47f7443c80302e266054bea5e4f467b1b35e86368cd2073a6e4b65c055a685d572ec6082c98c56387bc807f5fe6d441531f179d14916e3290c3dd6a373fc2c671d1967232edc8c54ac26fa6ad258d7ec33d8cc2bd34430e9052113d12ef45804bc77031d08c87984193a281892f83bec28a2386134033c03f6fe27ec6dd1365cc0706bc7238106504269585596b861186b923a62cf59d8229933f2391f2aef3f86d8734500906cddbbac7366810ba0c93194ff7699eea41dde99a9d82a774bf24e2100fdb9e1b72f83e4c4efb92bbd042b35e9946a6641a351c3d135070111ca50f44832713feb8f2d09495762ef44ec1eee2589e348bcf30dd29d50c31c4e6561fc0476ceb22f5c6e8fff3076de55231ee1baccad27a5177deaef2a67f51b499b9fff1e4eb42c813834f92e5fbdbbf1129e27867ccf62cfbb0a66cac7a7127cfcd7a09e0fca5613bce33f274c06029a2632a67394a85a94e2332fdd82ef1caca5be4c2637b176d9b143d2f361d7243e925de9dd341e406091ff2a9569a9b355ce33c9ea58841db49cf16e4d7d160c23b74e5d8db36601cd9096ac07abd93b9fb8c8981c9146381ac9a58507b264c06d1d0e7a61953224f432f5d752231b2b7f553db03ce2bea33d16ef3d8209051ccdac6c3cc952e089ab63399abedcaa9a3d22faf90c4ba599e2a37413b2a101bef1ec6d4ac3fdf8144b47cb0726b35a5b4200ba0658c005901ca5407398f6205ba05c9296881d293b1e11be88e99b2b9743c323c2eb4d6692922acdc97449f4c708420f25c181e157f7415cc7b66134ff94b12c1d461e07c73572ee7254f2f554c253987b74b03255b13b53051032353910d01cc0e8f0a2240133554ab6e7e1c089f3b4e81be509639d43a670ebdf76e81baf84ab4c95d29e394413db291d0c9ad00b2bd735c893a2335e5c12b4dc39bb6767ea1773309fb7b579f824292a6f6a73dfa89eeb37d9b30654900a8ccb9b5bd41272b790608f02a5e1245f8f28adc6f84498c87b55387fba2973767f0a4bcf4a731e0881b9dd5c3f458f096d9a6d32699b3231702b82e742991158b7f42efd23c1cc207b4ffffc9601e8dd636579348662da92f570a191867c0615f2308a91875619c122dce2ac59b831cdf1568622a1d81b62cf6a81f0efb5d464a6af098b352d1407f0e02e3e86dde5d7b572747009fa15644f8307492c0ee53c75b8c6813d5f8bfc9968a2335928174338b17f111f94bab20819130ad1692e42030774758c31a70f719871d43f6aecc7e4b5e869f4cbded82a5ac8b9ef3020c6f133af9777f27586bb7f80ebfbd96cd6363a3c81c41e26109af97a1a4ee4394e53103cfc6d3c6c0b2bcc9a0feb0f7ecfb38adc341b0e050924603d81f1983e2814ffb07f4db64752b471bf9320c5287201925c02424abc931e95d1638710c96e7ad0facad393120bbb488ba71a1f7aebe049a81004f9fd098519785f43fdb9891b6ce644ef1eaf2a0913e216931507a8f186f019711a24eb6a09337e56029db52eba2f03a13aae83cee7161ea79635266257f023d54559707f5e98cb6d93aeead2c836932cc393fa722c2d8c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
