<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"79b2feb1e417129dc95c38d4b34d1310e22ebf3e249e03f22577ed549f90ba9aeaeab30e6e2ca69ec3aff72824fe23a9d344a71d4079eaf436a81d3f01a5309c9e7801aae43790fb4d16863426304a290061d3b783d9a69b36f003ab4bad8bbf1f7cb283f7a48dced3ce50f67085dd6270bbd7a76e2e84079007eb99d6533ae9060c45400fdcb7ce62b72c7df2ed13d15a671da0b7ba3f6d3b488c59588c075379ac10b871d4107c0f092c208c411766e159533ac53950f71051d4a23957e81defcc41a414ac3ba224ebb5a2a5a479835ed7c480225602e7714b041609e7976e827168d896ddf03ff7f9562bb903791ffc80b6dd9a5e7218cea596cc170ff2f690def0b2c58749bf005cb91a6349d2f1479f7ef62a43b3ae81422c8bdd9c0cdfeaf00f407ff43408c2826b0ad2e0d17949c5cd5251c1fd4c8571844e3bfe1516eb330f31017af74605c2a00f17e78f5d0ae02001f28fc423dd6516d441466443957493ee4a206de6f0d0308be026c7667b86b9ad8c26d01fa4cae77ec04928d911f53d985c21a19febf35fa770c3ae2b2d7a63b19191c4a46711b0491b29627232dbc82cefe12ef0f8d12d1bf790873d6d6376cbac6c31144645363e9b4a3a8202b9798fa6c5556f7b91381573a562786dc08250a36d7e13a969c4128feeaf1ce05255da474f47b55ac0080db26034fc6c106d035b405b8878e98e29eb25920b3f84bb73b24a8fd33214d05de466c7c2edfcc50432d3e4769a206008f377fe0336af337c31865711c25ef26b15da67248224d5db235c6a2f46e32a8a8b6b78388debf5078b10d5ecd018b7d6adafac941ab244d90b743900995ceae5c7aa302634f0a683ef03eefbfd120a78fdeb3b6ea2d8f53d964523d78ece6a741176113ef91dd233b210b7946dfe668a5c4a05e8b85172494c4db8dc21733cb07ed264bbc49982ab3670e6bac3336bb069f8503558367edb0169926c837e94aa6acfef6ceced37a279a9353fc172e19c62f3595a872b042d82a2c0a31fa33ca725552af5d269af51f0d314a75aa8f004bf8e2adc2ad5589f497146448536c5d94eee611ea67417a55cc89e561d24b1960577b248644042b847b521c3279d59f629d5be69e90b9caf76a3cd7719c12d8c3e40b30e92a819505679d6f4043caf289d954998d549d6f6cdcc1af087caf61bca2c0e066b682b02ae1ec67f255b396efadc01d1de03ebb1292f9e0f06950cf811971ca0b2ff9b0418e13d222bde392703e6ad61af2bd7a11131a8dfb17b1463c348306a24d550df0e6c9d32c1c9d6322abc0a27fb83969d920cc10cd3e34c3b0a6de2e831073797c584ad3f769d91237a20b11f7a13ad16d5979b0c9d2c4d4a1e9278701dfe6a024dd6a0bb036e0390f0c6f1dbd4b1e0190863f60aaea37b69122ea4e5d5a800d4d3049e1a3a8d440ad0fc87ee8adf63808116e7e7ab1c8785a34c6cead76cedb4c84b77e4fe4d9b1baf56cd41351b37460892de6c29a589f8583b4209f071c7b248c0186cd1b42c804b0f4653ec39604b7a78496a4173b81919b255582702c582dc9240b5713e917afe658cb0e857f5b089aa68bfab38b84e8a33ebb46d25f2499b55673853f66b2d2fb23ac6f39b465c7428149b2906705ce5b8ca90a2b0fcab4f98e9b80fd2904174c22af7ec4cf82e09acb9efb1f47a028008d899675e5e994a7b6f866bb7dfc0ec1e4e76747d17d03c407100455efbf75c2d26c77665052e73b4575eb1433e8ce2d3d8c94f440235bf5a1245b1da0f6c14ac98850165ab2edae25da9ad5e043a7fb74787525b272a954b0efd882ba6b2c44a0f272241dfda27eea2eb6c40fa27445bcf657aa99552bf9a121f08c86015c55488a8335bdfd9446dd910f0c4b8b8bf2b1f08fee467df94b987bd10d0a312c41709a7913d3eb1e29cb088c4cf4635cf09b9646c03fd84c9cd56d7524b9dc4a0d6b7f1c5008dcac544e910f249c94e16ebdce433344916e2cfcd630e03bf9890a89e39a897dc8f0b5ffc20facaab40abd4f4274f60e8224963770139309356e11867991f93197dac292383953fcdd7e80b12773ff80bd9930e252675345760abc6f33110831d27e2a0bf385b1ee18b486c6cca0df9603570f6b9205b19a53c1f044b20badf2f1893a2efe675fab33fe9d49fdacbe2001ad3ab94aa1658adf3be041ecb0a2deed4293318af339197ca68f59a9df9601a1612eccdced2eabbc5869f05f5294e1ba0c653381652554fecd127359af060b0bb265633507b68af3ad858e828d14133301ee259b3ffc20235e41c49c694f1f2354946dd0e80d329dee5fa73312d3caba6bb1154499517fe4e4f1bcc581a59a9a503185864408ed44f98d0c7dc0b0ed99d59ff85b462aa43c997088812cc4148a9a731ca3f115c853348850a4fa9821b762641087ccc45bfe42a935cd794e455ae1b6374188f882cab12ccd57297eeedcd52545f6793c1352b32368c5863f3c0e89afe08635e850ce053377a78f71aa7d5d2e77f175c50f9f607001e87e5dd8937c51b314bc9449f2caeec3029dfdaba038d3ed2ec06aeba6dde2aaeb3124d3b0fdccb7cc6e6ac5ea0ba94ec0fb7a022922f0ed58e42f525ca0521398401bb385ffdf3c3887d7dbaead02c2ee34b6ab00fda96bc754ae7661b99b268f111229aa06285d5ad78ce63280cd872b5a5308de5b398c3c083dcd001ea09ef6560a4a23d0b04c46306e3123f09e12b4eca79cf5de81de3c7a4d3f489bf5f63918199c615337431b8ea4386f247fd40d2b1409fb89765c1456892e73de202111d2bf14649b98aeaf7a263f64ebdb010778a99ee7ae60054b82d14b4ab84a321a55353b8c126c33c06336c3ed0f960bf63305c3c2c186edc63b5d925e5022287d44a216c06f47826fb79da4df1acbef26f848d8be4eb9a9e5fe825a462ec6b859edf5d74116182750828430264ca641a1b4f139db65848e5c5e8ce109dd65b011cfb919dc679e1562a23c44eaccb17369dd2d73f2716f530dba02253e83b84eeb02aa1ac06958c7fcba84566cc94951be60ac6430a8922d7fa9fe236ccd01a9bfd0c83067e0219456d57b2585e3eca8b5bdfc129690d07953b7ccb7451aa740c5f1a311408e980cfc11b070746cc12f7abfe96f5e3e2ff6f2b1401c5d35d406780779cff58dd3a8dfc4d83766b80a9df66af7c74a039a6e8a7e48939f9c5ba93b3d3feff083ac8862abc0a38ddfa707bc9eb9e5207361d79cc8c2b44220843d3a084fdc6283bce90a49aee7e2bfa3f49fb0e4e8446fa8dd6bb8d49c4feabe2e24b098056223af15ab5822871582b2cdb60d36db71d47dd71a60446300241990f334a75fcd626b110542fca865cda5ac8225824a4dba9847353702ac08aa8bd93fbb756868b352f1c1dd42bf2fc7242f50cec95460876231e448cb2dab70a3c277f94acbc516688c6e5c09f765d38f6f233807c805f856fafdac8e8c3570ae9755dd88ac0790fc4802fd32d62c4e52fca7c309a4dab9ecbdd786d6db497037108bd5af90e4ae7b7bd053a169d3d11b85b1b29e043d25165a91104c79a9d894f30697447739250b87b1899739f1fded4cdbb60f1a7824cafda9749131a870f019af7ce58b94e84cf9dba8d853e47cdd7f44d8590f8e94005b3bca01203a838227e8cca342f58be0e50d266eb5d8d1994b79b34db39be0911f0cc4b21431c5932d2d344e9b2b30b08d57791d26be93bb2840a2e39d8687f6e14a126280e1866f072efa417ac9b2e37229c5a3694cf2cf7655ad36eabed4a304fb5dc3964ff0368f3b56fda58238ddf739b293cacfbd9a3a96ad1b10d8fbce83b0a52e39d7db6d9736ad6f4582a9bd3eedd4da9ed8096de05295ed2f342932d57ee77f08b5c17e60a5dc05415c2211c55a1699e0573b8a0ccdfa64c3a57d4d00d462443968d9bbbb907452135f5fc005e27c6a5f2bc6d0a635021c287a9a2f0e737e3ba4f09d9656f4322e2357b08bf54fd72d77385f99f7b113ad0fed8626e75be77920fd912826d1558818101f45b15d8b05c7643f7bfb884ab3aa8f6465395db0d0908ae480a724c3b1c4ba171a4f6d876b034619a4c116cc71b1f57995368f638b05a108dccdea65cbe23487d6ce48e18b658fa4d502a76b6c058513e451b54fb67308d02141eb8d62bfde5575d83eb1e8f822da79e3410f12c43340742fbbfc2b4ed14df50534451451637ffba17031c08705dc90af4c8ee43d75e652534579f914bbe8a1933b9d87d0b06533f6d271b807d4eced81de13deb81680b3e245ae4df1279194db60b32e141c7243595cb8dfcb429e2655ef7e719deb07481344807cc6e6bd879a99ed824b446746f0971822f91def3bca49bd2f13441f61dd2102180f5cd293a3edda7944d23587c215b6bdadd42769944121c6cbdcc5e744810c700220547ce3e83dd627649a45ff16d3f36832c73303da801e82aaeda10d9ce635f204d731f9fc7163309453d5189bf639035e2b37a302766cf036568c14187df273baa47e95edce468661ad2fc6a6798e8a61fcaf9f18edb251b52c103ec3bb8a4d6eb4cea0bd227704a2b51c844bb13aea0c716093fb1091742f750515a0327e008049a60031ee444f226f4bfe857519816a6a8822f671bf9592153847c36022a9eaed1b7b4da38937322fc8b8949aee15ebed67e244626defa10fdfff12e982cfb39b7ca470b3e8fb750b155e03228160ac913e961f26a4c84492f5307c8c5c748efdfc008afd518632212b1f8b08911791a41b0ed0f65a866289039bf15c9d36a5140e6235238a798230c06f6d0bafd97f861731131b43e054af83e6c3b021cc52438b923539ea20ad4c2bd02976e425f11030d52051b71571934bde629f8f87b84b0d414a99cbc8d54951fa147578da8d0432eaf557e20d54586087bcbbcae2353a3ec49f4c4f2f5118f93d2fa02e01eea1520426b7fa174448aefc70d2082c72045964424d293292b0cc1e35b3ee8c7cd3ce744926a26ad37e6e71b497b8fb08f5692e4286995808423e3536bc1dec18d6f01b9232530f5802dd8c5a87ea6aa9ccf1eed621c0ddb9fc8c523e788ffcb67cd706d44947a173106d70ccd784e659ab8bc96f89a74a74c4f952b92f4c147114fe021b8dab625167531a4d8031ea3ffc795f4ac2ca93df18567b4d5eb835c41216cf7f3ce0cfe2e9cd9107890efd5b541d9682be795fd201def04488b6c2fb15c8fcbd102f30dd16fbd8872ea245314378f1a194f954af27bd342aa0e511f1375cf553c9e91f269f3f5cf756c5893ff0596910fe82a9eccdfa37b646b9cbea3cafaa60557fef1a32c916bdcfd36f95b18101ab751a05e542941aec143e4973782aefc1bbe5334d9ef9131439a5e7373fad1c5f15ecb1a484355c31ec335698c51d3b2670d0db12efb96d9176bb7469759c7d48b00484cb044548f86234490049146ee34fad15f9e896a28beb41971bab1f72f9d96094df952a41926103919dae483239a80984b197192f122b419bd6d4dc2ee88ffc400e62149228380e4c9c79c683026a6bea44769fda8af8a42db9b8da760e5ed7c39f998cbd4a0667225824161d821b7e6ca77f9188c949d28c1f3c3fd3c303b2c193f38304045dab66608ccc190ba18253996b1878044b0408bbe44da719f4449638a9264247413d1d79c6d681a9764bc37b8a9f4445a05af0c0ef5eebd88a5ddfa1b75a7a2d4ec2f85a4e3ad94f129f761a8b376c3ce419e8b6faf61fb86e60e85fcf4c15a2cef108dd003ebc6943af1dfa951c76bbd016cfcf5e8aaeb2708c473d0248b2b9a50b06d19e0c235bec726f090c17e81e92293256eb13b69e8e0ed2bd2ca7e721f1951533deab4ec7a3ce672e345c966cbbe7619fa93fb621e46ae0b599cfd28fdff3461e65271f56d83f0fbe8ae30bd7afef3bbded6efb4424500849c85aba1ffab7fe465c1bcb751492f1c5f957e64793d7a7b090a9b3f03dc99478e21665c9e2fc1ea42b141523359802e8d6a807dbbfdce1d379eba89bac9e1d84a30b18b2f01dfc86cfbe2da39d6fd868dd5841551ff4d10a4e78f6bf117f4e3ecb2930e7ae7bfb96658d26c3e1c8c71b648b503b24ba730438f35befff52c062263629c2d316cf6b49e4b78406f76f42df40316f121bdf74df3ae4d6aae35fc80dcf17ebf3f3326b26560b09ffa460b06f06865dc2ac47e70cde5215986f1f113eacb3319dfb431268dd2de6c18b41fb86ccf19de8b74d25d18324c581ab56796be3582329d27ee8bbb91f690e41d7a2164f5fe5d179be75d31adf9b85cabbf6855c0ce70c3857f31588e4850b49b1a56fd0b084bd2187b2747428d68c49ea65904cafb8b90e3997022e4c0ca978ca253b1f4cc046cbe0f5f2124ac46dae7268d4c41ec0f2e843e9faac1ecf3db22b145ac6ae747be791c565e12321535a7b640495b937a9491eff5fb56f42d332c19ff84e63b3b42939e4d32a1712169815d9b6c9c34a25e4e1576c3dcc09f105cba01a91185f51acd19b6eb17af7aed4ba908b16014d2fe31ddcb1ceda437e801bba0a33c92d5a0f52c79d03c633a4203428da061bb3984bc544eeb94a19447cd5a07a4f2165074c8ffda34a941c4edad72ad53fab04245f1a9c9cd6cc0caa9903259035bcec7056592a206bf60d9480a3533b91c4835e2115c18d1b4085f429e32d9180a115960b689860fcf4afc3623468dc756929172a1bcd3a04d4942abcf37307780053b30651f9396fd0e15ecd40537f72ae741688f1750f7e3e5c1e830a7350670da5771e4a40e31ed83a930228689d7223db1ed1a80b2b2e72723cca5f82d7c2a35d7c06053ba879efa747ee2de43cac3066733acbd5099a6cfe70b0ed27ecbf21ea145cbedf75e86c851230587759e3b89fc98ac9e6f699d17232f84a6bc4590ae272d1a2f3e4e5adb5d39592cfda6c3f456a3bec49728f10e5b92ed4bc0d1b8b9391264dacb9f9afd8900018dc1270c0ac2c9ab0b2499842d6a902ab9467e8a63cd0fc6b9b98bebae11ac1fa6e260d12996c2e0df7200a2aa00d6994d4c30577a092f4192e161f78115da3357f6dfc85c42577cafba401ff059fbd8d996796c4baf7e61ac781e22c2e4469c6561c277041c177f7c3e59a68c54fea1f5b7299131c72187d9830da56504230a3867cc91416848acc0a08203ce3d221f5bf239101452076b43827a173bc87c250bd9724981a4882484bb428e307d8d3bad2061c57f8ecb8bdd703dc89c347a1cbbd3fa0b3570421a303afb4be644617000b8ad56127e3764fb173f37674ba5de2b962ad3cdd4708b2554283a10309a715dd59ab834aafa480d00e51a8429f38eb586a63f3b58d3afe05eef4d13cfeaa76bba83b4a70adeee09345652a47ed52bb21204677b79e082ff82c9ca741f5578ead32230c2a0b4509edf9d5355e1460330504a44c70bd0686c5653d318f96c348ce9df171504955550be251f1ac68dbd3a2f3eeaac45d1a1b983f07666236d47d42cc8d683f9e3fb506ac95175a3ad5dbd3701d4aeb5c4a5b3d50c5f9935a5c857ae39bec86ca7bb4a47ed9b840abda75370d0a068a23d00a81c1825152da0c4a6bfb9d389afce4355174fbe6865c6c279b52122a22d8af467bff9967db57a231e9a153a67d95cf4325bfcf7073cc5b0643ebb7767c61f37f2f149a35ce1c6751c59616fab9e96cf0886122ddce40c732fb6dc8d7eb82c6c310efa6f0a21cdea8981e9d121b49ffd18b1330d8228fc1695a3fb04a2a7eec473097cd4f21928bfd8eefb7dda936ef325c298aea60fa638110f03a9232cad5f6a9beb1ed05b2a442ec5c865eee43752191dfba397a42e47fcc93833131a8ec12be25acd73a94108cdcb326e9b53d7d8174004c27aa6a2f2756fee9622fa923e8092cec021ee0cdb190afc3af0f4c9326f589392f018ae35d4579d5b018d0e8be93cc5b2af28143ba1956ca20ff3e75f5f57bbf55f2dc4f8fbec7eea1d432baa573ec33d141fa896dcbbe4bbe5f5ad5e5a0ad455b84c35c4161ac6e9b14c0d786c5ac7671a95f003fc460175e4a8f5158e68f3821b08def3a9d53a2e1b472884c1be8957fd8717c4ecfa0aa2ae2fd8c39e3251b1573c20891294909137f48120cd94c2252e16d2d5174ce21c8133720b23761ca6810c0d0d41210441a3804ec67a1b93c365af86b0ac01ea7019469fedb29c2bd5a6f1bf724d0edb40aa01458723abbf1103571529306ef6fb2fe5253db155a2918ed3d3b7c6fbad84a25061a3858bddfbbcbe4e9e338500c0bb3725073b9cec784e67f387cc5b16018e3b12d72a89424e5bfbd7290021af3613217c9d7427f87b5fe8d6728bf799c525c48965a5b99bcc007761737d4ed832117e5e48f266f9f8a0ee471d5954b11ea0b994373fea18206e218e3c2b959c8c34b29d40484ba9189463ff30f84bd9bd68be1d7e05767c710d7f0a2d5a6cc601810407ed57aaaee8f81c030d9a361b53861e4154abac9b231290fb61ec88e20a4bb4c01e062b6bcdf56a53a91fe6bdad94dd38a530ba56311e88f62376ae5640f302bc59a37f708a43a92549251915cc84c2f5896294317f8ab9d3a117fafb8eb72dfa63a26b7211b92b8b1c35699b8ebbb80b96552fee0aaa4533a80920a07a74d2971f657bea48607682f15bddfec382bd52caebeb43d122915d4135b72dfd8286fe4211861b78726f6af91cc09843f43483a4d65dbfc5c18d606908dc3d116bd3a6033f8824123478fdba1632fe000f0032ee50ed57ee1b04e7f2a3c3a59f78c6427113b981d348c05e824fbecf216a8d721916f4a5b6593772ef7e73f9e6f41bb9ff69b424561e0a0c54a76668e97b054c3e517f50abd9dc3c2c4d26c8b0db029e3984f72fa0e4be64c058dbe87c4df40ddffd55bbc857cfe0c7c5ec3f292cc3c3a7b33d1b332a23080059a6c9a14940a1a89d28a35ab45a78cbf40d0616482a4969051053ba0e4ff3a448357ee5f551647f8307243e11c79820a5564f530321dd6153c64c462a58502cf6c84fb830767db1e847f2250c01d29f7bb6f9b7ee0419d993c636a835ed93aab3a63883af8fe1b8d72e98bb11f1c16d04cf0fbde1ae2e287757e588d6ddee19fa13a251f29e535e684878b828b944a0d169f8e4e2548cc21e83e8b37f92717e453ea5cd5c9b3bdf8cfd15ad6797c6323227fb8eabfcb86ec5b8ae0c8f9c553f053fee1c83341f8c68e1045cc0a90b2714ef3deb4c6986a48cda7eb956792ece002449735ec1bcd21643a31904a2fbd5fefc97b3db3f96b2585260a57199cb90479d2b7ceed30ef9c2dc3145f0a98f47b29df16270a8bce9e8232ddd3d4a068407f1daa4fea5a7cae929b8ed457983c5fd995779a950028e45e8268966757e5825f046f79b8e747544ea489f1145921f63aa8a68153d9fd2eae476b8b1566ac2258c1024ad5a41c366342c9bdf3ef5c5d70e748972367166e66d5c50e07cfa2d9269229763400252e7a51007034118ea2dfaf84780e24c720be3c3aedc1b6d7bc38767b57985108151106729e1abd7f089a2f0ec068311d944867137a4ddbd67eec6f6b6abeb14240a093b98b890b0f714ae0251065b17cd391174cd4f7574a6e8de2eb1a7b44fef50de46f998bdd4e9710109fd2deeb95c2ae143b5d7834bfdd81376dd33e199a7e5f84b8fcb5c5f9bfc70ab2bab38abb8570c913ed59a56942977e652dfde52f40a11d68e3a143d60029087a9b361ee4b89078d081496664724ee2b2b41003e3a839889205abccfd2a690cc75eda0041b9951c710daf387ac182c4a2a8490bb6906d839f53ca335e206782e165882dfce58415e923f0f41a57e692a90a30f38fa3e67887f6d55e5e3ca76c82ed9ed1f4075e13d9b375bc033a12659b92a24e47ceab69012622937eb3abd1b252a31f42412eb53b05d1c0d3f674785b187211923c490bc8eadb82663a0df57412e4eb8b8ed55d1b3b462aabf75c60bfebc66016011b474ad61246669679681034e8132a21693b742cdc8fa43018405bf98416477ac47b3e7944206f23d2aaf1956380b7e852faf8df6514414e229aecf918dbda046f4101a59a4128d2c46f5441a84861df4224bc4c34cb045f53245b2b2551fe3de54130d9cdaf499adf674574044e8556ef08d1e571f9b8bc75625317dea8639cc83f6616a697416d1b3ae4cdf2cb146a32495e8e9abda03c3fc32245ab7f23c3b50eb2505eb346d464dce6bad235667b5e6bfbcd3fbd174e6b49bd7ffa22535e0d931ccdb3d436a40146c080a855900d4efa9a305daba718fb735ca81757e6644ce1b8500daf32502c0e50966a75d263967d47be54d59b81dcf8c8c591d441066eb403d5b928b0380a45eb07535e5b3fd356ca093165b891c85a214f23b2114eaea706ee484038fb7cdbe3b496730f64632dca62966035c88e38576333d050bad9b08dbff07de20b15e72b095ef4a914d0bc7d9b624a9664c3c9174968d27cec4ad83c833e193af444d05fb39816c33d4691c33d106ae0158e63353c261e4f570c29b46e2c14e8d4dd17ff254d9099865474599774e20c883f3ca2b4c0b50f70e119f07b89547793475d816498ecd8249a5a00ba6724e2ad6b1822d6927b1d9ba46fba7994c751fe0512766e65fe7a3284ac89c8cba8f8b93041c4f6cd9ef196bb8d9d73b89e3855c5d100d70ec14a0dcf468301c46c67acb04ab26449c65521cc7e8774025dcf52cd5bddda9b127e7878e05f8172ce60bb1d6066743a726c3e38d2df24311952243d4a423493c8ae1390fa46b245190747d85e8cedabc2b61ec74049838438da31f695e252c6348fbbdf151ec09cebd5a8b21c33a4bb32bfb42c23ec32a51ee3ccc056ac83d4244d4c1b2f2f5170c20bd5ce95af7ea8da8a090baa162535425e025648d527f5e691bf311c2d0d3f9dea609ff5addded19b1ad892e46fa6debc00075b2dae81b8405395c7859235a6e4e752660a5acd4db1826a1575e8cb4177cd712d93cc9534c2d57ba6562ca191474202202ac5779bb55e855d07f2aa4a821027adf85e8098f98c20f1cb7abd03f53c4033dadae78c295760118f805804bf15f215fadb20c0701037fe306152f9b8265b92ddc12d4d6079da2009fa1ee21acaca361ae69943e68029de7494168686a6b345449bdfc7a75ce9ef7d0ed96c99edc200ab1eff10ae646bfde45de77667a3c304a3731f71d0c3caac9f91c8087d57a415cf5406e8a627ffaf0d5f1a48d80b14677ad0240fc5c7e90344b0b5b47fd395c2ce5cd36cd7cc4c3aba37bcdd7efa13b99bb9cef7d76a377ffbfecc34ede8ede0cfd7a3957663fd16e3113af12810926b2c3ab6918c311a44a3ade15b911ece26cceb53733d2fa03dcb450743a191a25e4a7597e511b5869a9822e879cd5bfc832a5fab045a8986830af9c77e882e6792582575077aa82706c4abb2cda2383d122492cfa9d2a5cc0cfb2f251435dae54dd9c1a414010ac0faa9160c875ea7d4b9d6f523075d92d9598d7c66fa113530ac159bd656856d2e2bf3f1e789f5880a6664962f00a4f52631cbe736a0c32eed388572a2530f2ae06a57dc2c006b70e6c56462d8688a319a3e433c900d3db11e633e1a47b5b89f51107e8ed7d49fa90735457615cfcc4d339f2503fb34925365afa3c1af8ca2c070be48089de86227ed39a84ca0d8d876b7546b9201d68039599c2c3ff9d6c32505602fe8f1eec932b36d38e214fc30cb47d1b19b2edf58012d5afbc74523825acdd2fde27d6042d59ad56cb05e2637c657e41a5bc4982e8039cc6023893dd785435fac708ee1e26437ce6e786c3a4d7e943d7c915fdb9b2108226adf94719cdb657d8e52530219896aee9cd1f26da293edfe62034f439d9396c8456d7cb4b92b42d5f0be348b680373c55cf9e85452f0a06144ec122e6ef8b869f51ed57e0a9dc755a1a73a8ae32ec6896978f16936a72a63b9283be46b5f4ad416dac1001224d8dc026664a02993390fc41cbe32e6a63c77f13aa11440a8e911df23701277c88e467df7c881c43b5e3c98adb345a43c3a32040441a1269885cfa9b069af5f9e4c571a0fed0816b201a446769334a1dafa659928781954ca881172b67fecf81d64ae321d3308a7e02deb84dcbbb914c62dcf81b1b38cf8af1717840b0d5d7fa70b9e0f37e6deb3c324f94251298f7e2a762f3fe2961bc379abb8facbf6f59248f4d77d0edfe75f1498b56de327c5e5fb2159d92054a62ecee4cc723ef5c76003b6aa9811f260bb8236595fa9d90e9c8c1dde73e1977197f85d1251caffd2ddfc88e096bb91f110821f5b376f4f8a8780183710291ec9ea688fde5b24c85734aae7bcaec7e1fa5bfb9ebd8cb801594e1c310e66d13772180a1969a0320c4a84cbf19450e12f1cec905b51714c0c239801338f49a8253906496a1a625e9486c638ae519ca5bc2ef00d6cb49412acff8bf0d3a724cb9d4dc611eb6877b05b7b3810937727c2a6e1780f50ca232b1abe7da09c62dc55f443020af95fe4da48ce74cc85dec3e1c2a0b52eb59b53bb65938b93961f0688e5c2cf608cfe56068eaeaaa8f2b7c84e56823873c248129b32c9125027eb3a4da29efa1e0a6b02333567ba27cebe45c61ecbf8367dded35c91ffb86291214f5eb8fd4f500a9fbc4ba4d0f45eaaf5775d56d9e89e2c4a4f19b9d65a6e095fd5b093d33b155834455a2e6cee8b1fee7279421d1a89cca25924f0f1d4d0f0a1b249d06cd39b4173deb4315d35b1672931377e4fe4cd2306180929b8e379239e51b4792c5ceb595be74f370bf1fb9190bf3fe85d394807b6d7c8b35974683e10a7ce3c081d5490a4115d6efb58af2f8c8542dd02d2543a849df608539fe45cc8a3881af0f1074db49964a346bdfa093e18fe24cc13513ee92e0272e1e556ad0c26878c430367b4a1b5d39c001db7e12b31b11e368423134dfda659e635003eb554fd5b6851aeb4127060c331e35e9b5225d6eb7db376498d1d5438d8b000f48fc03d4a30fc616aa3d20d24da1d68c52b656b9fe1e77b2a8468fa39aa24dc1f7813d7195dffe216acbb0767c3a51dacc1a9165a5cdcc1a7bb073d2bce2c5ede4f44a7877add9b8bf86d7f2486984dd61e05836f15ff4f3b32c0a4673beeb186ce398258465108a3b2a48a2c52a66e6cef99fab325b4bd22ea2741f73e479bdde0bc24f78099d82d0d62ca863f90cf856842deb62a0270219856cfc729114008870e0b48049db9e1397327338e5c42c5c7d93410b61795194f2bf418d97afbe949b72436a4f94e60070da88798db7b83b57f71859954ac17ce975d22d817d0d61c91358a1caac5e986b6f18c86ac8a8533ceba9bbc0ee9a15376c6c75c82a9ef86c314812f89ae1935b4b7f9bdd3b8a176d0ff78f7665ac3a054de7882daaa21a28f60dd3cb62a68b1e0115b143e6f27b9999cd9a5768dc6975f4771ef96aafb496b79143d079ddd0942044bfddcfa84a1df13d2846f887ed00affb876b32c84f513bafd81ce6c8b829235bd924928175db293cded101015398bbae3b44124c0c88f035b0c23c513a574eeb454c59e9442ecd9739732687e8c55b9ba37828ce77bd2131f2d52e961bd2957f44b04a3178b04317bcd640e7ce1bbd8aaa827917678f97b155de5ae541706c239c0fc43083bc012b9bf6bf5134912e2f2a9cbe4780eff0ebb5ef594a6815448172e778748c4ffdfe45d418fffd8467437b8807257557049b24fcb547ab598ecc504c8e3e3ed74e4f4d650257942d8f5a3e59bc3f645ed5124d17e208da7a11fe7b0ea04b61e2608d3f61696ad233269761d75c7a883356305b584e09b66c10e4528fff689d06dfce4743e84f690e430f6854d09a06ef515d6b818fa9984918384084d1280b51f39b0a522c7a0a272d7da9e569c45b849251cfc9d0e1734198a9438460cc7a670d18226abb35e3f0da286b2c3f409311683ae3ee830658890a55f14180b452940ffe4a4bde0cd2317cbb7097077d327f62e77f564326c1b2e16f1b9461d40adcd0a06ab54aea14752cb2b1c343993f40f59ca6b274a08da4ea29bc82ea23c78150e67e61ffcfcab51ca73d0cf858cd910e3d1a4c2b6793f9e027bfd7e3e34a4985465b81ace962ff87aa65f8dfdbcfbe011b1647f2dbd44b22ad2c9a66a6793d4994c0a4e2227b2e8ee541081a367f5eb3de104a4d95072cafaaf72f5e802a74208202314a17b1263c628eff0a03554e3e585435a46c8685e48b05c2979dd0440573fdd7141e0a5813aef75af5f60b54fb29457d847b02137dab904586057cec6a659cba1d7b5a171f1514dac590ba3bcca970d4372edfa5e1ce137feb42cf454a649c9a937df0177305afc610f734dc52b4b923d233ac1f2bf6737cfbb50c69324a8bfea7ebcdcc6b24d6835ce2b796c09264f1519dd97386bf68889e4be18a4c22afc4b1c3bd678afc9226763b17d374338b0fa9929b0fe1e2cbb78802bbe2cfd748bd5ab6b6d12562ef1d5dca7c15d1a221273bed995e39e51d36c3fdc13bc960f261b5cd3fd6de31f290f8fdb9dd77f06c8300170e89f4556a0cfc1c71857a2031d7bb04faf39eaa55b58dd368f18ab416450e8e3d29a83abd4d79478646aefcebe3ee7e9bba1515bc2c3310a8853bd178796149ab84b57d28631a89889da148df50ff2f81b5092d4fbf97129b33c61777e4ed31fa05b71067a662435ca1661ddd650bd58b8ffbd49cff4cb724450ab09a6563f3187f99223c98bc02a6cbfc2b3117883152023b2a14bd7e5702aed968766","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
