<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"140e01909bbe794353c1a0c567ead0df8cef18fed40d128012bb19bd9729e86bddb867af95f39ef74632fd32e98e4a20cf293338708f4f2389d5f145c1cc534a0efb6c3d5ac7bc4805376413249c4f39b7326f11397cbc2a1e2c84dfb03c25d9a075ccea0623455159622793bafb7155e327207ed92dd479cddb1a29dddd78fedf7331db0c3acad4c63fea26f07ca3e30b81d957e365c6532e780fbee0ca90374bab1eafd909003f198c336aee51b2411bf4b133e4bc29e16d53c6d9e8b7107b518c218a7b523dceb7910253ae6a23f189b15054f9954bc700562a64ba92287144778834cc4c5c8a65c61e0bb50ff865921e4a662113fdef14f3fa5ebce5ebf2f56ffededd0d367c073d0b2e721b31edcf24ed5c24ea08fc72f52c7ea6584530d3013f775aec6b630dcd03f09970ce30bbf19d87621e534687669d9386326c647890b3ab5907bfb83b91ba1206f03aa47cad7f2c993dc0bd95650bd4aec2065053290ae82c62618b840802b7702a9b80320d0de7bdc617aad10d858d173f4bcf99011befd8d46a8534f31caf6e272892f5348774bd8b68d54637bf0dd0ac5a788a2f9e032199e02702d1fee1e71694e0ba3e94d13911d0a86bb1512325e437539a6cbd5f5d47df7e08dfd9c69155ebb459911e75cb6352beb5e77f387b58db97573ea1bef10b829fc332ce14ba209183a5fc0f808765ad825534ff836fb9553d47dc3820785a398c5cb75db781bb61546798224b0fb27fa86782b0ccdf1cc63218012de17d76278f271c5e90a717c0bd8aa3dbd5aa92e1d2e16a9f846be0c57c3314e6de380e8006b0b1f60c492c3c302a66478c9c6ced66321bb05c9baf52541aba3e46204b1e6aea4a73e090cc64b397410c44ab9648fd378b9de3f99d312e0463dbb9821d4632817e9fe0116e5878cb498072b9cb2fc63f01033702b88388be21ab5f7b7856e2b15e5151dd92b04e413246684f4b31f65f445d92d45330086504644e67bd0f0cdb8eebe255ea57b0f0aded5cc4a501c2d4e00b62c918295c4df9e14fa4b3ca26890bff7a99f04517971f3704894329e975777ea09c3c2fcca0f682dc3db0bde7f163a7b57cf2e2d1caa074393b44f14f3e39eab0471a60c3d16101a816d41420aef9d8d6efc5bc81012f85712102d7346885bdc6ff2ae2726b9ea5fe308adc449095456e89806978e4900a4af4ebe3b74d299b44e67e9efcaf984b2a432a05f1142fc6c6d1e94fea6f00e6125b059c1e21c7cb1addc8f1ef51cea78fbf42f6ee0625716810ca02c075d5c79df6603a2eb732c1e92ba8acbd11d381f00d292b0215f99d806e68ab966f77114b389b9ea1ed2c6cbe66f06f03d791cef04bb61f27aefa6a0eec0bbfabd0026db8580de3cb6b23740dfb193d6ac139adf6d2129f79b1972cff152db91cd4846e8549a82ef4e85d83100be511d11decec4d868c604996a9ffbba62bc992661d44d46cb7e9c591e03dfec8f2d6b944f84f89ee01a7a23737c04d5478c60bda619bd6f6f49da4541e296859c7628c90ea780d2916204458930eff818851b3cab648aabf58f66f1b0600aa5b9a6e354ebc9b60b5ca3ca8e8402481821e5301a5ba7d7d793fb9e8f06cb463db02074a374c730543585e3bc3a53a95369356f061bada8ef7b55565d1a36cfae0249a46c11d7e0bc6597c4e4aee6133432744abe0094e8e64a956c43acfb3cde485e3b1f537d0fcc6ec12b31788398a7b0b0d2e277d19f5c299fdf191285d02237b4b2ca3be37e760257dfcde90f9ffa4beb5d2f77d8d9bfaca129cdfd7a536a5b0f9dabb1f54947d2494848b98d1d58c19e906d83a1d93275c84f1c12aba0e54ddbc4f3b8f154003806a7db4863c5c0876c155aa603ac2ac7d64cd1bc24c3e2c4ab930a66b136afad24b3c4021f2e8d81863272e26152d08b7fdceb770ed887db6c1730f1cc58edad43446163ca1645a8020aa8917f1546b3c492ebdd97cdcedff04fed3d609c1d61153ef17e3ff0ab998d79fa378c3718976bf6f0def53983c20197941614fb764303e23559006bb3988ba1131c2f94dfbb287cbba1fed4483bd7a3d748368209074d8d9bc4458538b47288439d108a3df8bb20f24af7aaa4ce81c182ff7d01a77a6892c8a2d6395104020a2dcce08fa52083193aab42803ddae1e094b3ae9310d8e14f15a81d8795b18cd0782b4a76692951da2c77a1a430c79c9fe1b45eae0912618f3af7b3f27ec7ebb4c748838a415836c2eb265fa12233f4cff9cdf65d3231bd8d96f92c15ddb01d60a6a489947b6a46337d858317133d751fe8675ead0d77572af32fd1a73628bfe2985b1f48c36591926815b9917b49798d4c71a07ee67fe7fb0c31a4429941f9404a5379fa4429732a4bbf4201d31b9a0fcbbbdebabbfa57c1564e1bf9114753e1df639e507e98be6ff0f9615c03decb9ac01357732fa2d0ed8fc177da96c2a90be8349cb730c0e792a2b4c97f868741fe12c0cba86ae804db1aea68fc80e08547a1784d386f97fac0042273c29f9065b4ab627f3b06125013d3fe228ff197e8b2799e1c5d64d6972ba57508bea1203284db15a6be66883d0765a926879c18b5b0d86044969b4f0aeb3d6cf888e9f24cd70069c1b85b8a966c974beddd2b8da192968b7778d1f4cd5afa0abc39468e4f883985de32fb22731b4cd496108b089b5b4bec1c487fc55b614bf32bc6c45c2ca9e7dd62b61789bdc05d72c089ccfb09cd145cd2b743f760b9323b64eff114bfcfe2d69ef1b1c173dabf036fb85593b120778e59719fff1651d03a299be3cc8dfcc03082167ba8409517f557e67606c588a47a467b7a7952a6a78715a5c99a45fe4650be51936ff242cdda360f70e952749f3603ad3abf20367813a125a9844597c4c8ad45482730c4bea25c978fbebf1c368c28bc23a278af191747d543188c32e0dc5873f6597ea4de552e0f79cee552e80e625c2b37b4b449fb6ab2962bfc8c4d738b3318d864af85bd4c1660dbd3c0934ed3422fe3dc2b72195d8b75aa1ee90d7cd8464ff93388723f0c1c45999289184605971fec1eae0bccfc80bead3dd08e57a7db95c32851ea1d6e91a576d6bc6294b2d6a4eb674be5ee208077009a35e91f6f3c8d2d11b1f043323fd6a3a44d5c74e1c0a008c71196d72bb2fcdcc8f0b4b449f713ad00cacdc304615f8a24501c37c9750bf23a7a3d890051c08808e4cf5e80b12d406143996311aeb61af66e68d20a3615104f6c8e51c6ca6c6b73bdb7bbd78d948bcfbe06057c01e3d46a1f28170a5bf1d748396f8c7906d14bfb05b7d862cdc5fc3f3b58e7d3cce08bf91ab2cf79b758b7e7104a73555cc04903e3192c20c495571da227c19acff3d24835c9687b7dcd566814e8c738279f3ecb70519de0065d0623d53068458b6d40f067103e4061515ccf20a7aca58f14544b506ada8ec12be0350a495e764b66b9cb50aee6f61f8033440369af8737db82ff9a7ca9de88285fca92d1213b0f710873401e1ddd61d0595bef342e394fb79f25dca24b087b678ce0ec0b1e33f73a5c49fe9685492ff9e680265a5d842d883ceb5397df8fd4bbf9ba701c7934c9d647cd7de109e3eb9c9e66dfc07fb20d47a4f219c99a8a88ed762c776066458cc359b20bac078e96c33989cf0e9fe644cf5a67f4c8065b63f940334b4fa945b4216918a230b02ed978f785e72923328f34647e85662a285f7c90ae005da31b3a0636fa741db031334129c281e0f9b8ec3df3ed3beb617116b32a3fa5618260d5dffead93e11023ff0071b76294c7cb2aa061c3430a898b2b5e7760d402ae6c87ce8f52f44ef99f85c6a4dbf8b2e766be35c3074751004abc7741a3742dd019103415a4fe51a72576f169828d5eeec61b8826fc7b9a36336fe0b18221701a07f3b7b44def7c98947cd60c07b28926891f0522dd598d968d1d846f352d824242911bc40e7a20f6829060af3d5877518f515088f40c30cb02577bb78d1bc747f4a4dc87d514cc0afa4311c90f7cd245a530da26daa7dc6835aaa52545a645a7f9f871e4f05a0fe0c7a1cc2a0d71ff80b47e1a957f27a80476bb7ee9db4c68799d90b4028fc30a49dda45e2a01c196e429a91ed666a21ab1943ee7610733e22c640f2e54ff4aadabbc031553244e700700e92eea515ef1c038e81576c31e65ffb1d455525903adec300a0e36d5c640c944ef6239a0a1c148285a71f9b06b0270e2ea673a7e9b8e350c8579f504f90d29b57bfcbffc7c5a3339cc466e121780c852ab4b5046c596549cfc9337a063861c6792ab957eeade435e2b5f771b166e194278d64afef9a8d78fbc0af6d96a60df8536b0749fbad5ace85ca0078d5ab038b03e0487f80fb67cf9ed165462c8d1c39377e1d15d8e6857171375847db00830c0fd52867198e9d85f1b9bfcbf3d46e12ebf27717c57f7e3f426a0f68fb1db667f176aac9437a1cc85c365efe6342e291d57152e7578d44410a5acddfbd4d89a388f2c79fedb5326136acbe89cfec962ef0eb90783a1b6ea4e6b5e2e99a851c9c72463f3840918fec6fe7238a1fbf4935acacf1cbd9933a589d8c369be398cb8f1288dffbbb245d41a3cf711f532ae642974cf52e98bca9e605ff9c36ed1d57e314c9d019dc24a10f0162a286a37b4da96a96d1cb213b499f718fecc4e71bad68969fcc904aa80d0c2986ec471c79b3938aa0e3d0a5ff6c473d407fd7fce0e6c2c0ce24487b6523bc164cd44f07c917ed28cacad78a054a87e148761bc21dd3e0055f39727aa74c81b7205830017d4e3c12890b6c3cfb4060e0648dbb9b114451952298a85eba70668440eae500f6a0810923adbbc9f89cc76dff44dfef41e0197b7fe5d9b58d1c6f8a47e0f4d3c49342076478d425953d81d894224ee908a70da8adbe7287e1d3c75392c56b07dbd9b1624330480122ed324071f47d6637580f27b3abcc14579dd763d9a501d47ca4e6be727e0c6158b91c639e3ed507707968c18354dde64eceb48817dae08e33b5e030b2d3b0ecc85380bf8d2ecb4fefe9dda96fe0d9733c38d3f64be509aac59a0399c518661160b33e8a5276600075e55b6d950ce7de2ace267a86debfb38e74dea0005f66346f3e6fa4757c3a1dcb3cd3c96ae953cf1c958ce70017a41f90211a6d8ec9a5aca516062ba9892b7e2749f0ce70dc0cef307c91733242b37afa7ebdf13ae68b2fbda6b85c987119e861ef4c9f9c9e4882bca8116d68e829d62161a02908248f4249336c900312526a108beb1d3690a9ed2772732247c19e3d165992e349c532e214376525a35d4f5e55338482a1974e96973c33c8b405d68a52bfd6514b4bfa93a6c7c82f8d0905c9eff13bde3606a009971c7aa44c46961a06424e37248298c61676c42dcfd1182fc25a95232f2a801e473687c74c5d86d47de94de851a95ceda6641eeb06f537c88c0ac9089ff71d670c9c81c09b84fb3345a5781f5141ade89d149eb33c0b233edc96a948162a53dc46f78b7a03c1e72b3336e7296448f110acf4e6c542307e5a6bdbd18cbaa4364b9c12c38364d7ffd1f31cbffc6d9abfc32c2c36712636faee989b63f946cd4f7e1810940aa795b806e766fa4056aad6d8b830a14ba92a1e0469d188d2c0b1ae0e9b54e9f52544194b28ca5062438916d976d2898b0d3bf64eef6b17a54b8ca39071f2cbd94b135350cf5d60e8272daebc8d9c9f70cf66d3695fe9fb742b8ab9280fb2b505e370b370353e29916b9557761fa423ae8c06ec02a4ded0101c931dfd21944b229af34906342ab1e751d2bd84ecb57279dacdaa42118be1c42f3d4a6b02f3e6d638658195d87996f2ff597638e575932a660bd8397c1fce2a22f872015b1a51fc1acc9c6fc0d8d5374390606da29e17128d3610e2137914f8e3726599bb721c8025e3667bf74e678641efce8e24b808af19bea1c43c50bffcc7432d91cc2286e3b1c2dfabd8cf970b40a3887c0adc338da031bf2160184add78a3a3128071d67579e4ba3c2a153b9fdba9cc0056c8cc33937e3a37252a9a59e2078c878bc2131ec2c08774f22be15de30f7e080dc5d0b3f2b86affaf7f51c4ca3d66a597ba16dc6efa15cf6576d416d18b26950cc3f7c811590e58cefdfb2f3920a3702223b49f5c62f198f91201c37d3b99086449bdb09fea49d894db9dbf33c4299adf4bd23756a0842ad2892429c24cf15f8d9d840da898aa8860691682c342166ddacda4ee3947e20225935563b63ec86e35b07f8d9896c5509af33e381906ca83404c94e8565db4b7e6e04a08c773bcc315b59b31c6304243f25f595456c11a9bc6c65faa16af1563db480dfc41d123e72f8f50adffbba279bc5b08e7d358c32c0d952e37b58ba36d76d56b1ba6b4f080b48665f4efcbcdf1a3bf6d1c6ff180413b2987b026fcf973e7f8ca003346c132bcf684b4d1cfa2064f41734ce15187928c2a107bf2e193d349ea36e11f543d591ff140ed2232291209f68c4b5f477337e7a65e3a3c210a2b47f09748b91b5d33703671bc1d8626c9aef4d6e57bf62d157e16b63c415e99ae4dd6651d4774652818ee45aa59ac631a7a9eb552ea56813f4180892fe9382951896879dba9d6be1e9bd8ef1bc0f355c413d9153bfbceada14294d726099b628b59375a2f49f6627dec91b660030847cebdd5837b5f9b10c07d0aa1458c75ec739e391280bbd9759fcb87db984d028d13a580223ed01d87be0ceab40eb9fdfc1a9d852f3b8b30dfc1fe42fb02477996acfadb554953066289716c4f6e9b6e11fd1bf33b6dbdbe42f7c1b3fdc55f453b0857f2bd23f5e6fba6fd50fa2c3dbf45310222150218a22ba8177187d61d495ba3246ecb6c741e88af4d0ab403d6c71a0ccdd54efcaa259159bf37499ba0ee8fe1a2c6b29fb243ac361365e7d25484bd8b42d8035050e55d738ef6cd59bca5952abc6d20c7a230b3ffc4e64c4d20bcc6f82ef94a3b455081aa43de3a64d1c3c3e614ea0b975c99506dd5218e6b13d2ee033a44fcf3c42cc774487a6bfd4962cf625472929dd254daddabcb8012313b09dda333b7bdfe84d2402d549d14e7ef19b1ea8b030b643accc73bc4d431136c58c2a03e21615a7dcbb90fea767c1756639ebfeb8ce95bdc6dea3bed5973b7f697c4908c3331cda8db4d78bd61f6511db12a709924ed8ee8c0e4cf0962efe70d58b57d7549f6c67ebf7f6c6e1dcae66b97d8a1e1e079acb91b66fa9b23532a636c9eca0d41aada50a5dc241d1465c98642f488c47768af57b89122ae62086511b1d058860a2e71ab803b9ae1bec8af3eabf83ce373db7d8fbdf163d192413aca7040e8f835bc1b4a6c546902b019b9e432b2a5e9728eb0b7b25345df0906801d89b5d03d5d9e97a0811d0e50181d08e4c4ee62086732ebb864ecd037249bbea74a5acac7aae0b7f865053339c950de772449ac118073242f3398b1f8c15c4d89bdd03e1c5955abcf1152f4200579d38d92c4cb53d252e3042bcba8b58f4cb27136446e9f357ba6d3c106cca4b0f8ad40a85a3ab1c133053c4ac234701bbb6ce49de4a98adb330df98de55cfd43577831539dca6184ff76e5532ca27f635afa023cacb9e59530d483c2dfa05bdd3cdce940a356f3e638612832665457a486e1dcddc228be806f0287684c73489f9d47c9b791f246e3a5958bb01e2ca806990913f125a15167570af3aefeef09fdc39dcfbfa0129ff8d09e2f5577e676ea5556d95359c044fee7d14b1a95e75d30422c77a9d4a5a88a7d22538660497a2baa4fef18d5fd8ab1467c0e70b7df58911f57e914b2715a6dfb6e36a6c574e3a99df606384bc31de58dea9ec0c0abc06c96419786b1f805b3a678bf7fbae2dc348654aaa6d7c2d7f047154c0e84ea80ef8d3850cc4332a8fa162636ac23fa2f44d57c4773e9d57481eec20885a6cafd2b52fa9d6a30da2deb7b525f1bec6e8b4fa0342e64a4df95705d98d90206d02a7b2d653c7b4beef8d411bb194d19ea559c327bdc59deb21467f8978f0c51c7638aed6f598d5e754229489227e1217cf52879f2737faeaa59237dcb05ec79aae11f65e9c74eb95e840c476690a2c250ad5954aaf609a101ee4422179f78279a9f3ec5625107263e67cc3f423598f93db7a8e7fa3fc2390280e8d8a2f82aab69ac8310a97cf9312bfd691eac48c62df366a127594f31c2f4392ebbeaf675b2aba61ffbb94627b352b7eb5a6e7d28f87adad5a3190f0289767f2fa0586500f50f6a527345bc5bf44541ece120d9e61a5b45a82a4912686157568fb06df9154f4e7c098d8e4c81ffa5fdfc83dae617f1ab1abf5ecf8148634e5a70d67d571c8a8f5d895e49e78d8bc334d9ef72b5749db29f3c710761d2bc4a0a6ef063da0ce44fabcddfbc0fd818745c1013b1dc1d8c78ac2f0d229bbc6371dde008b2d8365abe4e739682eb4b2ba21a7cde0f7c52f599903b429a005a53c84b9f4d4dec6924da9941f7e75812a502da7cda8576cbd215eac4b35993c0ec224bb8cd79fe1c98e7b7b6a827a8c6703bf7a3e09b164b4372ad3a6f9b9685eee2dbc8ce4871bad3118531af1f6721df2073e7e5d91846229736144763f8ba325883d9ef1e294d21bd436fc70b13cea53cd18f940a03087785e4d04a317e74c18d190c28f670524598126bb9140032401a9c832ddb3b7f317783baf75f812466febd7c2ae8f1c9b68f4a9d6052d4d1c89a1f88fee43e21688d7937b192f2b5d4b32298f26e3a35f9cdf4accd49ef28785f8a979bcc83ecf06de690ddab0e9836500160c05e9c708ced02809a4d690b03cf7ccbba32c79e0741c934eb7da557b9c55460bbb39729b326dd1b415227bdc344e258fd754ae96efaf5ef9acefa81bfb7902baaf892b089f53e1e5028013de6a80e8bddc78da95b79b8cefc732aa4a8c2d80a544ecaa8ef110c031074fb3111688de6f144dbfcc877821b59b9d9d22793d748110aab370a5c16355e200f25aa30b47e2f5438d1ff70717e6bcf481f7c849f252c94f2ad9b88c1874172d54913a3966408547906e41a36c59f2c3d6966c6727558083d4115dfebc3fff27f45cc76bd890e756293cdcde4b087950a83df028767184b23c75a6418cbe06a4bd9222dbc465210a356d33abd6f6392ec2f5a429bfb27d196dd05c41ab8516dfee1ed85f1950914eb4e5cdb205f1d35493ced2d0559522c7753255d3d361ae9666cbcfad1c7802d2e2bcd6e5acaddc008740d7fb08dcbc5d1404bc826bc463f173f00a4df7b7b14406dd2387c38d5fe39df6ea84ab66ff2b5c0cde91894ec7a1b57e7c0bdeb31e215cb0e74f3a4f3ea2404bfa81ff1240a012750ea0b4b3f5d95c95b72ac4c5d1b429d28425382fbb101254b9eae77dabe70f20ee46741aedd9a224b7d48945852f105a64fcaeca19dcacd5cf3615b03e157f53cfbc2da08468c5acc75250789df7498b18e287726b5e6c2f62f8bc8d7a896b5bd759903b612e8ad68dd981714c6134b196eb6e4d24922dcf5eb14274d0df3b26ee360b6729fe7753b4107132daae73ecd4ce2861aa61d918d2cf1024aac823cd6e543db4f725bdd2242977d7b17a52dae9b4443521fdece2ca3b7fb7adc14adc307c415aef8a057d647414eb2a06bea5e16f54c374cda9356d7f52e3bb134b598b9844b5faa5297d53be3b4bd7baa9985d036dcd0d2fecfa08696cb217039e7dc00bd0c0b7dc73913220b8c67b22bd3ec95a2ae0bc8c429b6ea84ab875859fac0c6693821634a758e6b9b21144df571c3760dc06dedfdf91c5bead1d41ebcb3f53153ce7ed4b586af8d8e623120c6c78da54c154b552f95d2c0dfe915f941ef9c0e43c302424fc3fe50df0b39b7c628c21e64cea55a387a51ae83351503e1643500ca87bb0f27412a66644c4b3ec21f9eeebfd2407915125d47426a6495a677b4fd0357f08baecf581f4cf0bef0d8b2e405a46eb227d7300f628acf09756a98b0241a14408def0fba71ee710d2331b5f2e116eaf94908ea4c4bf6134058817b95118a5fa445f06ab41485370a260246e3d02e50131eee28afcdc530128bf665c8efbf4d33ff7b7b0f8643a2bc0e4ba22fd3b1c50eb0ac955016aebbc7d3b765bdc7c4fc0c75d9296df7536779c3c5d54fee7a686e40e9bf44d79200f78a749e689ecc5f3b0822725bc9aa9381d3e7c0f5d1a56068a6870302198a8610577d08eee95df87b34f5a12de4d7e2e2b39eed0b81b75083448f35f0fdcfb506543457a22c31f62a9796a00aa3902abae8eeebc956d97af1b6f97571c25fe255463caf0806e04007a6b5154888eadd10370402bf0159146f60faadac63b6d0ac2211edc90345efcf0a7675cf7cecebaa110de0f0ef23ab67867abab5ade3b7598b9dc45aa0177a48bf87defefd5aa95b0c3ae4a71863d233f6d559cdf2937f87a6014dc6d960f0e6e1cf53bfbe0e99bf6b0aa4537665b90683bdc3eeb6b70e2b70d8344de376acff05aedddd047c1e099b02ee5c3f6760174c0af1392ad6c6941e7a693341782e39da8dfd82ff4be08f73aff2610b42dbf2d25ebe789cb0c727842179b2309fa3d5a70a4746e9845660c50b96ef1ca193f8b65f8f8901924f0bafb7fed3fc38ab940b0a72f141ca9a6077458482b05b5b53012fddaf004a98bf943502b34b47afb3d184eb57a4d2f316e61a7c30f9d735070e16a73a545776704c5373db53fae2f71bcaf7eab11f96906865393ac84896f6f9dea5ff0cc7b9205b71b2f0d87ae3c5dea19b9cf0c9d955ca4235426a2302c92f6c14ddf0c20f53c643297648375b39b5280c918f3d5a1a538f3707df643cdaafe47ac00e9117f35fc92438a649f06febb99e57fefa929a4c5efb475ca9510fbf8e47d4dae7d8462225dbde35ba9880080aec3c92f9c5916eaa79b7e566b3ce4a98ab1d9182ee6ab6e5c9650579efad098211127740adb51ced19d05323b837247324635b4a10f1e338ec3a3ef8b6a8ab03da5401056dbd0a95cc64c6a76830573fe65cc5367096eb1459cca1b63e62750a524b3ef78ed6cd5ee983d036ac295f2f885513073f58e1f7799159ffef0e119b7ee2b5f194a2273e62efcead5532e3a0e10e2457f07f17ea4dae69e3f46e6a5a244bd6def80b6e4405ca0a7e7e4dddf0cb04e334adb405f3114833c6328b1228c83ef58e2425705fcf7a1ce6cca7da699aba6cccb48835176aba766f718607492184716ae711231bd0efa315e940b6e063634fbdb55982eb4740a6cdd088be25ab120de1d840b0f1f65ba144878ed33d9db2a08911dbd1d6c2561999c6332a7379a0ba9d03660c2ca774d522e0c23d50da82d3ae2053b083e3db5497e1620fb7f2b1d2ff770a1cd9e4b3086fed84ae44b5904e367a2000da324e8b9989ded3cebab6f16fdb5c7d8b01ebe1c7587ed458f90dc2b68e961578a77daae5fd49b1b77aa38d53a37dadadc3cc08c8f38fbf2b028f99a1204b541235e9748bba34070ace3c5fa630d85aaf7f81b9445d22b94eb264cc3004cfa995e2e2f51ea4b569bd06e086d72a4916503ef1a500400700cb0f1ed4f74a921afd16add959001550fbb04f81191b35c5e5e7a09ac0afeff921672da0f1dc49dd461b23d669b83d02613020a868098d709bd4cf56ac0b53484035abaf196f21746e06fed6dfb412c38247cc6556a6c7e3515891f3bb545f862f0a604fd05c09155e6f4b039d88380c3443e82f72deae4e7f74c4b58683d0eba08d0d832af7bf7ceec4ce7e1d4dd411c9be0bfb0b3bfd589b98dfc9c53786b905b554c7fcdbfb5234ee77a76a5c44e234d64166b206628bb6892bda31d0d60ce36d3d72f79bb920b6442a0da37ed4dbf0fbe29944ffa3880b1be02ad7195f16928c839fc499126aadc1518aa03b328a1955fa2c27d8697d7f53fe23d34e3e5d550ea4b8c11bfd5f6476c81e540ae670c344610f6b0e4069c78470cdbef34a7f91d8fbd3b4c7545a80a6d2d15e0b4463817b54a36c4f69dcb0423898aecc37b4b76a1fd67181a3c8a1214ca006342cfcd1341f126f7d622dc0073ba880239e57cbab5342f451a5f3e36c5dca440f3a698e9a4c8f5d16f1eb646b873b1b81bf3b2b011399b6eb9fe81e7ce3ac33dfec45d50931f36256128494be118f9497a0d589c79dc95df537490d10a0d18ec4b4e431dcb19018e09dcd46ce2c541d2316be6c1f5e47311cb51d984c7ba03aaf26ecb643810d44ee0fc98f8bb6f3ce6f5d03d8f9ee5e2092e5c73c0caa3d49b6daaa92944e3f280f6be913adb4ae698f4e72e0ca211f7e4675ff56afefe84ff8ee97f6f2696a9c9d8ae203bd7f6c3b4eb37f89cdf08a5d9bfee08e87f8add01b62dafd507b4022666c0a1aab8334449276b68f50e08f448049d8f72918d6985ca4a09c782f774a0aca6f1bbf3d2d4b3d89a0b9a769ed3f8dcb70bff5dde44a153ca0e58abc2ee7ad671ea24b252c52ee093e6585dcab3730c5698d3c17217fdfde187f280824ee84d4480d694c12a39a71b154266a2ee9ec15708f1dbbed7c80a0619050e5b208c112c20c5bab382fd25c2a7bb2bfa16e475eb101fedf3d4f79f1e939b767b71f498cf34cb0c9e2c39370b83a6402e297ebbbe3f30412ecf448cf257b47ffb4928550b9513f1ce9f465f8671299b7a5a2e0be97488e8eecfdf658286185dd0635f8049ca3786dddf5522c2c26de3e1ac8b640216e48b2fc4e655ab082187355f7e61f4299b690265721ef9bb838e3849700cb15c1e8d536aec62d542e8d0f995ae87319c75b575cba4bdc7ddd2372f3678e8b9a65d69c94da7038f887bc07b41224474e13d4895fcc027d0f3174ee3cd5b4f52651ad0deec89558e15207aed760d381b3fede417a56953d99a9e8009075e1b68dd7340c752fd698ffc9626e6657522234777db0c56cef6e5b59d691b62f993622f9ae2282af47f97f90196ec0c66c002fd86741faee8ed8f1a4867cbcdf88fa146f3a2a3792e07922d1008b9fef132b5adfbd37e018e901c4e075b3d3a8e8406cad3ece766a7bb30b1121ec2daa01db66a94598b7b9791a5760871c9f067d0983c05fc847b5b9848f8af063e36ce76c554fdeeb4da5cfffac7c07e9e7f9c598182462650a9f5abbd9c644e29cc07205ce734ccaa44315e8bd5ab2d0fca114ecab0d4f933bfeb46257db2f7b6751eec18aeafba22a2a043302cc142125034d56537e01e6f2fe7f6a5cc2cc4d7641e80da011a8a7b3c0567471e91b373e0b936939a64fa6281b725e98269523bd3b079f45fd59395425884829219d4bbf04fd5c946a53c18b49b57226dff022a1f370fdbe0ad6a1ea0c0b3c4b202ea6745fec7f6a65edb01d3c69955bf1dccd2e33f11b3eff35c610ea81da53bd4a1f97b32dbab254f908b2e9115d47048db20b4d01639a5d5a5a2a2cfe1455acc4fc226d08cdc5d484b85223f7d780e39265cc0c774a71ffe6bb708fe9ce108233a7ba8080221e1601fe061d14224c01a882ac200b5ea9d7aa9a1afafb47528673c3034ffb26a2dff8b260f1a550ae7f6789e78d9b6415c36e20252ace493c6137727428d1021065c39627b7066624761625565e2779edd3f46f827266b44d50d5e96962fe893ff797cc66febb98126520336dad1645a793536eb562336bd21f838354c8465235d901b0bd8c0d77d82e4f008535d68736883bf5e8c4d1f9e48dee6c2721cc83562d4ca8cd3f893d433756d05a22678b855d5ac3962ab9226ffe34fd88a15748f7f94814c6172d43f26ba65c6539a4fefbef629bfda22b4b751ad1f8d3ecea312d9646cdc3013239f1dffedbe19da6e544686f31434f87cf254a4592793cf8afab402f431dcab036265f6e1a0a04b3076443b2d58ff1a7031dbe56ef2f560801dab799fdb1cf312e2d8b0f650705d0ce6651d4178a78322222f592a0a5e1da41b31d05f4af884622389151bcd3a11c0095868950f2ce8e324aed81a7e5fbb187d5143835c6b702f7f41790a7c119742f6be553f438705e71ba3bf68d0eb478fb59603bfe6e98aec1da3be4b3a65e2e4877ee852ac200d69517201ce696bc382df85b46c29b351ac0531f74ded295c4cbe2293f89a627cdc59bd44ecdeed149946e17a46903c5cd37eb5dd9327e201a6722f914fd2c0a1b004aa77b61c5388b77ca32a4193130740f06799b8492799d89b4e5766a897a31cef61dbc371c1a75d8e4ea93ca7d27afdc270bd539a52eabe889d46fb982978a9d5316979d80d7e34d02eac85c60dbcd8a1110eecb875c22b334ebf2b8a737fdd99a515d1a7251c9bafa7f9a5967ab8bb4cf057bdc81d97db2de72c7d8d79a4536d536a7aa5ab559fd426d57a0e1a6748b4bc8b37d494e8084f4e614686e510dcee5fe1fcccf8a9554b179e296de92274e512ebbc169607e20a3faf1f56114a2d3b6a2c33992e66951c70d7f0e95891412ff43dc92c060eb9e70cc5b32111f701408dfac633bf5f0fbf16568a93bde00a9bf74663ebeecd960a59932d8ee87e60af6ae2efd108905ba5b837f0d0397c4905f921ed06b8f90f3cc70ad71cbe6dcb261bdba49df59f247af2220947919333084c8dc397034dbcff8d457ae12534251682fd997b07a975f3e703a265f262d0c95ec679c762b9ba876d04266646d28d41cb680fc4b80084ca56df1b7eefbf99ac95220f7bdd103567e887266b13341abafd3ce999f6cafad4e17d2484ea42c8552863bf976a1729d8a23040f51845615929d8169683425d9d8c97b5cf2674967a9d8331ad4f9736e2f1f1d7038214234ea832889d8eb1ef06fb5a4f8708621110faad034847222e559131631f2af9065dabc188d07f70b7a99ab4ab71403fefec43d3dabdbf2ddbc45e7220ffa5e0e2ff73ea91984d24818ebe120d39ede30ee663dd8ccaf4c9a571f661bd78cbb0e1d256b4d21d417ba49e854b44ac201a26b62feff01843a9c9137689968b5d6eb56518ed54cd8644ee7fe1d22a1ff191ac22c3b5d53da8f6412f30ec86b609602733ebf5cacee7ab37f4fc7775ed3d068744392f435e4be664deee15589cb238b54758ca2a0e70abac62cdf2ce1fb834f10d2cd4f59e2cd02b0863127e90d519ab57c1cc3853a4d77e72392cdfada248f5a5422909064f2077af05a6c9c51b50c137eb27f6e37824c2e2f0927e8d1255f895efc0bbb25f907ece0dcd6ff55fa16b17b870bdee76b882f8bfd86a52c051465a2b625be0635c62f663e9fca45d6db4cb2f615bac11911499aa4306b7b8a716ab14e96efb67fb06eca879a2052feafb3c8db2de19fe9d781d4eb8ea36dd84e55017a7928972c333d34e03f59ec","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
