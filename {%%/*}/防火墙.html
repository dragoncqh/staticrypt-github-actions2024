<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a70aab4e67b1c6aee47365fd08aa8210ee3ad6eb34afdcf01ca1951a9b490e2748a86ae0b232b8b3fcbeef9219ba2ae33e33317356c779ed81618318992415fd13f237001d5ccbb488b42d850897eb98ad2ddb7ddb6fb3937a3d5a4adaf6104a4e867094ce2e23bead3b45c532c21968b953754ea364b2b222f573a478fbc60cd60dfa7a53afd337fb4a719d22973cb17c504eea94f0369ad7610da82f49c01ed60c9947599217d7fb9631d934f78aabf3b49f755a784ecb8fe6aef4b10634d57e8876b5435cc21cfc462d6462e55412c00b95ef180490fef5d68272810e58512cbcc33ace1d77b40700ffc76a26fa4164a5e78345a9e0b2e63f09c18dca6991c5e9b9100ec779f4f09a39b85e6ab957e81cee76236b504b2c25e21805a5d4f5caac3d0a75e1cf6c59905f0448c2bf6817373f1604b08c6a08a52bb06b842eb5704a136996dabade971ae0e32f7abad357f7ff5242308873ec4b95d29015fab3b337b2e3cc61757ae5a096cdf68fe8dae06b6eb3ad1e6b4acca5da2596663c9b4d7f052657c2b397c678c76c572028360b7f4da4b3a05c04644a2cd9bea5a62d71b649985ba7bbfe675fbfc5e4558901683c2a7bdc029efc7b3bc94909cd95e2733e5f3455bd0f9f02f35ce29aad03e05163586804dca4c6c8e68f9e45b1034da07d6840a33ae41309e1274b6c80cb147e47c3f9efd4df75e4b573e7cb2120c70db9aca1d6cac4d60ddea0b40047902097f021121ad40dafc0ada2e6bd3bdb2545e5edb1e236b0564f426af1051dc54ee418161db8598a9c5a771bfac1a7ccf7503eed90cca57c23264f0bdae62ed0a8696a0fbada4a7ee6f1b4bdea543f298e26441b26d9d5abbc76556ccbb1e359f20638b258596b82f0caf67b796e1f043208d522b719f2b2f97aa8624b43a57d3655a0aa520df02a924ffed47e489fd9354e6c4a62b8afbee219704e814b9b2c2a2caae12207db556bb0ba1e98685dd151aba74252368964e9fa9341acd859cae7072602570882bc948b061359be3ae80c4c93dcd8f498d5fe093eb3340ccb03d0c62d40e4f03f56a503502097e68f55ded13cc18d4a7fd87ff4fe15d1c9def43f75a365d50d4632adace57864a8fcf72cdde1bcdad807bb9ef375b2d5f83de53e3e442c9842273983a6ba096641902df433db2ae1a4fffe162fecda90ae0e78e4722d90170d5d06e316c4ac3f07f67c7fbeba4380db0f8baf687d4c2ee2dc589424fd6b156c127eb8a1847cbb6336e6849a7629dcec5d9046f2bfcaa256239cd4d2e03cfde7e573eb07b5539200ff417393e8c93f721811dad8be65c8c66293adcdcc9188008d853cab0d27cad39d56056374f026a3bd56ff57171d6cbb0a9fa50c25685af36963d9f4169522ef29deba250f0503c9e7890a65e90f1f963e3675f04fb4a6411cb3de6157c9ea1a63ca58a4a696edd0f928f963cdb17f178e66463adfd5ebfcd2844389b68ab0e890e5219995895445eaea1977188e48ebf1218263daed8b85d5643460c6e4abac5e202a68d8fe4b918fd1ef95f5b441cfd8fffb31b81c8acc50f4d6fa61570fe5d9ad23ad893c05775e912a3b367a609326ffad12658bf86a227bf997292e195cc585a813962cf3e087f39f7d2461b03e854e390488d2e996851cc52b02d05ae1d6c7b176590345995f5a8900df159d78fd2d8a0ae6aa0caeb017cb26ec49c15a01f4f84f2d834013da5c3279140069c35e3425f3b5d8fd877b01273a765499a8dba4a26cf2c695656133ce1f28a08d98f45e3b46a21c819358c3634a58a4154f6b5d0d91e7893190d92ba915babbe775d9da9873825e0cacf68d3e8cdbb9f9e8e6ce16dd03367f1eeffece544863411e4af0edcf975a8954923263bffaa48b35765501e87d245e4a17e108ca76e82fbae859ee1a9c411af90fc6cb8d23eb5570284ed309596ec43fb031e0e28e3feb978738cd66347bcce22c28b97e4892eb9bbd155237317c9c9076ac81170691b2b9034b1a0c359630567a539e3e284415c11b5702bd8a8edbfc7f9839a9038322d9b071d7de0e32c638b566e54adea0ba58d941a5f1f6e65700bcc3cebed998fe14fd09f3c8d5142754757847c2a6c0911d5e724955eed4cfcbeef0d7908f36f916b190aafa2b024f1dd7917b4c6fadcc13d7c58240ca481f74dfb2ff6a09d95077bc4d440828e6f377f4f80ada014419b86e3f94131bd7f555a8c7426375b19e6109c715fd86f25cb3121a6aa6ce35c5e67cb59473359b092db313d772abc8d18958e7e16be98a3cb94a0a424649b785a3772aeec4d7384fc11a7de1b1ff6953a6570cd715f3a993ca4e96b71f9fecf3b089bb41d37edc4e80e523ea9fea21765e382d74fc5aad398e12b63555e3ac60544f5d91ba00151ed36e5acd33aecd69729ee9ea21ef795fafb9965fa1634c2f8ddd69acc1f75a1e4273518497943e32da3d8894e323a0e02ed5f55e4941f168dc569e2b970a461ca16adb40dc73f05364538cc1ce9acce641ed09424c10c6dc7873db9a09029d89a24e41d94766374af55447c29c6ed49d8090ee3f7bcd900064073a2659d99c5555d3230abcffb56eaa6f509cccd99c51fc06a38d843ec5511178b747f8515a1863942201f6113fe17b6bd3950643a808efbc0bae7b9e997717d542f20ca20f788a93835a2c9e0cf9575b083ca1f202f60f43279901de4a52f17f5828def1a9f029d5de4b07e1f6b3ff562c915a00d687b2065ead373de6a49a6b86790241d7a5fa58d2e09ec4319309ccd50b122bb967f46fc315eb294a53cf82a0170b1ec10748d89781b2867fdf7ae972d8b048ec7ed380a5f703076b6e6496c130f8762e88bbeb085452597c9523853be12371299fa01ad6a268039e17ada86deadca415e065dc89b330ee40591aa73160e2f97d5c08ad2881b680b3112918a64a713d7e2c8114d45c7de83a0fd06c176f50deccbdf574d231e1a4649d1787b1542b52f8dd91c8ada42a1bcf336b0b9f2122086bfbd7ca98f624a453f479f80730ebf3a389e1ec4b14d214e4c20a9d8e17923cd69a46e9aa12a3114c27052e8967c74801d0927ab0d2eda679574994b1deb0c091bc839c892da25d9d5ab4854e8db9127179c0d11bf6cda1b69bbd51a60f9e8c8f468d57dcef1017561fc4577bab3722693fef318774654accb44831187c646ba154455eea2c38f3e5e54dc6e389b07d57ff9dc6f1102b58a2449ef58c2fc8164a5148b7e0d6a24e80fa52d0ea6130c4e7832c7688f8ddc0c41d1fd06c0ef043f9cf4b8ab2d94462a40d40e16b50f56c47923c6faea588c78043115f58217f6573c839af0d43630282ca75814fb31ac45011f8ce7d3934610449c5125f454c8a96b99a063a3c94984abc713b3c03f11ea199e884cc5e82d70516cc53ebcc1b5bee3543b25c005ac6b91057943b44e4d7619eadc197051867ec2d2a67f33135171aa7b562710f03801575d76eaa204e5b847c26ff7bb7d72b1aeb85c9f1b39bdf72f0112a05aeda0dbeef6c0b7a04ee20e652a4200d8871b964753e06e80b3199cf0c40acfc2c6ede0389b79d51dc40855a3063ea31e7dbb2ece3947f20c6ec3c5d86be86e665ef63353ac61f54669a25dd437c727160300b6905ddd0ae357cccf78d8a03ee0da5926b07710fd2d87bfec378a147237fcadb2334b69b1f5cfd8fe1f5e969322c30bf24210b9e7250895bb00afd7dcc79f0689060bf09caa85ff3b5a56b312224152b8748583ff255a34c29008fca0449761d6dedfb4c16ffcc526fbe2fac05e279232b871792ea6f368b222f5a03f539aaf2d6a7a059c1dc4a4152e23cb9237e6847881632292a52e165fbf1dbbe46e85efa76c69f85ae0f10dfd1c02dd252a9868ef015f5d993443035d7444625658c2ed9a87551b7273d06b7e5c39d7200f38b0ba72914081c9f2b87258dec392171799fb7b1316663e510ac70344fb2bf17356df8a4fb2f58e1fa23d5c9a18f814709e00232ffb99b52af51e1860cc7386e99e15c7a008eacaf0442c05df3d2972128b9f973dd496a141c40ec0c73b866a06af6e8271f03a40cc21bf7cb0f48a7f95a2b68a00b1baeeeac4c27b048145bdd3886f56a3ebfaf2ac46fe21e08b2623b3379b910b799c89c2e31071aab0a98d3f8774eecad208259614b037f37e1e6425731cd6f6ce4a808a198578d7c4bb97e762624acb39e22515d967573182014d43ce82a6849f689ac31779310ab65ec57732a5ad01b7b2819b0cd6e7daf690068e7114884697ba0ad229fabe9c5b48e94861786b87dd83f21eaa65cccfb5cd569c7335133f617b0c3c04c9c48337d7ac8179cd29f4d089b1b242156b420acebc1b68cb2625176b31b7721aa0dca0886886502e32e8ef490822a94ee25053f590ee329c20b295dbeb8892718cc8b13221698435bc1c2f1d479437495a452d7a719a351d6b9f96b341bab28424cb0367a89f01ea74bcc88eadb4f261793e29c65e0a38bf805e472c031e47f205328c8b810f86cb4798b7def062cdf0ea6959013d8a4b9a92ced0f87b395d1fc309c43d80120d74af59612fed0f1de57d2eb1e8271d01fba6923b54dcb292421079f503ff365410d1732fdefa48f84ec12e4933b6b0cb7b3b2fb92724055d11619334ab4c8b7085c174c3a36ed48e8fe77a2701ae1723c6cd46d6e22e53f5a70abf66ed78dbd5b5af88a3db08ad104bad9dedf2b3651bafd95ca4c19598c1ddc8d17248d78a6754fc6655142c875fbf10073a40ee02f0e353abb472b49b3eed826b7364bcc5778625f15e471789387e55b4f5b9c5fe541e20add0cce48f1a4b10a153db230bde853b071c4e13221d9a12dcc5349969f42b4c1114d1466dcfe38d594999028747d2c8720898f5039c70f711815b74931cbdb0273ebaa6bc88c802d2584bd1e162a82bd6a6a3ba32fe8d03b9f9c0acfc999cc11c1cce92de89509053340be495a963e57f46526cdf95c51c92af3549b0f3d0fad9e1e294698d4ee57ab80c30122d68b2c4000f72591154677bbfc229ea2d1e36621c880801277504ee310408b7282e37fd4bba909140de038f1d966cc2246cc577f5987e8b2609f5218e9ef76196b289f0c68ebfb0117f453d40e87efb3f0f63056d8113d5a1b663271dc6dc0185ce2c8194d70852769aab2210ca12851eba9cba6c467bc2c3be5b22398e0c5e22a27e722cd906898d9d84ff3709668664280f80c8ffe71cb1dba8cdee0149bbaa8e4a913355b593879a602ccb0c4a61d035243ad1318722dcc0a3fc2f12c2ec51433f4da65e19c44d66b0ff0d69e50e478da9e2bed296c71d14af7bd25194b10cfd12fc658c0a89759b9735793d0697557a95ade380ee657a05025816ce335e4b51f8ea9c8af01fc315f6a195c4a14adeb3c28c38bc2054559c41317af487ccf8d4192c66cf5570388460844b3b1ad1880f6127f63dba6d1616a8194ebe28109f7f699933e3f949cf4399f6bfcdff3e5f525b4b5dd1e038324ca8c98e8ccd55e094e2bb889077d5af72d89e882cdabbcec667d61e42f846618013431a22035daf4dc4b83d21f2039f18a33bc86c6cdb18341e1d2b808b9baeb9e7aefef4e5a17904c5ae1550aa06622afc0fecda223c76bbb33215944d977f44ac6808d956266f9754cf04e9fd355a89b8dae5f07322a88709ca81ca529093559eb43588d07f645bef4e960f8fed84048cb836d045605dbf173883003e5b72e1d284a3bee78c170e1cfe15fc992bb1ea5993a807a16638c6f33bee095496b2c5430d80aa5083c682101579e2dddf8bb06cf97a220ec0e03ea40de96c5bcf62821088fd389d153c8023c74ba284e91b533feb3fba08174253d49829ac2e4b1d0fdc3c007910b229de64a8ddf66398f572941a29326851ef9f9d189a1cb5c9088e0aed6420885510c957355e2e55c8101c8ae6da67bc3777fde84e2bbb8d64c439a651c7a99aefd065fafacc14856d8894db0130bef2e537fd2840b459204677d2925f278b5c190ac6cd95686c72182b0d788e7cbf0acb4d9765bae21e2db8504bdbcd3c8993279515bbd38fe22b34cd4d0c19afb49c6355b8640dc7e8ca61b7a33d02baa8211d23494d365c0a07a9b3d91ba73730eb0fde288af4d519d2a2c96558a37f9e91267883dca215a451c62fdecc496c19bb4362bff677b5b8cea991169d69113fa3977a3f7bf5ac8bb2d11234224d15bd12a8f540a5b145303a53aaafa2d9bc7856262739fc64f989035a44faad1c5926c7a85defa246d857692d7ddf8d5cdad6d52ac5bce211f43b292479319a1abcdb97017cc253db6eae22cb83fd9c65fc51baeab93479d75124f6ca5f38b67180cf252c3bd374dd56dad508ae73e88f5cf912869bfc6483e0d1e65b71c9b321d8ceedee39b8252cd7007d83968bb427e76a3beeb42210ec9bf0db4687c1eef6c961d1b9fbeced98bd3f61bb575e5d57d9ee7e80f9ec51a2c7d0f655064fd8aa980d5421f404ef9c496fdcf861cf2daa4db03993c113a9471ca449ee9db337c1ff2a98e0decd531a539016460f0076fcebfaa6eb084aa123f5dcc24a5304a9fac9beb7944c2f2d1027d3ac3e200e1c121698b0d4c445fb2ba0554d01be5bf89410987c781ea61e945cc9e58b0f747e16b2f09afe04d03c49ac2d6421ef95997919af69574ae011cdd69503a46a79be5d3b75400e2760c2667073a1dff2e69e4ba6dbe5ebb2ebeac31dd4a1961e7fd8f4f3dac5939a291b41e4b89f4ea3e381c73d81125afe7458ad250f1e147d6b7dfc4817aed0b7c9516b4a15e49f4d546748208013bf7e2120535996d8fde2d5f9cd2ce778e7a85778a670a858e1dc3528d33a5d8815766fea44a724605de7070e86434709a9fd9d1d013828201284055b393199fb311d549aaf113b313107c5255fd233e07621ac18de804a780687370c48e4dcb07e576ee708b23d57217d24db63d4bafe9bd694b86c78c94845320232bb7b2f5dd94500e01990ddd205bb052967a88e0662beb39b48c2cb1cd249cfc43dc1cebcde2a21589da6ff30440f02451cbba87d6ff6bfa9b549d044e9260ee092ede485b1d5b5fb02e7d9e9f097b73f97d3d67eba797532e38c7ea2722169e7821ccc7a7ec5037fbbaf88e25cad35d0f55fb3ecadb21d40d454ea2d5155938db3ac63f9ab859e05f7c2401e05e96c491f160cf6ebc753ea8be567d6e42c574f5ec2fd58f4adf9d4442ce045c7df6741a25fac7bf678f415a8bb78f66a48ef6d5c5ce643f7807cce4fbc6d18f5752b78bb7a1f515b10eb844fcbde209fd153af0e21e17b100d8ba065d9c91aacd7215254e93732025eca322756462195b41316d5d5009b83dd0313565cbcb875efb9f992e7a3d8a1618bcfb040e7bda5763375c02abfcccf98817dcb5e6122f5f4d121ed5a8e58c809f838f12d0c3cb910c14e626ec873ef79541cd64be95264a27c38c71b145b6963e8c0616f19b002c23cb54ef5c852984b988f2b1fca19fff0eac437bcc7159fb79854b17687efe4b3bb007489cd1ebb99021138cb55fdf88b9972e3351048663372b456874096dfca697c755431fc8a5a9396835c32bdf7a9ab2b0ccc9e7e79008f5883f7e2a8801331adac1218d5cac35fff01d832a17d605055526ca4373120b7ee4be9d5abfe43e41adcf46698f464878c82ef5bd51fed18b30937b49c656426e3287a98c4534004488c876dc94befe0ee91d84583708e10062498eb86ff97ed07c7a479864a4f6921b96f1618fb35a403cc4eb2e1c5a795cc2144650de79799cb3bd2185fa01e33cc1ef882885a17d4bcb5c5f7ad83fd05256ffbe04b9d6f38b500a027d143a8a6c00b25e19c2704f84788690d706c35eca33cc504e1f47d0ee3e11c7017ce1e2113bf49add637bce22e088863a48def4f69751e89cb0b4c8390b177d23bbf5c4463d94fcadfe1df065fef75f323ecef12d0bcbe5d6b8a684ee892832c86abc265b1d6951464ed8eedd1e31c0fb0066aab1873f3fb1a36b95268c6fdd2fad202d1986aaa011739c56ab9979eec54cade0b18072f4194404f9b6dcb71ea4592ff3b4ec9033d0f0dac10ce18ce6347fec18a13b0a7f877fff5d5e1ce6618edb10edfe8130cd400d2e827391ed67324d990e8dbdd3a6a056e1f40abcf9f4d7b967fd000ffe9740fe74c1530aa83357bf7b61eaaf49fdc857ceddeadb5089da6ed7b2402d1bc493792dbb85cac1f54b43329bd55b479f8111a1915e561b858644fe7ead49debd8c7daf54e8b684c706ae90ff2f132e650a620a55bac8c7e4b0cc8f3c87c435721485f5b623d67d1b4f8c8b0246b83194b5aa2e232f82f148b86bd84e265738d604d49a9608812862e2b8aed9ee40ca00eb78b2a990e01b3598f8b4860a13d0bd8cbe2185d7e492986a20500e17d69314ddf9270045d90ddb0864506424c851b7720e8f3f37c28b3e6c0816c894c85006a0c113a14e99aae8635b24c829b467aff6ac8dd00b54fdf8db9fd90300920df4a217eb472068d1fe432602a52d4cf14cd409a6d64133f5306c32bec2a9990ade066e22a8a0c55fcb4963d332345b4d7ad532da88c16f1004565c6a384ae31e81d1e27741e7173bd809312c251e24b7024ce799c41841a806db3f0c37c9eda17c105adb15663cc8781ee87acf0966a20d6a332e9cb272249e8225fa5cfca638705170adf6310d268417c5e18917785908e647ce6e6398b0fa51fabda676cd8de811884429d7addefc15b7b4207bc2621cf6fa581584e4935248c97390df190e15ee8e94c54a0d567a55fe33b174fc7b5b29a871804d1644b847f5389ec4c60d34246080da1e3b3b35e45975b662b5337172e051f022a47f4448a37945559f102b1f77574f615f3274ea7bd86635a0665e8159b5062d54cfc16b2ad3e91daac79e5284c9d49f8d485861b71586e153941a06cd8115b05147394b2dc7c6fb34624c72b3126bf65f0827215ce6d31b3949a5c0b84fa084c9ebbf0b81e677cd95fb02acfb47342538b1fabbe54cb296f75faa7434f6a7529f5ab40ffebe6a1240e088afa51831fc2a6a7b0564e19e1aaf1d44f5623a857c5d974ec6b2a2e326aba812a0709b154bb48738eeaf447174387fe1e30d36bca7001faaf49121d3d39616749333bd6b5f5a5d0c426aca48853c136c8788cc60d0f4f38b7a2276433dcf15fe7efa1b0dde8aec255757c22a4909fbc5597dcbabddc096d9360c86780f0de0ce11569a8defce1dabf160d87c93f286c462be9b89d2ebff825f6577206d9f887194a8c56ac3eeba062b8f6b1d03a79eca0eaa2c1858e55377524547b81b201d364e61c13458873f5c7d2d853bbd3dcdf63b10cfeabf383a6ccf001081c09ccac1f42300896d17ec20b480010fefb524acd334ec30317f9d50bebc6d3564790574ee67c8bb45c463505fc8afbdec238ad942beff6d53a2b0c869a88f5d443c1f33670f85c8fff2548b6c29c078247c66bc124406e8cb9e5ce17b2c01968d4136c9e14dd976642810791b951f33b19b0f0852971d792b5cccf3d3b79a712ecbcc70704c4c149827c1cfbca3a63c21589401825e7c48b0c8cac5b16b5d7c87770af10112a38489c4466004da7a9e64fd6274daf594ad7f086219376f70a09ea229c1199b31501674392a65e4e8451514a8f501bf1fac473060cda4fe66ff6e53c76355d8cce8206ac28cba3c42eebe808887269da1a0d4900556e21b15fbea5e789aa5f6e46e34ae266be5eade67bab72f877f9db3c8c2a698076598eb28854ad009599e4419d64691903f84352a1b29deb352505f15e4d41075661383180f1e6963736e9edcd3447bbc7bacc5bd687c8291b08c2b2dcc789885eff66fc206f854724d37eccebe7815c4dcf2d2a60ea3fbd95f5b1159837082984431b452b2ca9c8a27976015564b23f51435a53ffcb5e5c8d0d629db94f2f191c9ccf55e726991a36b0d64ff75e69d6ca4fdf414b8005af92476b8ce5e4e36f5d239c408d3f5408b46daef86f0df2d29b06671ed05f55823888bc4ec332c4caa5815c06642d7736c3d972057366b3b68890987ac4d64c6d054bc4134d52e04ec0be7d036c9fe937751757d0359e2a98351199bb5e81d28bbc0ace58723bc49492d4d7fa3430f0ee4a167fdb567c7f886418a39daddbeaca4bf592632ca6c980393469432e6a4f234ba953b0e5abc889c4d2030f7ac2b5f8c1570302f91affda4fa0cc283efbeb3686cc5c604e2c4edf49968369bd62c2178d36d3306c8c5a2b3def520ac24b0303d477a548e779f748ec7e08ef114e1e91803b1ceba037aa6b81a121f2bc5e89caf35ece50f9f2804acd0d8a32e5e78be82e1595bd25115ef65c0ef8fa345b7593805e17696d1997d2f7a8fb1aaec34e1d7766704cd0523fcca3160176ec685d78866e6fb4b48c0414bdb8ce4156a4b4d7f5e6faa132c03f0be9544a8b9358a0ddc7cdf4d664f8f3da8e56cdff67b1204267ee159fb472e2aa7027cb9cf9bb1cab52b00e65a902fe9c68e764473c657477c6039727599c8e5abaf14509df4875255a0e1e55e6fe8b5cd85950c1f4f80af4a71db901426c4ee7f35c2b1d30c825ff8e72617c1c4af26bc34d4703fa1645b8baf52163c0c5bc89556a1ee4ff0d8016d22c3585fb2585e6d4032254506242f62a5de33c455541253840667204473d8df4fec327ec58b89b71a8621447651d20113a01923c85513f13261ce63af91dc07e6df0bbb48eb9fa6264e1e2c1cfa4a6d04deef996f207362436aaed15e60aaaf9534c44b96213d57765b9f76cd6f3e38ce1a99a4bcee838141e22b98ab019961a07d69b186d4dac8719cdf3813b78adee164c4f1a46719625faeb5ddfaf059254b1303ec2f0a0d3d5cd5575a19af1266360ec07947f0c619e005d0a70a6e55bf5ba18d6c314cf5a29f554d903817fe8749905ca247b11834b7b2b74cde20ff8f1913483ed1d6cb1c8df23a21f824efc5aeb87ba468285b629a8bb897e7421f5554445c6eed2edc948ef320f26bfc54cbc223ac48dcb0178669e3dea1301607fef4621a6a43eb568183c83cfcffbac2f733c991d2dd9da8ab98bce234416e8f532a62d07f9b58014bc8a428a1c336b3fb303d3b4e53763b08c08b13e5c85da66e267bbe0da632b4b9c1ca433442062d879b259fd27e468db988314536af51fd0ad963afb9077566e17478eba50b25b3fff1dc2b8d80919d1e15942ca240fdeb787ea154c167bfb301c47aea5310c61d2e2353a6e35a01558fc0a3557de78bd2bd817cead2b2347b2c36d4ed7a571a815cc0ba2224ae8f4eed16ed8e3a671bac55ab1df985dc6b732615203a5b21fc7d8495492d01109beaed0f54d4e91f230720739e001f4dfbf0b96155085f088d8f3dd7b179758c96b6de0282fbfe00e22e6a6cf97b6bd99f7382b104112e036903d9ef9b0dc18bf5d0a661bf5f90eb5eb2c78665391ab280ab8252c1e5064b423926de67ecc27b91c22df1bdb2b5ecea6f0852d05a8da48794b0c76b15c26bf4f1d9c4a3dbfd6c87fdbcd6f831555aaed4d7ea4462c6cca8bcb811a7d9809630e03377cc9882e9f0eeed7ca484781c838e38946400752647dd67a46bd25b18c60b11f8ef25bf3029c5be793599cb7d71729c1b00e34d3d8ae5061f7c8ec15d472a403a0c0604b93451937c93615c17e15be99f787adf06bd92fe991f97a37bb430ca89c2e5577bc668f33db9415970fddea063f3fc1d0a9967b542c09df8557fc1f4555a015adb948d366a230ffd8adb26d51990c56d16b40cc663becaaf19fdadf07a3e5161b71c6e2441b7799768b5a1251fe58218c756ac41863e643adc3b933306843f550eae7bed4c24c3003576c7c9575033bffe499cda3035c257ef2dd12175d0ebec7c7c68d616f523e1c06cd47331660884fdc6b7a6bf95c68f9600e27a71aaac0b878d75e5c06b7b1811e95fb9a6268a2d926a5818a8935f2dc454f42ba891fb1c2cdad0dd97a70636874f99a51abad5d3865dbd07f942fa72baf45531ec49f199cbeb74f38e4a09c3c0786c80d41cf70224309256eb75470061fb6835fbe11445990502471654e41328581ad6255cd51cf7e2354cb3b830fc158b43cb4528ee78113d0e8e50d7bee9aeffb677867cc3cccdb3787c2b7d4acd5ffd7354ed42cdb938a5938aca8d24ff4257f6eca51c1154c8b3c6da70f28bde707c82f63a1651a3818c9b24b97f5b2975c44f2e96284919b4971dcccb1fd30d5a90db46c177cc9250c0eaad4c507c0c21bb6503d362df4e764f0c606e8887df60e6014093b0ca61603867eca6628b7457454c3269d1f76491a4542b19fdcb99d11257f604a76362d08c6cc74fe7a0681bc1251529484c4f936a1cb610452cd5c360a9d4aa0fb9cc2fccce3c2d5c8a89c17d4444fe9d7d648fbbe4b68edf8555e37fc55b95ec3d6aceb62f6913ced6850f7afea587f10b158b8fcdd10877c899e066b8fbab9b814cdfd55e815936b8f3d3e2352f0a400f27c60ff8f8d797caaebbf32f3f786dccd1c136b7ddac7cc2ccb5f585824a34e04337f00412c3583e99ab856e632f6decf51be7be5e83d3477cb0991aab17f0417554e6d43813677df58db00aac7f7f397032810bdea1efc75cc6897104460c4dae030c4163e1581de271d92f5e5305b60f237b3688ea1c6a6133dc620e040bca041fe442d2cddac13e815d01bcf1fa5664d41abd8de92368b23e116e85c658f448893e51c4ad538a03bd4fb6377942d649536a28d497b3fe4e06ef401f080e846c16ca2f7c38d30deac1afbedc5dcef12b01620a57451650a86b5b57d8ce8ab5dfbf718ed43a8a66f0b126b4068738c5f6f3d643995c434953ee9980e1ec578088a807a2584b2f00b743d3521e4839090a071d04a5427f6815125b5fdad40bf2e336354aebd8203634d0afa6248211e9efc27853db8393181bdcf00daeeb5797f3b7889c93e6112d2a2eb12429e20853fc649e594541e1ff5635e96ef080d321c678a7ec14b4df169b6809ffea3c30135e7606d10ab8eaa5f4a1df9cbbcf56d863366547ae29650672fde936c3cbe044181e373b2ba63c27990ea461570e91eb65845d8ee5e2fe7a2ed1da3a4895432dfd3fc23174f82d5aa51ec134ab5db1d62288c4f93218ad0b8a08c1e6a175f391f25226462f2b49b2da913e73b18e5bb9038f2630d0514589731f6a9aad38dc8e0d0040578adf543fc22048c2846cc0c38c9abfc68917186b71b980803c52d838a49fbc87510c9bd33858c52a89ca2f711f4a06fc84a1f2a8a544e1c5e111a3ca281c4cabf4f026bd687f949c1d65a901a7e73210445f743f0ec558051041f645a046f83840fe9f06e64939779a155a5a296e963db7ab2c283bc0f475c3a1062a5c47da0cd65eb48dc7a897ae23a245aeeb3327e3153bd6d504cba683a21ce703d4c53640a41eab2d598fe21043e69db496d2b1ac108cbe28e8fb9037ef9d305fa424d58bf4137279089d20cf06368b161aa68de571245e9cad7af27ccb6f998caf6fc6020f4024bf284fca22f6c7747d55cde4854aea7f4ebbec3ada568adf702fac3bf41dca6c8bcbed38607119945476987c1b1ef81d9e15bd86098da048c0b226757f7e376e854cef4fc8d16b750eca29635455599ded17ca1cbaa44550b443c8a447f74df43034351929344a59861ebf0cab798106f100c275e732f79d47c2285684bfd099674d79333dde322ff412b66f597ef0c51f5079416c621547c16b4113fa17a1552fb0b0023d471041c70f63b458039858ad9e62a8ddd52b658711c88a0c4abd651f5a5f97e1339dae6ba018d2ad5811908ce97f161ef63d50ba403a6ec8cc9dd557227b443b17d169442b7430644ccac76c13925b744a8fe0cfcb7a44966c48c7698c68523e1ed11d221eedbff9a12a7b27c62194780854c02fea6352fca0292ea0a50e5d37adce58fed3c0a17430b761e8fd2e615f5862285f4d9177cdaa5b414cd573b37e9ff17eeaa24b710674f95696b24582d9bd525603f8957ce2106d6c24518445b58a9cb9475ad08d020af38c3bd25a18851570bb296da56f7ad170c5d2dfda665080964802ebf8149104d2c9bc4856328eb8a14efc08ca9818985a99ad15639c2969c7524ca792bc38632c794e980738a93dd09ac1ef67074ea58eb78e1f81cd2b33b9471f26fffda8720bc71ccad3be7cedc6f9bd29a28f64ac07ae8475253b919ef1b92d65032a5b34521dac46ba52ca216a16333bb55d77b296d055804926ef16eb3494e483f093b8e53837c8a343f27a74f65c4c70a039563358f60cf2db3c3559281bfa51e73974b6e908b97435deae2e01c1d06daf5488107b39e4b2b5ea52ad2b0d6aeb342a9b5f89918461501eed108ab4ff76dff4c3dfee4989e9b2ffa12f1b221ee5bd86c29de37b8ce2eda0fa6cea5123479dfea6dca87188fb5f032b0f1ab979f7ca533a1ac19a9b8a664ce7c8b93a781bde1229fbae543b6575d72d4e652f52cb912306049925a0f16e78890a84b029771550ee678729820b1c50ed0e458a6fd40bd5c8537847812a588d38090228816841f853eeeae38d8729d225def16869952a06a4641c3cfedecc54d7cd59822a7c7874369897dc7b3fe1c0effc13acaf77530ca7d1ebb562a50cc6e90f517ee888fb2a8c84d000f291863ae5803f6414207a5e0e7b1c582b06c40e243f06634c8cdf695074bc24db81922190eecbfe0870d81dadffd225b1f2a3d3424286185e7db59cd94106971fff66d28a7d7ad4d6768f9a2d57f042df69198a042b1ecbc4f3ee527e6bd45e5bb2b95f6f4c70aa85dacf4452282b255257d2ba2c5a38e84f2d34d65be751e1ea90837e8f028463f94794d9cab351f19184c82c46a6d9cf5a3a010eaafa58d4c3a2cae7424add4b2c7d125dd2d37cb02d1abecf2ad673941c70d6e3a80b62c9234b2efbd3a3eb99185e7131259b164348da88bceb37cb1c3fd5c29f07537f7203dc8a75e1fc976704e6999c6e8f8ed1474d5cf152b12d4bb11fb01dcb35b0f5c6e54d0002a944119f3a11488cc5ccba6a7424c285b145b59bbe9bf04acf707662ef9c990cbc642fe067faac2d13ab2aaf0606604a78f4c6200af5c40d7fd87092fbeadc7eca5a4d4e02516167f3c99a1e62d5753d098c8136402835df23e5d3c3bb829720daa0168ad1349a7b3f01490c73798cd87b6483d40f474eedc7c16b81738e9939b910dc704b07f914fcce15e823b4571e1d6febe4f9e0a6b67517cdbd64e3974fa0242549d5697dd5ccfc57c25b0bf7d12156255c413999f74eb3127fa336d15df97076c9024c8929c29de61e7f58151e231a34bafdcde4763fc99d355dd0dfd62a553e02b8746e965fc0b5fdc5183fb6a47700652f712a8d8a1090f34269cb62852a8cd5c94a9166fa517b041c874bdf2446dd5e6a78fbeba9b09ec140c750e3efbc8950c113b2e3746e22e22e0b5605cbda4b7db284e8a11c864b9c111f4b35c96d2c0abf6974ac21a0ad7bf1f1de14633f1a4c1bc8bd06c264acf94869f039edfeb1699655623f9dd95412113e81d3689f729813807c7d29d23864558d1b6d10c78d9e9d87e37669c41c32d7a4502e3a3727d8ad6c60fea7217a5c1000bcf70f8380f61571eab5590089d45ed4f3f4e06640215b42771589ff36b060cc1b85cb089d76cfa05af715bac007e5914414b30df22f12b463d1fcffab0807632087e7712fc92a0ab67cdeafd32d74ba46d80a36b9ad2bd29d63cda130bca67a83a7eaf1c6feca0a0865f413","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
