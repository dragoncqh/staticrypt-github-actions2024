<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2ab47da61a420541c0c6c54867a3a144ceb95ce2e6809926cb2d6d5ce9ed51b72be51a13d3816171dead6e7d9ff13ae6d82c3153013bc526cfdca8d78efafc803b225bbd17aab34bec3b64842f6a256e16b0070f2f8e1c615971bde819709097be8bb8bacf63c14577e6ddae2eb6ca62a82effb00cbee8632a8969085898414e4f32e7ee3c4d906ec4e5f18e4df65653434ae480f4969ce39d4e0efefba2195a2d7c68f56145c42cf2582f0b4857b23224970e9399f27f5c40812e90655e3110896b438addf73cac32f37c925b50a74925ed728b173a06537cae009d33b82d97e4c35c9e4a10056e05fd6f87cf173d0a9422ae12412c684dda75f9b51d9db44bec56b5e9f021b74b534afdec93c3867bc5fe2fd58d2909222d3f33f963d689d47de69e2ba92384dddf4025ed387bbbdebe1d4a83e515c157b923db4de601d1f155f93237ff4b76b5b92879a720a4c7bb463a3343e3d50ca1bbf78aa3b69c393829e65487b8a484e3dd3fe68fa820d5724e2c7cc9f51173d44d90df6f987371150adda58ad78161bd398d567329a421b393307c7261b4fee748afd9dd7d35fb71cbde89740efc926a3d66ae407f34d9293ff179426be3a5a8a8be7e37139d7034495aea0514a445b7b0cbab9a0dae9abb85017be29c2cf6db14773627457a8edbcbf40bbf372a6faa6b28821f36cb76eb90ee23d00308526c5be814aaedc184de7ef6879b586a796160a2e5c36920d445b75df0ed094a89f130b8a5dc81fd1ece614e6854a4af3904fa651d39b363b038762106142ce8b0393e59c55cca867f3191fae5ed882826450f3ded3b99fe756c311f710c53ad76b70ee1b89f688a0cbee41d5ef5107a285d0c56dbcf18324b4469bed7f059c4805bad12f5074dab1dbf0b17d93be36a8ca648aa6c1b2fe2cffe8c29b0a06069634d5610cdd6f846f646db5448a2fbc5db59c0d2a7887e69e246e04a857c3fed81c5ede9e47f6e1bf2c94d00d62128eae83939a4c9b56ab5885799800efdae256186f94ecda6873dc46784dfc1a433628821b8e250230c5df24662f0dc449ae09f35be10e9b7ea655f2c74e0b8f113ee25cd530e528eae524734b5dc1018d18e75c7e196204b387214c78b030f52eb0672b6d4972462e2e94034578ba2f0bcc35cc68a0d08c1897e7873204e06b420f2b2518a748441d7005ad6bb28b26850abd5aa6dcc074a2fc909547fa9e5ec33b0713773ce22d7e6556cd6f05fb856eb64eea87c188b3b0f0f0d91c5e6913cf2c154bb5a3c98a83e5436eff61d4fba1ac02b0c22f9114955819389842b1b71c913a23f0de6b952441a4022cbfd3d03107d95393b85f10e6288185656cd20a429a836dd8f023b8fd244c494ae157f859ba1c6fa65c7843d2b526f1502dd0e64514a28059c7af56dd04d560f5b615c97d1c691d33afe329a88bbb30b9abc1f6560b38b043a07b14becd44da38738fce9b7a368a7b35170686e8d4e1c0a1f6779d5bc61c2d5a7d8cecd1899140b7981c0f44a7a24b0b8084a8befb166c8771a275636afcdef075ca9958a985a15517c03c7c087b91152e15a67cb22110a0dbf9bba0991f6538cec8848d1eddaac2c29663ca6472a4ca3d63215c9aa1af72ffa4b097ec2b4021d497f9551a12032725afd025e1a2526457b7ed7b99ea77323b8439f993d44125c7b69315c17fcb7db5bcf4cc3ab4135b5ba548358bb65b718d8e353e9d02912e09cac487e8ba9d782969938c4943d07e37b00dbe30a219e6238d15aabfed10e2f101ad5d9da6c8145eca8559c42b6dfa92bb23c1cc4041e514a97f8d3d3731d0d20aa7337e8b4a52c3dfd2d6b1617768afca63009f9fd8188cee186eb4e2bf533b5ea35d23d58c448f8598205fe8b25ab3d395358a90d3d8316389b1acaac496940b553a865c01ccc9764d163f609d542793ad33d5e8ea97505d609813fe8ea51dec18592344f5040ae7dff1323bf7ed1f5ecd5d49e444123ca4dabe4d455f7c1593ca1370dccea3016ef146b414733b0087aaf7cd8671aa99274db535af28620d73e75a86f7630e13dff9904228c61739f346f160de7a9b5694a3d3195ba280ee8ba93985128c3624ab29d260fba5677634ef5200ac0a1eaf365d7e7b6ca867e0f1085739733a09c65b665fcbb30e108f22ec04bd9ed98d860944797b678a9f3a0046eb8003ae363a3c80cd93c5d53ba0b09524578d493bdc0e670ff45652bb1abdae4ab2a4fd74a93533c3288e4554eb968c6581f6cd1e4c0f7079ef4fb273747ae5d77355eadf7c1cdfe31327b71ff1d405b8853e82aac533b4ab2770f1cb945e24445b1a695e4c59a9db606f2f80354cca18427460322717a8e6a0b2ef11cc4e9a5c20b6efb36039363417287bced29121d9a97f95b6160f3ee07d4ce8e9ef55a1620d7d2ad8a91906bb31eef683912f848469a1f027835edf40c5fb1b639c36db01ba6ec25cb343544d75149b30e89f3c5780d088a3b823f9bbfa5a217236807c7ba5f1729b2d5aff883e5708c623c10ad0d05dc560bb1af014880f0e045ee6bb2501c1aad29d11b3b9264f11426d46ef559afb6a93fedc076f69ef76951191c9bdf4cec3f6e3b5508ebf3d95304a0224bc1e5fb43930ec534408734bca9ae1597a2ac34f8984c02fd48d3b7d381fe9afbb9e65feb0df8fa5909a25ba53ebe5a9bbd32852278f48d8958fdf563b1c18704aaee82b2ceb541a3b7d19a8419f3c97e694f3213ca1af21a7ef6dfc3d5599bb7c11a743c4146612c972646d925c537d6913be6f919854ac95fcfa1124e795211f88d57a164ac203ef6b0c3c9a5f3b1996b8c9faf0e9211082f7aae5a9856537d74e9d2e991f5b36c00e951b28542b4d014a92f801e98985db5801b7bc984b7b4f125502cf1c32d9f40471f4f3fc0101f0c1dc4be608f0b1a601048d07a1e45e8ed637e2df42e3936b2b280f6e5c8a5011b9083138101a8ae61a1b3bf86e62008a84be743614a39cd790d0f990e13c29c791a82fc1568ea173352956b2c310ce7f39a8caab46da8e2fed5e648cca637525b2954721423393f1a6fa5a9261797b751061e14b9c72b36c31e744e7fcee1faf67cffae718cc906e2faba7d9a14d5cbe9f3387ea09b3e45f9dda048c6d5604b21e9891e477b08964b81d0ec8881cfd164195c01635182dd4e7dd90d1918ae15c7b8cf888a8042e5e69fb59c747631ce6728fef56ea609e2337ff0154131812cc7da88dc3ea4db9129da413be7736780928c67d0fb4dbd041465ed49eabccb89404d976d391dda7f40708845795a18481b258167e8bdc6763f77a5fcea92b7c76d22e5528c0e5d809764dd2fdd95b5df5619c05c17354f2087437bcf3bead1be75291a2941cebefd0232771a354824cabd304669fdd7ee37b266db38f1771942611fe2c8c250c774096528d9a5e51289d9d318ed4242184c1dabb93e336170cef21e805a36cdb932fca97aed519b60fbb696644c50544ab35137b51f37553507b396e287ef532fbe911f69172b8295eee7268581f6bd0c672a2395dec1e1daa201b48fed4672e3b6d0ae0cbf90b2763c6fbb55723213dbc15143ad8a4137d5672ebf2006171559337d3274ed5a8ae0277ba1a3cd339834413af5040843dfa2155b8edad88d7cd0a32d1742d7143e4fa0cb17b87f76c26bc28683dc564dcb6c9369bab23f98fdcf59c4b45dbcbebcbb7fe18447ba4a8c75a09203d7fa6fe25ea88cf547e6fb70aec9afd7e94d5b19317a030c29f942ad7def58856ef9fe70da492be72d28c5aee24adfe8ba3b3cc9087399bb05aca7832c4ea8a2bab0a52b2b5b5f1db5aad66ad7c53c13dd68659eedbf1794184e00bb2d10183a0479a0d1edbeac165c7a8dfee75d37f4238c001381f6f310fe6073a6c0019da03a9c584467c2a0da25675e2c3b0d9190a8844d0f9d88421e6fd8a46f8ad0540b47972a8aeccd4887cd5e08b5d9ddf80bbb5febe5645d3f4d0ed602e38d2cc291ee8c64a46d6ac80be43203f98da7cfd523a636e7ed1a284ca44ad6b8bd28b06116270d69b74b9a3dd9c1452c47c94900d848b4fc2ae64af9b7fd03e38a17d706fd50a18b7240af99507c14e749c17a86c7ed3b2f4c5858715ae2baa928cddb8310e56c4d8f4cb73ea0602a0e0748d0e7ceb07cc5391e2df261592e1cc68b8e1fd73d4fdf4ebc0a8fd83a8a14d16ec2be61165dc80f7e3108b013f2b84b6bb1997a7017b12c662a082945401da2af221e776d063eb11e07f6703fe930a690d3e607f1946d080bff7aca635866f009c273061e99b7e6a49a27a4de133e4ed3eb446074fd6586effc41b6d29ba6232a418496fa81b6c6c27ddf224978d403a24fec5a06d258ee2505902737b811e57e48fe03f863fd7016fa0647ba109e6974cabf9020e8ebba422aa2bb22d46067d7ba0821470d957c7885488e8d4abadc762283c09a7ff16e84a77e7b0dee4670a543d561630e6fc2c785ac77013b20be1b73b594e4101b658faf4bb36cd7273049122a57689f1a49c5f01f26ac7905f7e6d5b3f03c3f809b84c9b480d0e4cd12e34447207181ae1c7951e840e9e037311c8ff824f2025babfece61f601976b1ad60b4ab9d2e7a47f917e899395f7bef3e46a66849088bc7062063c02ea47f77303c42d06301a44f10476e82472332d5c867c5d60be46250d4fce759886e815295d70aac1d9aaa452dc8917f54123c5ac034c9789e721b8a92a3e2fd43bd41cf1bfb09d000cc34bf7f34eb2ded2a30f7991fa3d2128c5f79bb37c3d499e9efe8828177fd1d515a0acb341641a4c8800cbcb466c40e01c32c6c33d9b520851c3d0cfbe621a55cbb9675b153331e51fcedf7f82318ea9061d2c4b7492d9ed8a6c0a87b0f67333df7cf0c06b593ffc2f74980c4c4b0328ab87c25e3ea46dea8c5bb7bab35ca4f53740fa73bd8e1fbdf41ea40ff9719028455f517998d092742a68986998dd70876ec3596c258b8e9f8a8ec266d2f51676b87a7195666b8400f7a77fc2ff3f8c94165125d4f5526cae521212770b2f2cdcc0278108ec13affa226d06eae2b747982e9a852a28946d3021f68dde48b477825132625b7420cd68493e1350d81aeaef3ff6e5043c2a472a20508ec9fc439618eb85670529e6c1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
