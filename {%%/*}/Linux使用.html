<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"42eacd51d17b071cc1ba27e8d167d1d103505654814d5467d1ec25f8502d3eff4472f1256a93142f65d7164cbd76a7fa122407434c970987ecfd475258ee529394ed52e82728d6bf9cedc032cc0b23968a710457e1d40ccf74686b2d7888d553e8f1f2b68814af4d67e293dbcd73da6a31d17cf1e0244a4d81e492944ba20fb90b633bb19faa3f87deb5b8eb7e51b2d5b2884c7c57875753b6db2e701ee5fdcb56cd068574c5a797a0990e0d606a82be5af5da39539c5fc260210b918f0f2626a07b3d5081563f27ff1685cc0f780c709ad1a413b70631c836e96c01f88c2d3a801bcd8d383439c1be775355607d3331924d4ab14d28243ec2270c52a344ef75e45749020f6ee08d12a4a34edfbadae8bdc45b3274e0adb5c854575c54b7d593adc8329212efba3087ab50295f042387bc65558db6e39c58ebf1a70b1476d90074126841a0f2807c0601c2be4ac6ead3fab6e049fbdc4339630e85495470525d46c9bb00ee8b703f7fb9e982ad39130663aaddb1c529c41c175231275bbfc53376e78d8c4a4a43186c1344e1bac8ab3aaa9966ff17375abb922663aac120dcf61fdc446e3cea1a7d4157264def918a39116febacda0a8df6f65f2fa118a039388e89c3ee9132032ac644f7e12638c4b0df3f3cc8ab5a50f5739523908a7bc2af51bdd7e32ad330286e304f2310dbc0671022d0dd44721a55184eab1863d060dc9955160936f656763c1531580056ba094cbe3d6eb99ce8ad9f4e654ff90393ca0697c7c4f79769b2b4170484998d4654af868538ef87178be6fd212d3b2236b7ef23c3cab4d2b435ed5c936040019082c8cee9face2fc5fc31e96f2b80f9a297a95386cdbf4b88d19f603be9fa46c41385dc3a29903bdc10b0f72f048486ab62984254bb872c518133fe43ea559592a580855018abdcf4187802fc314c31e19ad9ba4202dc07abcccadde8995ac7b1a1f25262bfecac138b17cddee6765524879faedef070a99af9995bfc20d5ac929162a2adac7961b93fe8dad39c0bf79acefbe483c4a435587cd1045b319a911cd59d03a54f94034f2ec4557a3fb3c6f1a8cb5dedbb03bc7979694f285c90d56730e1d6811bc01831eff319977f43c752bbf993f74601a0b3cb0a13117fc3172d6f35dcd8cb78ff88e02bab02209b02d182029d412e910ecae4aa0bada976a19b52b63eac5a3335830f3431311c2d8e2394197d09976d5d1ce9f5f539e01a6cf0034cb939f79a1dfbc55ff6ec1e817700dcb9e61db35829d181a99824e1139ce4844ae703c2322552486cdf47d6dcfa17977e02c3bff379466f3723782a27facb2831c6808d4331e52d0ce9cf3cd4e671f11da445896b7d6be5a575394ef75c3ddfedd476fa89a4b9169284e169df725c379d3498d47ee22a193ef1d6d260b115c7e99dc157c1af74856caf8e1f52353a9774738ebd5d7dbf72edebfcf5e42e1ad04c489aa1670d0e14eec34becfaa36953a9a2abeb1d5905e69fb3376c6e89c9089974fd3d8b2f1ec74e4fd60719828247325314f2069d64035120c2fea4bfd781d9bb6232ea3aa8ec3f1d5e5b46dedc35e66cf865d8c4fca0e011866002fd4dcabf71dc13f7ff605aae0287fcc7e3af5a5ae010f5de14690d7668a90b6a9b007aacec0e17bb911717672be194217dff695627731599e9a9ecdb19846776e3f560fa59da4f2e68e07d6af0287b45dba1701a22ccd5a141571501b371f77215fccf45488f560b1874ac7054041f49519a7bb10a1669b2ea0204d44497a97eeaf23f77693c211934fefc4e344c8f2ad6b3ddfd7f8c11557de792840fd0697b815527484f9cd9cc632bd6ccf7822d3d65dd5ee930ee38fcea14c294c355eeb7f00386095f77b6dec1b73ecda1abc95ed8a51987d66ef7b3eeccda50e7459089d997403629a39ba4588d6b24907763032b85f0ae95b094d950663160764660901dfbbe1f151cf9fd02d3fe740321ea3f8b4fc3213bf65f2c2870b9e7dae33dd7309e099412f5ae98a5f8a0743ef24a789ddb6ac739e523a779ccedfc00390511065ef8a42c2ddaac49480d8dd3c872527217b38c63f1052c671bafd091063dfd3bb7e05a6539bbb13d9d5baeeddc084f196724fdc00c4098afba83e859e22455182fe37971d12c1d20f11d79ddeb6b88048c98d6acb42b6ca18785891bdd7ec83c205e02b6bb4f3424e00b0df35658f3bbb6177c64c3f15fff126c689d230f40d9cfc05dc35af9e4c11e5d50d197f07967b973ed1037b2e8b93a30ff27c7611f39b6905cf578de28d94c085ce5952e653984118271958cc4204ad966770209357dcd1f4f8990e7e5530bda7b079be42eed1f5b577c2034ba19f8f4ef6fcf9f4f3d52d09d35c21cf694a8c954512903c9bec8580b00a725de0661d68eee20ff4459efde688bcb5173cf5a15c1399ad592713708ca4b80b733106ad8070ff1bca5856cc1b8f194e40e600eb2db11e96c01b86b113d29e323610c468fbec609159bb786071efee0beda9a8d9a86769042b75b5d212e1ab301fba82315ea9522e7716c77a471535ccbd995379c3de194b0443be4df2c1c080289db759d8bdcb1cd53e7b1c5ce71c40ec17e134c668a726dad6485e89e491904daf0404243e41ce731ae719a4f5ebc109fd6dcae554da94763e04c1b2c13c2b8edb79f7979c5e8bf26b8ee975b8e9da1dc2146d914b97a94b4889f75d3f76f0453d023fe7487d96a552a2ff544a86a338708a7dfca179801e65590746686a0776f607828b293b8f650ec128eae3de4028239efe17bb18d10319da8f934bd9df34e64f8c8a1c617b66456c506795c427741cb8c6b2ca92d1a31d4bef00635b070cc838c8d0327ec832fbc1d6570e6e4c652a1cc87dce032072c31906a3d915753ca1575698ea6c8e6fdc916e8ce6bd1598839e998be915671af764d9ebd3a583adcafd815c3487f35a3aca2665c97a45f80cd150841bbba8fddde330b5e39f4477963c069d9ade944ca0370f47a6198d4d5bc824c87a1926b2afee54252521bdf580a4972b8b46fbf209d47fd6e3adaec1c9e4333a34b36673b76508d6f57f00e40e063b2c93da9808f3d7ddb2be6c694257ae82d93938c01075bf74942557a08ae9cbc26bf38d39f30747f9b47fd0a4777a83f2b1a09bfc6df8aa13cf3bde4513e16e1bf4da5b01a62c84c851f20dc356a18287ef8b87ff34c3469ddcf663de553d5cc58af72623b4b18bf81190067823be53e56bc6f35cc6ccf669492c123d2760398d7fbac2ccadd21f277bfd0024f339be9f7ec28003e19202a2220b5e0d20fedb97b735729b346284e5a41916079225a5b058d8bb261163a244e692622e0f9869485880af7aaab4cfb9ae546056d2e142c87617c8290d162d0276a7f9100f82197f945aaf1fae65dc21adcf220ab27feb4b35f7eaa7047d22bf0df170a795d77d0ce896914d95590848dcb3d4ad448296fc25bf6d6461fae24a3004861518160d3e5f049d226c122cf5742342e727bf6eab8d2af92dd0679c3eea58220ec1a87aa05df92ae7595c790a674ba5a68799a147925a62e05a0593819c8e76cab948fff7396f01be89cbd3d542b43bc863baad32fce4f76260637dd09eb28068082b799a71b610eabce4a8e734cb6c52f918e7960b1c7a17ac868207cdbad618e28b20644f3fa189bb2e707ab5d093d2dc1ad4aa1db5935c3979c32e0e3dcf213e27426571b5aafdd72173c5f536f3e5f713aac7310b096220fb19e43f6a83063ffd9d79135b37aaf0835a8daae5694195591932dee76a3f13837f2637b6f858b11ae099634d858a1cbc7ce3423b3d213c1ea145351d05a2e4c91d0070040b92ee24036ad8f97a53a65ace9cd1adf8333bf409af6fa498a54677cadd7c3b64a44347341cf82206fc1f2605a4506afeb633b0422114dfd54e5021ef703d7920af4de2198a9814a610b39288c8306d5527a95977d21e38cf0b0917fc857252b67274acf773c806b2b368d673815d23b0014fe27f83c09064162d4942c1d1d66ca57b53ec9ba6d0570dee81f714a3ed027d12421e3d0c06f08247ce156ae75f1aef1dc3bf14864a17c79af177864a69cbc8b8f424f46b7734c82bf2e156d1a7acacfb20bf927b4cd5f1f7279e051db09cf8986d496ae9e9ea00feebb4e0baa4ad99a29ed329b08bceb28d5e18897ec6fa6a1c2159cfafe9dfcbcfdaa0604880f339968369c2965c27442c7a340b9e24569d089312bd4428bac93b90d0ad3ccd1787ac0d7170d225f6b27ef77f67ed0e43b3d62698b836d9a4d863d8b458835a612d5a7013875672fc490ebf0b8a73045c8007b1597a263310b19917989e9345cd397bbd9bf2095e800277dda01535fa9f2fefe1c7f266f39cf05ad97e086147124dd71a8d068a5194ed0db6db4f3fa795ba4642eefaddf0f5267ab0ae2fdcfb266030dc797b50b94bee10b4fc0047a744d97a0a2cd3d1ecf10ad7722ee0fe29d70e1cd9b16a11e3f25f6e4813683ca563f64ad97cf8d072de13d3b71b449948361e961735bc4599a2b3562dea9fa463e2cb3abff7a523f92277ed6179592e858bcc1b467b12db7bab76bfa3e7990458bb8e099e3cb47e44201759d921f36ba463275334bf18cbdf0fa7469cf913293d2dda5ea6ff6da2e295434a6c1068ead55b4b95132259eb9469e220d0bca07eaae37fb4b797bbe821b73a78dbf1b4e689c3ae7705f5d05042ec7485d20e7e637bf7c9ceb2772e3919ee5cea0b83c5a5e4a1efcde02cf0b4a143a9adbaebcd58e54ca2f0a40699d94380ffa41661691c28a639ce67e62250c4ceb7c5385f170d0cb6b5850bd01e39796f4792180c38e661f55e2a61b99eb86b821c9ca0dd5e07415522bf40f95735555e2e9baf8d3b47b724c598b9bb5d376a616373703ec110ce656b0c0cf86a311dd08db36e889cae19776fa985fb5d0468163a05270f809d1d6da6154f9399bd497e668b2c1b2b786f790ace88970111d9cb800b5701a3977fb3676d1853c989b178152d8d84eaea13697cb0f47906e81a790db5f8b3592f2c0cb584e9fc121b4f28e6c0dbdd103826e485adeb1bf8c7f9b6be0bbca155f3f3c6cff2c2f7c2f5c3e762304546e818e601cbef3050d17e01122edf0fa4e05eb11b5f79b3e60b9068e9e2a4143e49e2f003da2d9a3db013189e2081dad9f0046aff0d1505590e8b8726554bfa32b88a583ac1f087d3e248336762c9e0fac9eeefc452c11fcaf468bbd01204b40db43e686e12dbbae4d43c5a74260a4759a5b1d562e3945c77f39c78d834924374eba22b1b35fdc7ffc24581f44a24cbe0c21e1c1fdba5e2e259a53dfac21739eef3ee96e627a8f36d815a1c529a51e498e4a6d1134b93980e6aaac5cb8907cb35cde9f4c1798c448e1df04a64d84169082a0f342aed4c043007a0da2e57df397fd15f053d538265aa1d1cc205d35dd3cfb8a2b1c198653b0f085ce7f55afbfb6794b95338d08505eec785bbf22582ce1dd7d71cb4bf58f3e60f7f6c793d0c45333a7857bbd0a56a9bfdf480e3bf6058bf346ffbb06c12db5aa91f095537112bbb7bf7f576a18e5a2dc38a045875558554cee8a74489e758dd976d5e0bf8b04f0472d312e2edbe078d175a342d39bcbab238521ec9f263bd886aa7e79bf672d1ae43795a36529b3f32c131ce24197da9e43153b7f8bc1726329f3e174e1e5d9bc4cdf65cd2839fa90e32dc105d3afe5e5a6358fe0018237308aed595b7474001e47c270c1e3bd1fc0ef1b6936df5a7ddc85984a5702895adcaa8e40e6e9a7a824cb1f5964790b4d3cdb8ed3f84c95b285c5b7ea88db4637ce9cdba8d40d9fd69b58c0cbd2f14b6ac493bec1568185f0d9d3b6f83b725348cfd3e1e19c179d99d4d739517578cba2836132dc8daa5fd2260be1b08b70bd776a9d2e0fef8c87f26ca99d3f88d372e7cd47c5674c872b46e90d9439622c594d21d8347319187136f225fb800bd8711b350d65896e5e9a52dab06c3c07090469127bd463885a8e17e2909b2d3888fc49fd151560f9035bc23200b8c6ef9f8dbd51571254b2dc57361d01396cf9eedf1305960237223eb0533e195babd8455d4c08e7fb9ac7f2d59b3becb7640401a9507a763cb8e2b0625d38272463a39152b171eb0e4842f699caf8f9efe6272e303ca6defa1626e27311ad6779e5d466e3b85736f5755779914836f727121a9af7728edab3065779697778ddfa3427c78892a8a11d5a4cdef7804beb11081a02d5709b3aba448f1400e1643ca8b6ebd9fd0cbff1063e21ba3dcd6125e3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
