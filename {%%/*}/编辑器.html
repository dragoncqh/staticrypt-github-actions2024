<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1d7d8bb9d92aa6069c42f9e12c2b202f80f72a898fdfccf65e435f4ec2292029e24be5e0853707e4af9930e3c4f5d92015f0c08da69e5f7f636480e89355c9026a05d96f90847c7494ae937378149f1159346839f47367392bfcb8bee581ed3af54713da8c178b60615f48f062d078e98865f9393471c2111f83e684db856d60bd8d555fb5b55f0937ff48c04a2c697c78502c41c2eb90e6781448fa1ae57df693c853c98dc979b427208f2395186996c0feec21c16a56febe94aa35ed113e7630a23c2e9eab311b2eb4b7b2c56a684876d653de834b5e50bc10364b562a483ba7ea9a28f30f8e872dcd95b21abef42d296a88c578151345427d7251eed0a2f760206d300eec04b1e665012b92ea5cb97145098f78a8e7d3fe71f875d2112e79fe2274a46edefbd0fc1e3d09fd3b7e51f476b2c68d4d39a3db2150a32acc3237b69362d7c0173913383ca7a56b13c79e5dfbf3798b0624d1ad28b07206edd04e1ba583b7108fd3cde92a23317c4bec052401d3024c9a807ef3b48c3a924dea70b83941d5e14a0063f37091d62159d3cbdc4e0d4d30c54cd02ff721db1d14b36bea65d1c940ac3c733a9bc2b64173c2bd20f7214db2d2869eaf256d85bdc6eba5d8bd84851636112e16ebebc903fa14e485091a95ae1d9a8a7ad1285125699aa537ec897848856ed5b942fec24041e14294d5f698243e1e71d565bcfb559be8165dd043483d13937c83bd596f685ba741e9edb545b0688a2d1c56a26b61412e373eb8f69f8924554da4e5896f9d8f57596f8d5a9cfbec976baa3af684bc949194c7e3437abc4a169d8613c8c34ac77bb6bd2006281a5483ef63b3fba9fc0eb0d2b499a19b2b14b3f4047b8e0d5efe259b8cb76f8a7ccefa625e5ee2371a74c3a114eeca78d0e34ff553c80d8cf1e7ac343b5cf41fe2b268d7bb35160d501d8fdf9e6c4386bdd3d554d0a7ffc2cb7a935882144542d14b1b8023b1dfda7710cfc84a8c62588ac3ff46e74456f3bc69bccfd7a3848534bad64bcf66c4398cc8158b7cd128bdbe15f277e64d755c11d0e3606a8fcc6459fe4eed1579928b6eee1b507323c959ad178eab4fb6bca41d6a361d57d1ef69870bc5d3e1b7e73d02279c0b02849b8392ad362479168d714ea15c07406f9b765ff3aa9ed14809c4525402afd0ec76b2d136add0c4d69d01a0c2364b9f896592cd5bb00eefb63f69daed36e79c82eb6089f911357a2b8b600579a50a367dc29730b0fc91f2e8dfb09814002406a1a92d38999071010cd10a0fdc6b403221ae4cfcb9ace4ff3355abf5c5221d55d38d87d4d7351704b997467f64c3936b3d60a89e194a02fbf842a5cbf4a80b36b30e3ff4846e96ac9f40a0503a18ab79627414fd6166f59027dbeecae231f757a08b67e2d73264b964a14bab5503b1e071b6c673158634cf2851818f766926dce11af8265f1829ce762457dec089e27d97ef80cafa4ea385dc4cef3750585380321653b5d8425345cce9c4cb9b0cd1d9cde3308057468ee6a107fe1ea748ddcaabbdd1982eff397d4df7673e5d551c1eb360d1a9a5d2cb7b14663604b94ddb3d2a56f936e41458daf9d16b5144844bd8342f6e78fe5ca4a3d5356f04192644047e5e4c5d4846c66f6a7d72ed938efee3775bcf87d5b9e1b8f3872f5ee541f4836bfda7de0247a1266577769887002fcf3ebbf0f0c0593725b448c85c25058e2af66a735a85e567ca38be979ee66306affd510312e10c3aebdafc504b3f48a12e38990cef670af944b604c979d377f9de9705b636fc305e9693865366cd9fdd01b9dd45164239506ed4d745afeab031f930b7813163036a881cdd0e4584e39bdeebaea4846037c7006f031cc9cbaa9507dd1437a3c269eda4901556ced5b1945d58d7db54d57829d07b381f003a541c72a0a311313032100f12aa21dac4448015e4f5d14308e1919af5d94d75a4fc171624270b679072f549daf89bc4539896abb4fcb30d5f3a6e4a1c6870678f9e3c132235a071cb96d8b8eb801996316812e6e5a64fe2aadd748fc572aed93344d2b2e79daad840c1a5a535ecd61a35b154fb51445bffc2d3dc180c4d1428c68f829f19a6752206192c0318c388ca63f3a2a852f470d89aec90737ec37cecbe08c3caa5d2f1c06c97444b89c9ed1230b0becc32c22af65c7341f701f072bf9488abd14de6f1753dba8cd776d0e4e02eff5b25a66563e4d8c22f268f5cef8a06b895a9fce401d7fdca0fc225bd991d4be3860c5ed81c5c382e7e02696723c010a9aec3262706fac1ac78e433eb35718b7c7e00933a4647c4084ceb041177ec7181878647e16538aeae3d40c45cbe0a006dac4a22fd19b1ce1c4457716809c97da019408b368aab3e23ea70c003a9e2431411e264156a0f95488acda8a4dc35823d398ff73c55e99c204bbdf84566c6381aefddcaec47bd31ce6b9dcb03e9d9d06e6ce70a8d4068a84d209ce17336e483a7c50e7c2bef5029cb598f2d41d74aba72a0459a06c835911aa4dae11fa6eba1e98a412201f3d34170a9b1e5ac5faa23c4e055cf24170da4066585e2514a2877cd310d649fd01496eb5e244051d2ab6280611d7dd07f2e9483768bdff4ca0f11633ab17a5b22f175083c68530dce252fd73a19b6f32813a7476e8363f89a8dfac88cae4692c9acfa83fc51fd0f22625c7dd87ef020274e77f339894c4ed48ed3fa256eb981a51205af69983a74ffc20458704eb3a08780598adac2dc8258f82dde9d6a0980b24ce50e454e3b7eb59f390b76f4a9eb62c3252dbb9ce51492c0bcd5fc89061726746f1c1305b6a65428a4286955bdb5e82e72b591f18749920f7d91b0c32347a810d79a9631f85f14d7469f47d556f5268f299133786699c2eaf776b7e5c8e334b510627d1fc2cda42540af515e5e09790c0165cc5e29901d660f9452bfb9fb2450c1ad63939dcaf23c6a6040755da35a8aa4f543080143fa5ecc02b3bbd73fcf0ab5712ea979d4d0d5b5e6c3f8664fe2685096261d8a662592723d15276bb28c9793c354a5f381f1db88231331d9d3d10c4a433be43ca77de1a1441225fafc49f178c6871bea84b4602ef77dfe85590f88bc18ce1bd7a9a1a3f94dd7040c00410fe4600b661982d7edae16fb256cf14794cbe65ca363a7a72e037df918124384677e8d513c1877e827d63069aff3058fa4e1c1fbcf5614efc3c95c88e95a0f09c653590aece3c8a7adfb03d7cd9ce86aecf0ff591bbe0aacd27ad7cf9e695932026aaac4668ac90ea21bd2c95a68b57a23c7a980fc9fc88422dde367f1fdf2751b473cad17519a50834e9a0e2e895b7feda6510fd8cc3571f4380e6763f48d63c2dccd6bd40368e9365850201b9a6853d83da3c5fff19e589ab526e1559bc695ad36c9f0908130cd709a8412252a3bed8a3bab64e8e038d614e434b7366b8af2c8228d7a20277d6a8eb3d3ff81f576d87b7a143ece3724285b08b03310b6e1da802e8a394710a2024253fb7a1413f64793e570d8dc92985d030849e02ac3af95948ac08dafe2fd61115ec7c749c467396e5c0264a6924e296ef3363f1234d9f56c8bc171886863689f77f008959cc27932ff8b3b6fabe48c35e73c3ddb28131f80fb310d2afd11e88f55b390a240e53fa5d31a05ba16856f498a798614c9f69d32025a45848615191c601abddfcca2957222ca4ce3b278d8648da9a9f2a98078998dc6736409131a22548c621c78dc40fe4734f4c9ae8daad3c042730ce7f40bd7946a17d67d8a21f32deedaf9d1a64846df2f7ffa0f216f3eab73fabaf47d496fb38a815734352fc0a36cf6324f90c2c3f9f5ff137716a813217a2088d4317bf55fa67658dfde1f2433f8ffdfa888ffd579bd9b435dcf6a7e3820aa522ead92753a5cf9fe6b9c711fc86070193f4cb5174fb447414669140a31d736dc68d0cb07f2462c85d3a951b920c9d2d5fd5fa3a08748e7055579cbb81d5e6ee7bde25d3a55ecf6f8f9176d49b44b88af1967cbe8fe773aae2b494b29aa8891e6b5c89a6f6f4760020228661b826ae07eb4f167d63aa0519fdd81ad4216c727701371ae49bfe8b8e38386a5b39346429f04716cde5bb0b5008440f3998941e0f94cc6cfb736b3a74f79e5746aad4ce06c52dc262307c3d0c9d9fd43bc879c047647a4a428a324f6338fec4c740ea0353abd19757d8d0f563aafcadb3dbd728ad05efed1a145f2b90bc5ac4b7477108b27e6faf915d34a063bb75334a9e107ed403fd8d16df8140530a9e65d23b14be7a24509f92c24d406ba68bea53af9ee2adbfb878f373d33fb83c290dcd83dafda9825fbffd4c5c14a148132bb9338939269bc3f4df30f8a47801c5e04f444150d71557d37f2c633c9cff2df09315fcc3c166447e43be49e72e73e28d3ce9784670136b9b5ae02294d2717f68e1399b552ce1b17bbebf4225f052e1440bf48a730431fe91262cb1246c101a59949aebdc48f912fe039ef7e5d6d4ffdc1577bbd8ca21d61f9d9198b01a54e4ad362fca883dbd09d9b5cc45f8f6811d7fa617bb74b9bbcf8aa45c17d50dd9c3312f4bdc8050a5990fcea8f8c3bb5617d9b509bb23ad3fcf64aa2feea02ba22c66d76b2f877b5ffb26e502112c315768a066ddf5f8d1306c1d1751a0e0e49a431ba5672a726771676c75827ae81ae832db2ded2e683f45ff5f59ba7d73ece6292c87ffd1e411993a7b6d896b36a61340461b856ea3ef597507db885407d68d2006729e6274c1106cc65ec1b1ec20bb6c0b0af79789de173f37e7254ba14aa7614acbe9917b04a8b8d6653b6db8d094e23caefd59d3aa05d393c38fb2e47b7502c1b94efcda27dcd9f06c65205f6ced0ba01dbb1c4e2adaf05d7e3c66addbfb9ecb8ef4785ea9c8ffa7699ff7e601debb62a09fda196b15d8e199ba1cef382eddbec6f77a8e2d21cca64df91d5aa320b01b907534c0fb863245aefb3ffacf07834a032c3b90c3b8d44dadeb08fbde3ff181c3cf7495eaac03bb5baed094d61319fc75ef1b678223229698b3c82c08bf682ab19b7033a96eec8baf156af89d0b2aa8a24e981c8db4a220a4b6bec6d6fb1bdcaa143753923ec1809b717be031fd9fe15053d19be85772bc4270ffb757553a0715efab6fde5bf5034ab82b9db67939836600286575dd4703496d963ebdec5b66c2aad1809770acc7283f790597b82035d5affed49035ae371beae81c638cfba9dd7d2a01837897a90092dec388e8295d95c1e8ea20342ef4765747eb035b3a52aeef6f083038ab30f8f7d2682642762d93bbb4d6ed7a0f5a49bb7d514c65adff2d43ab161d2416fc0374b090ed5c1449a65aee36657456a57f7e433245c8440908d480038c0507537a0dc4cafa2d9fbb4e9961a92b206e258f4f11f68891066415b4389866315edb332128fd452aa8d3ffca0817d24aa60470680c10e3b2c33756af6884ca710a3ae6bec2cd66cbe5003faccca38260337197a37a0546917b57b73982e90e8c13c35a4c1061346b97777040448f8e08f97e0265facc26db8f49e25802b0e0d51a985db25a9112f6278202bd6006115c620d1abfbf4c314a1c51be7cd75ce1f477bc2e717656dce1a232f9690d3ab35eb590f4d71bef96b3e0b0eaf304d1e3167d5f5bad1db27e2af94416a4c9600b062877611b993b4c80104c390fdb96bd9e78c529c6e3b87dc4d605a8c7913e39de7f14e68a133c378635a37901b3ca7702d03dd6fd62f70157178323cfeeeca3ba57e194e709f2aa081a5d56575502324c4b075c053c2357ec6fe847c63dbb268b0e5f34b4adc8ecdb8e648880b8aa8cfb98164c22bb05f7b4cd1f5cc2458e46131b52256caa43a66b7729242afeed3e0b798b7833dc4b41909714446edff5f7d007b1245d84707f5d42006dece4dfdb8aa8003dc693ffd069ecc5b035dbd2e441bffdcbc613bf9a18fe7ed9ef3ab88d5f9088920f73219aec54875720b32d743aed43ee06d1434d1e4aa76116732c71882f5bf94b4afbf31f3c4ab2625c3ffc6f3629592620c9fa7ddd787713ae5397c446fa2ee78c960d144fb8b8d315cb97c384f301d957655af4321404467462aa407200202462b33f8a64511da15d9226c0fee6c9818fd8579d6738b091ebed62b0a3c3fcb2d1d9e74867b34340ff4483817d21a90224697194b0f48d90f0d193796a162e8c530469a65dfe96c8d14ddf8eb9cae0a6727d55ce60119e005626d33f45cf4c962816e3aab74d27a638bda801594055b37c8c108591e1fb52e9b46927fcadfc4466b48786e8d4ac0854f3d68457065f24d9419a62c8d4cdee86589416f8f9f6be59000d1d1980bf501d4bdc1177530e378aa9b395345194232a9d55ed910085cc4cb9ca1fd01d467c1b6f222ea8febbf507cd0a2619e7963aced5bad92b6d01ade2f9c6d81fcaedd105cc46a89903b611fe60cf53ba4dd217c1886359d3d59d6ef851bdd166f59e7a55e28ac32278e544d220de6b26fc0c0bfdb987525f7a6fe387e6baf1b4eac2d99043593134f29e449b0036f2bf020c6917585a4c45f1e0f74fd168ae36700f7b920981ec247f37de035e05f52688b9c6508a501b201eb86e26c97c059703d14c7640f4e42fe796b10049266ab51f34d76bcccb7298f2b61a692f62c2751456571ef8ac3eab539620c6af2875a6c318ed6195a71f27cd72d6fa93261e7afb34688b42c3b9f9bfcd65e10c66cf6eddaae265c94e93b7804fdf55438bf36469d6e55248b67b1bad40a7450a0a5beb3d5d874da3798957cc31f4d672054736f0139b09a2745647436d9619a3fab36d6f8ec2a29fc5445bfa9e13f0ceff6fafec163f90d8d5cb7df24fa32a15a89c2d27f185fe3154287efdd032a40f5cdcde065b9876d053858e0b8e348a89438551159b13735b2bfefee09a268bd4b3fd2da1b05447565c930a1d946d1f214b7102eaaa7edcf94365a46415757f738511321fd0233d21159770aa6050e719b0e10519aff764d076af1a2ca1654742f26f1c2578da417b19a04cea47d77bd4786c367a72879ff021c149c6151f9c17f6b5b12dd3873aafc03596017402782f6bf9f73e11334549ca79f3016e6f4704b93586dede721430c206bcd50595d1f7e1c306090db1727e526bbf7c638dc7415be5ce66f097a8c0d184a1e9b612d3964a3bf8792f0ec9e4a6a219fdfefdc20e4f21c541f7fcf3e0e1dee38e5ca2deff2e74244a8e544929012afff333526e0f0de0097fbd78e103ce14b9bbfcb7c10951943f9e94251290af8cd987f19b9924b9cfce526dca2dc3673aeef0e739d09889c2223d5ad72b679bbd47b4e6e490376fac152825417c6e6bde863374151508a786626487c4f918fa23dded8519651e5d47df5ea67f8269f7e3cb5030af43505dc10d1e6960805baa18269fa9c92f19439cea1ace8394b5f02f38a16fb108932778b150e6e2a0a173ad59f5c069f02b0890d90f7e0e5e5a04a579a4bc36b0c993a08e17ad47d46c8154ff41c39288894b1cb663f10b08ad265ab56e72b425ddcb2feea86f0551936373c7cea82c02812aa470f3a95fa6f03a0bb5b918848d7338932e2591cd01e77c6c9b5336054f19553c6816c8eb3aa2068fc2e69267c620d8e7679c7a0a881d83f9e70ce669e121b82107700bf9a213182c0c249e2cdbfc0c6ddec9f622d39af33df53f55d3f378c376da5202ba2f618534e23b554a916e36494120fa8308edd2cf8cb32921ca88af3926a59d9590c6b64780d1e9605d2f92ae1696981d74ca672b76d50aca1e8cc62883572a7ac779e52488d7d3e94c82e885325b2c9e7c4d8296a49818ccaa4423564b1df87b0e09ac8714751c93239fd4c41390b1890df315a7e68dd795c0a84cba59c3e2f2d7951c3fa97ec98b9919650ee204cebf5e12912cbcb0dfaa66fc857be24f320b4968981183c12077b052c60cf552a1317e6a051b35b3ab524da4b35eb2a1461e237b97e20f077ff87f3d3a7f555dc6dbb87661e0b2b085ed4ce2451362a00dae18e5eae925185f72f936a0aa7f0dc63286800046180e2fda80d7159b5a2cf85a1e992c0a1c2cf0efe86891bc95a108a89c1442bdd53dd75a9073af9bd764f65068f756ae017c404d8e49aa685d621b668805ec0555a7cfdd4fd3ad3fdbdd15c7dcac67876efe1b2635ee237697e18d94bd0e3e300850fd1d0ed74ce88f60c7b77df02a123c51d4dd0aa984cff0a4a0020e7c0f2564dd86ae0b2deb73092835b991e552ce7480b99bc4d041d0d6e0677f86cb6538494949ebbceaa037a68fc73755a7f2ffb4a048cf7a4e64139affcfd3a70f12fd9284ba1ba39ef572cdb0f600deb2d495d51ccd8f8e7b07cf50dea00291a2402a9bb8d190e543eb3b1b4f6b5d1423415be81708962b08ef17d586c35011c0c1f5e586947d8be6e4d480c3a72dfb30858489e47336a8ef0533204d6ffcb1cbd7f8217db9427f37e1e3032ee5a156070cbe27729e35eb836989e84b0f8e9399295d7246662a70adfd2e9ea9b5b7d8317fed01f8b33255e960f55c6a8fa679a52699c0af99c5621010ec7f03e217236ccce2c2f144af9c34bc38e1b230de933cccaa4b92baf6867cba2441375e89a121775409d52c60b5d83530ec7a9405c8e6c0b20157a3221402e60e3dadb9fa63c3e51bd55ddc2c4679f83e2a9a000c3195a5455df15a1a2526ac7c59f06299d70f7fca00a2092b0ae31c268d89e80bae20a954701954c1fce6e45c28eb40ba87a78a0359ce0de2535c2aa9d4591a1d7eb7774499546e526bd5e8d9dbc70629ca1dbf9844f1170b5cd488fcc4085c3d8fe1a0fd974f911a7211801b2cd5de2f5923d56caf44b00ec5b3e67d3cd379cc9034f75af428d39333af55cc2afb8f0c0957d37f8d0904d9e261c54526fdc613c5440f78cc13c95c41cbd9c32ee7ed9f34468b2d8bc8f61e9d2dc5eb96fc7b7717b368182437168fd576f09c9b2861095436cc2d008a8233f551de614335f007a32fcb607116654e2016e318ab92d95596d3e1eb80d8dd531eaf8d596c279ea91019f938b726f631f5a76007747458a8ff75ef382fe4446b3c3238aada61a05c7376c557e58dfc962dd9a59eab3500cff5266675a344a2633a0da9884d5dfe5874f55e58b9272dcc5e4147c523296dbe8c38c04a8f73be6c2cc1ecb065737758a768025fe9d541c4c02af07f20cc5e634b53a9c7f422f8b34c01f5710eda81c891bd832cfebca37f4512b4b8ef5f9d901443ddb1fcf7d55a3c085543a15f630db7d722b475af7e4c9fb34fd85223a63272279587607613cb03d00dad814974522f8a1337f4357a71ecb1122e21ba31181fe22563683ab2f6e8da5b18ae7828850b6cf2f3b0cc15f546f0bd9ad8ca8db25d5aae1c540ea511b4de77a0108da995f7d69b9d87fc8e4e750a2edd254edccad66e347e3070501f8ddd9456c5921f28f16124a3d936f660c4d2bfb5eb66b6bee31edbd807f73f6ed23540d8ee2edf45f04cbee842143186f56878ee6ec6f49413d1d282a68b4cce661e98dd30e1e11f483470f34f8a23fbfd6fdff5f4aa76d8eee304f5ca9ebd36b40410a1bc2907fc42904ca0d95e81e53a11ac3c27f92ff025c2cf0a378d52eda4d1000b82ec007fc6df9bdbdac0ebaed54ad0fe480fcee550d9079b4dce4f285f0608bacc3f330343e1ffe7d08209333d172dd39e463b3458019db09f2fcd488a905caa3fe29e27605605a72ff0845ec200122ab29d3b6904345e4b8c6c0de412b19cd286d2b07329fc6275e3e5779e4c37090d91ac01825facd7935928df0fbd26fcb677fc09f90ebc6ba3517a4592c3a3305b9c8822d075886433e2ae99306d6fce1e607043b0cfe475d6557c0cf26210f44bb8217f77d0740c5e2683c9831132c8756d408aa3f7cf4bd66ed8edf3ebf89936fdd3cdffc378afe2185604eeeaf5126537bd3791b1d8ec4352a81083a7d52930837b47cc80741668051cbc712e00f92844c07f7afe0e1a1a3c5373f4d7f0feb88fe21f976023fba28d7116b766aec9e1a64ae98e6a43669bba48c32b67a2add6df44bc24e7f976463931fadbb887a32ce9eb0396bb1e54c09ca2a5b86d062dea269c3721e2fa368b91c3b4f06fad31057a4d6ce044f3b5ba166b69edbe17764c2ee072e9154f2f479d012b6407a3eec783b74aa3a5e077830ad0ffa944fb5b6fdc3f535270abdbedae7351c4b4ca3c6df6376428ec93de9d3602718e438bf028b0a34d33edc72d9ed4a7b23356dd54e76255ba835ebcc5dcc1acef7e5a8cd441dd8f1dcdbb052a22ecbbe1057fb3b9dd82a19ab7a9d11cee5f79f5aed73f99dff9d82edf1d6a0fc9494951ee546ed4d4d5388c364b5f8ab470bac5b7afa9498517c1437a5078e2ebfcb6a24460574a7850467bd2bc7eea384c83981332bcfbb58be11989190af8e30ccc103ef0bb460b26e1be4fd323a9a23dc1d7e1e7c8498d43b81384cc057f368c0d01ad55c9a9791a8d0145fbd401495a65e5e77523750858fc9705b53dd8fe4f56d945f49b9621472b002ac4bc1cc9c0b8c76fb5320e71fefb3d09eb359eaee913ccd22574a29dab6959db5f2d92fb87d459eae6aef702fc48f0b59c81fe3570aaa633773cff7c9ec29db7b9b4e1bcffc8b613eb95beb19b30f11691bae58d47d57bf5f745fedf921ee3c3e5461f54e13d07875320fe87ddf2a4a5862bd2ae49a4a1862ee3cd7f99f1f1dcfe5119158d0c8e715b73568688640f956032eb3594b1d135122cd09471fcb51b00d2ffc299c154ca7e0ce532b99ba8bf9dce091d0e2eb4a7c0a15f3952b1d3044747186412a538219b1fcd6ec8d10f4342bd1e8dce1718130a5790a6b92c8aaf102d0a7cce94497f31568d33a88358d6f29829f0257d21310ecbe7b6404d3a5e993ebe5fb835676e48ae98b48b5868c479bc0fd85c267da4d258a551160d1788a9ba618f75812bd0357eed005665bd7ba225c2f85c167c79933e14fcc5ca3980d8c7a4ee16692295bfe9ee6428bd596bc3bd1fbc561b2d5eb14a367d89b9afd3b14e5383b6b89d6e8b82cac2021821a75bfd0483ce40418e7a56c1a709502a9bdb6499125230405a132be4c6f7e82ce3d9010b474987e22f2d5f730a96b3ada82919455ca55455d139b2f5f14ee2831e367117c6f2ff2eccee2ff6808323d2ccf582a7953f771cd088ba179f0d875fb71eb9dfaead70c6aee7ff29cf80de7c1d6395a2cd20cd9565dc597a1b6c8368b40b82ddee97cacded6a4a673fc75d6d7d65593384f398c7b4184961b7ae37ae235cd9990731cc2e436b084dce91fb1f6b5ff5fe15f85aae803138db14949399a6b550dff1e7b8e5c1092508dea0b9588b5d80c4a546a8d7cce5788d77f9c13550de9fec93ac859c49bd3dcb0c532479f8d8fa5f6bb6e32b6d514495c9d0238d070f801b78204984ca7f11682d1667628e786d0960cb63fba0cb587dd54af7b6031dcfa1acc00e1231c1b86f0e691d612fa919a2a3d4771bcc6e1ff3be3a736ce944adc375fc5679768d35d25ff4528a6d62d7bceb620ecb3c5f8a7f3f2c29c699532a1610ee0efe7327c78ab928496929b8ed0fb8b65b1f1bd4b00fbfc23c0297f1194516775480ab65775f906bc108865e6fb21fe7214f5d83fe6437aa358be5d7d6112b26436763893d159413212650d4a1102286492bb8bfcc0372549179b9c16f2c229311a9703d2195edb08cf097647c8dc287230060204e4ba3efe1ff6daff99145ddda72520043bf329a5b3e206076b42b53cdd058ab9fe613abfdb39b1361bd3c0370c312fe4567282407844b96f9675795e40e12edee2e01ea14eab8f0675229f91e8e58924e7b4719a83522c54d795a4b395012b6639ed6399437642d1a8200d5140725ddbe754461c5866c10cef79c90e96adf7cb542b68d0d41138818eb953957a52e818e5aac2bbd7a7239309","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
