<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"01fedc6f49d650e4d1da684ae18a991bb0feb839112405fda02848339717f88664742d5d420e69d2efcbf31c2c06bd9a2fefa1d2eca04fba621a906c69bb012ff46ce4d10093836803752808da08b4453c0210deba1c1969a8687726a02e5957acc287e8a7fa7c210c91b570ce9205a474effb5ade4adecd170593d6ed391eb331ddc05ef7d80025cf3c37cc72eb995be4e090687a85f5cd185d68c62bbc8297334dcbad5991e56179746654ce64dba55ba28ceb657cc53982834245c5be76db5b98eba2478772bfcc757c5729ce0246b67e2b561f7d9ad903e174370b03035abcc66a678979e9de97e5be2959bf43b4774161059efb0a85ab3a975ea54691bf28a81906d69126d66c306753525aceedfc00592562f20b534efdd6f5587b5d4b2b718f6227228affc41ab7ee4db62b315aebfee73b99a15e8e76bd9f512ca4eeb40164491ccb447e35d794ea6999420416974e887f66cd38b1cdf7b9b0f4f9c8e5d80067da5b84bc4a9501e98e7545b524ab2e05ee2e1cdd3b13aab7c3b4805dfe8cd469bb4e47ba23c76710a5cb19f513320d406710d393c410753e819389de108c1235e54d67fcf03e9b12f6f2c462049d67c15c55c100d37864128c1673dcfb7e52ed23344b676cfe548ece39becd9d1ef2bd19774e9ced3172eb582dd3dc204c7c5236e10a0fcc914dd3092a808c7a6f5dc0d93df8ffb8f523f7f64e33ee279d6480261d17bfd5bea8f9a6239f67e0e01e42dc54c7aec115256a4738593f3cb09c321f8d774e6ed6ee89e17c795b0af83958355b721e5c4269c5a94cd77fd65fe9e7754076b72f6a034759b8d8e983cf91880f1b7b2aa45d30e6ad0f5d17d90132d38add2c9e3f0bd2c4a2f3138ad6e0d51ee1817fc4463cdfbe252078447cb2dfc3b2e963f5260239225f5225cc36ef51a3144dd1dc061aad5e34034b170737046abf71bee21d22d4cc77cd53319ee1d663d342fee10ce35cf553d32d6048abd12fcabcf6a108e16438ec89c7e56781dba190ef80e8f7c0f285094a606c78b7f8079dae8614128a09a38966770c1c3863c2a439a5764375bec833991e0d07c497b53f3c538aee530c72aa897673c61168a8d77ed8538eedd0de92523d5a10221e0975e9dd276cf195d6b186c50a7b98177a3260d4c379edf68dbdd00b037b56580e620c724b9dd9dca7776f6d2c6d132e76f622aee4beaef5da567d9d60e67088bf21849c4345ea341fa23f2176ac418aff5d69c9e2aa597ec79770b6c59ccc06ac00dffd4e92659b8dba7e3f1dff99abd9c2baaff62672461e6f4833739207e48871b89190146026343e78696f2c12e9b611414f117f6ca6a3e9ea2929417d2a96ea369e7943602105ccfc56079b59f30f048e4cb48528cceea3f9d2c2a2fdeaee63943dd91836de94ef75c0ba64b1a752d653bb529bb36a04c09e0b837c9def3be95aaeefaa507bf8eef4d70af632af1903e3ffa80a9c2a9d5c63d4a27981d10c0dc45ef3ddc7094afe5c614672b23afbb8963a9758016d1b44c03a2012e84d023cf6cb4465b0699bafa7dfda415a222d843222833acbf9ba16e926719e8cfb5faa11638d8ba7dd2a58a8dc2757b7154e39f6b8aa6d5ee8b4053a3f664d9352c651045f6e3dfe0d1999407f131efc1dae4563a440f52fe8255c6dd9c9bfa6f554f31cb559ecfdc99b15e373b46d386efebb175e3ca48a569a60fbfb2d57ea5bcf026f63a6123ef458510ba2ddd821b42294406c873211270fc8934904659866e11522ff0aeabd965f12cf7052e2d267d64d31ecf01c4b7f858ac62f4a585c989fbfaa5a445da6edc3765cda3f1ebd21e827ea6b4c47d6c3ae0193371ec7e217d65c5b2dbfa9fdbb1c85a238d91754df7c5c9c21e845b42ff75a67c030cf835ec42c7103905ac90e92f4a9d10cdcf365ce9799187923cf4e3c47ebeb2b06e09a93198fb39206f7956e2fa0719bb5b49da94b2aa67a248d97ac585028cc8ffff93029b640a0d3fbd259e90885638ef67ad58e1e15eda4a335c686ffe8890d7a4d1546d4c27334469f79884e952474ed9a9071e9651e5907b86606d07508f7a10d86a5a3e1e4849ad0813df2b16be8a46498fa98c12ece386c145449dbd2ae2e948ae2fb2017dce3382ee7345076b93c1bfd74a8bcec44ba81dc40fd2becda4df0963cd5ad40e1540956c690859eec042b019a33dc2a92f614f0d827efffc7c6a53c56c1cabdc8d49d3fdf460a444f49bfd8a79525820cc0300848147133d6fab59d4e51aeefeca0a2487a816b4973f26b833519d7bd5578327ffcedbed0c8adbf9f030b7f925727a2cfaa22949f0bbb65616ea9294d3fe87d8e4b34ed2a56272af9ced092ff14d0a66a900bb6c92e691abb511dd4e2982fb3d7825cab4637567598e0198d393f4328d61a7c0c1ee4c6105d839030b43b16361a19286b2cd6388397ab4449f1205c332b100c1707addefa358ae413e7bbb96da561a569ee420d30968b67b5ca8e980544787fc5efc30da4e83908fad21de9af0639296c4494b56ede56d44d25c98583389e38e8a5cf26afab14b9f9c1cd8b537e878b2bef5e867106e9b46c77f470001d631613e4d619a4e49c09c9d11ff0caa7463b497272accbe4a661de98d824c6379282556271091e74ee5a0cca76b5a8d8f8511ddb5b01f5c536e8d731de5d02f89d32ee129e0f070f00656ae84e3c549b553af0b74670258acd3ac14454bb6e3ebb13264127c58e907f5515acbc647309e47a294cb6943c4bc9ec17053118248dbce89e7562854aef47e257db0f3d58add927b3bf21f3d62c478a32e5443e56e2428ed98275985b805b4d644372883b99427ea5a240fa261e9d520d3bf6d4b3030b3f30015aef5f6fc681294b935480650890e525b0e79d300df0da67fd41358705173450c1c7c1c2eb5c8f1c28ea5f8cac9566b9a265adc75d285b7317226312a731b8f2fb3e1c1a30bef51a94b70b9d71273f419aba70720f7aa5b4ab9cd4308851e7e37cca3fc5ea699270fddf905de32a62cfce6818cdc0fe0b28ffcae6631d0bacafe81db6b9bf28adc32aca12308ad29b10a24af11f3abbedb8d1eb476f3f974dfb74d414015af734d5b6ba2bcd6c4176b551fb1d2538b36ed7ddc6685c1eecfb87e2b05b0d35c622064e0196547ff15b5f18eef3608670eadb6778cb9da23c841ebe6849a8e3b011c55e39cccde43b10ba09a7e221459c0b2a9f280a8c9b4deb9295ddd309dd141c43e959e40520aa61cb8011b0cea58cdd4a05c0a48e6e02ed4287af0f84ab9427be2d1c554377183bdfdc7a1e972463196bf0ad1e24b1e65008db6a722aea5607ea749c9b381a4051afa54e629576a473bc40c33097883d3b1372cbff6a61d9f9ba4af8e079bfc8ea856fc6aadcd1949c14979b96141dd09b079807facaa49b29906ab32e2f0a99587b46a78dbe7932e290c32e62d45bcea776049209e6e136f0c69e2c22a9d4e3d71902665597f80c322fe1e88ff57022b27cb7ea5a24e1467e927970da3963469f40fbcd7645ca1ee6fc71a2df5e13cb335d6e2e9e865c8c5ff46e2615d79f7bd9777d62b6d29efbcf33461c4c66ca3f84d3f0c450bfb72310458ab1f52b2407dd56ecdad058de72beff02bf8605c670f37e51188ebceadbbc49e36de2faae3ec8c0bb64f74cdaf9701caaac115ba55145590b3222e80efb3194d0dcbeb9f0fdebe566acacd4d8222283dde310c18711b623c9c3cda90d7000122e20dac593ed039b73cc3e55a9ba972cb534dcfe66fc43747b483ee05d06703ec19be2d5b439f2c81c77546f4657449eef031009ac2789912082daa427f3d335076c39877e21b2473b21f492d1926059bae210b5c414c28d954911ab4c2f88056cab603a74b1c518007643aa56e7c2d31c2db29c4838dc5fbc4c3ea387dd3ef71a397d3d753e845e99482af17fe46382eb810a77ee0c4a31614e0524f7ff07e8b30de83301f8bc84fb7537346734664884278b3eef524670bec0d1f87e1e336073593f4151bafafa072ac9976bc9be2c1dbf29858947e0685aa40ba39ef5e8cef6773bae97c81dfb8eb366b8bf2e9d7fd39561a2312793e8c87c562cdcdc68fc86a270be011face0929c4987e6e2a2e8d4f5e78a0f3614d34124bcf9130f6f5e30ad0e84a6b88b81acbbb6480bc5118bf9c8d01dcd414515b1f5b7d8b65c7e8709956e2c3f871e95044ea0a820e19ad55aed63808ccadf56109ad640be301a65877f3e5ff3e4bb364958b0d9cb3327bde81969abeb15de55eb7b22431e08ce619b771a8fc184fde99caf09b7136950b0e452a67246468ebc29423ec4944a504b5ed80951fd6bfb3d75a90eff07036d0deb4961daeccb7a7431661ae8330e409482cc67cf0a73cd8ce64916e838f5fee0761a2e3ac2519820e15706acce975c6660f89f2de817adccff3741118874a1c335429d528922aca68da45fdfdc172ca629d4cbab7c43256eb5b82234ce451c043a8ae2c4c621d80978571428421d81c3dee42e339074ee13730432fbdcdde3c7dce73c966c01bc0df3a13db289819db89389579c6c4f45291a32df7e6de03fbbe4f27e61462ccdfdb00c7539368fe90b126b3cadf892af0f651307eee25dbbaac0538819f2956b99b357e5bb95ae64607bc6473f3aed985de60a90c04a6af1d0edfe02b66780f850c772e6dbaaa7f89005bc9ca2406232cca1fa863e79516c9b63e421b0a177abb49084c0b9b99afafffd15f771ee91d9d6d43aa845484ae4e0b421a2cec1955357b63122352156f85286151d537e69d9deb47728f61eff04a0ba114c0ed3e5db115e6b5e0e3615f5c4b35832ff9792c50c4db191fc5490ee489f3a2b62a079761b23e84b9053dd09af00b94f1a7d6ae2a14e40151ccd2d116da7605c0505098a971d83ba2b13eff4d29ab890ffee3efe49a103bc5cc249acd88274f4dd231ae7096f566955fbe05ba3615e77962186bfcece0e8e163e97bc944d8dda9a6a7aef6835f7b69364431b286765174e9cce7b704f54fb75439ba750ef2b32a1a19a1c56134e08cd18d2bd0740b842b75889e4193fa4dc201f54afb30df3964a4b5fbfbf180d011dfaef1cc9ecab3d57bf501a1865eb9289004d0bac7f57b8dd6c826b9c1ab07ab8d7da4b8a4e1da8838c085a753232b40978266d124dcf33b3ac996a674d66497e3fce561839d907f36cd32a89edc7ec1f2de7d6c14ca0b03a2295b79c9b1f5c428a79132516ae937c2d884743b304d0250f53948049a6bf94af9418fccf846dd8103bc5c508a878373b19775146e302c94117de87367dd200fa95bd22ea29eb70a3440ec7cc2a9f8ea77e4f7e456121fa8a7d5572d566992d1797a4709dd117fbf19edaa405fd29ac69de3df30cc27477304bf312ae8986e6a043d053d48cd503ffc2fac34bd091ff10222b3c1ee57d8ecfef05a7b6c010a57b9cd358c1e4d9c45d76af2ecd0de61241105e1d1e529731ad43a3d9c1ba8e65bc8f66fced48d70a234250203f21123283ce5be8829da4069b7b9a5a83b6d90af9f3cf236d1e6716855b59a6e7fa19ce3fe65f30cf4acab6fb469c96fbf9b28616cc69f238314ccd0f8e5d3cf23cc43d125fd12c621d998c76d5f4f4b63d4caf9c06501ad93ae2dfafc25e928b1809441bc21f2e61a2de762e4462b4349fab8bc9515128960ad6970d70036e3c8f4ff516d7a564b3343fa642afe278a2585d227282f93028a399e6ca7b8a18987cb4ce42b285c88606e9281b2d8b1dcc26a972a4b3dabda85299b635bc2e4586b29417be67c04a1f0a067582bac7944dadb22c03b5b05c8e0f26daea4fccc8b541369b9f6376007e3eb198272276778aa615e26dd4bd0db280bc546e70c38a9ba050aef1e926b9ce977911d233f3ebd9c1c706266ce54da9e377ecd5357307c90ec0486752ef0021f6e6c74d71ced750f60f37d86a816eeb5e3cf28342f4caa68cba3098ccf31c5febf6b9e41ac0e64fffb8dd56561c06308d832e1f531dfa76b79c1d08c97de0ec2f7349068bbdd13eb156e03b8a6b5c97d06766a84c2ad5415dfc2a69c660612eeb2ac25de022560a3db4c82e6c7ec08663cda52d475029774479417af263f2b5c69ea65a4fbb4c740d2d1cee1daedfadef8a0274b22acda103062ce9638e168aeee1a124d81bda2d3a80b274d5a2c77b67415ff5b7b67c72970bcbd1c78aedf8f17e1453c22f74115cd6b699d98683800c6df253fc7007195748cd079b89101c8f0bbb2a2b9b4e6dcec2337ef179fc4dbb8d7e45e9fed01e1855bdfc6a4aaf5d2577006a3885ac8dfc398743fcb68cfe881edb03d05f7205d70aa1336cbc2b4aff9c910cf88f6d17d2f4bee93ef543e8089a32d2accc7e457c514b57b22741d0ece8da5abb9e894934d3827b6d8b05be88aa4e8e3f4f4dcb2c7f62b3d1aa0e1f8f8b6d31aa06eaee72bb068bd11915b3c0e7627607ae4b176157e6edd998159c21d894721015c9ebc8ea75eab042b11b723801a9d4c1ca8c9f5419f745b30fa38f9c03fdecf49194af58bac6309250357d7eb433f9282fa8ccb800f6fd3e6501e634eda962b81e34a36ca7fe9bcaf85f8d2add523471dacf604aeee47ce9a5f4c81d561c64a319bde8d4a02f05d9b97677c2a9586747e92d7450da9be7f136a404f76cf52b9be9451ca7bb5e741add6512ace47aee1039a4c29f2a0b2ca273adb06cb93139e951d7f01b5a34c005dd6f4b25bd7e7dad1272c3f2afbc6ba5dac47845f60bb1a4a40ddcbd5e2cd8b16183f024256187ea09bc204ace57345d5129b3c0a515a5f6b8b94192e7311523eb32548bd11686fa0f55e770db4746660b0fde5e8f71dce5cddaf25d46a79904cf69217aacbd82dbd5ff5e6d010b3cdbc62c161ae70c21021709df68b9f1d33ae2a4c0ad996899d189bdf8c34ac9d89dd58ec1266763b47ebcbc310d1d5fdc5545819b905981b44a6889bf3ea285021741600ed5316ed0bd9ded5fa3fc80c0f404b4c9191136a223793fa4d94c2932660c464e1d0b6044b5664f0fbe734238c5b11df333335aaa62387d016b22dc6d7513dad35164a49f9083c8fc4ccc58962d627fd8ccf27e7bfb893f00e5af7436218479e24bf1e32f6a387fae27203c60a3810b62d2e328485919ca26856b597bb5c04507fe2cdf6bab044534728f41e7481606ce0ed31c14846e69c749f693954a443c49ac38d1873198bb6be09ac13efcfc43edc864c09f45379b8eb9b27244b00abf2c1e451e473fe7c3be5c961becef0f8a6c26ce05e39702a6ccc9c2227d7b3948d61ddf16b2e71baaa1a04713b89169dc44d3a9f0e7b8d503093dbbca8b2c84ac63fbbffcf8e282f266fc1535d1ab6f9dd904b2415c7dd727bc8a3ff3138b97598035a1cc8ab019b09341daa7f2996ece85633d44b800b7ceaf64e2871635f0d7344b4f1e67e43829e51d13c2b2f7fb44edec619cd0bffadd3ce9bae076b2bfc17e99dc34bf51c3c419db9b37808f93041c7c004bf3fd6d66cd29d559efc86c312a6915a7ed31fdc0a2f382a414fd0b0af9d867f24102a4f62a681b0e486d0f817c93bcf3c8d4a69b89b5be959a414a865b9de753c604d5477b717f6a32f49ad29b35afd705e51fbd4bd43209bca8e735b0d915cddf6a59e5bed3cc87976d8734d0a0b6354f6bca6d458538bbd4d1e3604667dbf33959da96f26b6c10c59c147716d127a879bf76275996aa20a3cbbce0763741a2ce912cbff851066a13752d4997e3c41992ba474c542122683fff8a7d78945603179d38ed02d332962d95af4fa4ea038d00691eda2afbeeedf3f8fea86a8c8446600c19344fa8e699055c8a992dab2cbc8df9a2a763c6d17f2f8ef9e4a46344d52cf7c9a0f0a1c72be6f664e738f7b80e6b7775707c1a05191ea9d8387355904308386940b01633649a099569178f395476a1439f63f62de0594d2c2f8cf7ad4a9d04ac944300362a997a3c12a8f360b8e2b9c085eada5876df6de55d5714cdc5161121d05b8db84a129583452c81275758cb226d9af7e01ebb50805d03d15037d214084270b361bd51ec616c67dd3825f250c4c2909234d9a904d55af0fd1b3ec63d6e602c6ab76cd08bace8b005faae35071d07ccaefbd0f36e670938f15c4331474e8ef94e807ec817ad5c3e506b0e777031d66e2b94c97117415390a742cae59d94a5573945d71d8ab820f717be4a44fae3e592bb2ebeb4642730079643ce2051125eefffad192a0e203a9c160053b0d592929b8c59cf555f966229c2b0e15406ccc2c06a391c3b2f09f45e4e837cf35b2ee1b1b8762d7f50bd19bafdb08a381e3e0a4f51a6cc7939d4134e66c1ab05043a73135d163e0ff7e58170ac62ee7b22b26d31fb7b811624f12a6bec3c13d9346d1f1e885b64cb1d1933748f02f90d3877b8515e17b2c96c4ad1983c3d04485dcb9fdecba20f656d1a21779774ecb6bcf6456b08c6e878b52e34b17add9410209b610d82a7a8a2ef7599cdd508fb67fef87fd01b5abd2b755700323aaa6f7aa28cabde09f814c9a3117d16aaa54b06bf727ba89e8f00ef37b6168d8b274db56da48aac75c104b853c2e09e3d9ce81613ecb433e495d1f14f9bd940c202e9f7368a48d03196685572497bf8e63447afe2e85a53b7a142842790abf20fc73b662f0c60cfbe12f573916a0ae931f7b04ed8a6e16799ef4ffcebae57e86bc54192d9e5bc1726cd1ff5087b7ff916aa4755c4f2e00387635fac0a9ffe9109b87ca5285a78ba1e1a8b5ad565a45e1e198e58d637e1dee27bbad739a23332f78e0cf19a2eb41fbf0382fe6aadc60ce27597b1e370cd55ed58a1e0ac02df0c592cbb11922d634b086bd1df431b085ddef5cc037d8c923da74e97fd7a8f899ac64414b15691defa6df4bdee1d258eeb5633f6771f49796f3cd71c23cbc8d6b955a517a51f6eedd7ae1726ea21ad4726ac9c8e7dcc2b3886f1ebc53dccf41d872725f0c4dde5294fffbeb585a2177b8d58a392cbe0f8d76e090ef558b691708728b712211cf391a32faca3d2fd4652e9eb2f285b0db12bc6fefd3c86357d97538a2e6e4abe8e87cc7cd2e2b1c7dbb7b2007b79726d0d924a74cb1e7d93f5e3aa41a721eafd2f1563646b6ffa6519c60d5902208401bde4fec272a3d078cd2be9a12f756af22038f8e3242ac7e18f967fe9e7f4bb9de62366d99b3669d1dd19c24300c1ae4abca0744639ab16da04b189db41ad0c6a768b2d0f9e110e42fffbf6b72caff683788d1898b7ef4627ab8e1971bd448accaa1122d105e6751e5487192e07cb47b2347ed5af33e9be4b7a8365325e1c5abc65fa2801af6d3ab463b08973295ee069b6cc3c82c4cb47b49130fdf4d58d3b19b78fd5358af5e0b6aab4ee31b183e8b8e39547449d29b7d490d3daeca7a1e16825a6bef7790ba3812be0dc46123cf45f3f5fd57ebc83e813d1e0286e384683733083044428018c648e2aadf1b17a7a344580d0d0297a27200bf00a4d5101b24508c2c15f34837a2fd709e326c3c7cc86e987e3706bb293da998957d0d191313937cf5dca1272a1e1efaef1efc57e9e12e6ee05617ed3e175249eccffe7f384605ae74e03f2d59e0a2392b5957ab772b52db0760315d971777b74e51175e0975a15bb4ef39d47eb727de5c30d7b019989b3b48c1fa769d45631c4d4674e5a997ed404524dc3e4839461957a0e439da5c73f9af56375760d9b602bfe37197277e9f66d9e90c5c232e69bd63abe5fa3e1f11e3621ca8a35968d03dadd12f01b015dfff575ab6c6c1faa841f4409a2c22cc7ae508f36b08fef677e84e201b9aa238d3ff4477e5e1e58332992220fb0361427e3ec91351128b49384bb627f2749dcbfca99448b25bb1ac984d6646204dbd7b8b9c15714e2982980b7fc90505b1f2dcf98c3bbbe5e85dc7a5b14b71621880a32bf7136ff22b517fb3dcb4f92ef9f605ffc382430a1b7c7d45aca408e3ec0bc0d42ef559f8d78f9e46f022a0655d4f7fb96eeb1c213cef5439623a76384838bf07c631642328dfe1109a016923d9aa73bac194057b47a139e89b96aac624a2ba0b6a3d221fe850845f42a35978200cca605193bb514ed97880bc4fa7807bba642a1e6cced7d8a48c505b1048e355dd451e0bce37c079868135723c367f6c2ec388930b9d86d73cbcd82628b7a65c6a9578b232463269f026b40728883e04233d6eab5c69a4ecca978689fdba5eaea539e9752ad91ea50ca23071717391977fe70740f2248d753c047b9c22f90e3d16d30f31ad3cdf38aab4a6f718bfa32426572789cf59dd07f02f3fb3e61522b1ca961f0b29e1c64555cb6c0299235f57c6badd93f7efc654389724e7c30faff80a3a8c6fe3bc53e97a2137e3e93586830893159d3a68bfc6866ebed7ecc781847492619b2df579b04c9fcd080b43ccc36f19b0c4fca16af4e47b474d5798e311a768d34a0268cadfb8ca44dfd95e569ef45ccf1e8382422e2a96e409bdc4f5371d07aed37e99a836b778090c7ada07f0046e3a5ae1e563d096a29da218baa48d1b827e562ef4b25a6560cac364c762e8dda0aaf650fb5b75d972d6bb3611b88ce6f6be922244f53dce9a1391701b926ff928f484b9e716cbbb2aa03a748499ce86032339365778310a4bf92bb8562e03b0dcdf4521770dfaaf1aded1d665116518894adc3b76c0cd04abee01b664e70251c91abb1a3f2306a73e41bc4e9ce8036518af74f7262d7c7b9727af6fa2d1e4bca2028d0d7dd147368326aca0d6540a051b67705a007ac3225820be66d77d28704f50a2cf58f3ba7e0b566ae73e028f77ee936b66b6a466dd86f9d0e4d63d9a5943830a08c54634ad4f6776febc682d58d139e649ec4ee56fbaf821ee708f6807280e6ed69501c4ff22500503f20b873727b362b928b4db0041c917909a17c70b1cfb4ff3c370407315b20134bbbf54281cbe1c713255ed64df270b9b7f2fc8f74cde68a2837ed9207f1ea63775f7ea9b909ac1b83a30d913a9f7d3235087c22ffb42a7c6ed0f4b53dfa415f556890f9f7ce05f36dd5da33d808aef844e19034d6472a656525d05366bb49c40caefb088808b4b572fa769026dfc1003098182a428c3d3223285f11f69e66006e1ad1d00f4e8a9222bd1b71599f34c2e1ba36d232ad9fe6448d6ca159483c746c68138683b89895849c9656f6233e1a9a3f161abfe5c23c033036603390ad99cfb7d850c2028fcf352126682e4ada1d650ed093fb004a9a03b6215491c94f6eea4a7879958107c5d2176793ada32654d6d12f1344edd9bf18240f71b65e7fa64e075a01a85647f50814c33b9a93f6940c59823fd31f11e6be30c19f547ea1afea159a48fbe3dc5c3ae4d346a40e46c32d944bdbbe4f5607bd6a357d57ce7e32493257baf2f728758c27ca55148781b4ef8c2eb3ce672fca6ef5658998f30c2bc6639e72548dc2f4125bed4939eb2e773689787db71fbf0ec2cfe847bf56ef3b96dfb373c773e4c18156ff2547756ae49709f8f72f4d3a5943707e8c8cd01a8bb89013e6f62d6849f4c228dc40adca100310408e215bf644e52794d516f2195422bc2d194c8f2865c546c3f09340ebfefefc1bc4457a9324ffa4a6a128e65759d1004f51a6708bced21546248d055befd91bd3a71ca6ea2b08e8756623e8e4bd3da88976559addf4fb03212ba91306ecec3ed1190be6f98b50195341bf77b6f95cacee5ea2601af3f65417c274936b194b2d5137b7585be5884f4573a9114b41e00cf586f43d2fba208b362449c0c00c14c5654b24474c71020118627a22d270893f3aa7d5d4c6527952b07e1464a255bf8e723c75f7aa8c8098d5f776157fa20109c4559eb26b71501fb1517a4359cb07a9de4662e99758ce8137f97c800407d61eb0990de85fc96a2c0997a715b4c7bf389dc54e011ec0dc38688d8a0c4d3e79f8ca0af7af7b961563fb9d44e972d795e14799e796f548a871aa760ad676049d469146dc271b30c908c2d250dd8efe9b14c1aac4e21e5fa31ad7039f451e706f1a9b779e921bb80896016f869c9772f8b3b3f29e6b30121f5f4cd52004ed6a13f19a699eedcbc6453c39bfa251101c6c5e517e68f1c00aca6dc3e01aaec1a6d8c267e7e224df06c0ead7dcda370339013dd347274c8a4968d201b2e336e2fb5cb47b35f68791c770f86233f6a092b1a229a3da88d465a51553096945437ef5d59eff029b322b8d60c1369dee2a83a28b5447eee535456bb742fd8617c9935795feba89b34738409d40822c0eda0fe59590aa15855186dd90991d6f2b476f826a873aec27912db0ea70575215810ca2d88d61fe7031eee25b83f4f42944b507d636c539c0c9a35418bb5d3aa2a08dc87b706cfc61e02acf3ed4dfd4ae3d57730c5bd771b05af5f60fda19816db9ba22588ad3e1626425bb25d6f6242114fef1b12ace638fc0ad55430cae4906436ca509be674f4dd7d0db9ea6456461ce09dbdd560a929e2cfddc9cb14a3681c3e77323fdba3ddf2c6a651dc5d4122e4a93943594315d64888dbcdcfc08d42665d39e499094d0bd88af05a2455308da481ed4cf0121e54a0e7948616d7584aa53241b26f4dddd43354bd5ba59bf0153506a99460e4c4d37416029f890b0bb4959c27bd966880b733bf9ee59b462c98f4a267d98bb33ce4bd01a038ee7a7a912d85193b3c6d3f96ca4c2901902ef076fb50e2ace6ae9e784fcbfba96ff87db3629e5cafc0be93093ef3b88acccdc1f58b37956c62c0d316acd290d68dd772efdb2b79f3379672a15ec90d3e07e74f9d5773f5fd433efe8f3221327166927f38c69dba4944c67d7a068496c11624f87eaa50239c0e593e7ce7e2c180dde07cb918d118176975cc4b0cd48804f62723ea76a3a71ec092a18e1a1687d80716bd497a8a8ec865a7e938dc6a70fee29b9f35ce3da5904b59d8a6627e62ad0c5b1b8e520daba0e13a20fe05c2fa1d757582a869196a94a788f834db7ca1e62e8df6d95e30734704b40cba7c37008cb195b7b732aa6a8f16b666ac91b15c7de09c4edd1487d2068773be9def40f0ead881a0deca5ad9a132cc046f0e9d15ad09bab3565d6687963cf0bd7f38fd3aad5fa65ee47d8336749c18fb41882e71f732fbc4351663b360aa9653a189b4018f938e8361c6445b166fae97fdffafb5602c7f0a0da87dba6a3101e1e91c58a652e67e9ac34dc7ef474039a7de7b2fcad6523d5bafcc1c60bffa90912f3043fa26578ead0172d4cbf45d559808ae23620b4f4dd8f1301a164cad9428358bea4b84c97424efc5ebf6570d3f35e0f871dc99307e67c0bd1925457d6d76f9a1081fbf96c047da5419fc5642981727a381090be716e801f5215931d0404a26bf6a43a4f0072176c5e34997d047d6bc6764c5c702a819c34213025f85818e9d691668ec2e3fe364375faa42f54ff097b0871d88d3d4ec8fd44deebb4b04f51b3934721f8467b79e1f797e8cfbaf9150f541262dc01b19c09935a961f145d9b87b84c360017b7214f41439123384b387a4ce0bc5c4b97122f57a970b114397a896148d1a57b823595a45a87fe19752a0b7e8ae87daedaf9a74f1436761b6c03a20a422f6e15165f502344995cef0f488662ef745bbf121171097bc40d68b3ad7a7f122361d61cec738dba41b39d7fecf69f281e46e494876e13aab01488932c7acacfdeade649e4652fbce643f3dfa61b945d4da244521c7dcaba5e459cc55fd6fdf3da26d54134d5460e0e1e1de325a0c86ca9197d2283ff527a522c7028efe9476760f424d9f59579144413c7e10f72ff82170ecbbe6027148a16c7eeb6dc98eb025551d9d9566e93723ad8d65e627a97e53ca302e47714fa4e25003f7c07be49d85dc1b8529c83c9955b58103eb83f059556be1b3f3633f309d207ab47b36b071ed1cc2a2166febc15e40ff4c3c0870f3b27b1695ee29ec7811920bda3f2cd5dd161388cea9ad6b33b35627b9d86249e8d4a54c0b4770c0980c020415338235851035cc42050f6d580250c7f57dfd2d3673a04bbb49a06213c824296623e1c5bedf32e178684456ddef62ae7c7c990f4ba37aa7d085805ebb69c49ebe1418941b195a7ac9f67af96071300c66d76d831bdff517eddc9f7896f06306240774305872acf17bc524128e36f4f584d36f381ccdc71b75be52aa9f18a7c117f2645ba796e41fb6bf60f33fde625dbbb0097305334ffd3cab4b3a3dc6ca5a01108d06918734389626c0e4398bb322e2a1217015a761ab2250024b491caecff42552309591958b41239de10c194cd5fc3ebdcfab16d7b18105e64b0ac84b196299dba0a284d764fe80d815f733ee08829aaa35ff3c4feb2e637d1d0292a88cabed8e816bfe3a40e68fe11974ce1b2647898fe6e3d9931a55f31aa524233e4e5c8f5e9ffca21729718500043cb9dbb3c1e0feb7e422e1a8661c3bf24d5090eaa744d182c1f73083546279f48269e6fdcc69d6710dea904d584fb1a1d80d8c03c116f874368ea3c6c6e9cf129c6fa4695224c5be3c77c3acbe0410a46031f93c6d52f2081f976a6c2889c41907696363a11ba51e8b72969ceaf992d1ade9bec0f66a86edda3a9aee6f3df75c5427de5ff90c02e5979eeddad1444b341347473b62dedb94064626bd9903f3e426c36d1ca1b053d9a7a25e2aebe5adfdd8d4ff72f226f1230c5d435b38bd2b67c36bbff8b976bc50e9d1747d039600ddf7c577e4f928825e3ef04cfaebace3e3602f3861d6ee932ef40a30a044952f4f1e7136ed25ba2a45ba60a37a2bb9e961fa72241e88eefcf7164d1b2f0f0d0803301c3281a4c92c41a2e36e27daea93bd9e85f171184999eeed20c215327b94fa748b49bad376910267a22ef2c2303877ebb899c77d27eb53bde5f53a2d590a9a3ceea843b301a30c980d81ec4a1486d3f4e8eb0d87f47f1b1099027343e0e982f6e2e95c3940da47ef2e8fba5c7d866b4a78042e03069047fcec04a75c09810f0531ac21aebde72b5dd5829d6547be940d7db812bdeefdcbc24efd27c0df5d8ef8a2f313353e981c39a83569c9d6b631f939b0c9ca043f7b342cec3514dd8d2c598afb9a7254a00d78c7425d418ea958571bee7abf31306ed22bae166d1e7e90daa2091eb46544e5d42ee6923b47650a8adde686f5d988084be21b15048c99481f1fe3b5f4f8e702ad38e88769ed27a82825eee8fd2219b6b36149daabaa39bd9bb3ac6f492c6f90d7ecaf3baf482cba2dc577d97a25d595ae5e38951e3e26a91f47137fbe4179aa11d84502a8d71d088a64fe253082a9ba69c6acfe77c1c23d7d3821a8994484a0039adcf4a6c68521c354709c50cfb0b2cdd5939090fe057e993f991a6e78f0f8913adc839979847931b9b354069c317a7fc1c35c9414fac7a8da0226c874ec1b8869ddf98ba2c380bcc24a88cbd11842caf29dbc07c0ef84286d4dbc5dc4132c0121986bea15657997631168f5074300d55fc26a10f447e3af3f6cc8d1ef1b0e0b198ca35598967af29f9692e586f5750be6b973a5d0a7078e3c6a8fe7db820b99480c7b9f49826991de585f60eaaabfacd76c37949a791c3138a43b2971a61bc7bc2330a3de71dea3c4eb8ab6dcfe4fc952d3192fa60ac8a987df59c1c92552da77483b03766876322478289ca25a2cb409c0da5289c50f88cd0612fcf4574038846eb1920e8303274c8ba736838efdeeba1030e47028836bb54388b449c48b5ac05381fae097941e5708d16e6d77f08a89fcaed072da3b6a06d1fa85f8360c3ce631b27205809853074ff735a33b0e5a36fbacf67a65124a6b8e19a18165475f41fff4af991397fdf2d54217b043339d8b4ce15d4b51602ccd4123d7a227980bdf0be787699b771137fc8026025b35395bd01bad15561fa0915fad48be5b71caf27b9ab4bb4ebcdc6ee8693608b55df27750270c0c6e53125c225250dc05b892646b0ce60d542e5eb4d229d8ccd6c551f8fd5f7a6a7247ffbf9c1a2d1c6201b7d2788e9401c07560882ebfaad8f3eccb25e35094fd86775ad5d85ccc6cce999cb459bbabf7be10fd3fcec2fcf3a4bf50a0aefe2de18131ecfca28739c96e807705848479401e55a3ef85a3655e587d0b03d668bfb2c8a83ef33fedeec3e3611792a0e9ca4977ad18d8aed599a1cf24b77efbeaf33b0df38cfadeee9eb4e5ba46cb8b87ae1e1991b3942e9c07ffca0da8e10d605120bf014892f0f3aa8e9f1b6af023923c1b8d635715fa4a48b0a1ed8d7c5821b6ac0e9169e245fcf343e4e44c8b914031846cee0c9e2468552aab5c2d023dc7d196857ddb16866629133d6c46a1b878037b104ccf2b45feed6230f76f55ba59ebe3ee5dfd40da105167db281010e9be8afe5344ed40bc1ce4a3ef988e6144a83b1f61c9c00f6aba1a204d3ae610ecaca2034513da6b34b091dfbc5017a8fd39ca06608f0b1abd1fffe2721abfdb48f044f7b2c18bbbacc6b073e69b2a6305d62e8c4b845c9292b2213be5442832bf5ed8e9427be62d7c2e79618359ac886fa8790c9259893b571f1b0049a076702536588c6dc8977a5955f1d9f9a4a12f09d6f6f908e8b8f969bf0dc945d1cf78780ff6b054c64a9b5621ba05cf5369a0669d5c8fd695206f7fbbb92203b502e41ae1df69e70c183072ffa52e309e087c293b7f6496f0660a0c8f15faebec03d67e0c7bf3a2d43b88bc7b0a46eaccd2028bacab0bd0ad4d06de44e8978329f3f0346415e873e9c00fc858d00f9923dba1975b02394c7e8e33ea0fe9c98f4b4487376381df322eb2d79c1f7932c56bb4b013b9947a6d5f02b10ce6a00f4c4240a3e154fe65213876b17a0a61241081691c2695f465d75954514e3c94b85eb11fdfac66b3a04f08ff6352a0c791f72db4d9a054084601f2b5df52f3007a1c6c0f28472b0b227b915c1f59182b22405a39e46973c2142c8ee03e64a733d30a64697283b9b04b59d14d2440a1bd944d364a7d057adb4516aa4e104cd0086305572e4e6f2261f87e18bdf6e4368d78000873085bb7b152b5d325a4884a64a12cf5ac68159e64d47e62d11045db7ee7bdcaaaa1e2e80acd945d62785c9f9f4f048e7bd8f5977844807121e13dbe0f13d0ace0d4ec4034d37017fd2d60f7d615d9c47b901ca69797e65e3e90b4228356f6f7f63999c64428bb2481c5553228ad74866f514222464c5496e935f043159dc631e7aa997c3dd326b872e4afb2bcfafb26db32825c4df467a597c1548dbf6e0f01f2b00ef10890d9d4088d3846733a297718d0dc606a3a58f539a919c4097146a92bfa223755f25fe45c63869f4bd33d8f28eb95e19ec4121d1be16a09fb35acee2950372ca19718ee64e6c153f4d88712970f0deff0e1a34ac1496984be391d2f70172d6522f38a53f54ec284079ab00fc10bb2b5aa43106f48817d2563305d5b424fd782c0c9878e3b5eec96ff53ac1811361765b2d19bae58a89ba02e6cbee56fb110c7a63f200cb96f37e5daff450d2825917c16ce10956cd51d277a313d37246f75495e06aedc9783962a8bf5cb9413097da9bc850dde500e2a211dc4a9b723ba22f0352ae6cf26ea614e24413ce8090545ccfc7d69e4204d3bb78159ceab2d7727dc50348926c06b3aebeeafe833bb0d2b71ed1d0ee1a17181769f5febfa592df81d966851d734f49063dcd5065a9c68f0992ec029d9e892c15b761ad07291effd3fc3ae6ceec9db160fdb63fd85d8f21073dd7673b56d97078b5a3082e37d7e819bf4133811ce4babe01bfd4d9eb390cf499376269141ee1d9591080ff591287f3fffad6d27e8352dacedd096efc9cd65f0eb11fd8ac6ec46938a751f5227484e9f277a1b667c0c266a75108bd2b253c175141e33f03f54b322603003888fb8f34cf88c6b6e09eb828d2e046718cc973cafbde6718af3f5a0d00d8a16235381499c4129cb4a67fe62f98225064d9944f979c2dda4699fcc615cebd348aa720da8c69dfaf5e5fa298b1345132b6b6d4d5bb7e82d339480f13cf11485892befcc797910fe0cd1b6dda9b2a25fc11432cdae729d19dc0300fa93730ee9abda0e8a5299164838269d04f98483d3b740a52d2ad4dc28ac2d061f953245950ca9b3e763d29382ae3433f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
