<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"89de5e376abf2606c04ace14f5e54c3c05a5647f39b4d43aaa76c1a2c627735bf16fb43a9be662ce753d900a3d348ddf4bebf43548079ba06e34bd54b7167ac6c5c6f6baf5e67721ba718c836d419b741930e1d66a3554960237882126f0fe951900c36e07def2935c9ce0d6746119653122d274ad2df2b3d51ebdf93b02833804fa309218df6de6f6daa4eccd50ca811c3ff3cfd534e192326907a6b3bed6cfd7203fb1928c6f56a55bf4fe317646ef7c62303b0996e7561cd49b8c69209bc73963f28fc7149c6d76a5dec83bc8371e5e26d598ebab41bd556f24526d9cb5ab116253ee45abf7ef55ae6fb13665cf06df7bf0c8a32aee243855b9ab2928dda9ece420408cd3feddfd7b3da5b42925c3319cdbf2bcc790b63003070b1c430a29ee86c79d8061d95e038e6719ddc89ea4ece5b69950d8e9acfeedb6c3f6f3f70ebb456139fba148de083a772127ec66282c56d79addc763f5556ff64f54d9559d9a326c1ff2c55a24b931183ebbfdcd1b29d3f673b0229db8dcbf4ad6e7a217255c93fb0abc95c9111b4107b7b87ba2e44cfd12c6816bf4c46cd08fd70b5bf63af923a5699ce8b01c4396e3d392ab24075e08eb6f1b782b77749b1054ddca64ac89925c198661923bebd4d4cc160f5dac5b48a7a7d4175b1de85c39f4dbdd5faefdfeb9ebf887a6baade4ccd8d8a08e3b31f7ba7370c4ca292ee10bc09b1d1069273593b76800407519bcae21df2002980ca5fecdc82b47356e6c04ca7b8c7eec35bdc7f70d15cb651ba5daaa75df375f4f3789f3deaa8c88ec0bafd7424ba190abbbd814e9bc944c0ab1018a857fd3d85359c91fbcc861e8c0c5e4bede8016fce179d5210601f1aa01aa27d902dcfb2dc1d137da649bba8633d9bcc27e66d21da4e959c4ec2082dc5e6ceb3f097aa85c2de7b2c7c1b40201f4c553ce5d3d5648f2fa950b684d97be3048f4d25e089d3f40cfa6ba61145928b8cd348ed7c3ad13fa361549791645d429ffd7d3b2ed1a2456fc50fd6932c39fcfb39c06739a2e490b96bf581217ac2aa9abbedc6fa07c529f393908ce07f29aacb8aefc0eeff1e1fdcb8e5cbaad310cea8a261d82a16e296b1b0d932cac64e256632568a46418850e924cf5dc26691cb1fb749026bd55d05740791b6b006a2950fc00ad7e5896eb10a5f4445045214e84d61e003091b8d16ac9dda88384eb742e6c5e56da6b1a5262b2405e941d2f5dad092387af88fd20fe0fd2f1dc186a1c33137d6049d8bb1520c4195dfbccf8b5637aa669df654769156c86ebbc20b5598bee15d011704dd66e870fb203f17798cb98acfd9239aeddd66a4aea0b1fae9cd029474b3e16b977e772a1368b3bdd26b6cef860d7ea10f76d062c09f7f2fd55fae10e6395b17a82fb8c96417a8a442ba7cc39261151a431799d4ae8d566d18bb0ce1476514892d2132b323259ee14b6e3739916b3b52c6425ae5ee75454cd6246cc40a4dd7f627a5c348becec61cd143ebb0e2df344da179cb038cfc9976b3e1882dc771d2743f58090becc254e63cfb77466b79c04bb9e561ca82b1c95e0d0757e8452fc750082d1dc76cb12ade6e6b371c7bf30db565ad86018bf2c3fb5f22bdba80a66f675b294d0210d04127ffd97b5bc8bf9cdf37d637608c88ff43e6bd1f46a92d2b346d90941bd11005540849b557aa23d1db51d1f21214aa337de1d0e16431f35dc35123107f945bdd1aaf8ea4641e839d4a39c6153bb293a641f07417b398e3b4a4f2c3e918a26311d7ea36014f180e6f7c519dadbe101eee553d0920375067920e465cac89c528636c9904a7c67e13433886b424f733b2589daaa63142738a1741920113d84361616939ecbfc5448017598ce8ac694f7a51970f34871c6efd86bc3f8a028fd02427af33cfdb4d10cebd980cf96473c5cf9f7316a1aab3dd2a498371f15590329283904aebdde44dbdfb92707ca1bbc95cec8dc17b52498a5b1b235fb30c38e11df944250fb38face5f8de168fd4885136581c2d3488ec4875d158be827086fa3c956aa25cb19c89f03d0221c317d1914a1d35b5fd93083b1ddd8d26674b1e759ddeb6fa23a067fc4b3fea042f8415f864dd1418529d1d1bb87bac319a38c9800c659d1538efcfed7a675aa812737ea9bbfbea2f04639f2f370bfc47e5cc98afb92d194f37fd549c4a013feead9b7af0755207f43518e1e6f72a5cc7e320bfa1716ea27c2782d502475a8529e476b90eac604daaebf4a561365763fc4e194c0151b7ef355a0c146346e1c847581ade02eb4f96edcb199fe2e1977b94d7b4d96dbc9688b428a783bb3e27e7d1a72610160e3d2fe4b5d992d16920437950c007e1627b8e7816f367ecfe423241313a868526cb8cd55c95993a255edf41b4d5ce4c6aa077d92d8a44494ee4a611eb3bde7fb18e5dc5095130fb7f56cb67347fd30c946988cb00a704b3606eec9ee1f81e739aa60b77fc10583a956f592a9ecb2741c9d94a857350cf89668abd8368edf1e2d6a98a0023afd5a3609522e022b8459d0fb48b3597f58d90e4b70856f9d3a58e0919da61c58f7979b73c7de7f56ad4b730a88c374654d3ea169d952c6ae6f81c1851c8814e5f685422fe489619323a6b71a211f2181b75c090e9f6932c21a601e6985eb0a385642dcf8b9f796cd9694712bc4aab346da587ddbacf6aeb44ff6b598ef4fdea90e1e6a6d3ff945589db0b308a11327a8ff423d07f268dbc120f89bce98b5db50ebcfb10cfc8f0c448c421ec9147aaf40a9b52e3857a36184df3aa3075050066de7c9efdaf2a3d63a83dc668dc63d0339da6e3ea2175f6f8a38a0d4c2715bea9dd1d756bbaf15576b23b198182ce94968abea0333e0b38a5413a397c754c80d612f756e5dcb445f7088cd6ade4f2b76a47b77c48b75dcca315033909c24e41338270e395bc227bb4022bc261123368d48ac8e45c3109e775db9a333713b2ef8221975a0a3231bc2097a10848bc41a64b743f16d928dfe9761cb22a6fb28c0abefbfd32125611c3bef65e3efc5faace28d6b86047269b6fa75d1169ab59760a982309ff6b417cc253c629caa1fadf593d1b66add6b32e18a2ce2588bf18a43d7319e3375d3b73e49863cdef610b5c2a4872bd6dcda3c1c6b57bf734329e692584de5b39ecf1b616fdd923633e4fa575d9d225707fae84f4f23e7162f181d075d1c84514b526ae2edbe668694c6a7be8bf478d6a8cbd12bc6179cd37722c098e238814f0abf0940a4c58c851719ea8c380cff3177fffc3b125cbcfcea716d1c83efb346b4458b6d153b1b034f331ea1b98c9069b352701d6c1ad117ac1f6b7fe1125fbff1b788d869c8dedb507a785bc1ba72ea57a9a6c649fcef63d342151c64153763c835a2252dfa1b97f7e74f136df533f1e7183599c173950287c0702d16d71fe8399bb562afa47a1c79725b304eba443f4785f247c498b469e66c02318971956bc79f1ad82111bef4c9de0b1932088fd2bf1bd915e51f1314d37751f33a3406a28bdab3c11c45521d21e92a72211c9850aa275079c545d0f4994c406710f8b62761f1ba0b3dc0983a3f19aa5fd90f3be25d3eda64a82fb14685e4edb96ed50030f8847dd1d85163c7bc3e77acd1df7f6a5de59c284ea0f9b734f1147af151e903bcf7e662915ccf180ce16c6a994a532e4765f475ba1fdf4449f096d80346c5ba3cdd2b543108928b30bdb50e4e5b04af8fd760406c0b9d1fad65f09c035214509dcba344c058e5d1d19b0b6b5393d0679bcc2322cdeeab4c4c242aa16eada001acaf25200ea8dc7c1db5c9a3184a08b96e959ed5bfe2f302f87b022e439e0abeb181329194e612cecf98b8be65fc563a2b71b01324a0f6f4fa61ec714ad223d98c571b17d88feda63151e31fb2266d7ef4208bbbee5b1759c64573ff0339be499cc6746b3f53033bc033e0fd4493fea73d4a6d73ba2dcb13e858fb0b0b54edb95563c4f28b120ce28975859ee5520ef50bfa6011a54d60f7e15e904f0b9056ba37fb2fba476c75e5e14ce69cdc99263a147d5698165dfbc909702cc2df8757110c06325ff56fa189e25258df64503eb18c3cd9ba2b0377433a90e56edc3dc3a5d4321f942d9bd13db98270d7636dc478b3f1737897a33493eb1dd704b135a1983ba403db573200707330899a609e707cd5883af9eb274e329e4271dcab3f8977eca0090b1b90b3bbff05ca599a6c0c79406267d0a1db80910991e9fe60c115c6c0de0b561830543526cfd75fadbdc10e40cfc0604fc05ced3c4379ea54aed6702ef71167385d41399ab7786c49c1ec59edb73f70eb39671f695ece4332656a660acf1dd4cde8a65aec0ea8610573f27a5a26f4572d4954f7336913c3255ea2bb332023dfbba7ad21861ced8b6f780dec99bcfda28c6117aacc9f4cec27dea2517aa3a5666b5d27a1414e0e1c9858c80f0f85e728b3f03e4ce9ee2c6b796919e3f88c62f0c38aa2f7a0aadf38afa9b6f0c3abba0f3f4c0ec877610eacc166877ec127e178aa9a5a655418e55e3c05e829b7c2fa380208f25bfe2de4e59d34bec846abae34b2d0cb8e39e34d627b6080f95613b626a630375322f02a594ad5e9712ee4baeda173548926545d0bba94fb9ddb78fba1b86d5e3c1e27ac6ec9ca49b6abbff281e27d7072edc074d94120f2d7cf56971b2a84dedc88b0ac004e770b3cb85faf39873d0bcaffb2afe654272df4322d255c59f67d2bfe6558d0a82f2642088e610d8428ff0c2a227583722fd8d9c32a27717e5450b62998a3a502d5900f819635e191f7b7ea86ccdec4299d1e7308680095d3f1f739922efc8597e56d3df5b3bdb6c3db05c84a8fe275d24d26262c9c237bfc83ad97e5606dc818a2f9ca7643af26ece16a8309b9126629a212be47f3920a980448ab5c7916124aa78b5fe36c92501f4c3f85e167e175cdf6004597c61d8dfccac5ebb168a23f7c1f294e2afe4affe3d9cd01b7ef8b0240856dfa7e8795f0761994446ea97723b0ff3a13d4a963e2be72e2ebd39b267a68e7798ab4e564ccd8c0c4e6b3c80588ac091c895ba5a663106cd4da93748285bfb463545902664e427917c40fc2c907e4280f786c662b6792cc7c9562cf73ce181f3d21e44b9aad231a700220837690ba75f31ec4c45a314528fbc5f86b049350026594481ada1a972f37f169b8c52260ac8b5772ad620a4eb5203dd007161c7c6f4b1ac822fab5f94aff483bda4c304bd9ec14c3f717654ffa8a67d039529f4f2f140df40a5e959e97a399a80f9822d4a8599f5850b08d9a4f608b3e01d8835b8a580106d9d50d78b0a75c9a301eda863b032808b4988555c66536fdd71377acf41629b1256714abdd2bd7038d7ab3d584b4623c47e0cb5216eaf012cd93e3e848376d192860aa14c070ae1e23bfaaf584f7aceec2b66c5ac7c6b49049ab600d2b29ab29213491e2b097edddc7885d26186b90982498a65d0fed2103a5ca2266994c710d33fd75850a9e41dc93a472e9cb789ddf1e64cb3802b1b1cff92137f1be563de69f9aec3f4f5626e3aeba590550dba8e6b76911c5e4ee7143b909df05e1e4b0eff28188c02b62c06b07a614e05338409cd98913b803efd0ebe627ce8af7c7bb66ce9bfaa0cb7bba7fffddfe06a0dc7f67a61c63970991cc26c201b1c7918d8fe8e957e8c8f09c9dbb2fbd9a9872deff513ef055e22a2e288247b81227e3dd9055eadf97ff0f10baf3c04bc3e222c60821391428ee0e0e47e6cca4b3aaf9d5491d2aa39a1085749c5784eb6bde6b67b73c4531db2e217b5bff87ed85129af4918e263d4298e5d57bd519c1bfc882f4fc7a51783be9beed57ddc31c7de02ae8c313b0c2ba864936653acb8096053ecc6ce8401aa65b2ab887dcdb87b31e81094462cc0fe6eec01a87cafe082969d6386104be77c91f54a0f76b2b371cb2b58dfd01b6fec737c92e6e95e3af52a18415f4d1467f32ed33ef094016b6b4a916de4090111606db9aa024fce763f3fa475dd1889bc3f849410220449bce2b005ba7b1ffaed83cbde0c08d51644d5b612adf8378253496c4760e47558fa4305244f641f23f60388c0e2796c8f3553a3852145d0164832ee42c26f41b8cf7d17cb3ea193ddc49076ca5f71a9315c93ef0583697be518c0a4f47a0b581c369c9166f3fc7d5dc911820b0ec3794e964f12c2c311570035dd569cffdf12529611062f093f42e15b80d0f65c4a1403f6598de52d2a3c54ca78a30af1e62f44bbf15b8f12d8a1401ec3afc3fcfed1f713b3d1428b340d769c8e456c935d898bd6fd26eb37c2909c4e3a52283a827d63ebc326d8c614e3c79ac2f9c9182fbe7600710702a7721d6782275f9d7c297065ec1075315a0aa37888550291d5c7736d30e152da336966cb91959eabcb904a5810588fb775c791f71d9e998cd860507f5c06337fa175473d407f7ae4636d416479ba4ce4b1ab11970aa486538a3ed829a40b180e7a92a129566b7fc5f96cc833e839225cf53262440403a0c187e374316fb1e0ef1d0dcfe496b803dc94b4c58f7990c8a902afc38882d5bc66591677e0a78da3ea8718b77d34783807dce5188ddbb9967a9912e6a7cc478e7d194faff271fdbaf29dd02313eff2be42ce577efeb293528da7c0fe40b1a61a8a19fe4790db22ebbfc40b17e82f0a6d0fb3defc83204e9cc6574d5967f65015493999e7e0f6a684009b0e973c1ca0b34e3ffd7b99ef9e70fbfeee3fdcf30eff65908fd3629f4afc893878e96c67effd13d391092659dd8cf067c12fe3bb200246a714af5bde3b371cf9a06eed693bc89be2096dddf1432b44aba29557fd8b8e48c8cf746af28a2a1f2f558b6bdd592daa1a8d4d7733a4e8bd7bcf21f8aa3780f4743cec9f8322f8a8d43dce3c18065592f364c109c481bed661f360383f1a625b28c26513bb625e3b8e4962f909370cf3968024f85374099d2108bcafe4203610a3c704bc2f72d41aef5fded3e53837559696fe8a11b2ef5f338cd6aa5857067d28257ba88ace9d7885b1b30f1ae45ae6960019644ac855cfd0a4b1cdfd3039b72a6e6e8e92ae73d32d3f5f26c5b53fc4951e1e0a92272307e82b0121b24ed88c2829335ded494a29f221fc0dbb72fd936bd33b84f9542c2e01138d3a1132aad21d1a3b09fd9433b3b11ad04e6dd8969f9277cc08e928d61ff3bba330c7407c72d31d518fbfdf59af3d2626cbd18e2843d657168d81738e569f6b97d9c21081a36b61a2ec904ae5ba13a251daf445ec4e434cd969fcd8129714d360f7fa7784e30b2f2923edea4df343c12ac4b76fd736d524892907df56e226806e54d1ce831badba7c87b99769fb805300db1e7081cf76ae3b47ef7e7da7f8ee3a2d036e6b77fd18762d57029c71d2659cdbd91d44bb3f614ae81927d62da707514df1ea7c4116810a3ad33b8edc9551b93d6de8f70d0446af3ef76d7756a1b44096ae65e84475ea2030c3ba7e219825f08e68ecec9bf046a80150710146b59af266b7b8fa1f83e64cae0f5571c8a379f17dfb9c61c56a3b408a081da6864ead7587ed322b069ca7cffc6c2e918d01c9554972f6497c13b45fdfeb75bead8dd76c643e2cd22c22a0c6d4aa2b03f88ad71ccfdb73d69ad3fd6e37baa2a8de99d82372d265d9a76723597185787bb0f20b19077fc4b52dab8850cd41f1602da2a00f3eb2b45c5e33c93428c09e9896f4ba8dde87331b20d21c2550fa6f7eea019cd62f3f331f8828eb53440f52d6806c77345082bb767173c1fa1a4b1997820dfe7344058186eec2e71b0248792d477b41c6722d883dd385ca12a1f73f52e14856614210e02c3346efd48ca2db7f50f1b8468b7e6b9d1c0c4c2c879c8bad3f07b7285f3b4aa8c945b7fc12d5ee7809dab1e31b1bc66209688c0eb0efead6ba180eeef2cd290217c325e9fc2dd4cd4c466cd21b0fc04a88d54fc3063fe58c43955010854fcb3c62dd57202f45fc7378e7ae676065734cd710117aa50b337f5555a3ee409bd659a9b6c85ec34809a946c9349ffbbf5a2a81869e7ddcab5b4d8778e2f03685797c38aab51f921ab59a3e4c54385ac80a0150b679c2ef12b59ab297aca8fe19d0d9af05187ebcea7c875193203b9940aa6d8f327612ac7348c3ca072d22442dc29d27e8ddeacea9d70cf222f1a8a3648b805e5e5edd04661f7b70a89663b34e8dd57836ad08c7729e30c1a76de29783e6ad74a8a27cddcbdb67486041f23300f54d9f38a059bd3e3fc339565219be7cb89114933fb3e49e97a5d80bda2a9dd7bd3f758e346e8b2532e7122f2823d93b8a7534824b587d0b40df9ed27dd547a87dbde6223012dcf651c7fab6a73338c90f874619be4c95293732eb5d8221dcb37cf93e096cde9788c443f2a16d968f0459efd266b0e881a176e0f106b27702443a15cb947e2855cdbd358142f1642c1766adb02ca14c998d5ba4749cfc0e4738ac321","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
