<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"86fb3a6f602d64a1d56cf717c2d0acb4997ba9cfc8222cb2f0d607be98d8ecbdf9232c18a8cccadbe3052d1c979b526db303f49c1f9edfb1512114c64b43e82d5eb201d5d453aa4736430bc682e46f35b50034a03f0a0dc253fbe3df0ae897d5de16d7733d7395e39699d55d3697dc9ce0bec23c87a741c2245c71ea9a42d8381ec18d69bbfa1456be585ee7df8730fd6b49ee265b1005455ca64d8910064eed76e93a133fc4a8a71d0aa4cd8b389f72d06ba9b3febebc3e19243e4b4390fdb03cbf3691fa0daec401cb6f10e2a919f7c57d04937f6a7f832fbe48159d863c2358f015b59486681836ddebaa9aacbf932f58ab6653699d1ef3483efc5ce1579e12d9f4f0573979b45a38f709774c67138001f0594e72bc00e292118d6abd2bd0b4d31b1dc42ef87b9039a790b18e016f3693fbe2cc4495890d335dd3b774cf5c5d92d4943349b73f3e822642ba0c84e1302a3724a6d0c0efbdefa2edd0a31f80dac3ccc7e80bde6f923aad5328255b1cc80875c3058b308f4e048d95e3f162c00d9d3272813f8886824d31689cfbcb329259699fa221b49a3b66f6aa9b59293a4976bd1ff7ca68f7eff3e820d19295ffe87d3d96bd5df4bc10067e07ebfc345cdf895d0ef82bb2d792c9c896339c4028a95aff090169d1ab4af26ec64a2c06f24acd13bb81016263b0c2aa743a1b1d362a35ad7561759e6323caaabf094e81ac3c59f663480c482da5edf72f78dd96aa4b5fa40acc9f4c3c550584999a20522c1a11d3e1527726ff250466db9a45676acf2cc247573b270db2cba5c6d92d02493bcc89291b7ac2511ce872b46bbdbd2ec737efaead58b2eb0fb2a9768539b42b7dfa9fbfb77c554b5001470fa1ebad9a0678e0eb79cbc8b601c92ad7e0ad63d43c5805f9a5963bc3e1c58b9f4ec92ef942c13fc20a1f33f7cf8241a2f2ae1114929c876e668151dae83263fb5d23c7d6e42714bd1647125f4ad936c4b8b68ecc2e012d2a1919576e99a5bb4f434c15100b4558b7c57bf78271e406b68f7fbfa051b296bfe96f5ec16f4dffc6c51eec4405f9a61600b5aec6c44a815f549009905d001bfc72a752bc00d3d1a388168bf647886e58f39552754e102929b1dad5f3d795b01382e41372a34e6a3dc32e281f74cc81bf6b47a8ad20e489196313e73ca8fff28dfe8495af0f8d117cd58f0d5ab898d61cf58f505d305bb715318f781a196b668ec4a44d81f3f674cb9089e645ee6bfdf04f133fb362862fe61e6a75dc809ad0f09eb7abcbe385ceab5cd81f8ef09eae217af31aee7abc68601c75863998f3bb750b94b4d466659446601bbc1561768b3aeb731943f693964290300cca23e0ad214be1020a9675d3122b087aa25c0b7b35d581d6b5b498e3aa859d746cd09d99d010c81da0ebd5b8e216ad9472ae42edd07b9536dbfc2129211b2bbc66cfda90a197cec2fa566c11db76acb1061c5b32b0a346dc13459c8b710dfbdcf6a3652ab7a8a15fa070b072ac623f0cf2c766c643ba08e93940cb7644a7b2c74e89e8aad4523dcb02a936364861c7124cc325f8b3c1d324d543e3e0e0ebf2a92d2134f11d2b76f0bc0a5a75c391d46546395fbc2c403152ffbcfc83fffe1441896e9736687e891780a4d4ba6fce40b887c4e4229588ee3e124ea113439f60e640ab1ec4c9d1bf16e17f1b2aeb4e3c6f2ff6e10342b8e2d4a05781fb474093690be2c8e19ccfa595d9afe3c6774793c467cc972a752b61d854e2615b53398e0180071126bc7554184591bcbbc488f31e11cce6ebfb5f611cb2eb665607c2b5a2c26852b270d182a4c4a2c69d17213f20c7781e2a45bf7c1a1b792b1f54a09cb41874d5e5ee37d5fd425ce900a081cca58fcfed0d2bf3f391364c6a0a895af2a3ca5049be57037836e3aaae3dedfccf6ade3b1267eb2e9d96279ae5b37f578c80be1c2dcde95df2ad52652c774360e9926009798697076f891f82a3dbeebbe9afd82ed23d75bb77ed7d9477091f412c992ad178cd58e31fc5f15fed5e62b5816249700a4fcf6c76799e6c4ee0531a22277ab9451b6371103b0dee3ec6533affd7821ba76344246aba9e26eae7e2ef471086c4ee7080b815ae11753231ed5594350adafbc653a7f362eedb7c7a7e55cf8765443ea768467f0b395cca91a0377bafd21ab2eb207b21c34f16a5079dc0e81cd8d78973d8c468e3bb7af2161693bfb12d4db310f29d06056733cffd5d45f9e58e56bbda5b6a2442967fadee285290bc95e280d37e0ebd9ddcb55f028ac8ac1ac741741176e86dc402daf31f5d0e066210e95d24337032db87b85fd6b9113a7b0b21c17df43e0f865bf58e3f57138e30b1629a6c6ec006c712c2824101b444dcea056be2a1e5f2ef0a9dd38db6fe85176f71feb0ca80877661fce5039491b0ba6405b0ff06040642dd8a2e996741cdd4cf125b7a59ca9711a0116dcd071893f9794de1b56fe14a3e88581a20f4c7bd94b22992516c95416fb38474df68b8719874329a9cc670994d446c1918f5ca554999b2971cfc3a70a5a4457b46c0b3081e12eeea4edbea2a66eded2f580a62c44c5ab5505e39b0a73bbae941ef1713e33ef141d5eb4e4ee44fb602d4e09faef193940f9e2be2821e9a7f04d7879d2bc2fc068cfb24632426fafaed5c15bdbf4a2de7c2b89f80eca3c43863a90b3583ada36fb0a418eb36b09305effa12738fb92c62b4c1e1c5a2f9c50f3134ef7fdd9b6396450e9757094a63153676dfc24c28fcfed6264fbc54e5886cdb204c7f2e355eb64c8c2ac01fe318271976e44d5a9591fb6314235db82d0e22042dbc09ca1dba950641bb8086430f0c072b4785492a38ae35a35b1de42b5da0127a6e03ed6a1cd7f6d3ab26eaf6f3ede6ff1ace47b4038de13c9b1f1d34c1999cc6e9fb8760cf761faa9c22aee9d05338f5584b09fc8fd59b642f8bac08991753bfcde4fef4ee288ad570a1bd506284328d4060a632ae39a2b8e5a5f13394cb97d972c526a471bc15944b547ae91e53ee80d8b7179220f07fb618e8afc55ee732ff4ab72da257e67488c580af87a5c61bbe9d6d7dce89e5d262ac1af0808f94a7a24b27d189b6a655e21d76edaf448d5616a5ee018b634ba9737d2c8bd1c8437b40674ae8f9f4fc250e3cc2addfe70c3cc070fec0f201c9b53daa9102937d14303e7b984c81765aa78592740af3bf310ec55245f84cf0784a060222b006a6a8f5db35095225c0f64c6b47c7c3970c2304156338bf706f04bfa3d6d3c27a3f9665080b8edc9df4533d06b48f931af174275d69ee6b9bbba23fd5e243a1c264adbe9c5797730f11a74b677c262ec230f42ea44c856d1fb5064c02c09645a0b7dffdb039f67b345d6961e259535f367719d0bfe50026dbbe88d8f4a38ada6e7c86c116bf3aec27a37bce8d10d80e943f5e4c28da19d9d1676485381108107521450b00d1e2cc19a0827d08e0e6e3e1d3ca1145a308650b97983a4a8ef4668147690f022d8cd8cd6df433638a09539bc1e257818a0dfc51c657af931d39d5813db20cc5b49a705270e0556150744a25a418de6c0b6683b17b17d2a51d01f1d00ce67f5fa79a04fcb20b1adf2186e9f187190caff11003aa137773ff32d5604e137023aeca82390068c983c9bbdbbab5969e295b98e53d5fd6e3014bf5bc33c394f4a0944bbf63912850984d233de14fe5bd9acb50a154402251e43a2db82897b32f763d25688279ad55c43a8948b5c13c3ad7d8404d2a432fba9b6fe1d0ceccd81116e7d218fae143018b76dcb633677dc7ab76ce3cf36e9305c5d37874da2a3b5907a486ddc98a064a996b091488d3c1cbf11c3588d4858256d98953b4d70097002f4e4d420947bda303269b5300bc86de0961927f0198c3e85feb3e4e6174548da9863b9bf1c34d064da091fafb2a7afa5743e6d8c9f2e3d8ecb7f45a3ce2bd5eefec9ff0e152b255b8e5f5b497c632d33f61ff877448d72f0428460db03f51719da42329d33b2e91add9cad37da19cf26d52700488b8d281ef42719f8caf2cea74b37a4536fc71e64cbe2549e7d90ef84ec269149662c4b0fcd497cc7adfe780137beb875e4fc4ee0e7e5635c7b60612b97de0de28b30e5e42d397c68ce7a6e249d5be7d436bcf5b7a451a398b53582d7cbe57fc5f513fa60228111eb5114cff55c4dc15c20e589811b817252c3f133375d88f01f488e265229de670cfa7fa3f035565dbc43f0f6df3fdd180855bd469babc36ccc8b4aa30479275f171985f12073eb00474a1a16d4bb808ed78236e633d5aadad988e6d6cea8083884c25dcf733c0c6fe45d62063bc0faac3b1490a5ef7a17e13cd255df849a903296030ce82545c6f1ddd5c62f70f899436246484e99e645ea71efaee68f362715b14e946a5250e5993ca1313ea2a95b1211a5422ed35ecceedbc564fc5b7e99a929e5f853941af057737896fb0b3573b30df061d48cafc6806b1b78194380f96d389bbd39a565ad69a74ef77e8ab194f9bb2a740fe5d481b43f413ae3f01a12cc60c2e53b817463bb1504b9c5441d950d0783f9aab55685219254416efc2141bd642a6d610129178f69ceb76297f65a3429ab8563ed5d417aaf39abbd3464fe141c3cf1d777d3540ab8e8746c052431322890bc5661a44f367561464c4dfd9d8130faf39e24824de24c54f3be37a3374e4781466d7d441a8594c8aaddecf3040fae717a6b89557d0655bef6161a3040df28a794168cdd0f637dd4436f2a8384350e3a51eba56c7f1f6fa0bccf0a82ff8e1987c1335f3a70eda2439df6be5e0a4e775cca07f7e18a2f5018dbd544a04cf745661d37c200dde04aeb026dd55c0f59ca5fdabd16cd69105760486b3b183f79c3e8613a9883d7c9b885dceb3b7df52b44353728cba26166047f5ad38468a01106ded6ac4691a97327def2dbce9fb6c038e407c2d021610f9a21488d2925b749a225c17e6c820a823443d2aa811a3a549c910581895386bedb26f2c0791d2e4bf30a1be9ae63f888fc29ccaab96eefc2c15c985397618c3a1ce74025e1fd4fd1d69b060732d82c19934129db60e7b189f815082f9ca3d01f4c418970e2378c819e772cd4d1aafa6f1db4018e30b15888490ab60d4cf3b8e746cad62082c455ddba7b7fc2f2bec79988a918f3830db656e91a589df148a42a019e9bf2634cf1de62d324e974226351a9beaa5cbf503e92567b39310741837f239fffc275b031f7d85918e124c084239cf4a404aa47e9ca619708683899a8b2e469169b66c848a65e162c0599dc074a26fa99095bbda73265c6187e400afd94d8d9a6791aaeabcaab10756f55faa1ecab08ff35180d56cb0c7d9f961b706432aa068d3ac00232c5c9f2311aef201a40bfaf6db7ed99cae17fe6838f314c46b2cd448440777e13fb0534f03c47aa1d3a96fc98f8c316a6a411c6a958e25c11deff5c18737313f2295faccf78a33346e8d5c1bb573ae82ec47e16ebcb12898c8c09837c0b45007986d4fdaec92fac7e2a05ced2f4e0135387513664af7712ea8c2dc50d650dd14f41b2fe5425b49249059178f29a52062260b7c575e2ef28b3b03298bb2daaee0163e1acb7a522cdd8298b8ced1759a20f7605fb3e16d54db62d6f2054085c9522b4a0fe61e3b67fcb87ccfd88031aa02c4b05fc75fe2cdb840a2f1c713ef0ee6f40592f37a0967e133d76de6027a994881d86dec02c3d2aad06dc02d3d351c5d2e9424a111b9c5e4cac674bb91db32d225c5a61a1acc0897a345889bb8452d26054559562ec95bb79a25abee19757004c225f3d24d84600149295c054ee0933c51c3dade36825b158cb34bb7dca30bca5b49e9ba9d474addeffa91669d5678a317e2af45d561eb56bf3dcb0dcbc7aee43b6238cd28aca165e38e17b50f3b035cfdce5fc3a97300608131ed5d0893cd902db9704ceee9d72e815bf71ec6faee538ad07b0cb887f7c4114137643d5df23a6e4e18301ef7c9655560d9373c7f59f7d9a6519367107ed3f68254945f62bdea72f1d6135cfa46481298ea2c5a381b5c192faca6afb4c9173e3c1f70418531e82091815a07fc631249c5f1de63e776d5847fb4d02130f8d92bd3446ec999859402b4b0aacdf0c558688a7b5395c6123271a13bf733580a5e923ddfabc3528cc58aecd3f8898eb8942b47809010f37da4fc38c7923ee362ea3a5a1a364ccb431d79c81ce871a6d5ed52f329b39d7a99393d10b6ed8cde06302b13082603c7b8878aa6d391de8d464578a33d1fbb5dbc613c00ed829fe79fb2e5b376045809821545f199adca4d1dbf2e12c5cf27059267503f98d470a964a0b8ad2e8e6cfd3da6a523cb1c060a43c844b1143819d9f385059316f8f086cb44fcb14260e7aa9b2d917cf79f09a44e15a485fe97e37fa926fe1ce0c9091fa91e39ff03ea726f35eb3833997d1a9bb7cf358692509b19c4e37e57ab38e4e6bd5e76cdb512aae3c7c107adef76bf786ffdc826c30af3f766772016e8694aeee2fd55875195452a3d94c12cb70feea7a32f6945ec081251e9a71dbd20626caaac30d80c037d04818448b1076a6989e5fad00d710e88b33ab10127cf0f14f84105dc853c560aac7f34496133df7e71d96c901c906547edc3da99e03c4330762e118d3313e09ac5d59207447a821ed064c3d4831b730b90b4a91778227afb8bd32eb7b61fb6911fa367e14a561f482fada6ba8ed495adf41dc0964f00ad5c0276c20c590a2cf54fe4b39a224cd2dff5176254bcfb3dd72620db358779f8655150666222ae3a873a88805bff1d1c8fe457afdc23dd2e1cf50da97e34c66507edd99d1753a0650093c36e2e312ee5cec279d83d195f7d9d967c60a99c5f42d4fa63470a4cecf778c56fe3e275dd95aaac1a16c4144c6146a3c131c79c1f08ef87ec5c65375d6892238f6e3a9b8d8e5ec544adfa95a251837b1382082c172878d34e3d8514c6895808420dced09ad3d461b35e9d4b19117cfd36014ddd433cb1cea0fbe570acb02bd0224ff138fbb2cd39bf97c4fe6e5fb0caf2bad5374144efb92d2999bd61887b114a7d4b78641780a8eca944ed468f43d80f2de08413c53a93df7de622b4e0ff0317ad8f62b4f491cfd809fb547223b6b3bb7444dd0fc3152f6a325c92e46c06d4cc3c77d6d877073a0289bacc1c4384d13afea8298d63bf50443135ccc2022372bfa30419012b6e8a9444f04616088db7971ce224095de20192b11b3be429ef04cd14ac586b317372da2f274435beb7dd9c92bceff419f6b9fac6e8f6a74d3ffb71c56f33b1a5b51db465fbb2679550f7e1346138a611d2e9a249abf0b10220a0b9c46e4edc04629c28d89de4c120b29111f596eee0be064e14cfeb97f87219fe9520d01ba4620c165417c7bfa9d9905c3a60238debf138eb856c612e3e29e89b72ae3f8226f34c1fc405d4aa5f091fdaeac484cc0031f49f225ddfe29bbded963ea5f0594a1ccb2779a7f00595f3ef5061e9a3198902e5ee33f796ac4500ad89778c329c93df18f9f85896bb7f2c0732978672829408efc96a9f564c9f89b2b3e58835a212d5639f90014887783f7c958215fe9f039111ff2297a185ef6ee1cb925ca052e93d4886d736110257d17167bb3cd484be7e9aa291404232162159e92dc4b0aefe4a9d7496741eddb1340025e17c3107025a066d162ec3ab8d3cd317a06957242737ab97ecee142489bdf5b9d14c591a1bfc55caa1a93f919a5bffa96a17906d076457e168cac1e2663b1fb50e7814634536ddf69d9d5e085029c35517e0606932265e32bdd5588fee1233dccc36842022b5d891264b824f1bd870d8f87a4d17c4de552db2c659258ecf6831b314c671cc63ccdbf54f85175022d608c775fefd671d05149e70c5678f050d320c97920a51fa689b231f33deb02ff4e3f11e906dea9b09b064db67edcf4d0e0de7850b2255fe4b10337749e71b1be7efea16b65776bbe6596c854d9b04e2de4c064f55c0dc64b4ce34478fb7d48e8d06f68877b58f8319bd583d12edc59af5de40d4e8a6ac6a47f8f57f0360a089bccfb2f02b4bd3e463833a015ba7cb23c3553b7e211aaac679cb2c07e2248abe330b02cf4f2e11af9b6501ef2bef65317e79f9f57001ca4c0fbd25f5d67b14c257cd087f8cfac9058b8e99dd2847072f5a85609e3d1df708f290a14ed7bf911d112a906d0b225cdef98d9c28a313d03e905cc261c1fca4a56df371b11400f61cb87a6ee53bc03d4f7b864436d52c7a292e572824c06373103d4f2b20186aee8645b5c7f3858a4f4d7d1b2426eb490ee9ad65da30718b47125b624d01332d4013f800434b7bbd79cb0c20a75965189f1989f23c60ff97e2690cfa35b863b0d973ef1a22e854cf8cb8188a13756de095d541aa2b01a4563efaf535893ae7de86ce384de3a26d96b6e7e33684f9011a5bebca951eaf63394c570719f600f03d9fb63a8c1b5bf9cc299b98a7bef0423f0b9ab15d5e3a4443bb2154759635267d97536b8f12178bd3e1bfaf0c6bce95d22c21b3802cf8e0fd3e974fd4eab420d3c069ef0570b3b1a7195b5f06242a1067af05112cc970ab5944ab1cac603be27929bed5661154437ca6c4fc1ea4c2e9930fd9149fb74187970b0a06703eff450cabcfa89c18fa83623c949b4968aa945687c0b25cde5ecb6838a89499cbb07106a56f90a98f3cd2224ec7df4c2a225b0e620ab81351436deaa5d11ca70d3bb0ba939c5ea48fc305e76d8c13bf78576eedf0b281c335add50dfbec64707c2b3d7886603619a2ee2e7828ccb06d212f75e8a846aa919835760760206c2f1bb6135e9e7a4643b8c8be568c7ded18f398f3b91bf0993fc7de8be86cbaa6456543aa8231dd534bb378892d514ac5915f9061ec42a2d0c1d4767cee7c1da0355eded41cc9196646d8151c3842a47e67dd92de6cfa3e3d2c0ca33c7bf32ac52b993e14409963ebc659cac2d7daa14ea8ef0e68b0189b7fc5ed0dfc15b9070875384b684f73a767a773976f7bca6004bf9447a40c64ac347dff3d5d9a772c1f922e118ab0ab88868d001610530fa93694376d9aed762501066843b599dd72c7a8f904b9fda0d352c184243d3de992d3c1028a92cb40d76b326ebcbf2790ffc907bca21388b94607e1a85207af63be14edf5af60d803db6ffc4c149d752fd607aaee6110f59469492b8b6d91dee41ab30d0aa08686cadbf800a8d3569bce1a6b5726c1f8a8d6f9aa09cd9eecef953bad9bb1dd8ef3738cc2a4c6108a6841344202d79a6c1efcc1b2e30c4679272c1ff1447e6b61967ceaec695c8d691778a32187d94e9fdeda886e63acc1096ffb7a7e5d4653724c09744da5a7d0992ca543de8e8bfe240f4b78023d0e8ab28131a95ff28d8412396c16f01584f2dc4ab12b839d50be9b7b928ba3e5b144ffd168d4dc745b1b8e9a2202b6e5bf14bf042f79422c2b7c424eaaca852bfab8f49f29f498a2c8a927cf3259abdb7c35749c9b13fb90cb394b8efc572f419bd2b954037ea3358b9ebb9bb41529f6b2360fa0aec88b15f80c48795a7741249375f7e3d30f7c29e05b1f23ea9a4de990a557b825d9f1f45658f2ec88a1af17b2cacb573d360fd4e8e0b410255243b76e2f8c31fd3b63603c04c7637189804f3ba92c08ab08c2959c1a0a2619e6760d72d97a222adab1540ded716536c6f2e7b82524f231a726fa30d3197a9a58b266768e820862b00149dc122dcd0f287d2b86e5887d0a34e15528d79902a6f1e9a9244f648c33c69928db14170c208149b6b64ab6e9e819761e6b73bc1dc1dd3aa0cc52a85432d012ef6eea354dc46fe34121ca334cea8c74b01d114fca1337b7dd84be811b7117fe49a13b8b8c3acea6d6973838cfa20aabad4488f2b9c2e0369c7768f775a0a0b926a0dd636fc1a17cbd9a022a576c69a125e5ba1a35eae7bc0c62f83b3a57a8c054099750fe2da9070d258a43cfdf28f51ba10853da96672b5b58fc4d6f971bbe25f2de61e73a1a1a6ebd60490366386c0c171ab2e76f85b8becabf2e2bfdf0552e6326141edc8281cec3f6d97a0e4ea8b01b4e72b6996db30dc75cc3da35c0e6857d0509cb48467cdf9baf2146dd53c908e1d2892b68247e3a4f232937c6e0afa4ca8cbf15dce5fd5f5fb0dafad66e5c5c7a30995b8a9ce234dab383661123c735579fb91190efdee0389ca9aad63e8d0ec8aa157148f5d55e7058e19c7d2ae3d5405a9b3860ba5e71e32c48bcdd18c08662733b329788db4258e6c5d67dca89e6bb4f400a6214c4507cdea5b9b10fc3f4c5a82aafe32a5e929781a0ca7586b8cd8933705c3bdef01ac50234549999e1376bd69d51632f8ab879435dc786784604c7c16a71dc44d5b0507cfe1525da94812006643976f41d2f79336ed83228f5d18b576e73a5658c637071aa4f49e6e6c859dfd8cd94f4fe92c6006577efd004d5f5d75cdd02ed98c5d7fa8cfdc4b923f208e4e579135d665b7acef515425a84b65daa3535c7067ef50452f32506722ea11d8f606d93e934535c5ed23e6ef28875e7a3f0e740e61777a497bc73814bf1afdb6cca0da558b4d213ef512cb3e68e947e1cd225881fad83cfd1dc95281eafc72a586e8cb9278d9096b036b63ec417d79900dcaee40983fb952ff2e01f812fae84681c23fd708429bf5e87c75cf37cdeef6e98f20545cf5437e38247a03b1064c6e2a16501af7f24cb0bd7524383b2a1fd31e4dd632558fd13c76c355b3f53db565a9b4a01ec9b5456654278cb0a9aa6898528f212d348b3b9d3dda28c7beda884fc7190af57e16125a55052e521ffd46376206d9ef774578ed374603a93a1c4b60b63055776c3f5f8dd076b183b0955dbcaf9eb8395e5d779da9b85bee827c2fcbaa09365c0b36ac117d8dd49db70743a8bcc6fd22b7144ad7e26b5b23a38603dbf6ec0d26ef327a0d1d32180ef510b54c2b6a17837be797489e1d497e6fe08052494f3b4d299ffdf623207c88c41be98cd11ee6e9aeff49a0cffac272feabf8b144d6bc756349dde954ed6da538e8d214fd7bfb71138c01ab2fa2d9936f0641f87717250d07aeea24a6ae6a05a5598c4dcc6a641c7cd9b17d7f1507e4be80eba6166a001e8f4fe9d17831b6f2a9b1642059be3cc4e017f465ad4ea2c931b9a8ed9529c7ba1119a47b0ce039c3ca2178eab0cb235a53644a9616cc1e5e09f05cec43c023fefe740a96db87dc01312d606b814f756f972da2395f102717163f44a6fe0fda32cae7166cc469a3ea2024d28f0e724dac5434735db1a27095e5fcbbbe081a0d236f51e7a3a1679129dfa66a7f7519760d6a3110b961e97a459ac302ae2ae25d6e9ef1b4b9d905ad210f54731cd60d5d409b95e2b763c940fa9003f35df952f0cca9f9f3c15cd39b09bf929e410e45bd067d783cb5aa4eb578f0700af40912cc5429e5502ff0371acedd2b071058ae5e20cab59408a569e4c6870f774262ca94c95c65f5dea562eb5db538bcaf57a4a998953a35f59420f43231d0aaf187d43d31f9970a6f273fc4426ad4ff762aa1d1b82ad53e78b2a4bf2a81729a329b35fd038c77332439678f77adcc9ce1c2225e915e39214fd6c9aee3d43bb2fe901da563d1ad4fadc63641d4d202f5b6fd9b5586d0e3fde90d06691f3014dade6110f3ca641ef591ba60a7d1d6cd7fdf10747eb4296fcc34f08e12ecec67e10cce3828f4cfe4767f6e50fb5ec008fb2b22a5da315b6198de5d359aba01b11a0b3f2de368d7408e4823a368eee6ca2adc02d9a401dc313a1f4d62976d4af3bbc47770553957331837d028a7ba66a0245e7c2eabeea50333bf0247eddaec7a39e8b1b1161968ab1223a2589723beea43d48d967d3f58ffeb810d3395ec9ef2cdbc8f271e47203879b5692182c48ad68f5fc748cacb943d8b0778b15b52666d455e895e4bf6fd3a01ddabaccc99d1bdc6fd0b2d46b87e8767d82c5613a4570077246d87d84d6ca15b601d4968d41b3b91477fe010f75924280c9a63103e46a983e0db53dde895b8688502a340c770aa28909ca0b98f05f1d279b4bbee6d3a324948a61acbb7e5e77047dde20bffbe9d23643bf315104e7c25a01468087a8b23d4f23a94a5a8bc1b02ae4719436a1caec1d7a0251cbda04dfbebf9e59552fb6d9a138dcb893e9edd22b51c2f5ec2ab2980af469bb55c75119af5845513641c07fb7b2cdb26608d13ab95def571cab19c1c74602f0fed076915fc03bb5ddfc1cba762baa014c569b61a11aa8c18ed4241c42ed024e9a86bb29b3726680e44054025c384d065622c16270abd8835225efc45888e03e10d59542b478dc75c04bb98b2b9a35b776e2e9f9b9583aefb1fc45149a81b725936da25a5523ff74c65892a6cf81edb84080f1e47fa2f67303297174c94b4062a5ceac3616e033066da85eac456112c59522fc89427637732af974504582fe38f758fc549ab1e7499818c22378157ac878add783b6499dc0158498a719ea6afb77b21ba077f35f962934d03bcd18eb1088d488b2de34237211d43703d04d00bd256408d8a353a1713921f0314b839c2b7b018585baeb6292adee29f2bf5e25d1f31e40ed8e5cbdff9e6509957ae6c62a0d98e4a418e84abc400ad4c7e94f59b9af049d802576b50337c1d6945bc9f50fa48766096289addbfeacd1c7a10ce8b10fb77be41f416d4e5cd578291e145140e16638bf3d0d70d35c5edb13fd1b6005ae8883fd25cb4dc1a232b164c38d91afc4d72394d424d99e285d6965cf21d4bde91bda86ce05e80ebec117bbbec2ec3de2ce7bf0e1ca4f239c53b3970862f4d8df862f975da59c3c998001bc02e5c08a0053d7194fb7668b706ec09d77749c932398491e098d5eaba2398d500f537cfe697f1c1659537a025a8ff4cbdfdf1b8a5cc51876f5915816701f53e04027b812628e7f2ede2791ba7ee7534e74e6c6b34f5fd0191e5082a8e0284c57f1fc6c1b70b9db817f7d69cfa32afe8e182bf09a7e6429279f9ca876b69a66e1e1b3f2154ddc89ca16a05ebef37d7ec2957735119c439cb041429c173c2090673a5b4d83eadea221ab980f3db6d252328f264aa43142a876425ed58604306a391b01e5bc6bc298c08dd76b8db63724567e87f1d17fce070dc425ebbfc4636610785886618d343c5af5742b611cee67d4dc4f251e291831578024286c36b4160f9fa20e74b09741dca9ae22d68ce1c67f04c19fdf8c6447fba339a60bd6449cfb236f3e30964660b7aa7530a56c82be5b070ad1f6dbee6ed2338fb3c5e69d1b6e640111d66bb279b71426d759e8a5d695ef4460274de42ef899d5b94b9335fc72da05ad45537796bd8963f7fa481a9ca02c573987d7eef228d1a17d3615670acd89239417fd98971575c80438ebe0c8ecdc3c987a0b429470be321fa0ea7c5037f275e0e875d804b316e2986b76d29015cf65054b64368097eb1676a3df4209f5291e4bf96b75caaa3b01e4777251c615ba4e606c09b4fe898527a9b6e92a8928e08bd9c223fbbd5ed8bf2f759c48ec120ff3179b07a237b8d8597264cc845ec8c4f4a75798319061b84840e110d8d3a10bec18ec118c4039e1308955a37289b519c364bb0844bcc9261b45b6f888004993c350d36fbb9dc8664f0a09aaecd5a83ae802944306265a97fdd183462e5019d3f41d0d5a493542869c9b0c1f07dfc10b10fc10e0cb26f69e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
