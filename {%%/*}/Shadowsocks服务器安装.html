<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b77f5662b75c9085cc1fe03ef536cd51c7f51623755a291dc8eba1c82d7dfdce3b1a4e44f9318fec5314b36f29a426e122ae3d03f0e669ae9e8049d8817992d6d2ae83fabe92bc431c778a3ad6d1c4501542b204a37643dd2dcd02c24baeb0716e9ca3f521e857d25135aa24f5a1e1370607fca38c1296f7fc9514c1e01f65c9bdc823bd4092a72a1fe45b82cf88f1d5223f1234cb495c6581b51e1ad276b3b41b4436c7ca8f63d95d319a1e6d212dce762d731f6d5cd9bd98c5105b7c6dfad99d949ab80749475f99a8e9cc6a5b52e8bfac5a9fb651a6a179a608e869a58a53d8baa40898d98e6efa85846eea99f5887e6d0c1e99fe47fe57537e4326a2acdaee1110e3b6d4ca863db80e8f35a42598717da14ac1b8b36f908e69828949d72462a6226fa531e837c47004cb12b77bb6c85ec7e8a60b4e82329396c9f366df8d31a60fc0f5cef49865d023e60a0a5886a128da54fce079343a7ae7796796197df1531708df5e7dc02149d425e13d55509a95d80436f2b83140528a9cb196ee16b6cc86db0b78ff2ed8996659f4ee2c4919187c9008331abd392021dddad3f3a82aaa86f2594683df882ee83033b6fd9a9ea622bf6727120d43b1676dbb81b71ff1bd9d30f6f4b1f750a7c596ff17d489b4e620c0abf950ca125a99543083a6c4706c4a96b562f8fa97ec4ced36a0f0046b2d00b400e110d88d30e28132a9f0683e78f25fab9b37bd9ce9da61b2b3c84f5540ae6d482a65dd366922d05ecb2bb1b54903a2a4b24068fe0e50529b8ff8ee047aa3231e28e09a3a8cb624ea9342062193abb2e3853d9de98dc53b703f67d1482ac8ffa3a417b42553b031be7a99b7b8f2ad357bae6c5bdc54e75450a1cbb8717c3af292ea80f7db605a039a4aefd8cfef527bae93b9ed61e8a420c7f2c27a781c280ba59cceb1242d6dae59ce8618cfd16d1e009734c1fc1f3ad7b4278e3ca5ef4feb3f40bc94ae8d753dea2dbe9d79ea28a1f4853a59efa58eab1c0f6b5d1451fa22fc8b4c6372b68acd142ee57dde9e420dccb397e7391a67e5ffeb2f596854ba3891cda5afffd9b128e568efcbf1578aa7f5e9fdc80dedd6a081bc668123d2d0dd7bcd5c5a8e12b35974d83797e691c99a99084910ecc373da07706277b0dd702fcef899090907f316b6af5063d81146e7a0c1d3e46347170fe0967e95ca0ec47b68526fc98e2b5377eceefd3138d761a33ea2508c42dd5b646795106284b4e2f1d383abd8a0141d41bafd5e7f7d9685f3e3031cd403998ec758b69f9cee7dfb374526b701fc173619165b5ae554f56c00fb66c5bdc75a095181ff216c307bdc053cb27f0749a64f5ad005a75d35022ded9dcadf3ea6a407907bafe72ac1ceb9eb763e38ceb8e3a60c6c56a50718ec351803675dda10d1b899580527d49eaf386eab79585f359d673dadf4843ac71d0a2ded6601aac4fdb8d044550af66b8478c8d7aac1e469afd9e8e4f5e961e76af598037e65821561af7f9051293024387d022d53b3c19a14d9e0ed8bed908824024f248316a88133cf225e3f3ecfe243b140997a3ffc05b64cdca11876edb3b4f0a827758e614378d45a4b605c71f3450573a01a8835249878f1d04ec3d7f0125e0bd1d58d4adccae2cfb4826f5e0e85ac15b0f9113e0a66a87d17f420596c7a39186201f5db656bc104872dfe31446e83bd3c7b8ddaa8cc98e608429c047efdaab2bfc21202c27dde9ffe59d24b7c1c4e35472f2c259435c1ccc82430020a01c3f051f282104d49fffc4c9dc3555ab5be112fb0eeec811e4a044c2a4be3d1e0dadb48baab040a80b616a300692c04db384f311978f8b71ec2c09a6e8a2ef647a7e6d64b43754c7e9ae1ab6b10f7cea9ab658438e0ef9a0a43b03a30c8654a7c387fe466fe749e5f5e3eb812788b30499876c23074f11f01b0f2e8ed75eb417812633cd5ec766ac17a337b1ff94dc598e8b4479e2154fbe478dce09a2365650cbb1d05204028e92075f09ae011579a1fd2e09866b3ddfb8db409f8b7515ab6af0ae2a3e5ba6817d2a78973b594d044dad9101bbffc3890aea72b5877d81c5c36ebf363b3b598ec6b38a9c8314720ebc5e37812b365ea7ed55ad40eb2699fb7e60f23e20383c5cf2a99fd1265681f7b9039fae8c31b5ae1233ad372a576b70cea30b60f6d8943b970cb856a5e077002948c56c987f67b0ae52c25d380d2e12130342f3dfaba21fc45d04664bbe9d961fc0632d71f6ebde5499a1d39893178aa4c0ad29191a6953992775a148da2a5c18961c16c24dc8e79fd903b0288429abe08cf67058f727c0d56414c78a4876fe056bee1b600eb1307f0ebd26ab6e9973b9cb8198f6f35ceb0b4f02a65a9868df6c58d6f1ed131156d51f3a79f3bfa785de29318feb89efd09958e69013e46a72bc3edf0d38fed875cd4213d4d47dd81934dc035d6430b9aede13eb690f67c3c0c2b659a2a74fa8854d14005c422ba3421fd28f3229a75008818ae5f5512d2790dd5eacde0685b21419be8c0791b0e888daf44c048a86acb9fe27a51635bd76c19566d8720f94cdccc47066f169ca187069baa4b832c48c1e4d5ffdca76b00e228f60c85312724e866ad9d28ee4badf6a4b5d41e4bb463ecf88a0b72be2151eee3ac41dad986d8c3f7169f30f91df2bdc9bf6d9e59f2aa4007ca3256137645072e42255797e959dd314b317dafd6a5cc3256a56e86be5c489064fbf6141df5ec6f77e36655b8c8844b00fa8ea7763fb092376981ba8553d99e5e7520120bbe24f71270d152e0778b7971b0a2edea41d22e0b343387029aca42987727725aaa710d02577800e53f5484a4f61cc736175c6ace6efcc45cc7413251e55958da7f44ee40fcf22739f34573d4f03b3bda2a678619822002aee70f091f6fdd9a73e58fb36fa56d3b11b946e32dd1c709be3296142c9beb935dcfffacb824660dadfecfc4f1ace15a90d11ae7ccd64d1494d6019803d99c4f7c8fef86919837093572943237cb7eede2fe6f53ab46695bc1d5512bad54a307f4626345a78c1e3ec240048e1b7a36deb0d49753e8e0ffde0e885cd6349117f44b5f7ea495a4a73a4a2ee4c283bab6380dc0ed4332e6e37e244545508cc5d21b02a3161c99dd46842b9b833eab601f64ee87673d53a7a6a2b2e3c243aa0ec2274138a468d09bf926baa07a6b24b7c8b8f6bac42d6a2e6a6676514ef6ea45acb4d46c697d092899ae90416def8857b50987da24ab2156ed0fecd1652f26399cc5423e0ab8967d6405bdd5c565a1bcaaf1f44d5122d87cb19d1a0cab7353eadbacbbb18e05261dde6453d9c1d152f4730a565d9b80e00d3e93b95317127a358e7b5575f70b54f8fd7e36a191c48c0b8be6206f19e56556a4552b131519ceb9d25105237b6d0adbec8b6c521d6b0d561a1c05aae2e486e9bba5cf73ea229b75785dfe4fd1a76791eb6c569e720878457d2dcc72ff2aac35430efc12cd510f2cf83f4456310d3fe2d57efdd06b98704b66abff1dffc393bfe3cbb54767426da2f08a1189fc73f706cdaa15be1c3531139712083aa1bab1a3cb668fa8bb9dbc115d661b35c9be0c7ec2d40a4680d952fb4c9f972c89cfedbb974cb1d492d9ef16b4da6f490b2764a5efbaee851fe3d818955be903d756d707d6cbeb06c60256e96221f72da35418238d1d8700fc7a6826511df1ed7c38df0fe9e482fb26b12a7ad89bb2056b269cb5b72c2eda82513851ed41650442cd1b19e6a4e46fcafc1392b2a1726c1a045cd794f1ff260633de379bed6f8e89d10641e7ab8bd82fe20eae6962869290152e06c6f1fdc51d5d4c04708af06f5d84d427d8419362cfe65f5546814f502189a436b52427d1eaa84ed78eb288f791c2f8e06e23e190ac097721df0acc27ef47e43c766ed74574626afe7852e65d0237261860f2930d84e4a9c36a31af466adce10d0dec869be65990a4f2ed6fa6e15701d51ef24e4ac919aa54808f279b2f0a8e6ed4c713097d138961c709bc383fe3d00aef1d8f474fe63e85f59d927f515acb9494c93ba8d4f6400d75310cb9b162c563b5a97f31fa701a2b3e253cf0b761cc1e3a3849776191e10f6610fd259408abb26b9c2693e716a1577cc724af9d57ec3284acdb37aaf5b80b5a50990601c099bab803a1800d2c999a5f7863d34bc06612257412ecb4b2dc65af2faf8958e35f9dc9586f8452a4ad1aee55253224faeed3351874224dcd6ece90ea1b938d21190e3006ba44fe124a69b7dc9c56c2ba59f49c31e9a46381c7b73ab21a9e8b0c7941b09307105173e0a68484ede94f2b4ceca98c9455af429bbcd7d5a50a0d931a4fbdfb7416d0f203e5e8949aad77bde5a16780186e68825a519976431c1de68ed1280445163527c77ab05f9bb9afce6061fb1d70e11faf7fc128d43f6f1c79936638e5ae1df409851ad5f131a83e865e568b75b1c993242ecf6068852290660f94cad1b566ee9af28acc82f99f9462c155060a9002f4403635f15badfa0d642389d381ee45f9fd6b526702055fdd6706cc06c281203291f7d17218945d67270db86873c3271da45817fd73e63726e43ed51b465b63c300d9250a15e3d53f02b551278e2f59b65101529c869279465c0227f04e139823f91619a881df74e949d03df6c4e502781673bb2591eecfc16dde2df6e40fea0c21fd4f610ed9907cc251b71f0728f7806ec3201f7f4fa41019859df0aff6fe18ad4fdad3fcfa86eb9c4fb19a3ab5fbfc659aa3e82a8923b01808b2592137f6cb6ec90623780497f92b46f6e73ee8f581753e5b7fdab09e28b40604a8614c399d2d48583124dac09b37aa4a787bcc38d533cc34125e185a912b18f13aeb8ad455a068a6d17898715361336202e3ccb12efc0f2d05f4ac6a567df6b9096e05b4f8e592ab6c8f6171a9ce468b3f8c268c9e558938eafe1845a9f4b6f489caebe0551104963c6762e59a1c535dae9619d64c13084e829c2db91d5e94dde9f814384c18f546be8fc3834c560451c963753e09df867329d914d905f39661d84319bc6c7732bb5ec5f93c760772e9cd03b0bdc4390f7f84f4bb06e20eaa3ecd12e1cdca86ab6af4ee9546032d6bf011a016c573401ce1d0acd293a70335e2ea868a66c6797f612d255ec33a7cdd3c6693fae9982b184b44949308b2e37e56ef6262cc91d789c71f6e54c84ad95014107342a4dea8ae8bef532d1f5de0e31856104f5c859c1b2aa44b4dde999332896f2a01d5d053caf196dafd7bc98fa0e4f5744c5aee77afd4be2c8e3df49fa0c17ed4c0e58a2eb59ec0273e5b84af4d0eca06163c92a694d683e0f17f57b6f2015bf2a7c58660111dcd4c15e1c6cabdc588402262347fa063a60ad131e284ddbaed991b8341cca4537a04046a735595c8afd0cf506d9bff9a03c84d90741c770bbb77eb099979adf6ef81bb297adb48ee21f631ab2549495fa106d7ae8ec37fadc0fac4ae3eaf801abedaed789af569805bd049004c51acac00f587f3e9b5220c5c91c05781524bcf2c820e80d297319c1b5602e13aefde65dca8e47d0dd1dbbd0111c34dc62c81b8f8d760a5a348314e73b75ec08e318d1470d567e05a883c65d2b5c29a7a8bb16341825b32181ea3e75120187f2cfa3858edfa1aed14b46b0ed0b1ab8d95bc78ecfe9132c0758c756890d92ca57c89d5181292b70b09dde504733547d685d12de01e3a0d88dbae62abf3d2cf65e5d868f19883cb0b4e614f3c91d02724788d736f8b38baa473ec7587a527da46ad6f2669446c3557bcbed3b27d9475f23482dd2e40df6da58b8925ff2e68674a032c67af349918ae7d3d761dcff4a4c907c9e8c471a93ab47ec03cd8d32a2236fb0a66337d9a47554f171d78d90144943bd4d03cb9852732f997abcbb0a517f8ea3205a77188b14af039517b2d98b4bc91cd762c371807ba13d173736337566fea6ef5840b8c3deb6f6c99d979045ea54db3d83ae9ae2c167c601787f74d7e20c22fe8b37cf407e9e1e7faa5461895e3b2eb1d17ee8ff8e65211f4820661ad48ea4b436689433c56bb6133aeb39f6c23a3730799ffc96baf389010b3483472f004dde1b650384efad6ab0c60e34c621ebfcddbe79ee86af429876f787f21d384de192b2115f17ace42d0a00638bcf1237b5acf63123275c5294c357eb6d2999c5e7e4661051f6678e14c817209286a92885c77c691a3def20e7e0b69034585db46ee7fd57a5cb6c87b6e62b6831c477142a060a6cbc198d7507c46975534b04030d0d30676e623be35fcbccbf8ea95d62e5ffc06766a6b18376a4d026b3a63477201f74b903252c54b29c42f1452ebf4f7530b956c589ee132b3bed80b629694439a912ea88393b91cd0c9a7a874b54d6b4231d429d3ea1d6bff044ac2eae9b703dd138604a3b964df93af81ba788db230c037a63b9cd4b4ae18565d4c9cb2d0fe9c660fc5c7dc47cb48cfb3e645e465d521e3da61e600f06a192c226aae024dae05c8b632e6e8b34dc9d3c3ccd463f0333904cb245df282adb14a361d195e3e518fc099b2a7102c1865477dc724659205b98a3adb3cf6a046b620c98f829c3aea934f3f337f050428530c692d95395e60df2d1d05ce2999413da017f195eeac4b56e3ea7a68185d299ed96d5c3e2679c35ac7afe5180e845323503844fe2f77d7df6c4f8434d19df0225e96d77f51d6fad6f30033b85bb3bced5da6c8fa7b3079eacc85672d446f52df07eb665f80614d3c06fe5152c6a529458f9ca682e194169be0c0a6246831a5f39991ea46f972f16c8135aa2b46efb61a4f53e937e3478d8d79cd4cc45dc16d570d535a8c7c38e1601799a456f925faf6badc1bd34efc0336881f35c35415ea597fc345f787dc10a4914df2f4f33f6af001eca27184c281db6cae78f7b17dcd3fee86df03dfe61c7263a8eaa2245bc41378e81d816813dc4b90ca28a7d0b436d2344ea1c1ab49916e21d27ef830bb0ece9d1af2dc30e01c045e0267f3c99d09cc1e6c969286670ff521e38ca60c0c3265d883f105910669e61dfdfdf7ce621e21f67c73bbc5628e5ba71a21a24d62e017e13d6ea3cfc898cbeb4e3d0ff6edeed8aaf465688ae5efb57243748ad328d8e6eea164f9ad9195c32d273367fb3019e7e48b524c2c22e2ab455127fa737ef2032ef2671d2cee3339dee33d83bdc72966cb404793325ada84ba4237b86976713df21f16df91bf9e10113d8e4cda0caf32b349e612589e5f6e2eb456da085228ef9b7fdf5da3173be0266f296be6a684d1a1198f601d4f90617e6dec024216485acf1576cbd7b4b6a0e6f2ef9e14bf042f8162750e1026878e3f3d345a0039d6325867cc46740871466c4e2d4483d17ab1efe08c4e2c0e52d2b9c6861045c25d41bebdc469a917240a91add00d9e2aa794d1014f09458d07f4ff0c96fc1d9bf4f7bff0ce21aa7ecbc1b6a56e403fa563bd2962a7c5038a1dbd53e333008470c916cd1de3ba248e57e5accd30d1eb947bbbfa6c1f299e282cb63e0aa2e0f523ada0809a5a20425188dced986f4d77024e9a707f04130a7dbf4486fe1ea99500d1fd155b27bee2058803ac4c8aa5f98a65d1ec4fe0b4958828baac664231932bdac3d51e4aad111e32957f6762273b129ff7c87fb42ebf33c709196f5bace9b42b8b3e06d1d3abd3d65716fa3b180bf3e207feb7785224eddb50c67b3dd33ce6c825b7456d5d2ea225ae05870a891b0cdc0651024a3d3aa18376a3720f3d0f01a090313e2fb62253b3ca5a2e39c0519cb62769b37d22508eca1921b27078e6bc9c8f0dfee3ca3e694953b1b1da8781f6ff44d519a18c5aa192885de838b56ace26a2fbaecf24e6567dcbf629539550f87245b6d3628f20e761862399b806af4796336a6548dacbc2610a9be2704a8f162863c8fd5bbd30e8d13282f874a0d55238463f3b66698e375478d8c868111d64833623ce715b015ea7889080bcfeeda94fa33ea583947f61a80616d747549abf4b601dab97fcfbef194d5954872cbfdb660577447355b1cb543437c112a02d52121f0712c881158765050ca4bb96205f906ae515d269dc03ea40a059cf5056bcfaff1c1930ff5a17199d2099246a579a9a8b3b2457116be0b0b6939291d4dbc885543fc356824012b82e8b87022271b0c8bef7d0c8742b79d7a36fc8502c7f2f19a50f39d60cd06dd01a83d51ce0f34fbbc0a7ce72d0a3cb98afe3a38d677d4698bf3f6fba7bd620b584b06ef8ae946d94d7d1dfe8430c3540f8fa04054e5621637e80f063e50ecd743023e7f38e788c5bffc93404270d4b447051752f7d46628186656eb49d30c035ae2d6c22b42cb5af333caa0eb02d6ff6b27d0fe4f46aef2b12b043e1b1e403a3d91859a8d77d8dc870efcaa8bd0ef6ec3ffada74d8a3a58b5977211ffefb317482dfde9dfbf6e9c48a2a02268b1fd09c3dd9e5bbc754b6eb369f431edb7c99ade90c87dcab53d9cc7047c0829921a25ad07a4ea75e378c1e4c4c97d4a4ae8ce5cc76bfce54f43e3a1550cb6207dcbb7ea815347ea6c0174f46f015c68c7d71f3492568742f56ade104148650ec58c54c840dbac2e7d275122e9460be0ed058b9631d4799535a462305d19cf7fb01b918","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
