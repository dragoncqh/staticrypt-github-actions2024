<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fc01865e9e6505ff94339bc10415129f389e8ff4895fb507bee562c2ec249aac139b058d29ffbae5307e67941142340d583995e08f9a7fc347ce8c33b55126df91e5ebbc83bd06df4c7997d7ee65ac36b2ccb50f7684a4ce6320447d70c1da0072613a4dcbf2ee6eae794a5c1990e3b897ec2855ccb5eb560a4d9598ec6a70fcc6821b09d5ff8fb8cc060ee8b739f295e6d86a8aeb8ef8d0b7503dfec168cb01e681ea191404a45e90ac4e4104250619e4f7c406f1fd4b0b3ec331937b3e2dfeb318622399c5af976a1b2a56a7869927228be03b5613926a03d364d50fb7d672e956899f2df70804d12e44a2a2b2b729c17c4aac14c7ac82fa4b3537e1fea87a33a7b108cc3f2ed39524159857a1461a34fa29e6dac94a5005756f75bb302b9b81c6927faad9af0fee8065e0fe7e18f420685f8ce33064520884747fac10f17684b9e616cecff5e9f7e4a2877cb04f87f5a5d68caa6d11998edaf4a37b5c691aa9fcf8a86dc285f09b85b863880fec4ebdd000342180d238ad0f8913fa74e1249e3ef7abbb4b3950090bd065920e9053369e7b544b0918b15477567be53b125552446b09798f4dff1f29750cb45f14d6b0b11c22211d36c7ac556b5b28d217b03e1a0712813c2b524ba1e99381e40cede25c41bf70a1d575dd80f2b6314ba1e758875eae6bf176e0fed26bd4e8e5395716b6b64aefea5963f6326348d597e5bb96103a372b9d603265628f3597d6d567450a0aff078eb2c768ac60609b190f124f89bab8280ee1cae0863421839f9a59822a035ac9faf40dca509b2446bb8aaead433d874ba8c4ca04fb0dd17236b020b14be310e65365274e187df537731562d62f39b504d28b0ced36b511391d70bca85f62d16dfa51d26b1fb24660030daa2f6bef1889826e398295e87617682be280375b93a2c83aba56c05fa74e767440f67068c5dc5544fe056de319cc1e180fc8c41f407ed29f8b862d1b8d512a3afa3fa6d789a1ed32e38f0cabe5f3491db3bafa5a0b0743e68f58176b70efdb40a181cb162282ba2f21101735172afa6d0a11651706d475a0c9bf1497e76f9c23a9319659c7d6725d38eca38dbc2adfed95de7a23c85af24cc7bb9e9663302906ec95d18ed5906a1154da0b26e54de44812e70540c5bb6699e5d15a6e48f295602b4220f071b7a163e2bb022322abc17826c54b384bdfdf42da74a14c45435e6d2aad4c317d43ad5912101ad02eec52fd0581af15a640dd7273281c6c5f8068cfa0b9668e099d1564ba4da079ef89f9eda0f965fdab2a8a9094e160ad7187a57eff72a7b9960f8b23582870447ae2addd11c6ca6dce520fe9b561cb4f7f3d914010da961e3603ea80cee8ec39634b8332b0aab8d6c517cfdd7e42de411aa294b00670f219450da167d8cc4069f6e49f37af8651cbdf4bc2dd0245873ff222e377bf1c58f12393721d4ddd453f45d91acc2eb4c86fb853a9d1fef033a62fb76bc03d71fbc44dcef40019216f04caeef0ec23e1fd1d47f8440922ddf17efce2ebaa07fe0d1b31fde041c9fee28441a97405f6e53c6bf053f4fbe21f01905a9f7e4367acca9176701020ef7819b625c30586d35ae6f0ebf9d3d3bd44f2e38e26c87c805bb7fd5f1e655534a3e007167f1148190a52a8912b855f9aa255c44297244a4aa2b10364ba58756623b90be703c038411f372d2f96e336556d3db3082031603d3a200bfb620c3dd755a6ea3573d41fbe0c11d9387a60046ec88aa7409dd2c3cea7363c3d6664c7337268ed20080f29e8e5999a9eb382b7bacb5a342e5107a4f7c405c3ef7b922b0529baa447dd961e2609cdf4c83931a2b6e686cfd2e88fb47371f0043a6b16d9ef08f6943a6d694dbdddcc53b1e0a0b5af5502df317f2a378616a22b89f63ed4d18d295b27e99d493febe3d751e8a40e3ed3392add9fb702d71a9f09ef3e5148023a0dbfcd0c382bf837c40082caf68886c76842b1a3dcf8daab74f3e36994cf50d6837216f197eee219b70e69bbfd4cab7870dd41d2d5301542ce01fc508249f91a259630e6402d2ab755624dec60cd89275e5fab996dde67ecfda9f9a1a713bb04f69c0f509f81e37330737bf1e5afd324b89703f24312b7734c2bf24a803604114e3fcc1108bd2dd09325e5038f1f6ce6a2c7faa6bfd19a4f9fb0ee1614308b3d7ea0379dd269e4efe28696bee02faca97ebdb80f19b169a60446fc5a8645c114f56f0c03bfa7f6cbbb60f9859155c1f8bc249b5eaf360ad604b253f741c41dcf88f6e377bd2e67755fd0c7a5986c0e51fcd322c8d2683eef56f2f8ff5038953cd0a5bb439b83381dcc4eb668c3462f34c11881cfd482e70b59229cfb3f67cb3481dfac876fcb06718ba43ae659f4221d9991f9103d6476f75f9dee0b3eacbca4caa4bdee065f985e3f74520e2b253ed4269c19887e52713ac79761fb8b323290aeda792f8598723e4ccbdaf888d984f1c471d973aed765a87807460a16ed4253ca9839394214cde1fd6969849def718acbdabe03b456ba18ebb0d2cedb6af65fd43637046cbd991e178cbf1622b7b3ecbd574e53e39911cf820b16077fdbdb854ecda9606a945b9dec679108e4f26f2feea03026e693911dd9d2375e8af1992c01ecdc8cfb0ffae5d866f005ee0e4dce2e81f5382415f5a086934c484e51cb59617103eff550ea324627e99e204d346fd99eaacb312d0ecb4c4afe92fa0a203234610591c1f864d5b9a693da3c42b04cd80b0af43617093c26117151b5195fe10ba9d64bca2ebbb94abcf81b778d0d4272d4ace51b1876a52cfc9d36809fe848e234fb07e2aca16ee7a1872cfe94e10f901d41cd56e57583de3e7620706e89dc3697f512376c717ec4b789ee30422bdb839259761682a300d3943000b838d8bb65e832088d8d887108af87202560cddf5637b47e12ae3900485186ad86047f4ef64d87c7ec48d1cbc19c48587710ce12b8eb1f3995842fd45385d54f40d8682aa5a45104bf62e87b6b301e06b0ede5deb772ddb926a3b287bb17fdd8295b6e525a4a364ddf5ea3a159c373f231d59d63d904467d6672a2cfe96e63bee5ff2c8f62821da2906a8bfd2024ce4047daa2b16ad8bfe5a47c4160f3bf83ac203365ff95b7f6b53a2d93300b80b92d2d293ba8b8680167799e3e70edb1281d91a390d46550f2b2835073df497215b125b2f14ded418f667f6ed71a52e6581fd39aee6e92282f75ea88a854066b9d3bf73e92ad010acd1a1a9a63b1f86eb7ce4d47c1ecb82d663770b7b3f56b8291e3b750216fc2f5ed245616b0d66b3cbc9f1bc2521035b0922e88b9d25b88701d6811d77549106fbc5f6480a5c0f27672d4f88778750f6940eb64e48e4e27a6787dbb8b4c3974920424aea5464c74aa141ed677fe3dc4f371abcd9ebfd2cfe4d9eadbdf1c7e5a545bb854c4b4a07c795c61617f6debedb67baf63d8d5f431c7a5a028ab1242400393aab49c94ec833c02043c0d7d771f0bd351089e771952375abd2241dcffd0ffb432d4000c6707ffdb8a64fe61b93f17762fd88c4efab84170eccb029b371e2fb609c42f7f0cd61486b0f7237975979d79c49f81bc5651c5b94195bc0ea2abe5d80896f7b59620190d3830c7ebd2e3acf0b8063333319e7a76b20da93cd5a6e266c9571d80b836a5d046e50f758bd9b692358717caa833e606aac0ba807eb12fe96a226010bc6df501f0e8b42f24926fd56781aa5567d874425e6ba424e5274d8cd4e1a5f2e5eeac6837028f6c36250fd42f53c734447fdecb079bf99bb06ac454073bf8332f409faffb3a6384f138775f3c8a2419581115eb9b15ac1051e6edb9bb32269ef36bfdfe53455af3cabb1d1a4657f62f584a6bca3a3584a2c736cc1d1f48e4819969a7e8139a15b40df86c03b98d9e9c1841cf2f5cf2e89c620a106b3ba8e2b598071cc43000abf10f955f7c5be669bd3b694c0eeaa6971d8a3913ba430c0de3e0fc6c229688eec4c543d18e5c1147b93962d1fb369ba32af63afc21660ec15255ee214336f8a5d9ff50967a82e8acae868a114d103157ba4e3dd038e25d23086f66d8f5e5487817d62889dd47db7eea22b0adde9937316d2033024ee0ed5a4227319a572bb5c2c6136e0220ad8d2944186f4d860f8e788d21e5cd02b9e9102b9e7edc4823d9a3d620a3308f09bfb7688191f1bf8909b36eb0cc206aa8d652a63f886e3bac21c4579b8e2a6cc3a687db0da855ac481fddf1676f9ce30c17a88227b99061bb4a1bcf34a9fd0943d44e630585a5bdeac3991f34726496ddd490c7315247807b330a1dc1b7cff5bf23591e2de892e8c43a61273b26798cb823e01b58eddb284944278d00980ed7008441775aed080255f2c951aa3f8a1c5d76cb3e84b89cdf5bd4fdcc7b7af807b1b1982b219374aae439250dacb44ded2d412c9a7d9f6648d85641fe2ed07fafdf14235f6438b7d8af1c1c42f7e55b0d9264ca1fc56ebea25118859e116440b4cc96cc4ce0d76577753c863de47b171d6e8e849f0e35f2e7381b53b4fc5cd57e72967794527684efbdaeb0d354e342c7f509b563f81fdd8d2f8c63453ee4ffbb91efd50be7845364e11d0869705402b32f5931691138241632d0f9d25a22344c790d594197dfc061cb62bf5fe251e452922d46d4db15a80b41ad1814fb3ae7fae7b81890e1166ef4eda15569cb32eff2fd5083c9a059181769e4cb9361501d050d54f488b98a7f7262ec071d0251b3e1b75c7d22d2c2c35b937d37db84370747c361ed318227142d789527c71bbce0bf17088fac359b3eabc9a4c4eec09869351b4949669425ff049180c81b96f186192685034f13c318bfb0e84330b582460669c61d37683b4cf775ee39d1f2fd85e34b78a3daffcd78e2c76bdc3a85cc6ff6b46f022a173e204976368cd97860ad41609aabc34dfad6bd0876b5e2a6ae9b23c7225045d3b688450b34cee9c0703a9e285f97bd456e2450aa2ab8223a1f588b58d4b5838ccfd53f52fb898121cbac0ed5880ff13bc1ef20946d894c2bbe813f8a6f5306079ce105992412c54cdf5694813b3b45de81dcf3ec20b0aa0d60f97df2a0fb30c3f46944c8a12d67b879f9fb7bc6cb3514f85d44f2e1241691ecf8469e555820efdde66d460a66c9135b3efc2ce7a1ccd08f86f0bc73eafb890771fff5b5b2ff7d0bcfffc1b762e0149791c775c53bfee8b5d612da357f3ea88a53aba7193df6d0dc7f57813e713a392dd25a7e52de6a7f2ef6aad69d64426e14d468ab7c8ebd094c65793c18e0e7cb30eaa44f4093407d41a5e9858ec8ecc762ce402d1b4e5d15a2ad47680316bd2b2a962ae07e3dc8a03f485882b11e493c8ee83c0208a891e9c0f6e4d1e4e5577483e1089889762f3f3e029bf593eaec8621cf2c6d1b115769330c58f5efdbadd04939e7f4e34e876e3602f46222efe99ceeca7df256a9f90c1f1035746947816a72aeb1a4ee0aee895e2f22ff25232de71a54243958099ae477e6cafcd61fd1c4b9831a2f9e11df6dd6354812d64c04690253c70354119d25f4bdb353d9577f174d3215156005aeba76ce7785dec1b775c36f0e25ff4cc7059b6fd1783987c7cea7642aee1bd2d4b63b13b4cef7231b7fbf9992dbdaf07901a155bbb7ccbb8826b554a461e46a2baf9a4379fe05e5d4cb8ef37e3fe0391c406c35774632447754a4bcf92d0c1203aaeb18732d2660d828eb6fa453a1b692d54b31e7bff62316fb56eebc5ffcd73968ddc2e59ca9878c68f228733e668bba0f97bc82bbf389b4312401d098e552517507e40f9f3c071d34b7aea24e242b4357edd4a165ae0237d8bfcc8bd81588698f5f2349893d67715794e1f4965394b4ce30f77611350649174677d022e7be02d37f62225205eaaac778c72d77da1e78cabb0a1a5aa38a5f82d47aa78103f15f3329af82aae7adf673a2da5f49d6dbdc9acdfb3e5b41b83916275366d49c89edb8111ae6f1846e213c73a9b57c07451b21ae3be6c5e63606bbc6bb9ec5eb3ca3b78e19a7a045b3c9b7d7a4c96a2e45d41ae6707ebd59c0aa469c086c45f9d03c8e7cadf65da79c850144d97f664d536ba7ca01c13e3f65777e1690bdb3b8d595e0b933d8b3e32d5c557950fc976883393025fc77f2cf82b6a6ae72631f9be3ea6d02c59e9c22e422fa0de60a4d5100968df1236e54c9fc24f180f383f1a5b99224cd5cf803e77e9e8238160cc22a0537f3557abc60b523163de95c13ffe96b3588ed2865b64ee00849657b6ac4e986265fc25088e91fb020c1bda7f3433c07eb3c0f46e21902181463b0e82d1d958d2bd75200e16636e07375430cb35922eaf077468545bff29a1e91efafcb21ae4b184880e8e3db4e03c2daab00f29ae0db5e82e6b28aabbc92f1743d7dffdb29238bbc61c25e0ae2cde333f8d9dfe8b3c830c5831f44c08929a97b878036852a5314c31f73da1e11e1913eaab56f41265f8ce0162324f259d120f75a39249cc0f23eaab76d80179f9d06c1bd73ea678e11471b6f1ff2b2aa97e349aec9df6c29892faa1c3cfb6ecbfc89f1189195daeb1431a4ee73891e804f5829f17ec07a2bcd551f35d4f222cffe12d0810dc0d7f271ae353b13f687c24055d16334db5b245bd4b60610d43549f94ec17901a269b254cdbdf0ec531f3014bffbe9bbad7fc4b29c5550c612da9dbd3b621d72b367ce537039b1616150c0bdde93cbf7e979b4796d3cb0b3bc9e2b154a3121281c39be78987f1ba8b431de798a47a72630c5a56a1e51ce83680465a9deeb179ff1af0097a28898c780bfca77a01acd2cf578ecb26bc0e8ca199509097c84ad293ceb1306768c5d05895a8f95f9e6dfbe40f1c52cb725e7887a7220fd7267ae4c2550d25a12220995a10933cdf13676ca561541b15cfd370ac9a6412061a6bdd9acac75d8b7889c14eea875038a6b713947ed893697dd8d01e8fea1370a0c7e05030022f25b556efb5b1cc734a517f0e611c69e073c8623dff0b68dd7d8dcae434e9426401ba8635baf27bee2b04bc224b6359188dd96e52cc5fa3e30fb1395ea2cc3d50b2bab25a05b705eb0d7968079c4ba8285d4748b45af6119f27ded6ff1f9e906edec5049c39f519ccd97dfba4b5fb5c7a239e2fbb9df5e673caf472edc8f8439506b34052648719367dddab574338e73b39218ce3e0c4343e40fcd4cb6219a331de7076bb77b4d93187a8ed22506f08fddbf8cc9c996d0772429e53a6964cec789cc8e5fd8b6f3034635b678f8ec101f22a4905137726ff2ed9f46814cc033735e2e1c545eddb91d05b206a3a4fe84b37998523278b6c0586bb8688fb9b0bfa23a09540e14628f809650428a993d37a91cdb14b4910200e60c8a8500110de639feeec6d5100ed63ccd993152d02aa81ab14b6623fb2e16ef0df6f3389d351f858be689c1b2c288b6e5000a721f08f042cea6fae7c64ee7b8dcee485c81abe32c89aad276599d4151bcb9f0c037972c850abdf64d08fb1a8a293149e0127a6f455f120faebae4d7fcb031a06380ee93e8fc9e35eecbc7a45caecc526de3a6e652a743777020be3f2f30c667e58d575422a5766a4a1c7f17930f84b85d9783f708ca36c16e5074ae255e70233584bcf5a679d30afdaee0e7e8635c32086cfd8fb69e85ca7a2c7e04b44d8bfa1a30a8e2aa59ceef4a95e7b0e585b577db4c685af71645aa4da9caeedfee99d097f33080675fc5f0e063044eeba194337c1ea2be63629aff75b02ab2fdebc65730b6c9177fcea59618484661b8b73fc10a85897d88945ead929fec61140be5edc01698d5a9ea4fed98b42e2c40e95fb711c0b3e008c74d770443e10b97b503a8e0bedcfd1cbd1e30d6c89a5daf98cb56c9b82df4d1412d3672d77b76cfd5688b79e2b72a5aa285160b39f6bc28d85f6b02eee49893fce775149a186aa9d134a19fa29f474d202ee3b6ed0387f5614114addc828b579b136c6b528531905f5a7ea4d2fe49e1e1a660842e6446fb82d328b1fe6e839a626d57d172f6980a07a26e7892f4434ee8472656a2a513a7d84be4f002ff61846bcc85008d0fbf5f470e26eb07bebc787493ea1f131cbfa90d46e377befdc1ce37075a0931fcbbc04ce513eccc4d0ac94f8c184c11b82af3bbf4954cbf9e8d7710162f5ab5bc833266cca35115207474f8dd5f9a12f6ab4de71701178979d5be6d12672ace6392d7285b0be900133c0f37ed33cacc6861ce1cabd0fba0923bc39883a5f0180e530bf5e99616af8a4293a449937f90836392ca5174c3aa1aa4f4e6b7b5368cec71aea91333bc1071b565d77f1af2496f8f7f012fcdb24b00263c44b1c5bb5f748316a4c80e906da8821d504b6e04eb3fc259d9128bea1c43f0d0ecc4ffd0078045cf8a5f07c82965aec0970dd63db5a5d0e35298947ab70b96ed8b0cd12a0ec804f2bda3594c07ec1fa5f448600d029554a3ea7b878edb7b0702dab599ebb260cc39d8b38dd994cdbb930060473b5850892e6c210d03ed4b2167f808064549e83fc8e5f5faf0b954399d60103ddbecd1332d193d3a08fa0fa69d123db4694d899a508aae6ba861e123a636e5b8c02cb9b94eda899cddea8f7607952b870b8c91f82663a04a305ab17c8ffe9ea654a1e8bfd68e2af84872a1e45f78ad01e736a10d02586c03ba1d6e7dec5b54f9a359cf84a4d5267d68d0ede8989d840661882b8bce490b325f7cfdab64b1f4931ec5291dcc5db55821a066be1568f9da9c313eba8dbfec700104949b4eb57b6e5ffd0b3ed4e254566baf5394b60d7edaaf33caa337005ee5cd010c486bbb8bfaf1ff58c0102910244b49cec1e4a6eda3cf9d5505ecc122b71de6e3a75a4e5b929394b067fd390d93b56b1b7cf9c24d762c6954902959d2e856f1f18c5528055fa0d5e7adf9e7707a98982d75fa48e69263b679e9617e327e3dbdf32b94ef7c1015e9793867e7a7175e16957744cf4607b4ffe447d1df7d467728c36253d9e3e0b8e626426e1e2530fa6f830500f1015d28ef07847003bf6d31d6a50f03881377f3a465c59ffe8a1c6c86536e823027022919fbd72aa86a9392b5fd8ab9039f941b0d43d3955c253204d21ecf626207f46594f95fbd12d7342d7318aee07f6d29f8ca37676388acc4035dec09167e099e764242a9cd83272efbb36448496a334ffd4a198f8744f37abfb26389df7d8c52eac3d82e4134adf56b5b4e8eb8b72e13b7197108e432cd5b830d7f1778cac5303d718eb8e0072e3367c9d3c71da442d30e0acb863d00c29ec623aa003dc55a983d52654d9450fe8b8b51c8d2efe58ea9809dc30ea6f2c65de55bbfde74fee9fb1d4db92de6da4c484a8697087c4f83229f3259fda3ba045d968e0450df6564104c00b064087d98a42a2485e9edc6aef740ac8850da48ba579222e9e0ff28ce24d2066cf43df27038c988cc4077f9d18bfd9918cf32ee471c93deb4d602376edc1f8acca65936a387f1f2dbcb6038ce8952658ef6e38df875cca66fc8af2acbc02474a70fd57affbe57a39d80b2cfbe5b562901da229a0a1a97065ce23faba7c67348d6c234ab381c760ea8188dae2e8fcb3e79b70ef8ef29af295e0389ed99225339de7672824e449a1a1dbaad447398a1691e422a50050ddf460bc12a97ad1d6c8f220903193dba3a2f0ada7066ac09f73331967e81124f9d8883659b38d681dc85bda68f5b9fd65fd503d8fa452815de5107742516111b97195d4eb2355dcb46d226c769aa803a9d918fc4084d94a652b5dbae28967186020c2f8c8af07fff4e2725f7bc055d9b483e276180f13b08fb23debbddbf8f0c24795daed2f0b6e1c198f1bf4182f6a48f143bcaaf9cda0ab9456cb7fb2e0f2d6a938cc2df36aa17528212135f171233ba7abc07f7666eb3bacfebd35ccb5bcfcc2e2f9cdd039e3231f6ea97334261de6a0b8f6a97d2a208de4c3dd79958c8c2cc769a94a839fe05e795575bf29c1d849013fc42b9b27d2ed5a19d5cbfea78d2e59df9e105428d807f34040fda92af1843485c923f2b5ef7a7f281b1ad22623fdd7aa00c5f25bc01115efcc650fab220754f2b1d8292e63c0817a48408e31e98efed594c762664216c938a7cd993f0492167ae0784dbcc1efc6e9caf43f442e1013c75fb9cc5493afde477c8aa4d90be45eb4a7c495a4a2b4345f7fb152bd4b07bf4ff59e999fc2145768d982e66887c17a0b1b94eba308ecee3b0620937339fab9c5547fabdd7fb65e9c2cc87cc7f52cd146683a515246c9c800583af4799b3ccfcc3c8ca51bd93a758e7df16eea355a9e4dbf504d9e9b58645ad140a2d2476471b45178b5c5cafd0aec75a03ec505fb4345701fd2b2ef80dac9992615229a8d7e613e926d9192b789b559df3244ad9c7b3430f014a69714e53fd8c94d45e3d0abf5528b1d9560d0fa4abf3fe2d5286f0915dc9ecff2c2465bf66048d9371bd981d932e79874129a75983e24b789d0cb763f2182bee33f8cb95b5380be73390adbf7abb3701439a000987e8ea5d7d5f1a72d7c6f26d70c614b88056514bf25fb8be3e6f638f28a8a7a429cde08a45111f212b54771920879ec04a19876853411273a447eeb48a42ca22dcac3190049db895d99680d5aba44794ef175d59b6ba0ab962dd545088a236051b02c709560d185cbae49ec14ac898253c2ce26452b08c24fa21a213ae141917595365e40c4aa95a80de90d706d8e08badecfe3b0e5916d2cf57c18febc57e47faf7cc7a292c54bb42b2e098afb30fd6c849fd13657573a5373ac455dfe17a5a57b7d6710eacb0514955ee886ff314a1e68a96043aab1d8234fa31e796283e2071ffdcd0a8b8b601a470d1805a74c1bd4b6706b88506dd236bbcacc24926826f08599c076d8d817e18d6f5f85969174560dc1642c0e7be716750b8c387d50f4b44417cbcb50daf8ec3bb4915d9909147fb875d0d3592845f71b9a15278a03e3937299b0cb6e8b5623541c34420b1c12297e51bdd9bfd7bd0ba8ecc64ec7d958b6ced383e645f8e42e7eb4ccab06a19cb3eb80c5e8203552814000b19f37ad1340fa6efc840a40db38612413a4c5e79ac533fa512f48922b9e39fd9b308f1c1e10d64fe94c950a97e3b72ba0aea51d1b6d6b88dde4378dd216b50b7e21ae71c37aa0ff0ec0748a3ed358cbef637ea698bdcf45633d2174c65185008c4a84751c97bc8fbf0df1d269e4fefe311fc77bcb304a240daafd78abd04b0baf5782612995c1880f86064032351d5eb39c524953d2874d72c227b5966fd1590b817608e5d80ae3f7d22b2e9841c9d2c8b5c50fba589e42cd834f0a2842de9df5886539c74dc31f5bf90cb46d9cd81ebd26286977fd16c44b40f8490545ea1faf173390bf36e25edbafec9e4084f5198ba465489901a17a0b1e6d8aceb676749780208317c7488bb89a0d90800905ab9032573efa67fb4931f64e85104e2ec011f15b655210d06a0cf2bf4e637de1ae68bcdc69c8d39dc1089005f3a33cccde6dc330df35f34cc20a04b382da9aa9fade178b5afce507e8bdbe672ad5bafdfbb4e9dab6eda31aff9c6e52f0de19e4f24dea0f63f1d418bc908271813949a4ea8667f43f71d61fe0d21954d7f6cd48d579018a4f0968324050e64074ecfc396f036d5a4b3036d876bf3640a3d86e648c2c10628c27c2537d1fc8243d1980f82d81ef636f27003e81fe4bd9d1021de6740b3b2508a8bac2b1eebea4350c682f5b350804e1da5b2086bd2087f482172228c770c82b8fa480a84645279b0eaaa030f4035fe24b3e38ee1c26c8023710fb9405f2011e0338e70a3f97fa75db3752d72c4376c9323ca27878adc9919efee50e77b8b18dcdb608c539ff6c6d69bc44846c195b13d39b9e055057d52efd671c224aae7583bf01d998ff4493c05af958af3a3a0eccda7d5d6020e88cfc9091588379e9be326e2067fa782457bf9d04015ccc777965e9cf259894b774abd752c40a2c45df4aa8153ae47125ccb6ac02eaa9ae5663a6578dee87342047b3a50d6db825748f5ec25f6270ebc9e1ea4ec7823ca540847c5bd7d3a07d46ace9c6b5c52ab08d2a6968765484b09705adf6f1ae25a2569262c517095e67c152fd9e2ad3b8f8d570b163a6ac9bc7a032e4187573e7ea4050b8858a26788c52fe6d2d2290dc3e7e6f82f01e4b8d90191f3c6fda5c67cebfecf2be8e4d5fd86b9ac63e0d3afcc5c9af9417fab6dc5998448f3391b38d05e188f13a5a8084d5441b41162e1a27061f4a68167b921a2a85be689479cb731bd4aed585781c427764ea9d68e50670381c4957b875cf4ae9b9cde9f3cebdbe960a74db9fe5c8507fffc3a5830ca3b74c781cb382996dc8a88e5e540e69aacf50b7b029cc805d04fb0c45f38864585e174aa558ed7dc8290ec5cbbc9967c9640f9cf77a03a47f9d01d88e3b8423b65f423211fa507cc0d7300f240310ad2b1ecf1e208737e303f446c775a054fe1b42bd189fe8249a046395e427f452186805a7dc15c2698a2a717d4d245a6e2c9ff9eefb99aeac830e69d26f35125da319e695f9d5f1b05b4d8eaef1c4ea50970e27e70e3780d579b6db85fb2fbf6cbe41b745ab240717f1c4a8874709d69c182ec11998d080072919968c5195d92f4adce2459d920e767dacb9906765b488f49e9177304f37b1ce9056acaf6578e965d63e55bb3fb15866085997f9a717fa2ae00f33c8836a4d9394f171453d24c573d5e89821dbfe131fb6da6228bf4d1e1636854d680d3037c20fc3a8ce1fc740f7fa030a3e911680d00486cf84e236a70a2b25a869cb2d03cee2de1e092e87c96e79923725a7c96538a7c898fe31f7d5b17b8dcea984619ab2bed6efd5e2f45fb9811ab5d751e3a81f3a618147b9b398b6f2dd83e615ce4cf6e00ae6e71e3b4bf54c155290f4d3bac4b0b4ef2fe56e482025aaaac0328f6db28e0b2db85b6cc805327042f27d800e659a306b2308c3fdd8c95a0bcb0491410e37abff59a6bce671e278f3763bc1ed36b7a3fc61b10616205570c766f4b68f20ef9df1361cef4ff6685d2f84601c5c001b0cf8a8d76302609387b7c3cabce09324e6fa601ea4639c397f3ec31e30cdf65f3cb7b1074617d7720a12154f01f56b1f28a57417638fb6e476ef165d819d529b34ca8c6c91f13f51f88e57dbbb3242bc8bc5171eca38f2b32b1cf10cfabf096e6266811a4873d651a523291a94b2abc473073ad9c2f806f9affc024f298f8ef6aeac9084947dc2b4b7440970c3c00f655bd39b3700ba60b35add89ac50082fd5d850fbdb838635ccdda71ce220fc0e34f5e313d5dcebb834a0938568c10edebdf55418c798e0a2bfb67c20d867e1de150b48b8d53cef98ad1a89f29339ef39a7d2d7abea6e62098a53bd3a0567ef9928ad82716c14e5068e59fc23080a829a355728c3ef3c33434a43d66ed0ba5a1b6abf7eb5d267338dc89f828afcf735b6fb5901f35fd72722aaabdfc8bbbb7fee7d8955337f4a822ceda21ed778bfd6d132ef6f91033a8b4137e298714436b2ef2b535b02045d700765e71875da8d9235fdb3ac843456e2d02e6b772fa3a703527b8c06167d473f2873eb1f2892cfc9c8ea09ab4f9eaafa1deacde0d84221067ada5541641c02cc09f6c4ec8f91b5f29a076bc1410388050219258438639ecc968dd1eeccf029c97004540449490c310abb14da7c5587b9018763e85bc4a59b1f19bf27bdc33626b1173fede5337e342ce12421de0385e76e05743c3731d08481cbc3a5723c520098a9225cd80f752ce0c9a1952a1d68bd685d6e7227a670637727f68ecbf00b35281e2702045566d11fb1d19f04ef666b0b752bb080115a4fb4707c503030673900daf0830bb6f4ebd0826b73139083bb0becc2211102131970e49eb8ee782ab88494bd0ad8614d2bb121173a6b6c23b878aa1f52183bde8fbb666573f1b7b39c02f10e75702a71d51d3940ccc83b05543275ee1c9b0dac3660d4b7f30ce30d0958d705fc69d967f34b7fad3b5032a244914fa28a9b6c4dde31388cb1057137079aff12c6f0a53ffa1d8f063efc8d54f2de1ea7c21bb8caa7c95066d513c93ea2738b9205e270e91f3e4acf45cb811df3614a9ad7cab7e2fc10046dd91011f6a5331093769ab4889a3e396a46f668b968f6d2ccd4b6581c2a8ab926dc668b251d85b669ab9a7978ce118448fd973e36bc8e37a2670d38e7ffdb7f13f410320994c8284cba3afe2dcab46c19952a79ed9099d066082cefdda73c0193c90d303dcdb0744ffc0ce77e732cae69bef5a48d65bd41f2b6acf4d300314c67489849469b8815a022aacda0e71a55b80f0f8f367d2af9aba53a43ac9fc35a8a3d12d702010146913705f4b9a7ab1e464d6eaf8dc252edc499c8e2b2d80ab78991f6ee96be216d10eb4ae127ee8a8bb5acbca40589a2f61f0c215497995856e916ce76f7892e57a8da16660a2e3d4743bd9719f058944cf3956a808de3b5122a0e49dc7956181652ac472b72837bd77c65be19839497ecbd3a99c59f6abdc16bafa93203df38965cc878a9bb44ffbd341bce586e8d6767740ef454e0080601350b04df0c269a3dacb70d738eb54ab50297774073bea4d0f692d77a5149122c6f72b927669160fbdd0458132a007b8013ed2e8a6dbcdc8b4079a603857c8c2118834e43e0f95ba6e602e29613a7c336e9b2ff6b5948dab2df19c9daaa71541a9f19494b9ea9ac8b60ecf942f3d2b2d594c824ee544a2e33b74b65596ffd06ae6e59c12e2bfad5d2476397049ad18e89807769d3e729020d5f90c8f8374588e34043d8a3bb3c485900b20bb5dd8d89e0af3d56d37ae7870578ed92b84be2dbcdea48e638dab6e942054b2f5520a7cb6f732e4e46cea126954e1af0a3f87c0ac33e5ae406428f6fd6d1d0f7ab6e9f82f137c8f70d1e44c697b7cff0f6b6195b13abbc52550b6c153c3d8cc79f89e22d4c84a5d013d8b4d91b32ba609f8ca06c2bc81fd92c2b9ab47bc1e1faf72d72e31746927f7b738d80fdbf9c9f376daea43bf28103004ed928454acb8de359dedfc8c561e70cfeafc9028d8b560172674f2371dc3f3c155fbfaa5d0ca3e622cfada70cadcc6983e5e77d82e6ded792d57386db2ba2527319bbbcf9ff7bf1352daf5da6a9e734eb44fdfd0fd702cff8a19ae1d6d3a9bc031ae1977349ca455e4128070b53c969911666253ddfaba3eea852f8469c2b2c60e6f514f02a868aa3ad2a7e377b60683bdf870bde042aa905fee0f1ff5b159cc7b6ac8ca2e622f4749805b8a320c86d2543b900dd6c54f82d701370c2d9301c0579c6fa0d866b98a76d7c40e9b6fd5989be2902f945d9f76ff120e1753dff9abe38ce97bc26cb96629d3781a652f7c6b80c8ed5687f4a6e2c5c075d967cf93ab5abf5a24fb1397b33dfe070e4aad1e522eaf8d62505bb6e4b50bb2f5c71d1e253f63d0d5e546ba5a5eda94cb810fa15c13038e05be06c825e959910ec0a0486420c3acfe74cdeb11019d4c4dbc965e7731113de386b09d8bc568f786c059dccaaa00d0c66f3ed3a10a9475e81eb3bb4c561b71f769fbfb40eb1c8781d79256fcf89b93c0a0003514f79f26d4325aac70c49da50121acba6da530f22acd1d9d2c1ab38c23f5a54d169c9c7b7ff1b929b8380fe074969cffd26891b6c743a2cdeb8af0003ca17ce9209fb42ba1b96616eaabb3637f981efe84030cfcdf50ca73fb681397a3d91f4ed4e53492f1501e96ead94b5726edb52b36331ef3e7feb21788a523d2d1bf3a975dbd7b7e2439e5adf610151ddc5517e74662920f4848ead2f6a3c078e41d8598ba862678652b01ca922e592a0a81d4d5748775e0df3cd560de1d5e61cfca102f9cd8740d0ccce0df0000f6c765b7737f0c1152e69e1731336b7d5dbb9a66ad88fe1f33f8952d0d87441d13f3e168649bca62a87a5038177a2c631ae9c780b876636650ed25d5c7690005c04f09d8913ded8e2fbc9fd90b699ce34729a13650f20ed347328bc4c84ac65c325495f7ece7c70326533943b03db4c5ce6095f93a412afd208c697383244fc593e251a518f7a80b233756cb3c74bbaa5ca8b2932f56bd41bb9abc5da4369b536075795ea6cc2c3f8e069fcdc610d9ea7e34104a1b2f0b333157d756756eab66e1ae582aebf48cbd6647d32aebb2a9e4c95d63a577ff053196ebf1e4889cba2f36eff397240e91ce947ab7bd24fc9fb1daf0846a517d51a7183bb3a4f7a28df83c852a7f33d44ed889659acbbb9b655c23f435c6cdb272add9f1a3250329ea0949e01bc2692bb432223bd457d26e82ae70a8381a3c97aa5560e8ca783496fdc977ef98d66fc861a3537428708aef126380dedcf9eeae0c7ea6bc0d0696f1218590ec8bfc1985f968c02879bce434b0ad3fe01675ac8c6a211c8e137f65c1e05f332e69c22796b6fda9549a677abb634968911f4550ae4d0322b8328679406051a6f02f06279e134dd0e86023d90319c5eb2e960ba28a4ea04a5591984924d03b268d927c781239d0b124129a52b0b2db3c8ebd12e62f4139dc80078e475d2005de2853dafc3287ef7a8934d94ac41ca06ea7c6ce7f56f2949216f2c5872f24f678d9b587473a9addcddb92fed807b01aabe325f1aeb98e5a289083fcfb0d535489c5ccc26fa19c2ba178a59599eccaee1756900fcbf9596f50e4e899911a8f35952e5a795b52ed18fbed62ce1d40eb7bf63fa4d069810f3242d575b563e878bb79f1684fa04eed8bbcbe83642fe24acd288afa1ee507007c32982e2c816d5611b5a0c8a7cdbddf6a3247a927a1c014779d7a103f84882667c9042cdc0d1e76f93da1a1f756fcd2a3cb4192733fde4cc254fd757785437378bf26f67fc387c0b9b46dcc3b98072bb251766a7fcadf02794e776ef8e1a66d553d8b63d47e357c55e890f54b87750940e69732e3f702468653e50b69a84d8b525d055fc99901b1246bccf1f06191824ed5f8ebfafac14bbd20ef006f95ab726bdf6bbe302e1443353b238233b12ec5a501a11c43a19b637ef37bcf6084d78aaf9410e4ff230cadae541a8170bfc78e492ddc8c391f5d7f2b75927d156a9b83d27ea18b61f9884f1f4e7ee657d2906919523bf01b2bef6b37c91cd68445b2023ca237567a352f556b2e715b15864f15d1325f9fad69b2b746d6320e23b3c1a5d0e1bcbb5c0c077dc0db84184df90024663b3072d9cf5dfd94e9eb1add18b336b8b6e93cac18bcf73ca8cb1e74e15fbb9cc86f33edd65930a62d43db4df2c8a70ae4a7dcc7f76da45f985a4f566ffe71c4ec10070d01b6c128d4e3b1318419425fdbd958a59ddfbeea367e3b0004b6a96f7737a4f1a6c4aa2d0d92cc2aab9db6a0f7e0af20e28d494b6067568db773","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
