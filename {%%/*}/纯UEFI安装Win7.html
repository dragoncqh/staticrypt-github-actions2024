<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"042b9b20f44a11ae054185e6a2398edf52a6a39b9190cba40b2340eff67cda507d318cec912e7f2d48edfe5ea8ed5ab1e87da183f466595a34bec2f5bc49429fcfdbddd886c220bc9adb983b0d0386a222751672e824c2ff35b58357db7ddbc701006bfa3fe1bb90cf923e8021568b97694c988d99ab7aff50c5dc0d7933a7bbbb9785abaea16379e6a9a24717cb20c48bdcc4a8da72131107f7dd21766b9b0c89c38f8c129a03e3e39b3201965a1e6c78a9b49adacd7ef8e8572bdf00ada9e914b86f2a588e5293613d3cfc64a495fa1e7f5b1bdd38e41647f2091617120b9b926b64396e0d9e74c05bb6ec15dbdee07a570d6b1a95675aa185d43b869bc22646dc02843783b193585168f78f50beefaac4c1109c23f4b558a5223cd69275d4bd5f6c81133a8a650077c970d2699f18d88e4486f9b0f11685801ced5855e3a1a074fbfaf17ad033d4d0d77376f474bcc765e3af50aeed980499fb823da621d7faac51a9e3a5c558c421bb5d3ba8719376ecc24388fc22ab743f6353f0daea7f64bf4f2808e1e5096dbed0366d54a82ccdc65175a7f1ce6d8e746e151abe17d3f33e1ce655f235738987f48da93abf3f62be27e6e8098b1ec82fbc01f9a1d7a0577f724a2f8f58cefb98b25f26240f07948af3b401559a5d34fd23a384f7ae102a68f1e9b75818f62648b6c95a0dc32a1ecd97b397c20d65362feef496595948e2d9e3b24dcf02ae89735b9e33030d5012da8c2520bd9bbddd7b5400d291a484325a08c3c2053c1663ea2662609a0499a95aab30de9a30e7b59fd5e43d5da30493c819ee5ab411943965131712f0cc00135830f7a619c0996a1b15e298e99769b556bbc14c0af20bc4bb103965dc5c0cc43497e9e8e0e7cc3bc102ef37bea4dfe8693e8c3ed0a1e4122a0403cc74f376c66e0af5306b62b86eb6bfb19e69283091c9513d7a56b53c40603a1887235174ad02c6febd9f6e5749339a370097ce59f7b253c63f1b8d36b4104464323d0ce8a3e157ab3cf139f42614ed9ce05241a8b6f79ac5fa5b17464779ddd3de5ddcb94eff4c8ffde8d1e228acaa6b0e8de843f8f6726e8a8e429424d7e06514da9cc6fa7c2549f89096405dec3e43397a3b90fcc33b079a47b4628e9824c1b58c3e6cb5d6dec491f43a3bd472fc54eded23cff153a8fd8fac0c204fe7e0dee6bf1e50dd7f674fea7abd38fd4216bff8b8aeda0039de27aefc5bd56f3318b83ff52009c91e5d3de4c5629a2545c459d1d8511fa4139ab9c2757bb7c114d2ed8a4fb4a3f09eeb1af5626bc13ca0f344009f2c17012fbc5a45c7ae96358c885ffcb5d1f162e9a9d0af80d6301497afdcf1a2d8b20b63248cd3bf7a01d2c7c9e3af28a993bcba34c6ebdc7529ee6d126d19948d4b9bf2e2a8bc09d8176220eb4f6d128374d316096a4f326c071813d8da7e5e11c1656299ecbed56af8f43ce34b901664295e9b66479f83f44e4eb0803aacbe9ac5a91f05a80a03e6117ac1aeab964902cb8b7fee1fd50bcf3f923161fc246e97384a938ce0985532aca1bde32a6a3f439261022c6cfa781a5057cf8c7725bdf79913696565c60828c48de44c27605925a9235fd01541c778cd56b886c79532bce833f4b77fdae3dd25f6a5a9da401937c52858e3e91e1dfdaf6684fb04c3a015adfc4955546b5cbf48a4ed41b40b7a2fbc0a22c200bbe7789dd39e235912b049e6e2a874ac397c33f16ae83225fdda6a8dc803aa83b2a93a67200749de710678af39cdd6c00482c6844a1f1bc187948d609ae37524e379cd3a2b06d2b5f4ecf18832d5d3105dff4d2853d58f533322e6ace104f362f08f973f9d7394cd25d600d0326b109e2e62c7d8fb036b9cdc6e7a087d9f62c4d469f28f733d1121b24554a72ac0c6c6c7f70466907a5fc0f60bf826a8d8a0f224467d50a53c4d6da05d06eb91bebd3a4e44cd0d2f71c44f08b0a490b395b76a24597731ba2972390406c8ba24cb76965f9e8f02d41ab429f4644c67232cef853289891ae16424c27ec5e3dbf6122f903cccbc030c1bacae99236e86af662b8315f81c30aea0e1a7886970ef9af1091ab54ba7aec9db244c9d3080c789e3651c3534e198f06eaea43916b723d1e1047adf96767e9f481c119f9c6aefa74f9df10e99c37273c1a701da82ee843d2e1e0060ba7424e1efaa7a3ae38541ae9afa2e7208ecf984de75074bacd63ddf952be5d7d532ec3e304287eca552bfab23523c6f35d151147a37780f8c48089c6c08ca89187f497462d0034937d533d6de0c856181863634ea6d80240882965df3ad13c30134b9b4a957b2f9b2389844e6af57ae989456b308c5d4da03e47834b44d787d58b7e938226a3e5693e183e020a6e6ad1eabd82045c11504d9a0acf438498e8dc77554ebf0f91034bf8ab0b409ddce793a96d14f32aa0b8ee74cbc8cdde7a43d6cf14b48f1174284883ddca087f48de86e9f7d1332bbacd54be544bad97f143c9c16d707962bffba7e946365b3e0c11248beeb1f42957410b51b290a5b4cee8c70476202e5edccddf80d21b8cbb660e4d7f0530d2484ec4952da00f794e313c4f82be482449c47579f51742b56483a0d9e32a5acc2a7b0962f502533acb794c311adbb39347e17dc9e7ffd4df83aa22ba307863d26cf9cbe8bb4cb764ba4095b7908569867ef8434fc4b8cdd97cfe9e5b8cb43918e8e6f1d068c7a2c402dc98d1c557627696081f68561e6ba7f3dd4b23326ce03311037c0fecc65db49f21fe4931d054509054b11fe0d47d7673bdae0f670ba3847ba49c362205fb5176842f470b42bff440cb82caa54b371d2da5e72c7f69d446f13ce0c0ea086dd0d91ae56dd20f84bf76d7fe1a895f8d1b17d1940a7c69070cb4db14d59338b9718c418c6e37e8784ba62e276cb8d6152bcc543aedd210c0fbd006f8d6e10ed4f3a302c3b6b7ad7813233b210309149191a178ab496c0d3752140855729c39d3c0a4322d6a2aa7ff80e0f87ff974b4694454cbd71f74a4843731ac73ebb364a93281fe4adbe744f61a15b4de67cd826202bb5956a6be35f5ff8ec64f124fe152e50a353b776aa0be330fea6812fa182abb9d59d93ecad7bcf696d0e23313969d22f5159839fc681428bc6c6805e962da00182fe3e924191e1fc1eba760a553152b1ee726dd3c1016e86725910953fb5bc9c4a4b22f56171d03692cd4d5b4d323674fab98a26e9c5086dbeea51f460157137910f05a377d3e52c9f9ef122fc909c3c51e38a41f9ec59a00da2ba1020f43fb4fac82e84ca73fbc3d4e6a28dde85cafb2a1c881021fbb9db1d338623078363edfe29b0906ff9e3b8451a22b98f3337ad5fbe8c622e16bbc702df88223f7c35005be5b92d6f8d9bc1cae808e4694f6904536021dfe1b0df59b85c316f623eff36e64681fe2d7c99afa50a365d9d54bd031164282dd224aaf775253f9cef71272b2269a5ec20db848b29cfaded2b46a7ebfaba84ff4cd5481c6f58dad4540ba91b96e1fb04af38d483fec9f97cefeb2474a4174fa32d322e32ac3e68f2b3ae462d52e6126e0732fcd339ad7b255f34539a11c576236fc71c32695a731ddf7f9a375381a530bf0a50c9fb3f88bd97f0c0744599520f1796f2f8cc407c9fff712f09b0e8a37941bf198fade961ba4238559a8bf4c30e5edf9f8b1b6f3c3b6cb1e60da5c9bedc1e6b30b0fe0876db94c3020e5f06e9e068fd3bcd205968ed47665acd32b9315915e9364a7809748e9a46dfc367d528b48bb6978d746961fe32893c81c8b9a5e00256fa656951e102571c1e65c69ea7e6845daaee79018831b1bc38250b1a45b1d478dfdda2a8409b5d763c9cdc1e866ab144d46d3629326caabec9164f4b7494c9092f717d1347471dac3e4b382f7b36f5cc00cdfd07484c16ee94a1281c06665bee3765132666f660f33a1f91a966819f8fd4a69b4abacbdad31c848132c3587e39cb8af826c6ec012cf06103f1d0498f13de02c0a5cfd874e3f7d5c97484d254fa465c7c5bcce88548403db8bd64dc90c580b91a019b9d1ef2526eb7e2838c858058293b2b56761f0fa6509237f35808e93e675ac33453dbd0e0be47a5835cdc03747bb10ba00707f1b53949743370b20807d62058bbf3833b41bf73160a5c5a1e49513ba8cc2dbb0cdffb290f5fdf8373536c7fc77fb4c04a5ec6b0f2bcd33c7288a5c4e8dd3f0e6301ea3a56d0b15fe7cd6fc0f6d354d51e51531ed23f309b34907d9946f2e11ae9fa1bfa366812f9116a6ea2abd4c1eedf7dc2c2c60e523dda34556dddd8df7256a76996520e614fd166a2e1a59a6db1aab6906abb782c69a0bda0e1f9f70ef5533572f14239b1eb10da3281da9ae0f53c62b5735d4bc678d9c491bdb54333b4e1b1c10a4645242e05358b92bf5ca66271c2b44a9529d73678286dc2f2a1f7cd6bcd5ad77fa9516688dc59205d73d9577b6b86b00fb526ed43065853b0fc9f0242a809b9a02c1a2f9e4ff9a904deee4ac58ac6ecd8d38a0a05dec44e01129f4a158162d71e173dc9acbcd97f749e72d084f68393241ec8fae5ac25f0bed115e4e4b8d13e6d36afce6cdc2ee1766a2e2059ed590d48d57b33aeaa50fdc6090edb20cbbe90dd5e15631a01efd05be2e71f79100b2c9c06373c830549de7bdf5fcac9c50fedfffa30a4671bbb84705f8cb7ed04ce56dddbecd0c5e983808479977d9162d65e51e8b0a6eb49d71002f4bc8ab1826872689188e214f0e42bc2476bbde1a4384e1e1b9306d9c7965b9f40219fb5a984e3807b82255bfd4195320df0f0ab6bbabd80fa5053dd8d578a061be838a908e351d3de9e010cfa1f7ebd94b689e33df083ff437c7a1c8d5c7511286fed3e540010af1d3cfee98869a8f5472985044057e932b8998cd4daf0a718b391ac7a2ee1446f734e47f9ac39abefc61f50b9460d3dfa17adfdf3615b5e738558f142b250aa17b02f4ef5935a30e5382717883857508603ff7014553758f13b431bc5bb5e6f71dd797b20b22ea03c235081f2a6337b504a9011414ce91b933fe9df9a8c85a6918f4d44e0625c995ef4c8b3fc6c8bd7e76730077f39771f58a7b5740723bb4e2ad6e4e826934bbec9bf6a7fdd9ab98e875be1ab31f4a1fcdb0cffef83f263d6928ad7c81d35fa0231debf8fd97be2e54f671356875638424191ac7381cc0ff529f46e069cdf503c02b98a7149c747d58b7aee779caa62afc9a16ef34e60cfa22db4c91e8c688922a10719a062649b4254be75ac4adb904492df17be8541c32a6dac9d9d44cd38f91bfbf8be931f90bc2a7ec02c62e4b73db43647c0f70b3e7818eb0edec1c5fac372697be05ddff882e3c31627bebea5bc0593fdc898ae0e439336896291760c17a6227b4641493957453b195c88992420b214445e095f2d800914ccb8ca41196d027398c6419be0422565f18d2038b612f495d98bf7b20fc1fb5da4a9dd561bb7cc34e30e357cff41911136ff075f241cd43b6cd313eaed08e654b18f97b1ccd429c9f374bbe30a62677c18311805dc910f1de6b720306411ffc426f7cc9163f71b68f2775093c33d523830af39b9a8a7ae5034b4d29d913d5e70688cd0243fccc3f27bfc4266e9afb713c58083ec3cf5ea2134c3376074400e4b72f7f457cb8d9104e620a66a5ea145da17140978de006ac54ec19600462299a203b000b13a22a7bfe8312c8e99dce3cc8ebc132a3ee9fe18d2056abc04d08e28ac86fb4f0edff795cc34564e12e9485e7df8a63182081d1146a6b0ab839cf0fde11b82502c6e311b761a49d8857dfc0ea87a33077b6dab0ff4e2c87beca4ad75724261922bc1d14c1bd13c1395a72550ff87916b272d2e75a44a5b4193fdb4c745e3fdff343bddaa2d3b68d3c410eb8d30fd51ccdfd5e6a16ea652b348dc8ca08ae7829c09b49e28b03dd1c22d3dd0e23c238afad2724469a3adbe1818d10936cf9949e22028b1df2ccf7885895a6ff9346ff0891bc7bcb3e6c69e5213cd19ee30b5bb4203d2e47e58ccc6dc36906280ea8a75cf8e9494c1e1866e48c543431da86941dd9997f8c32f7cc81208b934cdf9e6450a300b7e0085b9f27d757593810d2159c9a5a57b20a60f30b6479f3c2de032bd098c3bb8bebe87881cfb5dd37845aac7482f427ff360ed4721f7c3e9ba7aea9625c76d9d8280ca6821a015bc70574f670c76c156447d988d011be46ac560c20547487db0c87bb7e9a8e2c0e9e416f7c1beeb9c21b9a7b44b56ba27807400601dafe722753ca314aebe96e9011b0041a369cbc5bae292882889a43c330ddf2cc2089b9302d26634008c81b1363abb3047a0a301adcb1fd704c8d578cef1161d2a4d7a7e4857600a046d4c992ba08f600989464ba76179142501675e4c47da17ab45ab04ec8d6082ddd2182d784f1874a6c79c394e4a0f7b72323ac411339203299ea431a51b449fca12c2e2d3b2d94e6c8acc78fd46c97370346ce8d8eb9ad51eb3cf0c02e91ef463e9b856887eb35e951f264b0d548fde1638266fb8bf74062f8dcb778809718deb4c286bb39845b8ed669553d6d3121ade35d67d59cf4ea030ee949037d842921ab4b488d7bd1c7716870975152502d7eb6b6d6813a41c2c5e5839702d85b1f3f38d1683b806489b5162c14edef38d1f523842a874d34459709e083065b54e0f4c6124c73d2abbdc9d1cce61a8ab479701855c0be36f12f6c6a920c96b1ef846ba15778a479b17feca4299423fb8618712060358ccc8e3db89f3896dc1a99d9dad9fc93d8eae5830d1753c751a0daea484d21543e0b9fc492f34f9da8d00339dae30f3b93123f61779078a0a45ef25d6a7924327e6904afe3a41c8beac96057021bb007830b3b13b514b698507b42323b0bf07ce4d0fd8388c32a88cd48473978f4583809293ea7702306bcfb3b86eb7b7793bec677ca6dc56c5b7cf04e25c22c1ff915e94cfdd685848613a707254609b77b7447aab10d55b040c633d1cdc6ecc14e3dd44e0a9de978403ff285291f306136c640dd62ffad539eb0c6a816a838c94960bd5e07c510cfb136df7d529c1c383dc03a2f1bcc5ec707b3b1cebcc9be909f90f3db9f1221deb92b675d1a2174c4d847dad3cc6f075175991608aeba98a316a238672575c6a12bd49a13d5817c2cb3c036cdc7d9d11bd139be09ed3043ed526f724548af2e690d64f9ab128b29fa9ba3140afff23e72fff0f5c0cb655dc53f7ae18802176916b486656ee7dff7b7b3652768737ff0d08b27a76bef44bcfee5f6c678a4b09cee52ff0d503face51f7b593b96db9dd4f94ba766aa5e7d4e09a7e708aec985b9fd5bdfb6bc012d5f75f32a1f8b9304410e8975dae0e71fa059aa9b3c5f4a1f48b19b94ca4e220e7e0962ad825646f061f17629f0435aa28bcd3865fd9839f4552717595bb2d2342e7471a659b2f944d28b8a63c7ef8b5919288ded72df7bc1b9f6de6aa9db01d085d586f00a203f6cb3de46806635d6b97ff2ec51c87be50e912bcb8d3c2b68b593ba886720d8841836c5fea4a8c86fafacd942a92c3563661528162d8d83d9fa0d7caeb6d36f889d6dacebc351d6fec42e71782cab1d826f199192185dd10082c3c983a1be4867c1a0a0b83e1d293cc9fc83cbde41aa41239cb7b1ffafe608f2eb8664c5a6a34ec363f033ca161c8baf98d96dca73f4ea4e804bc13d07e3569d56092781be88b769a5d45821102aa965304074ea61970501ada9477d5a53bfad906fbd27e06b5fe20dcdabd3680191beabcf7f5ecd77a6b45d6e2ee3ce8f27fe321837d954418a76c125df9fa29003f1e65af84681217494bb82f514d5b3d68e1c110e41b367af09a6a1770720651e0f0b9498288ab7a468fe9c11c5c1908e08cb761e5708e001d344f57fe3ec1bd4932ba43b274c6b966ad72e6ce90ae65f0845fd4b21bb64bf79abd699f0791baa7e7f89fba2454b0b2a46e899eef1a1ec4d50df7a53104e6f8b72f76beb51d260673c1dcefcad5449f47554e0c95e202a0f8971a036e138b031eb81fdcb73973d5b53a6754c423e6a6f7f3f863b24280450d7e29a43a71e7a064b26d8fef55b886f40d8bc35e662832206f3274e9cfca60f95a30795816cb4dd59bcdfae3f029f9681ebd12c1f2c7b2010b7cd26bf886b767f760fd4d7124edbdffb8e357594c7a8e33ff1636c7a6840cee5401fc227295a1b51b35560c71c5c0ea0453cf7705afdc086e2f2a34edfacd3907054c285fae58d18fd65dcdb7f2a2fe25dae60d6669f24ce8fbd125b5a7b9d3bda405b951900181aa7ac336fac8dacc97c9a1e51e9330ac5567958823b7ac8962ff5a8cae775c033178b54c6994035656f77fe4d9dc8e917abf6ece9a283f43a3e1047d0ca9bdcb366b39bfe4d9d6c49c9e72c53c6117367df1f628b2e2a64414f3ef1d92f375cdcdfbc3831ff1f2e44bbaf5d9b61fe509c3ed142fe0dfc156df8e4d1cb4c088e566fe5e1a5f0d68bf9d991cb1f8183ef2544cafc3e5aea224c8faf4ed04a192c66ece0d7a349b0890587919fc7edfb478f0397a242f23efc4f662bdcd7dd76822ab7c5e22bf66fb7639ebb4af9f6d7810fd0438ddd895c190e5f304938d7ebf5daaae46571440d2a0d7e6d8384399714cd2cd3c34f8978ec4d208b0b869af4d1ee500717f92029608fb92db44965c5ab804111157de15cc56b30a59b67554af1873721442b2ca0123fb0f222bd94cdef262400fb50b2b6769d2a0a6c0eee42c6f6e9b00975e154d9bae92ea71667fab4d6c234711b170658d0607a3e556e8e87f0e1c151eb9d7467432f7a87fa101c3c815a089b69aaf2c85f06ab57d584a878d1d7e63bb0607441b7b199aeedeb264faaefccfdbce3301a5c049b925ba56b542d9fdced788bfa79802b61225efb80b1bbf38e732a738315e0dbbff521b64d96ebd1eff81991ac66eae74cc829be14e31264f67a34b3461373b8e57c64968cf2ca5ad18af63f855eecdf1e0bc17e198bd8d1d41f1c74a72ef974a112664d151e4d9c45370f8ae3071e353e3d7925ce70fa5fb66037c508605c5caf2b8d03da49716e852c1340fd3536a1e68a5ee0c08c77cd440236dfa5f8a9d36ad117a42fda58ebd2b766375177fe50c629c5bf6f372561e5ff7047bbff8e265a7dd0df134468c2dae1baa5e677d110390883b22a7cf44569f2b41663d0c6b733fa886c0b2a43872fba889ab89aafa94ada3ff3855324b639470c2820e3ef3331bf596c036a3eb3b6957f1dde0ef65cc1f281fb88cd94e3f53c8c8f4c76a2ce36a11ced6de709342cca50d1a15481d45a4fb6a4f899e49d874cc6fbe7631a0f30c9ae857fe84fd82541edd8c5e18cdf74c7ea1f4f83d1fb359f997fdc34e66c87b12e933fd7f64caa8010b3de64e4e4018b45f5bd0880b976f30e5b2bc9bb80b41274a8c5e13d4b41e03ee8adbb2520e2ee60b2236a56a093fd071511c262835e7c19a9ce2ab3d07d48054c5dfb5b95ca5386cbbf1ebe8596fe90d141d4c0ed9b1076c495c3ea33759367ae599714ed1c862a1446cb4848735294abd9e7a871e4d6c61f2101c1bfa873ccddb361ba32c3aadb5fd7b265c8ab982a9bd5f5302263476c2cbd633e8a6ef9594babe07617e1d0859cc238f070ff3e3479dd164d4efea333d90f55f070b232859f55f09e375a202430150acd3b48b9b6cc4f97658f3ff6535f69bd339a91a664912f9d4c9d021fe9ecfe3a54538d10bcb1d47b04f505eb8b45fde65314895b48dbb461cb10693c5f415c5983f6927c2260187648bf4ca193e6b10e225eb02fcb176a0178cbb4526b7f9224463e2959830761932ed027c80dc77e4951986345d7a7e128812810d108b96acd30c32fe0f5e3201a8f62a96f1890cef83ab20305c889ad839f3ce62c55cd877eed117ba7781bc4bf98b8a6af143fff69cf0cc70091a712ca2af8f12eb060f299606d63d2baf82cc31f7f3328a9d5c425b1cb5b47f4e4986d65b49c000da6acd3a37ab5b29fd3350baa0a61a9e826a1f8c91c42abab8f2bb5a17a8f86577f177e1fa230c35144d9bdb075aa1550f36c735b8a8dc057ed87b2a8b2cee2bb2838b1ea2cf4d148fbf659c3d20899d19875cb0534810271a8f8b4d6afacb3e2362b3d0c55284a715e313c758e1ba1f9be44d92834ef2b374c807ff9e0c877623ec8f3308ca3eb99f98a3ea82370967a6ce9b931371fa98fdaf9a26e4db3f24f5258c4e9083fd3b780105c423e5897e9d7eb737110a07ea82c3c655cdd4698f29068fae3976d7a82c913608f1fd28078275e6018e2d1ae0e8a87150076196788623291b1f56b7045497ca9d6b50472b301a9d6f792291d37c3bb1783aa1ee03030855213b9c8bfc69fe89727f4209cbd922ccb45613afec197a47adcb57155735ce0766c647817f3cc0301a456dbef7e64ce06ba636bce769d8c7cd645287312a02dae54882c47766410bb1b80f278a86f76b9bc8e6e7d702cfa93161d7e93b6c9bff3db92931f7ceb9005f25f8cec89f65881394f62b53cb0087daa115b2df61b1fd8548937d6223000d54851698d7781c59305b19a6d0397f8a3ff577a8bc039da935ac7ab50ef16983612ffb6a9fe4948245ccec864a381fac0139548d4539006a1d2989d691db00857a6d9180f22aaa2066ff2e4b9e7dfc98ea07e423bce87a7509b454fd5ccd49957fe7cdc340bbd4c2fa097a0354f8e151872aa28e0a7b1da7f7f45c82526fb61833f9c8ff3ee79dbd8900ca868f1cc23d74f077fb011efaceeb61c0e0a3243e79869832ac091c3bb3529add784354cd33bca6eb6bb6767dcf8e1ccba92146ae9e2148b548072c40ba0c504eae9904d3bd034d44602add05de044c7cc45627dea45a9399dae52a3dfcec6853f3c809e5ed39c2f691bbe82c9b6c8393e68065aeb4ec4fce630da420d932e0d89caf9a56c8f9bab371fcae871c242c8c8533508af44a04c794f709106f04c0f0695e54079d30f0b7e5b6c1c9434dbcb1191114077900e4c31dfd97f6064335272773bf52873ec3c6387669c9df337300146209860836fcbb682f5323858ec723a52bfaa82a9fb8bed416b812958b47bac69caa56321cbc06a6d3a3166a35f1c3951d2ec72f40fcd47747c2f6c4f1babbde59eca57fe3b704ab7360dcc0423b0926afc7fb62522bbd25eb5cade18926cab1315625b7261a86d30f0a90ba3565f0819dade8ad80add855465fa3bd2325af9ce95f66fbaf15b0beca0025e0f57502a03d4ab291f1f18609e80c0612f1fe4e8a47d7af8b464b7ef4d42117473cc3e4d2b4334c4612f2ccda7858f68a42daa678603acd1904f551030d081d80eafc18a77c2df974262c07c97c4a1739e45b1c49c732018a97d84e63b2dd6cf5a672a8fb3d68465ed4c04d20dc9090d4a0238b8dd08b15ece60a4fd023fb5f982b44c37ea2103bc30f081d15976320c018bbd21df36d098ce2ca227149179b4b4ce08de9ceab92b48b56487dc3a18677c22d451e949a6d50aaa043f706ff36783bb749e51d8674b1c6851f7126da54d3c67137ec5a037f33c8ac1f7fb697f70702d9240ac7062374f450a82de227abe45c4cfb8e20e9e8fd6d4539b962f33095f3a03ff8fa7fdd9fca7c427a1822c2972740b3d270e407f8a6319c9f7c7adbd5b9e2d53d213862e7f893ba2883dcb5eedae668fb353143ef1cc3384500d9f4fa977f0dc4a81578637b3c56b1b596ff4c2b926b3650642e0fce4300158cba2fcba0fd7b7fe85a57efc343a49a1483d16ccd383707789a9f5284b9fad8b1e3d63d9c85f1562d0d23e81c08537acf61fe1fb579f2fb20a6fca82a1ab17dbcdf4931943a669324cfa7c4e627d83548a4809ffee0c4e28b030e29339b49523b95fb85fdadd1b06d227aa22fd1ff2aa338f77db178dfbe200dd6b295cb3163140c1ba7451f8a0776f3caab12253fc28483eb80c682f958fd83e43c3aa60b2913ecb297061f9379785143596ff0bd4a6b84172fc57a433961f45fb3e58ca87710d1d035196d280b954436c899c2156a2b6692fd1ab74f4ddba1019163c0743341357a063e133b47b69cf919a3c78b6e2213a7638438e69948839ab858367d8540eed4eb40df1451d9958e48e8833fc9d9adbb4f846d784e8487091a816dbbbcb019e455badc504152d017a93e894d2457fd3a590440283bef8a24586207c268d23a6e9de567de67beb89a6c5f375fed4b1446fcbcc1b933da8b473005964506ee50c8c17ae609f382a566f7db87c9fdf2f9529403a36748ea0c6f2e35fc68369cea306715592a79e244ed805dd182c7689f9ecc94e406b5be2f2cc42725004545e30136c6bb4a7cd897fac486d7569727ae14f48fc0f56c2be85469df31ae105007d5e29bfee070709cb12275bbb668ee780adb672d499a90552261c802c414b61630b085b77eeff24b852bfb9bccffb47ebbaae9c45e48b75938fa84addb66b5298160066bffa5eec079b79347f8b0919b17b033844bad82134738317990b7698886b617ae45efc2a205627f72932e47edfe13c33d0b462c772056bd7650234531a3a033e6637d592b7c8a4f1297efde23f57f5fd61648fbd66084d908005fcf9c93e48082943ce7047b6e1875e5ace6a421b04c96da066991d3bb0e13903255dc57d8f409ffd40e67d1858d4a9d1621d4adc12224431f788cbcf579c43d4f57fe5df732ed10df209a0ebe5219aa58ebed97ceb88e00968399f4c5d5ef8130252271be997895b9d37000344ec1c5263d9bd9bf90c88c87229d0c0cf2cbc39024c79f3115aa8386a283f86312b487c04f5189f31c9e0e3d61d3b51befcce42356e193d33e5f560bebd34d056884544c6fc3e25b2d55e915b4ff76636b8c52a2f21e0b5132b5426eb52cb34f6155f0f16ba342a12d8303970a9f5c3259e0447a730046128ff7faf083807999bfe8d65271b6d886b9272922dd1724ffec844e576139fa421a47046ab0613131b5568c98a34e9c80c4249c2aea6c81a373c1d357e94cf918731828dead0c1a315a05803eb46538fe6e6f24753c8ff7b5b542054a0e9e6b55d70ea264f4a2f4cad7d50ca7077e0632f02a164336e37f69a312019ea263b1e5a0d8543d4ee38f5ccb42815a8eed7e01b745090e46eb06ad9bce0768ea6ba5b5f15f75d55bd9c2892c67553752d042e958ac200eb0ba97c3cd6ccddbbdb7794a13488cd5ef959a5b289b1de53358e46be1f7be1adce5fbc41d40bd5b10d2208737af48fe85c879382cdc53af0eb756e0c9bf0e581b6389c9c4e7bd451bba17d247f320897902f2d85d0c71351321a8f3d9e5ef3b05f45d0e83b07a16d228ae40b8f25ccb4877683bc324a1906850c83a69320df48b8c590dd8a82763705075c6f5f546280cdee3719bfda29b5ccce4f73bfcf6af3c6a170fc5f36372abadf7eb6c450db112c0f00e975909e544f6a9215082547179bb80d31d5ebc1fa38d50d07947e70b2d446d7ffd65d32965ff9dcacd69533d4180d36e0ffd9288f48549073d781de6d5615cfe6c961e7fc9286746b050656761bbdee47ace00cad94f66dc1a4a58adb84d967cf312a2625b89ad716e121512005ef461d0b43999c0769a28446a20d88af76ebf11453a2ef2f952066e192cf6194564dc01a5e38492e7019cf04d548f0d9ab1ea8afea2256fa5339f8215f3ca3cc0fd851355687ccdffa629bb7258b1a4fb8f35dddf91a882997df1f6ea1db5022092e0250ef5686c77feb3ae2bec5c390a30e5a33dd7bfe2ef23cfc77d894273827bce34c2b35ea30232a12d4f7585567815b74d8a5394004130a781c4629224264dacd0e4da0f1dfe3196e9a0bd8eb71fe45bb668c4ab0d5765c95b37939a2083def4420ca0648524ace0335476c9f014be711a0f27d61e0987881309f30272ba641d01ef89f8f82e7dbcc3cc1f091c4d6a07ade09f34e4d0fb2568f78499c06f366b5ac8f07c0969835112723576db6d914de5ea1ff38f3a38cdc8bf2067f857b7386d08a06f09e1810b139f3b107810ef24c0c091a3f05bdf4df220d362a4639999aefdbefff68ffed71b1a34bfe2fe9e854824e479a815ead1a875b06087c870b558895cfe6d7b79308032096b321fed463496e9bd60cb98a662d2ec359f6635d66422e8b4122761fc15eced6f7f995f1751c9cd777845c1730fbc503325344672e3927ab57899cb5114efd33f53e2a072002fd9fcf24e9f05fd3f1bf9c4c5912cddc70af3b8d339fdefb5561485fee37a707d318e35ca25811f39c6203fe30f345c6910c290f4966c34bfa5c851e4c5b6e01d1c157da86a08010aaae7f0fc8d5591a5161ac9ac886d99d0b492cfbf4f850ce3c171ef081922c6d95475f5efc5321d35c2eb2916000a1513b426320ca82fd7cb73b5ee20cfd3bcec219b86ff74a8b8845a8f5035fd16467da7feafc05296be977f7b7a7df2343a1f536a92ed210f41cdbd4b311350e64c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
