<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"76e57164f85c2929e4d59ca021639c77e89589496ce55aeef9418907b56ba068a8e7e373c8aa597e0794bfbd69f97119f83c2b25627eb5a9947f1ccd2717b7317d5ffa190f214b75cee50832221bce4d38080e47c03b963cc2ae5c66c0e631fda5b367ff8db07ef23431b998b34ba48fe3801180248f7f4c423ebc895dcab19b52465d072e0b2ceeb7e5d5f590781580aff0ea69ec2b0764a92538e4a55174d765cbeb5f04bb569d915bb6ac0b54ae1d68f72f66dc9e0f1a99e12d06e4611f4b4e48756a071d9c84c76a77e3bee74601ef631dc25fa2338fda31f5c4b720ec15b1ebd8447f268bc6e30b0a7339ae7967b7e6b026fc2c56deb19a73fbb29736fb0241e7ee9c1e3df68c210859d166ca9852e24d252dc5310aec0906b62a4092e91798d232bf8a57df6d51b5caba23ea253361ab1b51c25c4da121e9d951b4639a180ed277e54e67dda4bc3a14f7baf370bf2979da96966c38c0fb30d348a7c012b044b4240d1adcd99cfd7ee79391678399a015c2335b08d1cea26f257d6f52bd5c2e585f8a4cf9216427b170b02bf6a2841bb7520c8fa83da29622a104ed61833c9020dc3106d330d8a20c30117bc208cdc460334325898875604de100d3bf093687fcb1055d6347123e3a1c29b8e2ddd2f147c62a6089a52a71814471a397d3d02f7bc69bca72842258cc110e8fde3a00ebeed1e12e3be55174d9227394644ab228b4520b08446bb78a1ff346704a371060accddcf851433569c0141f3777f0612d784fbbee5b2c131761064fe12a38c2ad70b50b14011c45188e8201937dbb76b3055b1b1a8c32217d17319886abd52e7ab5e80eb0fd9a7cafaee93be46ee0abdd44da03956aff8f89771088a50564857838404a107837b34576b1ef7954997b08cfecc5ee790050a2e4e2d040aa92d10abe831a03e6c8822c2699bc915e5fa2e336f033d4486b7d75f60ae069c76db1621abe64dd2d5aa898b4d8eff593af95e0075dfc6446420949bbed2a1bbf387db8a2ff03e0af7187a9e4d3e20165654a8ef66a40f957717316fff906310ba3d7bd012107b08cfcd6328827c1983881dd07c77c8a79bd67663bb1b22b3abef97d5f3e8f0946cc24a15a01f5e3ff2095a64de50b0d86ea92c0c551a1abba7a22dfa6bdf4fd1530c6cf9833fc8311ed9ff759657d2589d3f27892588a7759b0ecfed87820184ca0058d745e00710ba3438008f31072f7b9358a389e63b73cb1c52b3e632b218df725eeb3e0ca201158c80cac28b1f18ce80fb2bb1cec51adadb980519012be78ccbdcead81f10e86e0f12b4d76f612df8787e9b6df7cc6cc32083553abd66e6ec88b1cfd271f8a2eb0e7cd2fa7f138c941e1336bc58bbe3ab1cf280beffb8ddd1a86aad98d82d1f71f19a575b015ff8e961f8c26fedfe18e54c501b6140a4166dc2ea70f9a3441f3e771cb9b5c639517c085ac183a4685f0dd738d8b66e58acb0d93ceff5212505cb7192d57237db8bb0c4bcc86df69b0fbfe0223bab47b3a0728bc4bd8bbfc86bc43568326a703409fdb139d2acd8c317b8407412d6b3874f677c1b57da8557d8b91bb3ab99edeb15ee9bad0a2ebf139d1ded37ca27988df8a848842f0b9593604059370f1602472978b32f8268003605fe8da982f8922fa31f28ac679b2e668b9097ce5899ff377e1e8b1d2a1e77780f177bb26bdce80b68b6ec6f0e55e7a934f80e8512d35c98e70fdef1944db70d0989f04f5a122ed34ffd27c731f28cf0a34730cccd76a313696130315d64adbbadcf175e466c005bbce4e969a3ccef2bbe4372f5727ed232dd9165ccd2baab5eea622aacb918642a001cee098e95811e79df21e554684b823f76fa57c657928d60adb67c2b56a4f638a02bfc7e89c9cf33326ac2992a3ae60cebd3d4931d4e9d4be880f6bba352a024f7886751328d818965edf838f7437a1eac3c9b3b7672bbeb1655fbcb1e4c68ae08596775f369ba1fbac905218ce7aa6431a840e72529df9072e3d6f048dbeb7b4ec82ae149a053bea106354a23a9f3acd7d7f1aaec65fc72ec4df1483d5539688816cd1b17e767754d363a49de68c8986c3168833533f34d4f5c8f4de2fa00e5b95ad8202d19b83f745c52708d8421c87028d1cc47103debb57cad447a80277c6b1cd086951a9aed2669e5f93aa5791f5cf59287624c0136556a7bba066328ba3658fa9b6745322ecf0d7053b965ad51cfb3182e84deba601c4cd52fb97acdb49dcfb53cb5ee4f767590d3b31dca29476a0a502a44ff77e07a2fad686c4dafcf957c383d285ebf943d0c8e4d6101b72f5c8f89c6e20500ad51178bf98c10e67695c4e160c3d438ffa93b4c5dff836a1a2e73ed3be22436532adf00fc8bfebcc8fb182c9388bf8c5ac081f9ad06af5555d48c58366f6ddd5733a8db66f5afa027c845acaff959dcb7618c6913cdc89c8dca96909b424803b3fef35f70cde006835ec5f3b8c71c6b969ad19097c766be93ab08a3a52679d8ab7e27613030f1d399b78890b411201d9a59bb29cec6ad3a0d7974f2287e6848d8ad3a47b7c13eb494e6d0a0ee065c99dbd71eed666b32fa0a86135c983a274096877d0d597a23b4b4a48b1e91bab49c85a714a8157def95b1b526cf76bc7ba39e7afffb2f3a51a29150d2c64f134ea8fd3b43c4e03877967935209fe40f8468993f428461e826cf198b69f933d5f04f4457a19449ec708c3be84e868e48313622ee5e63458dab52c3ac8e5f39d4ecb4d93f5e7446dfa57192dd9532ee9e989273f9d618a367bf72aabe8ed82d3acfbb5f964eb76fe7380f1e9078b348fcb39ad12663a08ba2085a41022821523f35310aca4cab4ccc21f2c85bbaf79f335f4e563d988643aa95b17845957fbea6c30212939804832ae9a44413dd7dcb0a7dd49fe03fdf7104e495ea08cb3d1e1410291043e0d72aa20a9498a3070ec6adcea54e8544bbe3684a668a5d14325265eed4460c135a047150d7a5ad0dd5295a5e4d17c68d748954250d6bceb13a47cd4e4a2a5d98d17fcc473be4fe7e8e648646bb7c83f9eaae221c2f9bcc240f29a43d718e899b89efde92a506a538d24d2350c44dafb1d0c9f0c28f087875926d365bd2314f29c6d6177e8c552a73592af9b063a6e5e33ea593332becbf8877f09bd661877d683f6f183de59ed4209a75a420cb25a6989cd44471ba3b43714f80d0960eaead5c4f51cea12fda2d4fa06b37e9e269dc61e7b037b6704bb9abd3ea6f369140fc3d0e5d20d014261e61a8a2f3f1a8c53aeb839fe61581d4ab32706e2947344f5f7205139e3a2cd3c724675874f258e0de7b8982bd13e6d458ba3ed80df87d8fc1a59e4b971769b261d276dc2fba9eab30e9ff3c998df8e789f79a35e4eb6f42864f26236af39d196e42920dc619c79d1965a907e74b059e94216a0bcab0796cff57632f38a46f264acee3ad64d4db33bdaa64623b4fcaccab4805b3b3f1d6e432a7619f6a924f97c75a1a4dbf75b298b722811ce42dfd59546ddb04af6abd4ac9822a1c779c88a7206df58daae717c653b16e5e8feda6bfb385c8759389264997d0897ccad594efc3e4ed6367b75c9dc90d9ae015ac5fbc3d4c2be30624710c1dd1178af96933414643db288fbd0dee5059a4adf718ab7c334782834205ca586dbe997533c96d67780a1a6625fd0f4cac80e50919c3a32de0c2ea1259f57bff15928198922ae51025370365793bd0a91ea62f1a69c6c30afb01412a6a88fe4f699074a11478881f7815965fe0f78acd4dc92d252d60188015ecbf96f4b2dbfed6c71848d5e98fd789c6a3c4f87ed4397268a62e7b2076c3d3f3c7d16dd61a32206d6f8bfd7ba7b061289be7ad15ee11652dc20311badddbdb3e0c13613c1596c5887ec8d86ee91313b8a68b185696b346aa6315ceedd4ddb65aeaba5b8841645488b55ffcdc1357c8e201d6205a5f68f2be4cabe64af582c4fdfd7e2560e36866e752c0af3eac11233bf9cb9f9b7398740c0bab358fbae8258aa0d9086c6254d77b305253b3da4b08fded3ddfab5605876b997faf865b5b9e9bd03287310a759f76c24fe4a144af4584f6baf1756d3fe1cbf7d4108ece13456a478570d537834c0d35468fcbd85d0970fbebf31e6191a689cd06d02f01735d092ba11c551eb96f4e992b8c20aa984d25c82bbbe23ad2f75c5cfd37f62975e01e737ece57ad69a10a04da8ec6e86f72186d5a9cb45a126f858fccdc11a1a92f4e5b45e30b50f3badaf90350d41cde4fd5e0da713e7efc3239d9e4f8d1d1a9c4fe9ae65eefda494ac221c29b55878a32b5d69ea31071d57b4cedbaa25fc49208fa34103d9b9df6600dfaebe5fb059b7df6d8734a2dd82b38a22a9a020c92db32f29ccf8a960469ee16f1e22705452afd91e736590f41d4f35248dd4a997a2e58eb4ef73948e6e5134314fbf38cdcbd5ea25136fe7ed918079533bbdb11e0c4fc8c6ec13ab02e66677eb97830902557c8cb86cf043d1e94204796820d6220f0d81daf28b6ed58dcdc6570df307571f877b5316dbf7df70f759e5bcc1985ae00798e37efd60ef58ad56f2fb6fff949b8add34bacb1d7c499e1be223c4016bc8320adf6cde7aa51709e595fd0039c54aba2be444513b6230acc4e4d1feac16b17bf7270e8896ca6418746802f6bf5482d0b262488b7d0db570ad1dfc8ee65f89963508a9d943d2ceb600af0e5d94c2fdfc60582e6c1470fefb05f1a4ad9fb5b4aea7623f75c2c4cb022bcc931e92940e147f651fd524e61bffa41a3a5997e6268c369ddbb99b74bbf4b5d9126cc81747721fe59c3cba27491bd32d62de706da2ca781674ffa5e0b15caafcfc3ef9a601c1f4837540ef602abc0a30b28fcc38f31712c92bff3e9011fdb6569c2b0988561a446c16d0b06965636228bc211cff59e624e239d1b94b6eb5084e609b7136a5fe8f96eba730fd47846115d88c7079f5d7537ac90b535f55fb18774dc00d0f30bbb69ffb2283dc009b7ec486a144a0b45a4626de9e39409ac3658fa6bcd22814e8fbf6ee07e4429ad50d3a67cf3f010b8c2a1b5cc16bfdb40ff0d04f36ac788a2738fabbc3154543450b0da5d35e7490c25c4dab8f6973b3f2b73baf3d19ecbfb70205d2cea10a61b74340d86f9549946e4b51ded420e85faf6094c19b1a25a1b967715ebf76a2d48d00110934c744f66ae115d84f65cc9c9dd549a7d6e997884645f0325175f15b6f638b0ae3f50e5fb45354c3279e410f2c6d27ca2e6d88c4c27b3191ec38590b0de3da1fbf3f95b9b9f42ba66216337d2559786424e7c61b4d82d3ccb3b2223175edd940247d7f5c97ad35a844395f77b7167821336c1f9ae5e2c1cb5047e8229c31838b003e56814c82acafa22b275119870a0a26da29b8f6cc0ef90f477f0bb63aea5770424bce9d7d60099944a4081b0be627b252a582475ba8fde7fa095e851eede0501f93abdb3ce8d6e871c64c7905bba68d532df36d2eea094a370573709d457ea398238f22b74125941b2f811d24476b3e4151f6f4894729231d80b3eb50c17b8006d682241b67ce555e51fc4da39f3f9c0307d6bfd4c846750bd01caa781b4e37a7b802a6b24d2808b9a72dce1f5c4101fc242e8a9f08fce3d35b277a6af5bf83d4e1ae68858aed91bdc28036be18f605ac60a30615687324d4c32e68dd3bb9dd13935077567a7edcbe6ba6924d485de9bd40fc000926ad31756bbbca6ff8f24d296030cb374c03c156e14c9d9e9fa303fc62f5270b099590dff9cc3bfb978489378bf523e93736a12201c341bc3fc35a1fcc3e36d6856474cd741342cfc769ade49193814283933ecba0000995789b97ce019bbce4eb5258fc69fb685391918dd4b3ecd377bc569a343952f5d8f4ffc478d5ac63382c17d99f0d1eb6841e99db963203834d8a724843882865283c3981b3a5476ff90c7f6da550591908583b9a0d83edfb1b0b2a63430bd44c3559e6c02427515fdfbf541e5125b161a418ffcf2b14c664730b66892fa75c7c97a290a6813858d46e0981c23fdfdb9a2f4c5fdfcca052c790faf17f08e03267b2ca5998212a357629e68e6f6d708f7d1739987e9194413e79198cd44ac976e232efcc11c8e6572e7e49717291fc29d6caad7e7043268865ed1dc93c30fa04daf81b465cd5aeece8b0b526b35c2013ada55d90803f4a6e3f794a8f89bb72fbfb49f408d24468c38d5a3c3ec3c624734b9ba5f4d6885dfc238d56179e0a5e67f63772bea84726884d33790ccdace54439c32b7345916cccd67b8cabbf1d39eb7ab694206b55dbc5ad864d8dfff7e21ea47d2aa4fa658d8c1c3359f76f924eb7dd019b71f3c50d88d0d365651ec219709df05d88d8685a098c27ac80ceeec827f5f1c62b107f40f4c233e10e5b6f3cf52d7d995e7b062b7a02d8e673671817d04be7bc488518b0f4df8d820228e27d1b123526380c0af8107507e6b6efa4d31f4d2c68e1fbeb92db7bba59f610a26f4fe8a9f2dcf55f0b7e367dcbac935dc2433607e63d43200784cfd763fe1eef645b41d6061859c9366ef7c23bcfa9b6c2aaa58db9671b0dd98b771bde9acfd3ab2b8803b491c790a0922e66a83f08428c19e4c9931b871fbebf780a670cc916c984210b53cfb4f986c830ebb42ff618b04e93079a98ba67f862e37e6c3703110574d89596a4a8a31a9d9ef5e828e9153b57ada93e540d0f854ec085024ecd4fcbad4cb35198d085502df6487b200788b4fab7cd7bb6dd7e3b4e8270768abb7f8a740796e96e776482ba57114f587f4e8c9084807ea638534f0c1ad93652518a970a4277b7dce1de9c0bd5ce44ebfe8a8dc4a2a9f040b7870209fc047c2424433c336a86c3f18f6d1918c34ac139872ee17e4f05e8dc15dc9ec0ae4b3a82747714faf36a785267b4b765506c7d7452aff9c0c755f3e24b03ca390fd7ecbe70da269a9d8b7a9dd38e7553a518b9ae842295733cdb9956d3aa7c8eeb9697c3809325ace034bca2d6e22a11d74a009897f095854194d422846f962c7c8faa4512f033f2a75c661b7a792cc197c9c8c39f6d6ee493449c6b9d30d92a8e1db422af5a29749c708cdd87fcbdaeb087ae5dae9ba3c1d38758ca20636d22e42fd9f8b551e1ff556bbb31ae1f3d0cebc001ccc10ee3ab7e4ee6f8e5768ef0c4e21a24143a92d19eb70ea3849d1f59a7cbc255eed3529cfe197515d4ab96d1a93e908a921f54036b509ca29c9c5b7a214c22400d3c6a2b9283d9417978cdc66343bdbab8f6710686b695151e0bd4f95799be485b8ca58d879ace5d00caead22266ecdf395224cf3ecf33a8ad0fcb6a4913023987282d35487e663bf84f1ce744d70a879f3ac2818d497ad5268ea8308d2fc7ff83a5b45814f8e5f6d31607a202f00c74d831e7c6bf568c420fb864ec33cd696fc44214d642c4cc9544026d1fa0f76d62cc47bd76bab0918978d5872aef6a299408d6edb4ea5a7fba368dbfe9d79fa51de86226015125c9754d1103cfb0ff5042e6cff47cb513253cc6a92709414b85a1eebffafef015c0cdecd0448be16063123c172c02161a26c2a04728f1f95426de46700a59974696b8afb2c45beb2e698b2fa4362c5abe1e0e20e95f044ad2913225efaa71233259baa0091813687bd14d31f44d39bd57630c5a11515e745bf8d2e88bedc738b14de248194c16cdf8d53c45ea9e1b7a963801fbbe8162cbb3e6c40ab0682a13b9621a1d1ad6aee30068678bbab50414a440f5cceede5286ca5dd9a74fff705f84c68b537a87606bf738701c82101f06dfeb1baecfe78cb70817bc78e6d47075633b9269a81b5ad4538656fbb1bc536088dc826dd3fa5d009781b50647e433cd7cba26d8a43e7a22838f503192373b242891e35d796c46757124d7dbd5f7b246cee717718298dc1a4bb9dd63b72986300c5bd7d72ee701d893048d27eebd51368a2b90193510e6dc1dbe11c65cf584b0487f5e3116ac53db0ea8bed7d028f0cade6b7860d100bb07e9bcb0e7d3a89313579a3e83385ce94ccc2662e7e058a0ca2a005f9383281566ddcb20032911d3bd80d175f516b9af53b26b9d6b16c07e3b3e2d7399f1949cb8e3d66d70fa2a1945851275569bab7c37325a1c884e32a94878c8003cc0cda1f686ed05096567274c40294e3f6a11f631f1dfa332c4f0608acbbd854b97b90b1b8512d271dc82e7f219651d7c785dba0ffd34be871f8e4bc5532866b549424c7ecaa702b9ddd7cdfe33644be76e547b4e869c7cb5cb89f2ed1ad6c5546155fe5c2dda7ba09df76837ef979321725867b7b8b8c52b378eaeb07397751cf46bcce647ac52d7b9d4b673489ada992f8fab0557e3dc5c81c0ac5e4dfdce61d88bbc0983bb41ee77817ce892cdfd6a3f0dee7b79872229c78bc25f7ace13b9a1ec0f121f54efc74c5742e9b95e0f90b458ad923cea1dcf1a253937f741d90e88798759d8fb491e1dddf9fa1f00abd70f95cd9cf23ef40c508f1c377ca1e74c4e173af5ff381b6b6ced67ca48d062524254b51161e69328d49c7905788d38fdab0c8b65acc008e350066344f4180f16eb1415727ce7ac6780e70ed830661a8ad61ce51a25caf13028520fd00a52426a38de1084b776557de2a5ce67441c9b421df009ebb904d33d7495a4244658dff7360c64fd4be9832567c535a87e163a2486d272cdeef79e608389935dded2af58a156ff3a14659450e6c00820bcf0989b0186e36e4307755ff6f44f4e53dd55058e485d5cffb23ba1578b2edc33147f8f28e5a92417ce3edef977716f3b6447ba5213c1f54d4b7d342a6d1edacd6b4802b32e77d3ee83b3c63ab8ef5db0c374800afcb9aa4867283a4dad9fb16c30bfe17495f0593dfa1731b7f4fec458fdad3fd097db26b141e898970b8d74a4ab47d2a546f8714004e4377458d0f45a788303d111ca76d29a7f1cc418d7b4a490a572b2a91ed27733b93aa447644d8d161f5b314577bb70e0efcf42e7d40b4205f6c58b13a02e887c7a51b875c37707cbe696c2b5fdca506930c318e285788e2d204cdc9515574aa514481e3cc7fb32c5e18014b86d7f9b83f874dbf3fa8e71e9fade40004a370d182bc1fd5d98255417ee5900592f344beea9ef13c8780b1d9af97d8fea091d771279a14831f8a6b675d5c94053bcb918a03835163567bd3c0dd55cebc53fc459d47333a0071d05925c5a88cd5ad668fcd7d52967d0b7f7d90609bce9a976ad7b7370c6e934d6539bd3eb4eef58bbbe40400b20536a16048514b83138b691d352b29acf6ee7e6dcea7289017fee3d39facd6e02532b737c54e7d9e217eddd16808e53c78d8834ae66e3231c3d4616133d659c489769585cd189ce86cd0ca959f18a25610b180c6affb02ce9c068dea627ee8b8bb9f645e74c7025977a7aa3a84e4176f6bb8f62b872ca13a9e6e476eefcc0ac895a6f84408dc5fcaedad3dd4b8efd8b0e81d6bf17b6955a98759fe4cb5cec3ee78fa36845839e87c359f1818e587bedaf4e6b5a26157ffd5a0bb0c9355fb0a63514eafcaed19b824415b2e98ff6b2d5521fdf2b6ad79e2e0f76ad59617c6dee1802b0d8910f2c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
