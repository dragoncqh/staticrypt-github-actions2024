<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0d66fc1235b49b05d1b7b65df4f22f75d9cccece10db54190b23dfde9e0f15e3b41d46dc4e42b1467101bd0cfdfe310db006d58f188adbc29404bc58fae2d46c8c93a6ab6853d99fdbe336ed560cdf79b1f2faf9f72e895f50bccb9bce009f71bf0139e9cbb7ec9cff287fd1448d2ecc8d18ec27cc01ef3df3a53b9a019d7a8287900e3775edbc1fcf75f18c10484c1e5ea1a16ea037893f5b16a4f06d9fc18a75a21f01016bc9dc307308c1d9b0386e85a21fb654de9c83fc2587f12c57562ac2fb5e04dd44c0ae2e7ece06a3669c4019747ebfa00c777ade6ae6e9bf3d4301559dfb0ec40d1ee9b04390f80862ab03e2bce7f1c2c41b17475a938ce01010fdf255dd6497908bc52c66f1a736e6674e3b078c1dc6ac16a4f9de135ad50e2ba530d9f7592ab2e638715d83055992ba6abccaaead221f84333bd4cba70531fdefd471058641969a73538c52674541be188a17f91d084054cdbb2bba26ae2d62857bad7e6264a9403b8781bf17bcaaa30d29eb0998f15c6ab9c0837eb125b75f069c1ae8ef06e30be5e7aa2350673e4b75367f6210cd0b91786adc4f96fe7196396940c57c6d02428b006d48c5cb65a9f94fe43ec48b790bd66f7b1267d0b023b0f51519cd505c7168c5035379627ed542e276cd6dd5e7a3982c83425abeada1bfb25e77990431572fce10fa1a853b099088db6b8e182b46762cda22006aa1036dcd235750b8e314ca921548e77e08600a6af4f8c47a4271aff1593ce4ee2ccc7b41d5d28c2b14c55dd7c753cc8f075393f7be6cc24cbc8de5a8f3b2e4b4735e5dbcf28e3f1b9368b1ffe9486099647ef1b3456fcfeb2f8977fd4b546099c686a14ac917b85014e7c47f2a4099a0239a6fcbf6a4ff68b77b6deb0fd927ae06ac2c41a3bc351fd810f03a9175bb2b699a1410b0a4cfea4b5fab32a5a65cd9c3e58ceaa00576e7d9333315f89c84d81ce61858db8899a7edd6f66f602ad1965ad64eb6414981533e0cd933c2f75a84fa75db38a93d102eff354a2a8d87623a419c8886d6155afed09d1afda6619d556fdc17c6fae885540a84602262fc3319c24630d1b6a39037b83e040b722b3d5e719ea466e3a97a1d25093c73bc9bd81dc5eeedc4ee9c657acb065ae5ccd1233ee9060a36658203a4e52313f6739abb69f9be2877f6654d27b8761b731a4401cd30b2debcfa45c4a96206d7380d10bd00a57707b2df8b70df41f706476ce2fbc04bab23e3f3141aec1677360395423af86ace08685ee6cf54648c44fd3a6ad853d10c7b395a54bbaf3613cbe0e0f12b68cc988d3c1dc93ef3ab7d3ca8e741cc283f012f38b1b2a5fa6ba26cf62bba80d984f6b8dbc83eba8d701c8769132bde2976a4de8b24b590d76cb92a05bf7b42d41d7611be6763c6def68c3c861fdca232896b167495286e094ee5d6cc4422391259f856a99f6028fcd40c62a40fbadfe263084ac0d7a8c4390285aeacd8b0b4066192cccb8c2827a971cb624ed85e19d5a070fc6daea776438b7caf5472bf940ee504b553a9111b0e6e11c66d01630bcbb1bc0d257ec929dfe695e9f58ca69bbabd0517ed7a077ac9dfe1917dbf12df0bbdb96a4621ef99eb8986e3d3585b1761894693edb1c588d87a8ba903af60c3c788594284d4e3495de430645516372d932f690242cf97bcf70d62f5ed8f14f5fdfcc4474819d4b4cad79ee7587714a00ac3bcbe948c47993ca9862814e7719a586913317c1bffc8b0c66d1a635f2cebfdc98858f2297fcc06ade1afa430b06d07d6e8970d0ead7f59b09604c1693fe0a7b9752a3f3afe2c830d3c8d1dc7771982ab8acf7ff52842cf1e5f5b796b808a9cd06a7f6ced2db6994ddd5559ca36bfcec628daba75984fd1f44e836302d9d02482586afdd2217cb0d14c5d932c53838888169ebd47c53181d8f46c9ab31b4e3554cd081f567aac8678d7b19de032c0ac81ea772f1b4c32b093dbec894c1b9fb96e3414f0c6369fa943fabba4538b452f481aa3c49fed47d8c6e1c7bbd7d3663cdcf205e681c0d504e9e146f108d70658499e05278e853daba93a51aa031210e5ed9737863a4110845f5ed3189e3860cea51df1b1d5ff46e026a32d7c446a9af97f0a5b26e01dd900a7756dd12841dc55f5b4bb3d37ed5a1b0b9feb4ea7cc89c9202aa464216c55fbce9eb7871f980fd1f17486fadab126ff0f51b4ef90048e7453cac9d50c6ac91869a59e9526a0bc280922671cfb54870f34cb22782ebd9d2ee710ace0b60b5896f803de8cb28f304e4797a5f48a1aedd95565577e7f834a280e9c7a42d9bea9c6d8d4262258c8f6bf4ca69e103649c8df98809f2b1d6cf25be8a9170c5cdd4e1c242072e54f89fa71cd533646ec1d676f6485bcf7b092622f69b1bc25afbc6eb0668a4005dbacdcaab34faa795f45bbd64e02ff14e4343efda5dab7b209eae6710173fc731906e326fc36254bddfa680dc37e0f6ce252240dc3de1a84cf10bf70a821e3aab164c902f4ca84bed4b8c6dd0b861ffa03c93d753dc50a0a0362eda3ceb5a0396f50ee980bf848e7a730ae0615476f4e46a4ea91cd8218cb8be01dfe9ab8a10ca740d546e3ab17f728071d1a1c45245042e7bfca4c19c8d64044234c0a3e5127f3435bb20372f1cf9ac70e2aaa69d8b6b9e457036657b54730f7a0a60bf5cc2c63272dc6e7cfa9ef96c905a3ad25ecd34766a27edfb84ad37865e12be6fb721fccc59abd4d0db683c1d22ed516a0f880d5ecf1c6c502e534429b40774d6cf26b4a450a37404bb3355e0eaf6a744f55ff97b665f3c6d194498dc8e4e39358d9efa62fd384689ab68127ddea6d7208ded12232c36085a34c2faffa093a0f58941135a757adfdc902c60c7036d802727d888eabafcc988ddabf7320de50e6502dfe1009b5b2f8a185d495a262da4d0ba11e18f1f220adca226baedb5ab5d344747dba86ebd31b9f71420eb8997f297ba858e7ba2c19402e55aeea94bdb2cc67ad88043c6894d3d9954b16c6347b4e003ef0ccecd4205999e52df3d7cbadc3f9a75f2183b31c4fa700952e7fd6e20e167602fae867e41d4a36e3c0d4097e144735c8af7de763f964680d8ebac24b08ff81e32f8d325e53385539c17a54284ebf1ac8081c80fab961d1da154d4789515b4375153a1006cb8fb62389c65163385f616c5bc44e0b958ba96b5ab93087b03b2200c6b9ed88309131c71f65cb0dc919b17905d0774eabb9f6d1ffe77923f38c04d144c91df829bb6102818aba0de7e74c64243424b6695a58addc3d8f65df58548501fa80fd235ec688c1b73187dcfaa7b11c616c24e5b43f77fa1324750b4c9e835ee37fef888696e8504774624a02074bc03178b75cd6fc1845664eb772422b2da75a633b0b534dff5af842e4ed853716d61f9d0592fb83a79e2bfc55452c4363810ee7b46dc9c1358a5fdc7604beeb64e8a4d209e8c06950c685227177f8e0eaf7039df22622071d1d7dd035556eaa71ae9e815e6ddf7db7efdf9428f2c05b65b23d9a9f1f83bdcd2e49ebd8bda20b3be955d396d5d000fcf177bc4b617aec3d9be68ee80478ca6e69f0916a5cfd1c2aee0fbf7b9efcf5c90bc495b60b2030d0887a7d5f5eebd0a3d423c85771b9d906c81de0dc13f74de4086dc7721dabab92408c92a35e551a2326b3296c22edf806e03c423fcfa07041cfa653eca8eac6aeacfbc1f8df2392e956dccb8179f18e1cc05396f7cc39843215b9a243888f2d9c655dc084ab34da8a0c7d5dbd3d28e3aed536b6675bea85907edc19d85dde5b75885b75c7d62764a0a134de805b60f1281a9294233112bb04aa20f0f02f11f7b3af02a83b7cf059f122d030389861a537c239105feb3ca7e9c9c80da6be28341427d60b1e7e3fdccc3f2c17adf70705b2d685dde4a09dda281cc5dc6f0ffc927364c63122412c71a5d94363ed7188501e7fb0d6c28113c34cb01c1428374de3ece448348d0bb735929228dca899c404f7fd2b38e1a600146e3c4d647c01e74786d5243fe22b068bca95c7b5e3017c2466732604667eed2b407555688a1783432778e09a9c43df1fd229414f83117866c7b9ec4261e352dd1625ff9bd51207e5379171759a2cb1fcbac7d13b791c4aa2778fa3653bd7b344fc65aa447015a32f8caff119c21a1021c488737db8877aaa058ee60dae1b739080bcca2b2edf2bf7b8fafa800b26b2dad9ac95a5f175f93de97d7e8345a9652e5e9741ca54c5036c2d25ff91c0a21c099fb73da0447de1ac66cf44e667fcac04e1764b0f3948f9aa3cd67778adebf970c9deee43a40910d3c42abc41366be104aca428d82ba674d818bea2f433fe4643df89124da20c21fd4e3ae559de5c9b90cc9de910347031f0ed44a292f20297ff5251732298a07ee811c02286bff1b762c1372f040de3f5865adf36d45b7a234ff2f1f1691fadace3336bc1219de8dd6c4925085c46b86ed5f276558c4f2b7832f758301cecbaaa0e29e19f4b97cde56ac8a02afbe21df1526acd65696eea034246769d83d10aeb0b44f524ad05ee261db9b11c93c9aa82a5c688f1aed7836c3c30ed2cbaf56db123038a82cf88ac42dd6978f563792882bc28fd5da62887498e8d654153d446997adf88a613aab1e6e9c3daa24db989129f611ad0336628dae46f150c9e6742dd2feeb2898ef8991098350b50dd48c45354f83921d76e41339e2902c086b21774fd63a145e763e818e00aa79a1ffede0b7f0f56512ddd5ddec75ba9defb67105db7f88e8069a14ad88bdce79a4a5f67c1ca1c15681cc1acc684e55e13200307eb8f93a8dbf376e725ca0d12e71c28faad1b687cc4e0e233107428f5ccb41f7954539fb67b3a548713a7ecc991f9059a35311fab82b6877409a4446db36c37300fe05e20aadfec1d676280cc4d35b563904b0c2d18db990979363976f162cbe9a7fec05e2de246bb957d76555bd525c4329629f2423a0c110ca3348ef68668b64534fecb5f2a1cd19fe261c06b4a98dcb1364afd5247c8771410a9ea446b541bd037ba083e864a6aae748c2832cc8219fe816549fec5b6c6299b538ce3a9bf2bd8fccba324d528f38d62c06661053421817d24839b4f144f64cbe8d2ca6071ab33599bdc5ca72adaaa4c1d1e2de71defa22bb00eb9b764fdec04b305f148c71f35ea4139bcf138c9782ca2560a55fffa37d44faccb544f0c55a9b4b657ace259866d73efb447bf8f74263c6cb40f61dc7231c7e74bca57fd8cfc96f6c17927c5cc108f52dfb43ce5dccd88be55eb6f035175626a789256b973c06f4884e49b036ad237329c35633526e98edb7b1d3aa5bf538577ad83a554194b97b5fea7bb3ad0864f2b11992f4e83966fe3417e4ee6f00b79c12afcbf855ba5bd22b543cc1b9c2e035ef7f6b05ebaedfe1677688009b9dac5a0016bed8c9f6b2c8d704ac5f00ad904347629e01165c0daa7c1c5af70668ea20b055df0ad72529903bdd96dd139c355cbb1817f82d68a8649e91465d13145671200e3c21ca7151eab8695383bbff69d6ea36ed7d1a313ed9c398bce4fac255d48474edc43711cb01465b9d116f413dbdc7cfbe5062819bb4c095ff35d69a0d09a0e4e86cfadac7fa5903279908581de9f3d6dec09d13f0ce9d50883a08860b7a1f521edc56b6e812bc27e480c7ebc4dfc950572c8ae00c3b01a3298e0f140e6be1e7f8d6e3516beb2e913c292d1bef1427194f1f218d31ebde44c774406c5d3ba5a00670f3b8351f11754b66185c77fe3bf1c2f8e9a606ff5338e3fb24bbb64eaea0bf4b8485d8886df8771897ea441b46fdf5d6e591bb7c8d2fd933a76884c59b9ed83cc039d1b908cd1484401e346ca98b5a8ff1ee4f5f984f33805439444ec003fd734f9271f53f633c2093e5e03219a65650ac64f3d12b016190fb24d77d96b769ab248c7ba7b72bf54c1513dea6d60168a8da3871831e80d953310cca727c3140677b809484abb5b4646b70697d43f7df86085432d58e5cec27aada73b5d9f7265c5d566ed5006ce61ad3326ec4daa53ae53e5017f313178cb9873ae61918c159b437dcdfdf13d8f85d0c44429035479792fd76be06fd3d57fbe64866bd545c0a494c635d20ae32e8b1a9976384f9230bc311dbe61a9f662fdd94e479f6f4ab48bd49fdd65a8b42eb076c7109766c5b8b1a29d896057255271ffffc2fd864ebd812a495242c62e2fd1ae1dd976525e549edb0f1052924d766947062a52af0949711d491c6a50e14700fa6adf7ea5e3ae1549bbf47febc479523ddca1ec873ed24896a6931c6b14aa9dfb8578288cf41a3129ba212c5c87d17a7cfb07413f98b5738d109fce97cf28600e07ba9ae11dd5a4fbef1daf40a3d51f5dc4685758bf44d65b3738015fcee2e2c39c13361be187176f399d4c5afe8fbe8f36589eb37b62c14f240db6249b016aee1dadc56c6615eb616b9cfb38e67027e312c48546aae6065266a812a6b5648ba013fb621c37cbe81994bb056c7719e4cb0dc53434569cf1e327f05a3d5707567407d4e3bc32e03bd1a36a89afb2f8c3065fb61ea0cdeca6b35c30730fe111ea6fd354798b6a749e4a71542125bfae7020eecc91a85c983f36605666e488d303fd79b75dca4dd05229e7d7fcffbea39357c014095afd2b5c2eeff5e1505368146f8922a77d98fe0a200d4b27ce399bfb1402939ac0d9a5f3c360c385cfb4e0659af903e63d7d412e9fc883f396d14861370bd4bea32062ec925f445d445d0d8cfcff65e1f2f821afba5bbca4849a8051c26dd282dd12553c2b0a6784bcd2365979fc7db92b077ed39198fa30fd2ccbf5201c37bb44bf5549021e328af653831518246013a2e83f02cd5f5955799c72b5a4669eb962c9a5ae2e93f3278e8bc87fbc7897e8eb5d311c7304056652e6191a50aece6696e07ffd1c85dd5456796eb33f06f9fea2c43d841c2356866353c5dbbd66cd4b4db15ae432dd703665638e0f42ffd6a298719a0bfb2957e326e05fd2546952f52b6e1432dcd1549c707eb74127809eb98a54671942cf91cbacf0128cae29729a8362a52edd9336719e43896bec3b3eb1342be95fe12e1f493fd42ee72f956c421afedcc0ea42a0a91f725ed389b9eaeafc984d9b596415407d74739df836df205666b987873ef309619cde4f94491c399eb9fb6cac7aec57583d7a60f6e1943ff3fb4285ef5a24ec5176f0c6aa16f52eac3ceef198cd1d498b32b9f42fe63b783ddcd086eb1ce871fc86ebd660bdd710310a2832c49131a3980651ca80eaa669ef264965dfaa8b5636f71ada69d6df50cdb37aed6b964c18bf2fe358692ad3d8310b09b51b388e2511923bbe8a8ee8f87d395e9e6d3ec07beb0ee3aec77088aad048f6761e78f674b1f288ac07879b7fd2bc65b0a539e9b1382bc7182552fea5211c1ad9f7840cf0b9d59a4804f65140e11e84caa25014a1f06960ab6a4963abf4f9894d87a6fe50b2ba9c31c516d180cc876bffcf822f59db275e6124b38b39ef49be9a18c8a5d9b3e499899e781a7d72824a6607eac68501c524cfa536363a50406cb0133c266fa7cc154984a8442a1a5e951ce193c55a56504adbd9971e7ec9c3dd7c8ad3f094e9c4d377c7c312aef9ff2426791b80fe1a18c2a23cecc63271afa2e246c302e33d7fae2a34eed962ba3064f864a4ce2df877b044e55e4acc2e22f4d4f40e26dea08073379b85861c784a2d20c68a9d1d9f516ac3c1b7531720f9dd473a72e95cbb8cd3745a7c3f948937d00c760a46f0faf28689eeb8adcf453fe72a91735c5a92c60322c64ea13f15f6bfe93e6fa9de47189368086f5a995db411c2216d77cdc3d2ef29bb96576ba469b73c453819014cc21334ab2dc067155e1e52102743080adeb3866767cc27127d1bc0878d3ad04476b0c26bce322feb5f5c2665f2a343d1d2e28cd2e0102095ee495a40c5aa9c7d33616932a107a263c34c1143afceae93696e0544474e755d5b22437229398441c5f964c60268bce26b081af32379ae867c492eb3e3bcfb38f13dbbbcb44253fd45b1c3922a8dfb484330280b2dc19eebdd50d06da3c253760ac84c5450f6d3363fbe7a813360a52426e5383bd0e600aa50019f2ccde6e89970aa934438f065c9aff6fae8e54e28bd548de3862d5a86fa2fdba27e4d53af718a968480537c5aa3681f836ce153c3677a528969734f1d238bc6c59db8f878ad62f85bec9f50c8edb20f18482ce7845e6f1b7c4efe6124fe68e8cd0a825e92fef2799f0f1ff171b36b55d30bfb251d4e246da2b586a592a6ba57d9356b590e3f700a36e18e03500eac34940f422b69b4dcc97e7f39c1911cd29017262376912fab4f7b9bce0674f4cbd5ff03f4ff0445fd910e03651b03c3eb7d6b434a3eb9d85a9170853c7883d26a8e01c77112b7ca79e427efe319258b4be76c479d601a055493c39a9898e23bc14428eb6925e699cfad8a419d21df3916ac0cfb4a8f566b685f4478e3d5f4079783b51c154d59885895d9e0c2707734e84efde40b876e2b466bee26257dd6103776b02b066d3d43d7bc4db45367eb728fff2bcf39f1cea26861afeaac81fb78dd89b7677177e135615b8d32d4aaedb8088430021a13973767066c748408bb4a8dcba5a103025a56263d0bfbbea3d4cc7a205b3bb615cb0f61e40915ee8889d68ae485cd9ebd7f7898e11e0e6215b4286d294fcf6cf983cb2795919b3e22cce6ba4d02da1a043f4f743b1f9908cd7d8432b5cb6cf0e90a1742f7cf36ceab32cb601eb1e11b24c75b6ef97c690435e8c18f1cec6c153ffe4bd1f731771d3c30abf012df0f191e20a2c416d61e7b2c4ffa076e035ae62c7535a308f5c570d0fefa47b6cc12509313ff3d6b5d4a7a452989ccb5462ee019930158b257db24b711c4392d4e3992c5e91f7d09071318c30941f05c5ca3c401d78bb3e904893628134c41eb4a57c8a6d29008004e97329c2d5262c18bcfddf72f71997d8f3de19e871b76a99a09f99de51b95cc0f1907c0db56a29080e6f1377f4add3f0324907ebb720e6036dae4e0f96a7f16ec4f6831b6a97abbbae7aa8aa5f16336ec85b0feff9e6ba7c9eecad0af83e27cbfcc54d00be51accaf041b34457cd9030b9914db65748661428d119efe2926b16565eaedcbe918f994dc1f1db985110e56faa553e071cff07510de131d4ae4b842f81b647d5c8925533052b30b733f7eb6619f3b578b4f8baa03d8b45d29d88b05e77b46f7501627f990e8129e7c55185c983925809d03ab1f64a1492a638a0e5c4ecd81f48ee62e867cd09e00608c762692199f528a8181e0864a47d7ba6672b7bf7019ae2115d9e4aa135ea4bea0101494485dec85a86cc09c18638260442cd23093c0d3694e30211c9616c2629b94ff6e4f5bb54ee6a7fe9c6915184d8c23a565c2cec8a870ba8a390db93c19c3ca22a71518bef52a16b3644c6e77696d95b60755c61fba93b3f6a9084f38b277c96454ab43940c1060d286cb697f34faae54fca0e64239b4d972a228bc7f27159ab29d79574c3152af9fd835e48fd47da99c398bfa68a17ce39775982be3dff292c2ffad844599ec6d2bd22814ccb9a922303b384ad06604cf86b122e0e739ebab1eeca86e98e61705e56830c619a30f0f06cff88aaf3b2ae3596ae051ecaf73a1a7db4f594d2ef35131dfbb6e07e57756b3a15eb7fd1459cbf20e9d9e0901692a08b74c97403e24553bc8463a1ed472089b90c51b2120f13ea5556db0e60985134ad24f6233ba3d03cbe73ef9e40181876881ea51ef3dfacb5ce73e1d554432aa966cb833c4dea2c34349b600d16b87bc690b39a953a19d30c624a2a90f52a1a61441efe3dda3277de179b52e0b6826a4638771f1d389c91a8be4ae5826e4bec7e1f685d4455b0d6650bda8cac4a5eb30a42d4685814f8091c861192c857672cc43bd02d59da822e6841a9eb921ae16191c5739f49c203ac97a31fe3334cba419c861d6765ec0d1af2d3c985ba0283a2b6647320ee50c98c2e133b503842ad189ac28bdee7ad83b29d488fc0bb89bf4a06f2a19597c7c72e55540b1684bb1265633a84fb93499f0401f6519a3f13341b1026e42ca9ab311894742077712ce560514428b893f1e7efb99cc41709512c57dd3c2d52bced3a99a283803a8df2d0119737b9194de1c0ca00b81b78200e430d828e4a0aefac7f21f755336339aef677ee36a5d2964213b2f609f2cb57952b80559c2f4c008fdb41023eb4e71123c1cecfd5b804b62e2ee484ec095279f3825361acfc13ead8f4b68740769d6aba3ffbd4cfe16198915ba1d0213e8dc9fce2d9c66a755284d633f1367b7ecb98a74269f709ddc74ed14a67ec3121023cc3c066ca78907d1f7b7ce62f4276cead74cf2ba3daaf49048036521d8b794dc41bb1249603b99629205c6a25259e163386683379455ccad4e991ddfe62103ec44854f163289b9ad2471109149855438c2230ad5158a0f4f22609fea7ad4a18f099d3da04480ba604771e7469b5046dacc972c1d60651b2d9308842776e68bb84ae7f9c5c4cc590c0f6a15543050740b3d8f4b7ffae147994fcddeb0321457975e2874a71eb2b348783840bea300db8d875c872b2e330b646e0c4c3375c41a5695564f9c71f666bab7d8fdda42cd7e0c16d4d2e5816a54e72ef862205ff78563cd2ca67cf0e1a391cb9316401098ba8020811fc1b769bdbc52669be9c1901a0e0c942220c3dea50b958c23193c0e930a44e9d59df393050cb0fd0668afd54cd9bce4523c69164e6e1f1656b6fe6d1045e3dee54c9eab660fc06d7c594eef5756b2b38bca1c52ed6ca3e69aa33f1c9e442b535a8ab27d983321a69506454545b4f8eb72bb3f9a1832d97066313f4af5a0be07f62be7b380df9ca0effe0e386d100ad6bc8e2f409f0534ae5051dfa77ea45dd8eb3cfc91a49cf42412c7d8c31f61a6db6b9412ede54e6f94add1bb163e3888ca2b97d4ad131f36718e733900a56015fc9174fb730047333478a3f3d4b7bd358a2465e74bd03d26460342e6de32de2690b1b891488421e77b82854b838ddf38ae2de9f13b234cc1f42e2a868ddfefb05130a24a88955a5176787e6903aef596a3d371a999e039cdedd448d0020d5e0c1f851b20f971c4fd6c4b326c919246a928a209e6e17e27aed056972b95dcf58d252d7ef5087d9880449ef71f61fa3dcfe0341e3cc069b4bc84661fa293e6dd755d291bf21e2efdf6bf47b1c84d318e2a6152cba715c6a0294575f1c7862e385206b0f11b34824993489e9469ccf18b5dbac63e652e69958c446c29c681f07f44c627a3512d57c6ff0ee0b8196c25ab4c2f63e2c3decbdabb522ea5de2be1a4a5870398689b5f37b2e9fbed62b4617943995ccc0dc7762a1df4f81f265d9d56f8350c7708174b225d84bd3028b6d4c51d069f67887f8ae3b3f81fa84e91fb991809555a08c00d7abcb00359d605a964ff387e9eaed80d37c513a7b6acd5486e9b8a2b69e1f4bdabf5c10516101fc92e8ccca8f94ae3bd46643a10a90dea8d1dda92b4d3c0b3713c9632a5534a72c4906d13b8b3542f9400ffed8dc322db98f1cb826351f1ea203c54dd692bf68d7ddc451362358e96ccb18a8ac34a2a43d4d593a210e614ee9ab1b3307128c7d0ac5af3b14c3422b6c56fb8f21b9c97b2ccca249924bbbd5664e7c0ba74029cbaaa322b9028aa5a7ea07219ea26dc5fde8ac4a7330e3e85027c4807e2ac071575d7f9ffd9e8b2ef585fb95a2b9f9a488527575264074dad76d3d20af52957a388d656499c3f27c07c55aa7b5f821da8c1e4d8c1541fac86d9a9e6084b336cdee6bac3bb90d549ba162b50bd611d9790615dd33af2a979cbcd20e41525329e073982b523607fe49ec172fdde2b81605ffc50dd7ae130a4f1d6d7f51423c97e0956490a78ec0e2567edb3d0c89a76d975b55c87351783ba542d8c2104b9fca614538d9513d53001f6983ad571d84cf1ef610332c729be381c8df8abb025b7c0fb981142548b3e3b16d836834c9bcbd01044c40b5af0b70cc423e07e0ef6ffb5336a826fdca3d9669fbb118d648a2c0643ccd2993429c4abb24fb2c58e7a0059e72f33e7c78956b9ec51de8be9249ec85bc91dcb397bb0c4ae827d3fd6ba642f1c808cf1914be2d1fbff7cef15287835f8b784cf71c843ffffe2c60940211a6523c972e5125e444a0dfb4290aa641cfc997430936c033a68ce60606453c49b2c578f7086967872866a75be42711dadbd683cc0e4339fdc4b96e601e950b0fa44448c909a6cb4a410f5c87954f926708f65723505e92562a7470df487126ed5a052ade02ec833e60a25dff4e110e3085567fc0156cfa3087a1c5ac34d8559a58350d9bc6596bce4aa45afe3708342b841280aa857e9262d05924d6f724426e3058948697c5f11ce7db703d99b4b4ee24b6d6ce3f9a32a30074ab0fd4b0c35519e13fa066e3f732893f453113dad696205988855d58a2642ab6e2a0214b39356762f96473d34e3f689ea148d3008a2585c228e16d191f641c171543d89e65b6da9ac61b4704be202edf99981c8183227035e2a59f0c8616f8418034958536f2963a1b9d69e19db9b9c18d7d484463a0117c9b2372569f7ae7a971001b648484f0e1b9948e62bd51b444344d20588af4724a6d71b61bcc23f3db4b0eb6a3311ec2fde73311b9fc5996e8a87b4213e7c17741f6eff9dbcf346846cd751fe784d78629f1f79faefd7af5ea5a9e47e687f772d273b3da84c0254792fa17c75d78f95ca03ff561cac79136417741a41206b1cc48dafb6a51992492f66c6e0ab9ae72a06eb75b8d73d2817911b9eb506f2841126fd5311b3d81bc8e37e437de5e8728915eb70cc2d25b9048539c9f6f8adc6d04349ad643a7532eea72b3e8335a8c3835a758a9049b67b08e41d87f65f22d446051f20424b95be811848a502385414eb9fe5694c396d0509d2b6d4fffce06096eb10eb40637765ded3dc907a2b33112540c3525f671dd59c0d2ed50aa959022460175b624e99592e86bea1f6e8f07308644120d9b0bc335679063d14009ec271db63230113d35f9992a3a559db884d14391a7be36bb3238642dcd215abfcd2ec7586d74db06c79932132b2cd74d88d0e213b448648b88b39f2e0ed0b87784f01c1a783ea49cca88794705654e8403b28da908fd8f87051307e3243b745e1e3a244ba4dd84612538153aa635219ae5d7726be04a8d6608524d4af7dbfe7ced0aa8ed9ce40587d8c25e8f8d99b3d175ea509d5311834309d51a1dddbb043802e57ea36109b01a1b1377cdc9372423a870e55ab6d1eaabfa9464fed7633ad6a10710d6a1031526cfc0bf5d1e9be65cbcb1b2217f7fc0ca26061a2f4d69237b9e32e2c88f9ffeacae2d002f6c58fd3bfac4da19f63dbcb9eda0abc454242bf123245d2e755ff5a666841143882c48f203829b49e13e955aa29f6516906341671072f4d64827e824ebbad6d2493b83a654d87f48aeb291e577e610ff2fb69303fd054be01888e4ab453f72a6505596c060c5950a7a1355358d6fe58011323fe00ea4387af09882c50ffa94d2100fa11754f594a1a3612ceff05b88c5b6d75dde728c88283a60c37e61cf33c56da6a55f696ace79205bf69a5fb644efd06c5c66da5284f5aa318bc73cb0894f3828fb9208a24eacb36fadb52849ed58a00d9abab6e071cf6ca69918b0fc09d6deb513abf31eb394f1f47896756acf466a40497503b2de8210c30ee3ec8fe46767bb6d3b8906df385eb4d47c38e0752d7f4bea4046bf5865d88d749062bf723417b7aa1e1ef75096790ff7724fba39933b7043aaed4a1cdfb46e7107134d83426b6363ca0905b598046ddaf6000ba0f86b2f3b8610c34d6ddbf0187d9b7d2f36df319be31f2a96e52be93e10fc5b208d7217844f5491dc4ec01f64bc47d97c53d6f8df89b58ca2d24d77b06b642f0ebe453df34575af1f26901f7e68f32553c3af71984e886bc4fa59a1a3cbc72bf8ee8171756c594b7ede188f7b138b31f1ff5b9d75ba29a97246cafd666d6705c38021ee328012a1be3d481144a80eadaaf4fc621e45564b2b8e31642fa89b1ecaadbcacdf723186cd2ccbc5df216d6afc80166116244c81260faf1be5dc54b63f70ddd0cb0bf7eed6e732c5d2bd96699e38300b4fed927af7bd4687b6234393e4fae39db4097656399ac1463fe6cf16cfe4219b72555d28f75e9e1ab25d23fd4fe641e2bb9e95fe5bf1f3913497cb0293c72170f7e0b7f9c70f4ec02ba0e86d20825d10475a61abceb124149514b8186436ecc1c103e48282847f2489b6dd53000fb62e789b72b7465ae0ff7bb011d86949fe80d3fe466aa7c9aba08a69f61d00ee9bacd83b9be3ebe3662628f9380cd424b05221e39420549fa966d187f7b79b7b8bdee7ac202ef54caed8182fa774ff3bb68a666050fc123beea8500df734ab446682afa94dd153f8f3a388d6edc0ab623cc1aa3ad465d42ae5b38c0499b3156393b34aa6a72a48caa12684ff64977671511b9a37539474577ba4cc9e782183bc1ed172ec17a7f29a2b525df35802176769ef3ee5d73c75561528cac5f24fcbd3c38079dae9e8c4730fd96a0d7a5296e2669b5d839d1d16d6bcedb4ce3782a7bc99669194d2a2ce502065b7290ab7cf6a6bd65bb30e209b8057ef7198a341bd4b88e486e21b1a0e4cacaff0ba185c1ce75d20d8321f3f4ca45a55f095f6b91a7aa465b70531a33d530d616ea425ac655e95f1536f6ef939b5e323e541c2d81aecac6de209fba82c16960cf8c7547b1a8e3b5fb6f8bfe114518e0ebc54fde1b1c06138c1091748bbfa33477117843a354603f3333e3a1eac555f8bd94983e135abb6cc87943e1cbbb599f4b91f4e319e41cdb43b2a0748541c10112dbd06f8836f63b8184f2f0f2f0495681b10fc77041be3b1b7448d160c92f63deba31222e8ccc82734ccfde096e2e406f20297961332f9e4592dbc7eb2c82ff0edac935ab868f1a06f0e96ee24eb454598d02a58e48a897ff12e9814c817a1fc7e77b85ec7da59284ae1906ee1302b4dd5750a75cf916bd89d6a039a254a78c46923e342222e9039e8550b6e634bd19cf9978ef2b4e84ad4d7bb7dbd0bc6c9ff2a225e1468070b11984fd1d3b140cacc15df93f521d5fde44dc0335bc1b0b1df28b81f7280f5fd356dc116062edfdcec4c04b3378763c7014587ade416ac751add8b70daccd7b2517242535aa4b8769b5623f163563b03e08b23d79960812f69db02db723b12a4202d105d2e6bf825a46a5b832d62c200f122de70198dd4c44bed4a16693dad861f6d0b61461c1642a44cad79e09157bbf058463b624b00fe36aab72789dc20f62ec80e6f9b749c40bc3b859ec75f98029d9304e9b0a4c689d7a463b4b4ba952863a56ff97545f29fa49d35b6c9a57e700a2ff6430d1f1ca84e36de4ebc17796318e6640fec1cce82955bcbf9cdd3a8f5b4d6e36c93676048a924919d90ba0bdc9080432728b0fe7bd17d305755f914fb2e04bd054fda04b4ac0deb16990d63f1f2d2d18a8177723d44ff4c94f7a614b0ba1d803cf2973e38e631936bced1a36dc6e4f7d03a3d05b12b4e85ba4a29cb65c181f0fe03c53842a709f44a7bea65232c34ad28e0e71eea649313d25b6afbf7f82906c81999354f0c626212f85dbe4384eaf4a79bfc52fd4504c7f536059dd9ac2dbaef4d85f8f93fc289a91b3f0809704e658b0f64c81fce49b764035d38bc7043ed5ee9e96b1039e601d3f3e4dff7ab6f46d6c7ea1abf4480d5618d942627eb9dd2147ab2567f5b6f712ef5afa02253dd62ca0a7ec9489f23101bdec89a76dddeba0ea1185086468b081aea4a9d0e2aeffc60592f75a0daef38013e555dbcb0b635cddd9d458039719ba0232691210cc59073010d5ec5e75e3e27dc4fa2c986af76faa9f2f7a8f11f807dd4bffd70f4afb9c96083de4fac36e10f37ae664073f070342dc61e920948abc4b577682980d3f256d4bda5341f3dec25441e2e96cbb96b7128957f370673243a984364faf0b779df395c620e5bc1c3c1c726509543839d8423129fc8bf787b1024dd614fa704c35015f23ec9fe93076a6a9490fa4258019092bb5e1c84bd94063f2ad17b52ca6e03be66e40c5e0c1a824d17db676d63fb6d0dbeef13e4a3d29a27523261952a12a1ba12b092241039f472c2aa9a0c78633d2c30511122a8604e72907ece7d1978fa4ab934ccc265b2041a5f8e4cb3d3b59598b68c59392310fce5e7f8519c567e93598bca06cdcfeef983661adce6b458912ba660688bd011fcc8acbd8351b1b06ecbbb89e1d52cdcf6b2570ee68076d6210c75bf75f942b86533f0dfebad52ce69da0c795d02871e7295234b91e53055bb5a2ebf1550a2fa64eb5f62d1ef70127bdb2c127461ee32dfe37b9046805d053bd77717f08176be3162b6c1a46bcf1d0a5af704a9816cf9bbfb03f57a6af1e63bf0b2e69699a4c9cfc8953361e38f2089efe1126a46bf182568a03653dfb329267705b6201877175cd3ca884cf840eba067c174f7e6584d1cc6e87ede8e7381288d0b1653df033a51f9aab111c1b5c660950cef133ad976acabdf06f4b6e532070a4daa6cfef1f554358ea624375df","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
