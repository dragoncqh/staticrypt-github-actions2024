<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5c82e1e894b097c9701ca5f3b33e356af7eac79618c7fbe52388a809506cbd00b3037d3d6d72c7c35a18f97000b453cd73950e8d0fd59fced023d7d4fdfb8c97acd8cefa6b5c6fe6e9acff0a8e650b7cb2c29655815130af9dff1f989f8e6ca1094cf8bfed44fd945f3f23b461962a14f62575e608572d5cb414f5ae7e6d1e7718d79d67ae95675dc154aba3ec7c00e48ab5646469760e0f4729b54e1a8a6ff0c16da6f315d29865f7abaf5a0235d587b1fe7adca999d23ea5b4f00a75de85e7ed215d1e9851541b8e0ca94b738a7e556b219150dbf6ac970a7dc283bed1ecf39629a8e9f3d292df6fa14b9b1958dc14e09cb98b0f0f9493f43965b1aff27be99fb11be3eab6278941044944168c9de14a272a4cb458c92436f2f6e074012e3dedfc02863ffa52c7c2e4ca278da91b229635996f610fc9e2d60d4cf5ffdd7d610a4f40be0f19562b6d2b4126c7556a6d0e0adbc76d34b0e0295981e9e0fa18c24a901aef57a2a2afb19db33490f6bd5c9dd413add1d75b8a839ea98e7106a0e8a19600874a9180bc3cdcd68bcebfdb1155d479500d25ad360f504cbcb14055ee4a7e922decf4eb6a3b97f9d054c9d03182343e5691fd513ccd250d291cf825f42efe5cb4a16933fead6b8f3a54153fc2f4ed22918d83fa81965ecb62ed40ddb97c341df64799edbf81f76604e1a2cea8b8cfc021ead5578e4ed8dea2db1d9b1c279e0011e9845aafa7a0b5c6158d4279f3a0ad463cbe7c4b367f7c09103147556d97045297ac594a3ab203374eecef775343466ccf26485011c2adf3bdfd415b3451f5ea360f723c4b37ba200331f641e8b4ca06fdb05e1e097d816330ad3bf8ca1539d1e65572884a27a49756f36c3cfe5a2160808cb045d1d66ffb75f6d35bd5a8d7f27a97eb4cf23d3b96e49825bdf9fea816c13aeba1b7658a9f14ebd7b22d5d93f5cec876d3904b44d06bb1c04e69df589a19ea10f07cbc25f0cc932046a28ab8cf0a2b888027f6ce48a4e6087b1803585314f20b10e10d68ea98f7ca57f7d73cbd59d678823f83f2a584af1cd3e344c2b5835a3699ccfae8efdf9deb62239737f9f0b72ea37a01c1f2116d0092006d3b484d7aad0927ff4c4e4a297e11b73ff46cc9f8379f8436d50860d9b1befe8e59fc158e1a581161655827e8acfdbbad22092bf7b27d96977b378cd27b13f355d14e52ba37250f5dfdca4348dbdd01cd795689baf790732c7d106dd4eb33bc54fa4701178f79229db7f1474542a87928ce56d709d11380b630635fe3884fa57b092b9794c1160dfb179b7d35917be023b21b252511a41b8f6934a918696527437362980474ed5998eb81fed2d07a676f26d8ded0625f4e1d3164b470ba39a186782a8735ce8d6817764a2e2b4c83dc13381e1e38a6f4a94b9c00a0fe83f965b1adbf2ed336f86adab963f9930ef06e8d225379b730bbc409e29b00ca65e117dc3f6fec2139141da3e5241560bda35dcff6d0b4c10b8041561553ffaff9448548cbff4dee3f7ef2ee06f971b36b565dba33d8977bfbe2019c6c11dc3d04c424795432629207acb13c03635b3e0404f96225bfe360eba0c687627ea2da338c47457411421b60641f7b8a624732c82bddf18d2179b6998c28c68a572251e38740ec69983e0e053eac479296107c8cee8df16909259afd5e635c9913d8f3fce3c9b3e3847132e16763fd3fd7355d8370025ee1af39bcdbf2a14caa471cf5507715b98207ae9b4e70d5e76c8836ea8e32d7bd62dcf16a4203933996111b3e29297064de265ffe1b1b578e55b2906bdcf18d1bccbc0ed2a6825e59dd38652761bf33575593ee653c4af8aa3719bb22d88f6aa0042de96f51a5e33be296595f8ba4fdd1f79c772c938b8600632a9017cb133eb3f9645be7fe48170b920e2145fcb70593b3d4cdede8a1cc0eb0e8cc12e9711d16f8947234b04885f9dfa35bd13e43be0aac6848b0b3fa5515f75ef7a7f0ef3f9151acb2906024363bd4cdd1cddee4c7cbfe13e8e33e3f6f60ca6fca5cddfb82ab05e5f29f53a613a091f1864f09eac95dbe1f2829e87a6e7590d220c8ae7ad7b37d7fb3558b4ee07878829bf5e055bf0bd10e5e9f45a4689c54cfba59cdde2b15abd807ec8c7e275ee2e15c75aef675fd7de495af52d8e7b2d2c92a6c18c9351985649109a937ddc2e9a2e546d4208bd5e8fe333f253813a6bbd6094e4f5f439b5af2c0978a86b9b4edd8ec4dd434dc5bd496615f83867afbcaa1cc6177112ab86f35e197bb3057bb2b14548ff749eb66bfa0eab96ed54c9ba4600154efb81fb5d09af774e3b0db4d6d851884d56429c8efc0c8145278f6370ea735543499ba27bac3ee55367ff088fc481212dabb1b3e3792eb8b9c4682c0e1dbadae21a5edb4e9871d09288b0292da350f93c9660c2c3eca8aa9e35fcd94ca6b947506427589dc94e88c7988ca1c35f16e726d83e7dd167836cf0e99b216cb53b110122ac0bced2687758ca9a3150325199251021c6633f1f6640ff3cb64177e1a1981c1d00c83e1dfa38e1e154a193cc5116d79cbce2ddc7a1a2e7312442f2c73a6f507b5627d5e8abfe8cc566d82acd22b1f25fbf5f114333609320c7e8685bbff9142bf857ba16b1a4d24786c844db1f1d30a9d9b9aae1d9a5bc9898c54f62bd11359bbd9b652ab7415878f9f7b9f11486ae9679f60375ca77ffe4db0563d3982aa740ecb3acf880dffa22bc5f369e4e8fb936c583b7b1c4fe4dfa2e068410ff593a16792987ee75439de543f0c5ec2021ce41dfaaba75180fa34bc670cc692b21b58247676df4d49fafdf163b15f7ffc73b0eec7bc7ad808f7d07f5d2da3578bfcd4227a3061d57223dc17bac5b35ea355f2f5a8ba70092107e3cd5013241d67189a7db76721d8d22d24f55f6378d53bf449c7af9d1b4ef96b3b9a7221c401deb8b7987d928d00a1031b7c63633bc0e4926246893b8bb88d1d5c3ef4d94f729a99ab2686eb183d3dcb99faf750f0659282a7aacc8bbe97d751405c47348ce82766c5fd21cd95bc7cd3423a2a2bf622b9cbe16e83e1a19c81ee646271aca0957f15bf1b7bc766c381372c764898145884144fae2815b2e586bcaaa5a487c6188275b91ba37bb2355e7713dfbb4218cbd06cfe8863e5a2c1f9fb7db32344f8e20ecabbadb01444708299a31e48216a48c6f85851af15581e0682f7913673ad9a06ce4e10041c3c6e0bde97127b0a5c3dbc91fdd7739e583e86cac39de66c64f3e22152c98e4a229ef1fa2efc1c26ad6376d1d200e08cdb1bdc25b10bbe454be4e75cddb7ae41ef5aa136df3191d6c13b98564f882728ac643ae5afedbf75ab5b798b5a98b8e49c6c5071e8d1756da1374e8255cf590c47c8c997c58d3e5ad7336a23f7b518320ca076a4832daeed534c5dc832e52e49df10eb99c423b13bb1dcdf77e4f4ea26232e43365247e4103ea5e5565f75ae2668fb9dbcefad6698b0464cf830ed682a0b6a45afeb837de65395cea8081a6ec08c4073328a6eb1b28da795240f7eef0746b6c9981e07eac4df9f4390315631f74b25fe584aca25119d4f4be1d50f95d426baf0e7f292f3e4b10071660c35ee7a6693d1e427f01dbda3b3253b103bd0392a81b423e80af4dd04a2aa65cac55298c280715b9f6089289eda47ace4511f870c1a540224297a84362993754be27b9bfd9a88ad36a9a67664c8be068b2c6edde80a9ef6d99b4bda310f79342ef22be84490446b6a4454959e2c97aca7086fe33989c530b3de0755c9a0686b1471b9b9169c4f86c5d1f2d80ae9e7fb0c006c485231167e3d5534d8e394aa3890e45d77dfd71038632a3f25e516f46244b39bc0a43e574c6a8695b31a41387cbfe51665d226724cdec264038b6cd7e72c536f1edfe5d298da29a8ba79611eecbb48ca2f4015dd8512bc0362f1e0c96618eab1778cae9da36ff792066c7de74a0967cead775e38979546607b14ba00b5cf1f3ac72a5ba16977d17d9cf5bfb9badecb5609f480f27f9d17c619443a523e1370f848700e6ba89ddad533d468ab82eeb05d418ea1e182b7eab9f631ac74c29c002c6d8c8bbe1cc2a0d9a1e982887ccab252750848781338c79d488e42809f66c51e7c96b223514a1162a941e1addd38d8b68ce101f6d2f93a4c3e671071bd10b6576442582fdb3225cac196e10680801894a46428904c88b32ae777659c0fe3f765dea07afb27b0a15064ada1e38d08e2fe4cd87e52ff8196e8ba6161f4020b9858251b8bf034302e1d3c0f0906195a8577ccb8228ba9c764cadd07cbdb26752aa8f3023ada57e99ef73151b40696614214d9f048124a011746e639e30e6df641719838f201fbeb49bb290ccc21c8d80a2f93bd0e1bac1f22f928cff548e8a4c63b00769e1de77925a1949c00f90e310426ecafd3f3abf4e78496467eb9da2330a7e4a7f03fc8716baee55b237902cb552c54dcbec873f8c9e98b6b023a51e64e9213027cd5121cf2c01037596f91dc47a867aa0b72ca71599bb007ec9b6d7c2d61b69bc7ed7903bf17db493979f4ae052ab6c7b6890e39a1b9a66e9ab39c51cb2817f70c9b9127db6f87cab99a19e09d41916c4c372f7f900609c15ce7ea1573a13d500e208794d7661a164b7b22a6099d27287f71f1b566beb0fad34107317863e1fcd4d2ef0e6f6089e7876e75be57b1185a246612cb297df2caccd7a126865a499bd2a5fadec36904284691773b774d6911b1c6563766346bcfa3b222d1e68b52c831153c2354433d474259022355191e1a5c8d15b4c8016a9c0f0bb1d630749c1bd79e65e52b6727d0eb31ecfa62562cda1c1f7eb8892a295a4ed68f7b86c58202b5e8147da73e4fa7418c7a49e28bcd0ce7b1e0a09c769f820fa312b1e18d9f2f0a358095c0d98bed778ead2f954cbf2a089cb952e1fe364bb6a7890b40286a78c71fc0edd93b411111921fe00c54e44c377f3a72f0f5f034660cb7ef3ef464f92827110a6bf31f1c74c0c3953d5ddfc586e876cfd4c8b7a78fdcaa6661b52dba115411500d5b87f0352114cd4d6f7ae8c6ffbfd637b20df68faac8adfe89a24946fde386d683edaad6c8c6fcf53592954528dc35ea308e6d3d2d615949b317164bf322207fabdeee8d0884f31b2845f94784d41ac9797f651740eb541f7e5d366e4fc9b2a443470e8bc8badf9929011629853282f9ee19a86dd7c2597cbb74505833f0ccaa02a7a89fc9db839c088ec862b059b252ae89f1d8ce890271b135ce8847bf8fd0eb5d3f10df58113db4950299cd3dc88d920012f268213833351106c3382a39b64a358f9064f20ae65371cc5bd1ba0ef28797cfdfa51840882d32e27ab46dc2c18a503e5c7252dd32a627ac80266d8b8975a3ecb6bd2e128b63d5edfb373374b3743d949323c4bb3c3fcb7d2a462eed7e84a6e0dc7906212ca417fedaa63f92d304c9f2e78aa13acb00cd688f24afcbbd1974ef5fbf9e47fa83b6021842ec2319bb54236d2ffd76b56a146d0facab1cad6e31c06fd02408653dd7e95c985aa789947c6c48f326b5777ea07cec17b64c98132974c1c501fbb3b1d6f3447747cf74b142c45e91fcbce05f7ec226f7555e5c9c37c8f95de1d5bb7d4805cea3964daa9402f03803f8dfbae24c7a44c423409e173e5b28eb584af6895426dbbfb34aeb2c8856f98057ed42ff0178fb06174fc2dd11a5597e50b9f785dc9445f78ac4a91e0bb84fc97a91192508d660cf56744c0c0127bf5626ee1c3a66c624d8f9c909d05b1cdda6a2be505f74c8fe60aac21695d3758b5717627d84188d9eb742a01bf72e95eac3fc21b89e0f2dd93e19c1dcaffaa3d99011e2c7a74049c14ccf50d54f87a3ba6bd2588cb25574078679090882b9f23f0a4f6d680207a92ba30fbee87f0c64d103199e3da614bbbece59cbdbb69d31ae485c6d2403c8be25ead1fd083a7604129f56847c8ee04b3d120894fb63ef9016479f0f794bcdc5f57574684d558b0bf152d7b01319a707be943ee93330c14cff2c68b87a5f52b07f6878f8210557ccde25493da15bfc90fc55cb6e13ec69534d48f3f6d4074e6ea9dfe72b3c4d0254b223ebf61780d7c3e38328dc7961c8b984487649ab98458efd6603d09e6728e095c5ed2b091376c7293bce5d956eb1960971ce926a8c2ebfecf11ea34767b2b078989b5adfb45671032ece819142557adffab70fba4bb89855563af049a3db89df5223659073774f03f1861e6beeb99d59236feddd6c3c515223ac77c9ce06275a2dfe4cbb08e0bd3c7d53515b84586dfa34de6a355951370fdb0bdbc0b7186ba01bc9a60fb035cb773941717fe5415bb41b57bdaba0b8287ffb6858fd69bac63b1abcd0275caae95429cf85ddb4e4920a363ef316c79298b818abf326a4db5b791c607c93cc615ed20cd817091089c9076ffaa9b31be7e77e2ff2af22801cabc25aaa787f7e922bb1d468f2e64d4f39390c6abd52abb9d723a2c52b93c605472aafb11cca900df455ffc50360fc565c97a821d46e11b6450dbcdf24fefab4b350ee24874571c9f633ca01091994dbd5a40c081a3db7733c2abcefdf1b0a95160e04f287e7e2398adbf1c95a5b741c3d82312a6ee8af556c827eb52ff85cac22f744a90c0120c0bed3b1264b6cefbc8cdfbf2f72f749b55796907bc4b5abafc48605c43746b28fec2b9185393fa2bb3ddce432ae2421ba1a634e0e4989c13fe4858daea82d5a7fe1aca129aa1f3b190865adc424d02efe1a4e68bf7fd1ae07aa804fe331e3d5074e6b22775e68a1f9309627dc1e5e6390f106e5c69b3e751bb2b77db964ecb5c49f7c74a9396da43f96629ec86bd710a482fcbc94482ab31f7ce7d7b62d7ae95c15b158e59cf10ed419c6ea96250d3470c5570cbead6d4e340849c506b3a39fa58ceccc4ea59d1975a95cd20dd73e8bc1991bcac58127930bc1d4c94757ec4e829658b741ef1a616629f45b3633c72da5f10cf5996b447f1781bda919c97b87508f6d8f6d639d6d95b5a1e1fc579595757bf0e0bffd4d5720acc51ab9914ce27e63393d1308af597e11e3f909ce9dc20f07b438a4a06b160c824c52ec51fab61b82628c4dd3f22a0cc43ec4b801e9b765238bf19ea57a23e4f76241b04a1defbc704c9b3dc233bbb762742407f23cddd490b1a22bbe563fb8eaae5c9ae076a3ef14d8406280ada54c7f79a954b07a020eae3fbd90aa3c344c70dc3fbf485e49681aef8a28cfc9a5c7ecb85756557428334452343c7879d1605b35f7eba39eead03b193fd2195696853a10825e6c316fa377d43a0d7cfdceba2949003156711b8dd37468a24bee722bbd70fd7cd68952c87850fbf2186ba7c16ecc43a64ee2ed7c93ec9b045afb7961683020def54ea535af1cd233983b4be837489169ad7f1c16b79aeffefa99499d6f2e628e853de1b436a9a460de96877170c3cb92f38d4a3073290fde35184bef028d42852cf1548b1794e86d7838365eb8660dd01bc1e06270a51303b2e254a19988e22e4a9f3cdebd9b981d60b6a0619a96b357a904cf8fdb3b9ffae1cb7a4921a55d914671c937edcaaa107323a0e4c47687ccb320a71bac0c0ce63b1124867b46e8ad141b41341dd7159887d8cae3479f064e8fd98bc7ed10051b62d60883357a261295dce22e80cb1e1e69f648b04bd8b3299483145c6e075ef8a3bf5c53ec43dd5cc1f577066bd7099a555b23dc68d66750289a69c9ccf68586a5b7fb30f099ba3da04c8ea94dbf732091aa2085fa80164df75b61ac561cd99c47044df0783b7e126cbe1d34f71cdebd9f923e174148c6c993189980162ff1566c55035c99ec48899db0c818328f94a6673c00191388c0147b921c2c8e01890371cc640db53d73599ea58359d5804e78e564f174c91c85ef5c8132849a0f1cdeb243af9fdc53fcf7fe5c62158889b2720d6763e59b8e9677d13673a6c489a6e2403e8e20863b13bcd9c98b770b779f99542f4a8a0f26de92983f7a78ae2c5a9404be7f405bdb302f6e05aeb0267759c104c6aab053d253de3e3c47902bb34faf64ecc4b54b4ce4460fd0741555cc1ede8cea98a11da99593ceca62787ff347f1d4cff7334b67c38edbbe2036c6934c403ad0049b9556c6ceb4172908eb475145876b02e41bbb2bb44f642cba492a23ab5d09ae0069299d542c6cb76b42413d5c81f36d851e20b6950dd1869389f00d9f78019ea67f38fe1eb5144d715189f9aac4de7cfeb6194a144d59f9d69daafd424eac53ada974a319e39f821c375d9724e67000936deeeeffef3511dc9fa2c5aff43624ff8602e91d8cd746c1e88bca17b15135a16e02dd0bc1b8e50daefd9def34a003cb81cc813eb505c7ef1f8642c31388d4122cda495bcea30a049718a0269c65d31553feacb3ecda3636558b63079d4098c1627483860d29aaa2a5add5175f4fdcedd1fe97ede4f171411580f3fe18ed96c971995eecda431d8d5ffd21c9d631c9adeaf2d517dd79ff20c918d4cbe515da76d87430c1357981cae61a1a573f376e76502cedbcc8c2712dd8c5dd8d2ec177f95e9a96cf3c982be0cf3b745ff906b962549250d6692157acbc77c5b1432f82bc62264fc6884ccf1298547b969d94b8b682dddc28ed0b00e7c1a20adbe42c9b744063ee7eed5432bff43be637e249dd37c5d20888205da819a64df4219e1ff9cb6855abe717bff894c35e46c7b8243d5b60cf7ce1331ea963b6d120060a9d3f9a19b064398030506685749c365dbdada9912abe880ff226bb7c9275dc076e9000e548a4f0cb4823d7637044ad1fb47b98eca9db6201671129311afb0a0a84ab00a3baad794a604be7424aad22531735ad3af31a49bd27a826a1abbd95d847e485fb2af86b0739f8bf6218b53dc6029ddd2a4c72f03bab6a7211c6b4befe42886266b9455c8dbc4b5080e436844797d2b7bfc922e7e889e53b3d5ecc8da22cbb2bb6bf737bb1eda8f4cadafb8d5e54954c441f43039f640455befb60bada17183864768dcb2469a93066a3e8db5298e021f223ecfd5bd77f6c55244cf60088729e3af89b1c041ca55a3967b64487d47f2b2f86026c595a52d5650fa36a1103c137f67e7f800cce4939d1514178f077dbd55f8b8a5022bc7a06081b7beb1bbb4b33b2f5b690a1256f6c246e8dbe98b421fddf1bef3d7669c51824c1b23b9c9ab41927b7687689bb25bc6477027bc6e8074df326c1e21c3212ed09d164dc6d18d6d41128e7011ec765c2b174ef1c4274927de6bcd7ae9290bfca4e1f8af5309b072db60fe780fc9983ce4bc35f09a538dc80e19d78e066af549cbf0317ea28c4aa51fa0013fd81f84f8de5bd9d513ece8bf0f04cb1aefa95a4f7cae2f91c6bfbc9602933a4e58f7138af7fc8ce7f98ea434fb851c5849726957bccc82baa5f245f56dc27b5b018283575af25c78ec568885ad52e37e9421f3f5e1354dee18f0608764f006e932ac09e8e575b4bb39727e5358636602963fac9253e5968620e0cf293f278010d8c37f7aaab6132b95c8f94744d5702522296988c524c97577765424477093d268a4c7b162d377c728c68ebc08fb964c96529e4c91864d73be94698042eb700b3c39eb0f74cfb6409b96dc34877138b5a0abfb7835b6b58fd7d73463391d49c7a6acaaa0a1dc92d5f030f6e56c8c271e79fe06d8a6bab97d6abbc74da6ffedecf143f8e0a83644a7941055ff0678fea9f46f552c14c9a0fe7cf7f9b962852a0f2c471015d123f2be3227885eb00df2c12de8a72412e3d60bb8117339ad35d245f8f74a109da9f2330ae82064becd202f0122d1ec8bfb0d502726badd2f2703ee601db751a97bba44b80f01ef12146e21220a2ed2c4eee92711a804d6c56dd7b41353533d6e67224ef7671c2c9d04b2e726080d985b6e31aad91080c75bc85cab1a190c8ae649a9cae40e369a848327d668305f16c10284c80e0f0648e0b0eefa388c0994e7263a9e976864e8482d7c068ac8f3bf54c2ea4ac724f3fc40e55e73e5a2a4820cb0c72bd7b5db4bb9b66b5f315024ec41802627da21634f0018bb37801ca89f40326fc5aa168bf25587a738af005d1a0a15d2bc0bcc963ce717104c9517f98d0908b53ccf6595e54fd6861eaa400dec4a288d571baf5bcb2107e6a9c0dd5fb7bf251763769259e8c56959c506a454931a22e84c770894373a69ab4639e942b81d6465b40a5a0d5a735001308f608ac21bf5d8ac0d9968d6a4dfbc0e3b34822f9a65be1bdc29b1c77ef07bf8bf9a91305a1c783bf84c6cbed8cc92651adb88ef46ed365f7da0b8e3ce5c28e57c18729c89003b91ae453a6ed28a28d9ba76932b2ef038f6ac778d5c6e8bda37f8b89a38fad987a47e0db8c9a5f1a34de9bea36dc825ee4c736122fa7d022fcc7f5fe8b508a89be725f2e9ab177161e2ae406b28ac6490396501b9bea4ccd85569bde0eb8bbef6d685230c0a22253f93aa029216107c79d9816a0631d7545a8062b7c4e57fe54b3c3c8da5fcf4dc789421b64951fb31f0efaca427288651d77f0cb2f461ca096499cc0c5b8a6e87c8a7ef1a91a0db3e5e6af2b158491006b71bffceb0aeb8df75edd8d2f4a9ad2bf8eb9f54b525a01c8b1ad7b2355541e71fec5b314c12839cf13b7c1cdab2e1bf47a5965532f95ae4cd310b7d767137318ca700139546c1d076e9ff5bdb66edec94cf78c25cbdc4854220982c83e153357ddc19aa85beeb5c2a61d3c7c54aab14ef22e747f54b93bd290f367e6a937d9f409cb5ff754e7be360bfb9b9bf9656fffa9cf37f540ce75e2a5b592bb89a578cdcd91e424f88374adae86eeb0ad4f243902c9a06ba54f739961370cb83b2425098c4c797c34d0e745329500003e917af0740b3608de7f19408b2c9343a1a0bd1719ffabc6044478bdc3265f769f491c17fbfc496f82c7583ffd01973a33d6a29bdefeb6ef908a90ab95a585670f83d69c15af6fc86d42ceaad48f94137c10f69adfd61363d96c3bd6b7e6144234e94b5d0f9f130677514cf237804d544453038a740b9d4f77a4a8293be072326b0b1838f1ffa2da29adf190cd22d8419671d0907141604ef825822175a792c7124479e6864d5381df0ab100f93f75266a81cf7f964045dc36cd0f713c14fad1e47dd2f464702982925dcd24d5bdb27d8c8460449a7a4ab70e58d5b2efc1d415f24087413a3103acd59e20e3e7b45caa4f3d0d61be49ab9e31e071d7bc88c33e5f8293575313085f902d7c21e4ad7312feeaeb58490feb6640874ba31b78accfea15edee8ce71125000bc9f045a59ac05a0dae93db25e5d8f0fbfd1be39bab32151b74625b19d24304df48ae30e27e92de4371fb702439534c72d06815c01350471e26a381beb84c2c70ebf92faae7f8300cc8e8c6972f4b5ca74d094016eca139ecc6a91ea4c33ae05358986c7f4fc896d131624d73ad6be1e385c4e5e7084db4e6431dc2f0a84f25ade07bb8c478be8285a33e875dc1de5221f326538c401471fe9d698fc905ad3039bcc374566782004b602b2ca6c8fdb3d850f30fb6e175cc9bf402c453de804510695a84d07242dd6d71e3c793b9464bce043c0d24fb32cbcee1368bf633b818a68ce14448eb5a38de652d4d3f4bef61eaf9dc29322eba02761902ae1415a8b14bcd7416b9d799811d1b2cffe3853b06aa4f10abf4397bc4510db4a079b9df506bb5c6c101d9b736405d5ba5982b51c295c08b3334412b3dbec89fc09ed42057b554372d869eb802c7fc85e97a9a99ff5b8ebc9ae82cee422d355ebd6c18d5c8e95dd9c8369a43578f0e285ae2534f37c5b8915aff5fec56f30a3af8c68e0ad9cb41793aec97bc4f59a94b1ba2d5b35913f2d2ed1675133b2e772c00471fad6b8d7a0f4334e4796f2d15153c1de169faecf0650d988020e75c5afe5dcd5b96c75cc1dc162e277925a678108144a65d4db51acbc2604188f43e94d9a3525bf640cb1e5cf14d8f06b89bc977145875f4dd848e17478f163c1c69019c9abfd0862168685bd678a81c254c317bf1122ebdc974dd054bbb8ebb27e0cff1a59b31fd20fed8e1e32acc04e573c72cd269c0b536725525f27849b96880a556870c1ae965f74014a47c1ca3eb9bbd6df655892903db48b1657d6ccd66f4cff6d49f27ac39cd98b27be9089d710b4516095b697f34e3b3302b0ea5815a3ab8d9c1f597ac5f60e9830773a862294675b040e674f1f49fd97b69dc3bb7891c9ac49dbfb0f26a9a82b54497aa4115902ef44ff88901f394bff3c2fc391cf9c18adf199c9d6af6477754892a602d7a0859897931d02aa89cbf55c3b4cbdf2ebfb68cad404a8eb5e8e6c66489b2c614bc6e83e858b6b5369fa55b49ab8eb52d82de80f47b1ef5717116780ab29995501b8fda293d4d8a6aeb0bf6c026db35ae079fa438d145c409f2605a4f9ccabb596ca3195780c0c27329f601894950d7f58882952865af8c9fcd9060ab80f9ae808b792cbedc2c81f13a04a3d66fff82351168d2ce2d02336e6d7ea1649dad8155f8025aa5bc92228ae9860c1c0ef25363b0b82a4ca8665c2a1b194cd90e85f58ec6e5678ec8773a7832902c94641d028e42fe38046c1eb85d412537bac19f240af51dc6656b275b0f8a549ef8bcc8d4fa9e8927790f4443925509120f67f88e6689c736c91e3ffc7132120606076afa543fa500612377665c9388b2ecd7cbe5aa5eac3427cf76f5b503778c4bb3d4904b75470b7b2af402e70a37373c6ee41d69c2677235b78660eb16c38ac8fb398211eabf9cd74aa1bf40655e2174c9c5c7dc2e9924a15c46bcd334bb1d9af09714a9ff5b627259674f172b6c2eb9212448df6e749ec2b0f311856a11db6541b68a167f84708448b3715f9f7611df9bdd40adaab13d274cdd2192c14b4d415c26d11be32e656c260e5276dc5e4dc2fc88e7f99b0bbe259774099fb5c835a34b9300fc5b5ceb31641f496ab99fcadbc30e3450a9c7dfa265ad1af5b4cbb15ceb6a58aff5057731a41e9d1c9aa8c721754a2697fe0c1b855f5712e9158183a533c4a1a16d3a2548626def6a73378e4dfe4903ccfdecff1036159c5f7092cf66bb863dbfe9edb2658f9321c6983e2c2dcebde6406af5a17b1e2808e64a4f4f5705ee942e19065ec782311147037ff11a6b06d0a20ccebdd23ff93faa3fde85fec13fb4d39e6d07eaf27a7dea25a0174efbcb4a513912716b9c76a2dafc601755eb7a647468592bbe5263fff16644bf8d2a89915bc6a7b0ff57caaa858c629172bad9f7da7ddbc589902ddc589b3d635ca53ae4cdaa474cc9b9c2185f92ac69c7bd18cd8d32f8dc4131f506b462b38d014cfe4222b12cea92d6f112c3427ed04f26b7935089c247f96c6fcfa318db40676e731f534fd56e1ca04159d84d3b4ab50813047804e1b01d2a9d47184d28eacefce8ebe3334bfa213ef8fb4b11e78e852da4af534e6147d395ab2c91dfb92526c3689db47c9af64119a6d84888f90d1d165916b22879ec7c49e8c757507db82ca3a5a5e19dcb43209aff87b9ffec4d16a7caffff563a77ce7a7c05a701bbd7ac4f2357f3bdff84c9deaab66110d2708ed0a6443b14199f9965f4e5b52913ee9bdd20932f696bed8cf70abb599598fa96f4224f540c7b0fc92c5e4e80bf69d0ed7b90f989e467e5e2ecdd5656a2d50c15f686e241ace729e4434e886589adc4ee8160dbf3046f17d0a6b76e812219b8b3e308496f241dd9e92bf62543c75e55943c6d178d3a6cc46458d5a2fac9775b9efb481e5fddec5aec6a47bbcb870a200519eb3f27ddc7d22cd98706f88556e4d7c50fed2c65e9494b46e446b236421b87c245b515992deff10ee6c852a8323a15aec7bf94ce70c978436bd137c76b42b4faea8535dc32e8a9a5e8d7c6ee508f65779bea7d46c26b2db55fb7a3f22eb5a050016ca0a14724b062e13d8decc1617eccdd545fbe0be242912b2713b52cb5e65b3e251d652d9861b55528cef895e791e151d2d8d7605b78980a30eac9a6d820a402e69af19291702715589cc777a8d806a4d06bd58386e538825cbf30cdc0ea36e66c5688b8de8fb3c2f7ef66fc48ba0286e54fc892c48e7553d5d7a853514d14889fae7cd1a002d2be941e785417e5b11ae19a30fe5a08bf59c72625c4bff8120d9d1c83b2fe3e88d86a1f24ccc30d95cb75f3acaa11b0d084715e4910a3a36bbb92c003a7674500292be7f214e2e1c64e3e65f102562fa53b5f6a2a2ceb594cabe0762acd6db8b7cb4472caa98bc39c57c62f2f1537ae0dec0db2db193a6f74aff8d1e0c29bf42325fa47dca4e4f200360a7fda0eb3678f48029a4c5cfec8ad48486df552ad047c7b5115ffd22a8523ca40deef3f0a94b02b4a334b800bea990386cd56a9cdd80f460f373ad679358182cb536ecd503115179b5a8f95fe0c0b6cf32adad905e1b71e0ec673500ead8190686fa32539abc114441d264608cc7908b323f26a4735ab0ee43557404455797e79d355fe841e9eaf04655b406521483662739e0d8b412dcc8c26d9b6124fe00ad8bd4bd6fb503c630281fb8b1ceb2d0684ccbb59835198192b626d9b4415b15ee5ce7918966a5724","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
