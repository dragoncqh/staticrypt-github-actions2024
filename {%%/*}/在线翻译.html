<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3a9c7e96a0ffff971cb5bf34b3db8a101a389f487418b1118ce2305d27a7c7f63c2c617968698cf25623866649e90db649ceb6ce6f8a48d73c05cbab0b6c784894044e7ed3d64bbed7afb27efc15b35226bce4fe9e6701b0e36d3dd7430ebc38a0f73eb1c353271b7f006a4dc5f78d3855c224878f92005846b0ed4be3074814daf48009335bbc501542370d322e76dfd317942861444317d18b59484d001e35d0cda0cd1406610915c35ce706464dc1b9dcde35d4a1878d5484396aabc619c61249b35b05ff0818d673f75170bf52f2ab48225e7fcf4ead658b8fc2ec5fb733018d63f7d22744cd6c530fab7de986bd2c2a7caef74944def623828f4dc80663b4f4bfeb3e90431f5993badad5ae9bdf58ad87557c68774aa79367b32bdb0957c76f65412f0df82cd441a316c1220087d4910a821a6b141782b619b093f6a5497573618b9d7186f4a67e7f2708cd8d0422034a60a053c5628e86cd11ac8b559f0fa797261f5bc6361f6f5b5231d5fdb4008fe08006777dbc165a8423be4f199ebe83ea8426988f4f6c098f17bb89124035e9a17370fa9a08b243a27252df868dc5dc9297efcf11df7bb70b585ed69faf04717e346ee54f0b23e9bcdcb8ad6374b7495c72934b69862311b3dca98f12cb4192e084373d0a47e3d91a0479a23cf296eb690eda7120d1bc573342e5e4b65b366f51ec62753766b1c5ecafd1c7b751e791fe2171c6fbce4d716e7878d4eef77486a58ebea726554c10e7d54995a61ec438d96c6abb47e259bb2dadee1fb15977405e2f45c262f6afe21346b109b5894b5e96b7e0d491e1b81490fcc759b7fd1fa1a1f445008a8bb33e87232028998ff0a34c50c5a7710fde9f44ea685c19e2fd4cd416459df7e13b84aa7fd0580552154b85f1a72a5307e970a33a134569342f9396b974ad9f0ff0422ab0a16ef2826b1b72978e8385d5220f09acb939a6939f7fcfae0183e3f6dc390f0c0f3ac2392b107150a2baeebdef9b0342b250062b273b0572b929e962274b20ecbcb8fd3bc7e5242533cbf3ddc3db025325341d38010b73840c1ae8b6dc61aefa5a89e1e6c68947f77efd51dd07e5414035b11b0f4d72d17736cc8eb2ca54a8f70d804c3dbd78cc8cdfe13dc87ba68c165556e3a784ee20d0ac1e8d8f5c0a0240c1b59bea7484383d953ae79b51dee5842625c8fc7049873f385f0cae59d474b295c06dfb1062952fe17a94282e7130ba6de24de28ce9914547f9e186f134e2e9781b86488369ad3dd858cf080083f073804bf5eeb7b95a8430a88e10a73fbc0d8f8274c1d5aefd8ca1fecaa00df3e3074598127243939e1efab07d90e0745394d15f70c86c2263620939ea693c9398424fb57e8e1f03ff5369a300a57eefb2001e6aa08483be42bfd888b7cc1768e3ad0eba8c32c808fc9ee58de4c6fb02506797325dfb119ad6fde64d019bc410c0572d300ff5465bb901541bc09ef239c428891a074ef9203ad47e2a92945c804b1f68e44eca30987237c927bb36005d7e3086dc1d36aa3a7d0917b933e841ac30721b7734f6e34b3178fa500b1d9ff5f74644038a89827a7200a9b6b6d0c5fb30274042deb7973b14bbb0dc66a90fba327680cbc1baef8cb67b524f33b9242dcab55fc71ceaca501b560faa92b1d73f106d2c7a481de70710f350b841853dacfa0a46e91535c7223c887217ffa2301eae59eb61cbf732500ec2a4a439469411c5027a2cfca52c96129a1d8cd8902fb10844170a92d55fe5a5ce54c93493f5adf5f382bbf11c1de0503c073739fdb34fad2be5308479bcb39aa6d6e227542727faf6302b48effa50d703c563be30aaffc1ba9e4aded5b5c3ac713f71820200f6f5816a4292c6d1afae4569b74e5c0d1a76e45bde570540dba4fe8c7e714ebfc23379188499975b2c79481709a55d85f522d62ba2b9f24682d6eacc9e82ab945319745c188657a2ad8ddf53b9b7309decc2e18f987da4270ebfc348f285efc403b8ea13a1b586ea5b471266fc7cb82b66d2d5c5395c405edafd1d5fa1da95e55f880a87287c214c3bc810fe9936a401e81f4d67d5b0b7ead6fca7aa6df0bbc4963deb53c754c7668a94469326cb30c551f763ee29ac43f0e2e17d00e041c1a0087844c8c5ad1a6776d33c14f42325b84332365e6920aa6a660219ebccebf252cdb649942c37eb5cd10e12e8f6cfd3ca528d0561a5fb15eaa5f40d206eb2154459d0f397cb34af84f0baeaf3af348bd53c3d013dc8a8222eb976ad0f160c55e12e35445c4141c57cfbf470d8848300664254eade8bc5b0d815926b1ba193556f07e902d623b438192095a1557faa022f83cf3da954c6240744aa76347f58f2a5f1b208af6bec81d0644e34ea949eaed9309e4b603ce69e799f6ac5623315beb4fc6da8aa100e99fe4a483e6e89c89776c9cb5ed7d1d850b922b4f8eb58a39f36f9661a4f80051a2f3d36ca2f3b78f9bab2b4f5ef801e3016e7f82cd738b8494e18d9c24f231ae236c9082591dfdcfcdb9930013f990f64a4da607b767931fbf792e29eca849ae73b4a28be9b987733fa5e56894dc318c1aba52a36e9093f9888638908f4fc20b119286980306a18894f4769d69ac89aad18ef099200282edd38b6766138cc2ab2a0579e28bb579cafb2a25fdaa57f43e4e36829de4ac1db772b8cb52e0a419b85a2ba3ed4760693aed725320bc94ef2e7e313f071fcdc4f856e36ced8913709dbbd860f23cf1527ae4535ae394cb3b9b939a92687f5e5c2ec403458baf261688e7f98dfb558a6a43ecac37ed6fec9259a7540edc30201412e58def663faef36e78d8b24137e3ae2e2051e3b17de1a19deb853e436470f7c5ec9fb2762bfb7d3654e91f0421af361436ed2c0c3b9b8cd5c45612ba024a64526f1fa75a39b707c9ab2d6fc94b4b9fe595d05f11e83d60cb51b878fac7e1fff2b6213e1206d0b04e0fed554cb38c3f85febba0c000bcaa95aab105f7e1cfcf3b2c56479b2a3bfecd75fb881b0043ddbe0efc6470616d2f271d405526e1f817adf7cdd932e27c38a87c77f454ee2a920621225e91fed3e070dc50fb7faf4c9a70ca2d61563fe874a4e5f41da935b7471d7472e5fdc4eaa24b314886eff85e9ba6866098671d005c57ab8b7ba472440f43a9fa5f9023919205d7d1dc85863103324b2405383b08d85af2cf9c0d6a5f5666ac980050f720e9b62636d99fc079c86f4e090957f8bae6c65f053c51facf062c1799393fe550b9e2789cb1e1ca6c35ca5ae06c064075c6c9c8279476374ca0dfee8702924ab28c37a39257aa5df376d9149d34da97f49aaf1ee1b58594c41742c7aeeb2887c77a030eda9d617f7584ae9bad556fae5beaa0445b7ef043905f9a22a12b3ce3cfa3cb740f50351b97ee024eeb987b6941d67ea57fbe33eaadc78f451fe51c66a7a82879f63059b06aeab6cc77fb90b5214f287b8db3b71ebbfe0e2036ee393115df66b7ff5461634dd49d28d3f04be58584c93ed6534fc5f0b07e1dea45030f3ae7b990f4eb982388d4b3ff2bfa07f3d0d42739b066c96adce91ead817dfb6b050c58c290844d40ad8a27ee9963e35ae66e19aee451a3c36e2b9e5e4de019333e954952e957a34fb31b60a1bc640d60f22a4dfe256b493283b63d864f0b64243883299f7a8feb3078db55c5379885939fc491d8320063b0b3742e6d47e33b80f5778b07dcf1c2eda30b05067a2479a4e4c58fc442e2650d8e3dc74984e2fd1c2a39935c849f2ec704db21e3247d9d76a1bda266b5098561b2f3244eaa12dc74221ee60530b160df7dba9388ab3e5288a187afb90433d21cefcf219dc5089049438f939cdda423cf7bae2d6b5eb66c35146fcdccaaa1d835f50e170728d5368ea861e89d59ff35df867d7bd74a68f9c64bf6ed43e011061b21d701af9fd188311e7f87d8b8717fa35f3989c1960b9ff2d6c3605db8039b6ded5da6f99bbff01afd08dacce151ad99525e596623ae231d315d6b039fd292562a8abcd4ebbf72cb14021ff4d9d9d78b567b1ebf70c17dbc5bd8c04d3f05611ffae64bebdceaf4d9978a582cc080448e0c3772a94eb22f003684be532e2350743ca9f77c5213b8a5e4f9a837abcc89721a1c72a8f23e251689740ffd4776d54c2dc1f5d8cc83fdbf44331db2069f485e2b1fda549ef1e49ba909f37603f388c10a828732a9585efc609d3f80e7e4e942604847dc5c833d5ca88794e02f836faf60250adffac44e02cf1957df5f31ddf0ba9337bc6367364a85d91aacbfccc9e4a6868aa8bd9c1701686db012da713b28e9c0bdd858478afbfcb44c5c17bcdcd828b949e64d6b8f2528e86354af9120f4d1d1c833a78568ad3c7aa3c565c558bf2f5d0cd1f951c8e2492f22386ea4ff43175ccfafe63e82e500eae24bc3a045cac23ac3f636a46c09521b687d0ff2773d61434a35229dc21728d23ef1c3aaf5c49917c0f847ed5af7b9c3bfee0248a1c7335c07aa5d7f6634a6f946a7e171b08484e501196fca18b91a06889db65620b6ddd5529743bce1641b3a1f9ce81fa732dbe74c391ac9cbfab7537cf07f2744cbec266cc7fadf304e164f14d08f203102f1921829ec0fbc08b85d7bbf02564f58284b2aa0fdfc1fe1add40a3b5af16ea3eabc1b1e777c432e83fd20f235942948359b2800aa692f3cb221854eaeabead48398c7ebe11eaeee92197685a231f6b72733f4402d00061bc3dced5684056ae2c6264530bac2d0b2a1e5ee5b7788f193c76968a27e8f5738f978a4836a3345c8cdbfc2322a27bbd13f99aced875693c2475db9d622430d537f33e995859bdc9b40389a4e0155622da81abbe8e576656c673bc6fd5e03e2326f6551a8c888b9a0176a36e3a49593a6aa46e4a3da0e58d902555d0c52e08c72af58b33c98561fd97ae6bcbaebd903e5eadb1e0b33efbe7db93cedabf67cf049995e91e26a0956b3f0329d167d91453b585ed10c67b9772e70a98de3b526ebf602375a0c57661bb661485b4fdda852043a722b6d97344af4799e8073942539bdbacdb33901442937e5ae0b9921344454dc5c4f90181f4ca4f91cfa08674a72a4c0d573b125aeeb525ef696a0ea2c798de6504b838dedcd0b5a2eae3f01d32142b7c7e2b5dd6661055f8c79c8a3ac59171726d8c9403b3087fa298100da644133132aa09026ea50b7cc651a2786b892a35c537319b9e4687dd45e66e88f4f1e6ea84e9f8c8520b53245f686e2d8d568820e5f9ccec5c8a1c2282a6af603cf46cfff3fc5e99258d1b68a3a973f5cfd519a7b4771c9e36513264676a26ebce3de10ba77568ba529ec18c80aa37f210029b9b3f9bc0bd43608185cecc64d1d499c39f1e7867ef27f381630832e6d25a010d64c67dccf52d8df8290b8269c6c2b6e1596b9303221cac5682207ee9ed4e2671ae86ad5aabe6fb6016bd50865b105a6bc26cac40d8de7c2581cae26acbce7ccb9fcc1cd5efac9f099f05764790f6d52410bbcce59b9829ffaf8d07fd630226d439dfc5cb0843699f0b2e3d39341f01881bbd3a6002ccc3a9f01a3e68f923214003c374ee9ebf9143ad027af6db5dbf4bd6d16f5e08c330a4073b40abf2dcd93c6d106f8012c69fa23d1d804ad66c31966ad01e10feaad8248884838ac388a3075304ac78e61d0895dae949232b417c882050e906ad03ba7ebb2419b2fe92eab80987d181fc625d616e6c7e86a7d5100c2e7fc1cb80f82ac489cf50c6b5ed950140e6cbfb0c48c56828c4bafa9d022e472fd3603dd41de31ca3b6df4cf870db13a94537af95640764222b6670b05b22fdc18cd8b417448a85df07416459c8d22df313aa70f4c8bf281a078567b66720da093373f0a0e08631b609277042be00d328d75c6407ffd08acf59d3c0ee9e1bee5d39ff544d8074a7390143a5d445869c5d4297648409507f6f5cfd6c983327389dc31ce7ce9839c1e7c1dce4fe2f17c96f7108a80e46aa6e0bae6ae52ecdb5889150dc0e91de575bf2d10ad059b72bdcf8d9b44b7a25ee3b9da2892425f7a164da17e04a061e9c37cf454aea981aa0e37cbbd6aca471d593d481004479925c3494bc62411e6812a4d498dbdb5bbbfab81632616ac652f1b4e460b3ae9261e0576f6278bc5f2b3c80a3b712f27ed018f00f6faccdbd26e9f5f8d1c0873c55cad83fa3f9279f2dd6a3ec57e8c06bd04251694cc4e6739fa003241ce55892c7cf8d28a211ce91acec45ee61838f079b9d14e86677258b8794c44919db6e430d19a9ffab10b267ab9a2aad7bc0f0b04d894f6402c00ec6ec9ef756fd90258e7418986a936733df431d61dff1095b314e94b9c2b118b4939f16aa0e271207ba836fc2fc06f616e536070755b5cf4c96f487b2b8025179abd3cd6272c321dbfebf6f3976499ad8938cc6dacbb180186d7569465e4b32a7666c659a920c185f23e59c631143908fd9029c37e291d4efdb0dbe821ecb879ed7f3d2dcba9056270a83d2ddd4cfa7e7a07d03c7d0ecd2d052c230891bac8a8b8f8ff84cdd08d1b7d72a0a46922471ffef5cfa46d67e579bc7adf17da97292fc6ae448fa0dd6f441b0d3c2fb11f3cf38352909c056d9b7f86afa9794476d0be8fd58d480e6bcdad29a414fe189db83ce94b887854d6b5d251f101c852136ca51b8cb877b4003bfd9ae039e6944cf31037891c77514b5899f02c29e91b54f9de0a31af0903d5840b9d9e8f9e0373b6c4d76a32dcdd29f40099cd6dfc93e7fb8114fdadce0d03aa927e3260db743e8c23dd21130a8646090985499431376811c6aed3d4d49096d0435954f219c3a075f19a7df3f680fb38a3a9f191337e4f626239d3752066ff74ebebf9593b06867fc996f64a4eb33d85ed981ee56cd9f79b5928b58787b6b5c0a7082bb7219fa4c709c676c082ce90a1031822e9cc368b6ac336568990c608d1f11a0b821aab4407ed4a17c79a01b1505ee9e24aff9b9e248193899162689000c65be867e77b5a448fcd43de9635ff90024556c5a777aa9f77d4276fa1c344774115a33b685f343692b646ecdb3a6d119866f2f793a0c8cd1d17fb2f2268c915bf23e46178593f462e3728c1169a8142d9224462d7b7eaf2c15f212267cb1e4aa65955e480c6a92085e3163f8792e87927ae625282888e7c162d38088f283d90c97b75fdea4f49568ef5bb203cd6805ce4d87f5907f4641899df3d30f38d3c3fc0c5f59d142a45b538eee125bb7347db7597b9d0584f362f298c6cf0ca88b8afd10ac452d08e57941bae4790e14f0d8e162f7f1c03233d6054f12ecde2ed694c126cc2c7dcf118f6aa5ab025ed6a3d8867002ee554c76e0d30f67bdb1aa972ad158717fb07840b1e6da6b03b3b99c4b8227833020fbaad54eaffc79a6210fafd0470dfc283b4d38e43942c08343e4a2ed7a403503222e78c6e346d5e8372c46cd1ed5f354e7373042a5c99c3cc1a2772af04f4ffc054faa349512f1feb92c92617ca2a628f15f959e2d9003e317141042da786f4bb63c473c9c757c67025ca178ad3c40070a2c84cbc1192f16ab79243f138c6e0f654289706733715eba8700b6df1ebeb88808aba93119c92e122df35560515a3c2b04ff43b87e405bcc6c002f9c188653b9d98820076ad6890a35877a17bd3d548dabcf08358135a02e3a6e2c4b56d244286d2b080bbc222cee9a39315bd0eab8539df903cc6f87b922b6470afa49693274340cea20664396484b29f3ee323ea0bd10c851c0303acb9c69f0372cdaf686d6b7baa6e8cac1180e0bc65e923e2a89d0cfc5828b287f58240ea455d55b7ab774e55897c92a8881bd486d3722430f8df532f55699bc9b716dae4cbf04fed7de623154cf13c54bfa85a1404da237a215ecd6fbcdc6cb72bc48046d41d4156e715efcf3c2c14961be7e03a1af63e330654ced1667bbe4f77863a7a0af7bc7d03a9dd8fbc063aebbaecf8fc856472bdbac8082a37a74d23432dff0747a556616696f641260d07caef0a7dc1718d6c9183938860ca33c87cdc5c6ff47d5633a7df3ac18eee768e00232821da901ecbc1b11c522b0fa45dba1a2a04e0e2f686601581ec6ae41032b3014a7122f91772945e0eb381aef50456ab9e1fe49375e61b6eeb773e9063e9b26c335343b9d9e5f89a982b129d108051d7ed326ff47dc382f46adf3b22e79e412936c9d9255aa613128b5b92336cc2cef4a77b6e27b2fce32910163bf1672def24366bd6e949ca03a4e185ef5cff0a4928bfbdfb58e251a8c24520e9826c42303d211fae17baf15d9766172ab13b1cdb51351f62e9884f2641bafe363a9582450ac57061f13b2cc540b3f9dbbecc3f32ff1dc6c4955b556d34975d72547ef3094bb8e7ce84112a9c617ba44b74f76ba1a308fb752b427f6e30a186368f55ac42937bf649844a2d32f210d006d9f1ea6c904f83fe27b3824e5001ef4a62857f7474493ed8b2283bba5c387377b0a082c148bcb805cee11a886af054b00fddda3ccf909c3d63973c82ac349dcc827c10e6ea0d150fb09bedfccb9900ed4c7ba618955af600ae30927edb97ad70f246a7b2366e4d4676ca240ea620f54dd8cf3dfa94cc4d0c759726c003547b1d8b18cae2a4a4509f723536aa8c97862386463b4067b82bd3afe8996550978fe5ebc8ee4b01e460d2c1e454b2d4210916fe5e5202a18e031ea0c598fa380cc4d2f52ff01371f44c4406d06d496801e52761b0f4736e4e96a1ad02d9dbd3fc03fd22c9cc5580d607b6a18a65be35f61be3e9a68628a98f4a2c5684a7a7c93e889b4f1e032b0da57b2ed86527cb2db04664e0d8b93b90475ce693225c11b61fd6f483c6ca215118265ce341c41cec745975000cc435728c1b31fb7d8ba4c14f79b8599470e6c49e42256fa4ee2c1fcb27684eb22aa768a0e26241e36b5fa060a7268beb062757874e46cb86c5fa369738b62e9335da44448d04f723aa4e906e9b39d7f6c4b70285c00bb1b3cd7fa2d44405d5d5592c742a3d0b6e39d047c697246247fe0ba1e2495f322e0b64349df5ce394eb9d14e69a71f284c3d9f8622a389bcc8abf1f25339ba9ce64ec7ae342788196f393c5aef0afc17b06daa7cd11c7a3fc8636c02953e8007d070c4e518bb9374dfe5ee071f6357b888a4499e573e925a57b84558d8b601c819b35fca1e677ae47888717f62135499417faa37d3dd083661a3fd2a875eab412a0333f9bccaf0b5bc826ffdeefaa332c2af6b07cffd42895d235e6a755fc46b92c8b1be0a5291f5d82eb00d2505dfd344337b044318a305a3259c30c25e7d04ab95a305431665a4e85522f94559b2b96d0f45ddb44612156a51fe02a6b242cd90f19f990c1aeab1a29ff9404d84f2c1dc6b19bdbfe8920137755186ff23bedbc7ea7a004c229a91aabc95cd2e798198abdbd00553470c6b00918d8334eb48e715f2f01fcd54ed0c65edc9bb6c0bb7a0e061d50d6694aa7ad5fd94ce6476cf48952137aa743582a6abe32308b05208ce2a1b44102a5b681b504bedea65cce11cea105d37a043912f3f8ff0d2459ed3b464e3307d7e9203ead97456113e5f23e6421b36f1a7141e2e9d10f4ff2f1aade6d15f1249804e4889409d21777ef58e575f43d3148aebd6e5b1bc9e8098b2b985381d2808dc6ff55c708da06bf54329ac3e632d08bf78d8ab69f7c7b1bb6d76ee3260188037eed6553d75073a7534986973117f200ce2bca28cd0934f29d805fece90e974bfc08dd98f94600f8b56f3ee051157baea9f99300ac7c46e8bd4df46099175255ff87325eca86e4b177e3ce076ef86899ed50317a95a0074c1ad85b9430c022059df389e0897859d57eb9bdc6b4135da630dde79a47f07af37f6fddf5742438e075ec69819822408b33bc8b1e0408b08bbb065d644e199950c3cc8b6407f4c1aee5448bf565790e4f1f07a35e63cc7a9d1ec20f22ccec7bfde1988ccbbd8618ddc4c807eef425d96355bb41e3682123ef3467aa223afed700156bc87a8ef7ee59b9ef4bdacc8863fcdbe37d0b5ed03f6835cfb5f25fed48135f32c0c67aa76513f21435b0ed74e16f236a505fc8942da8cd5b2951af1c9acd79fdbb350f1550d5d1392eca4ecb0bf72893011ca1b6a12afb55c37fa2550d16cbe6cf4b27d8147795f36b0b7b233d8651c07f628712473d4773683db178920ca101375ed31f05f9cd023b99b1df3b0edff52d26b8ee28a0ec8ac66c6cbef0fa6f0698e59953a8acc75a70d595cc7ac5b43be82116fca832809582ea75743c6de846d0e0954a65abf1361f7a341b89de219518f9636e8b13648b0a57c18d146a2907633545674146251e4014446b2bcecf998053073d190788db172e338f08585bb35b2c38549bdc06deee7d8192b0c46008143f8f39b4e7ac5177c72985ec873bb2e17faff4e7d8ea3ef692d92236d03c5db29cbb71c7e22dc7b980693ed1b6db3db2044c53d95d21755f60d35a76e201b56fb035d08c54b052982e73ba3012d97763afa7f8c1c70a057519891ecf0918080a7e91b9357093caf32f46794eb7a6482eff6d76ec3426c4e67ec6e3010290aedadcf4115564115bb0af70c30fea5ab1eea0731eaaf4b250ec7ef9c9b1b10ec294ecc0661e47b3dc01e3aff5369044bf06920858ca0d6c907c639f258ce8ba1f2a8edca85ee99402ddba302b0bbfa30526ae4a1cde4ff630844712043e83610fe0af5d90deb77bf945503eaa65b5a8e7ec310cb2bb1dde104974782357bae847fd7398d49dcece805a50e5250940706cb3ae6ededdff0e80705c6319a904c44c5549bba951322ab406db97de4bf18f762785197bbf86cacebae841ad9857d88f3f20d1d59a7d5e36d0b27262fbd431557934607b4e89a892b28d29acf325586789045d3d0a15cdf9b13662d53fbd693c791af4b11fe922c4388292ce79cda1889f29b7f82956a99ddea46d8996490e288e2bebcaa6e1cbd50df490e1665cb5d56ce94439b6579e6ed6b3779991a0c9414639367dfecdb411b6ada972376fea43a0689ce23a880c49cee58dc6c5e7fdd876c22270e9cf9c1318e72d032e969e8ff5354f0e1c374e3fe76d4ea2faef8a1a4468597d6a6c4a7aa8d2bc906f79396bd183a78731576b78c6e8270ab90e881adfbc160d1c4f9b0ac88f1eb423b0792d61060d8027bbea1eca551dfb50e5d410a65e51de3b7ebf84db60cabadba0b19d09399453d51a3c101af5da8f724d94a730785f03fe853a5bbfc9c3f7c6cd455c28eeb976df9aa5cd014354d9f10b7f1d8772ec34619b724255a41119bf8268ffbf74daa7d8e409a59c315b7ef07d2f5a67dbbe51a58b7cde6069f915c012fc27cf3a82c73a16f13aa75cebda975b9c8da4c99eb70188d5ac969bf939028fce1109b82cde182a2e5fa947c82413f9d080971d25051a6f7322d5ca4d1f9fa86eac287418c268591d99f05c3a3ca0c979616d59c4dae2d45745c7a0ff474a64147718da1c2616223d8a36cdcbbe345573ab899f59e371d535a69b74dfdd92ee896f05c0a98cdfd3681a8ab02551fe93415882c3c0a5a8ed5f509853765a0da4bc41f5bafabef75cb682bfdddd054d7507187ee5d1aec86914936cf525ac3b2f6ba766c3c1d7efc37b30a68ed8653bcc55bb15bba683ab54836833bb0b6beac8e2d9df6460e3f73f031c2f4410c3167ec826c97df09a5fa36c64370bca268c248601d8d775771ffc6422b8b5258ff377d260f7681e52adad8d6d02c37a2d35d5771c851c38adbbbc77716b1d280c4ac135ce12ef6ff1e6a712213a20e66797c54989345e5a2cc31af5c5d4827a1beeeca84dbf2a3b722790972b7f6571b43098330ed44837bdca287f3902ccc6556002c7d846ae0f36e84ff834c94dd0b6c6894aa05febcb8986992aced05d10ba453a6c9e381df73cd49d54a3cf1306a23b98abd68b67955164567a015efe730707d2fd2ed7f588e6379a454fd78997361308f7c2393394bc58dbb3627d92340224dee0ee4bc542da5927f3732945eac03c3f7a4d114a093f5ed956cf834ab276a2e457402f6145d7aa4eb4427d3cfa8d47c55443eeb5472abea9da5aa28e99fae9a5e21edc5d506f0463183181384b5c6c93364b02b266c983101785b90a173b2706b7fb03cd9fc6993c63c4976823d91ac6c403826aaf7d17901a1ed89b11268677d4acd5edb07b05de96c1370b93d210f8f948c4552986ee8228206bf8f4886e486bfaa925cbd1de383e53ae5518847bedbb649787c5d5d0e691245a84a7c69fdfdf3573f5389f41d7d8b66767665e355feee6a75c50d59135d7b1b12a87eb4b47e598d6649b66066853cf1c3adb5caa85ad68fe6807697715dd3e604247fb12f1f6c5f7e444b381af4bb16fc6ea3a32e6c68a5af94cc55adadbf9d38452792d58d87819a1d11d8707c456929bfeab6decf2618470e07b7a487e7a4f5ec3e2acbb7f212ce6197ab99d5cbcb261c1ad0d9ea173b452cf4cbbf8a4778a2e7f8e33b7546d73d1bece0138eb82de6b845973bb5556cbf9c696939ddd337b62655b2ef16e85e33c34eb1721eb4bc7148653caf73385fe34bc64323dff2be386501fd9cdc303b8a50f51bc18867e7a68a4d7cfabd633082e7a42d4c79a1b2fa3fce99984c7271eacfe4589a8c70a352c380671c5088caa80a23d3237de11f1050ab33d2d35b5e02c2b15bf70090c65580aef32561e04e1347b93438a855bc3d0f086be0407b64eadcb76595650061e2d851abe61f8ebafcf3b07648cdf8daf04ac2294d785ecb99a81ad32da5c74bdb04c4a51c33ce90c55e6c5a673c94073f1e63493c2ed08a47a4ffc55bb5c3d6f223cca87223db04c83de92fa80cbb77b4b2ec171b4daf81b4b08a151b1b104fff4453b61ee7736b4ce840f9c677084c5a36cdd07a9e6459e425ed2c75ea5187c27194a606679ec663f1ecbb447d9afacd26c9464903500c7b4d297417c09ec37dc83358b5c4a90975729f97cfb23f9696fba21b8020e585db60cd86e57d7914e97d98f647fb3b08a398a9c3d776481ddd5f4b0dd3114ffbd1782f430f88707683bde0c159ae0590eeb057bd8622a1f7cc3a9590add83dc4c8c15940691b8cf26481e15ff6dfa50ad93feed79022e76ed24bbf07656e4e9850ae8010c11ec771e60bf4bd47e78463d559e175e3cf1c2fe3662bebd7fc790a48387e388ee634cc9183bd56e321afab2c40f0a589d00cfc0f1722e305374906ab5f9a43c13c241194173ac8e05e206c6fcc3c5af684a43ff07004bb44be5450eea641f15cda9d4c252a6d8a33c8f335b0ba8476d571f4fd4ff1e054102c9f02d3e4929a93dfc36e8d6f55dcb4c5eee239095f2803358d20b997777389541962b887bc22c3d71350d241c265797170d95500cf22f0040280ed2b62cf3e897a28a38d96c2bc5023424b80cbeba5446e27fd753680f5c409d645860a768ad9f23432054c1a772d8fc6369deab24ec2a4353e87ab0f1bb9347fbd50235bdc63ebaa5ee962e49d60c4bca78d238047e73118ceaf4e5eda741e610a8254658a6731082b54484442acd75fc9866d2e79e7406e4e153c92dd400408f15e4a77872ffbacd6643602d947da14f6e25b9fb5d1df591289d428ef109bd0d1e7bc725f2b25773311e3d48b543c5244b166e1bce36776ba2b19d9af0e9945e6cb63d1ee9b345633e7f5d6a3f78875022fd38e7491f8a839e20d72ed0c0a1ac4fb9660223949de66d7f78be275f2c2b8b43920ca2fc35a146383d6fb2cfe14df63e8bacb6c7064a7d2af8b0aedfb365eed9fbd75a27b0d0cb5538b464d8ece7282a53a6adf81b3580003e18e0b2b949838b9c07b5495aca885425c1102ab91164baa5ccf8fa3b6d8d98cc9f0001a888ca3435cbad3a705c1ef3ac8be65954876e568ab4c7719688f1b7888078738f303121f5445fe1a65f047edae9b7ca07f116ad959557b2526b2f6275457c7e3af66b9e9dddcad37a8077e7ea4037a5bc9deb1b45cb1bbedf623c48d247215dce5d14853dab7d81812a91ec100145851aa144e5c16bca9c43a1a3698a24d762af6e560e7212e7ccad9288414945a4b11203765005af8e557e4f6a6c42e6cb24c726367246b4893e1236d899ab365087d5f3dd9ab22193488f1678bd3e3e12afd34aac3191ec1e21acd7b359be720430b398fcc631abd6fdafd509d0cf9aefee7d86ebe8bceda065cc71be3b502c878c1d43d11c0d3a1688b63bbae914a29dde2135b3b541f6a8695ab867f14d6e4ad5eb7a52315e8e7e0bd223d5c7118325a85309569d36962d57af2db8f585d3e45f3c918e86aece78e4a6a944afb2ad2e415d50af49b6e90e7baecbc51a891f4350c8a3c0ae25b00f92f00bc35ffc72e4fa590aeef09baf46cba31e1510163d8e4432b6ff0a1e6f34fd12133760d62e6ded624409788ac3cb51ca6f16ef28c60e8a97c147017015f6b30890bb8aeba88765eca70099ee32b3b5146352d7f7fcde32bb81bbc2baf92975d4c9dedfd39078502a4233e6476cf2b4cebf17ae8fd559f00bd07ab6eb56e062c77a5eadb256c65d2d6c41b4cf417fbb2cff1939cb824fdc03fe9ddd5a0dbba1d77c34c9aea0dc234f8b781b62f00f8ed7d47186b6fe68c039ba4744724d1edb6f58f3796f1edcbf57aeb26947d19a07baa3aa19d185397f6895a5bc4e0df6caa17d5456d45353f5849c6a8a0fe08457c940f0b21c79567d44a597de244dd4754e14e146da9294b8e56dc8dd7c1712ce58e885b1e1b29ab878c4a3e22afd16e544b2479c0fbf7b9617ddfd4dd6271e221adeff6e2be3d6fe5e30ff668ac1274e6a210faf14fb144f5a537b1cf325f4522f52f8a437e78a372f69983d1d6534bfe44fdd13a68fd6f57d3c87098ce7a8eed6cd6dfa851a9a40daa7b3857b692069a5a941c516b4ba7edb3442c80f26f27fc9189a88851885d24613e432b6453b282610a5168a056209b7bde192e6614ed9ab1a49688b0e8377e38a1ff2dba402e157b9dab2b9dbcdc3fafb55f885da6a1721cc7e759058f8243c40a10e820b24aa2eb0c38462d7227bcb2678169b82c208ed6cab0281dfa0d3dc393f280b45d6812e4de2bb9a711cff50cbf07d4a1f5877e06536b8533ac9f831fc682143200de6a6b09ac235d8538232e76809c3e8e9c0ba1d7de234014701d63960477c1c943759de3f04d770b1d4ec1e302b9d24abf06792a54e6dbdd30d9efdbef203843f561d796616b411ae43e14ee23f5829e4fed5fe6d25d6367483cb31c23ce2adf4bd9834168a2317120a322ca5fcfa3091da41fa5236ff5d2414df1cd316fe2b50a02e59737543c94c1602f7675f70354cc6aab9d974eff88c8ac894b6d577e5e5b1c728410a3397d47499c0d428051ce0bdb75221b6c23378849d4a165d17096ff470466e7a44556e0b23784a8f42edc80cf2438eb4ec7d59dafa423c127309390fcb3c3dd18bca0407e6fe3d68a2d54dd92ba384e6f54e6d945b9bdbd212cad48b5921be482b220a20bca97f3ba1cefb2972016bde54c44b54677ec1f30f7455c43c68c6e445b08978275c54259fc01c27e4ed581381feb4d628861aa20f143b7272abc037ad2bb68669355124bbb42693cc296328be697264a295f044b828c5b5ae5d6969f1a95e92616a32d1e6fc01cf5862429b7a1f4afe2468f038fe9f6297f50bc5999fda2ea38ae0d2e358bb719ee9a628457729d2bea850d6fa2d9f974306c3a5afc4faa430ff469327a5f244ec293e72e984b9ff4cb3a281beba6729e80acc45e5649c7b36f54aea522763c30995852c00bb2874c525e3f125624aa5d042f3575ebed377ece14e282ce12e856b3d3e3c06adbd7dca311ab6a3ce0483ca295fd001fb4fb8a24d9cca15edb0fe9f65c4975bf7a317b32274a8a9b2a708572f1a50017ffac5661275ff3475f39c5a4860df8768a44fef7173d73f09cac68d7c32ab00d3c8b800d164c080f533d463473ba81c35ccddbfd9411d2c5fa8a0ade9ed8dfa8d8bd15340aaf1999048a60ccaf0fb40d834fbc47195411d412028375983b2466972dfbbbebf024c5d712cd24d3f0e8fc7b29abece3b5c0f5adee25ff7a51c94a125952167fc2b3126b67070b9159ec74a017caf3c241c70bd3d7d47262c3d5108068e3eb7e4f39cc6c99002809c9ac1d30e628b436bec71e223a7f2d68c614c5e58daf0c96f75008ca01cf63d811c50332e43c1b195c033093b1295f0be1ea0cd857b39f89f7f74b74e20a3a5f56a8cd391491c695276db26c45ae15c93e6e579352032e40bb0d3f26ceaa432776b3d1a5917dac1a420e9b9279649ff8828ab593e0b80fec18cfeda7b39d97bc60c6b3fbd0eb2c2ab1eaa98d5072cd1dac34354b305200e6760aad58fc683e12a798c905f901e33d2cd84146b6e78488d3423eb8e61eab932bd9aabbe69027ee61bc740136d12d7bd784168ab4d6b602bbb96b46828f53cf528231d076877c8f0d147fe0b54c6a96f3e76b116017c6385fe5c8c193e3209a1957f9fcb1b4603f580f86253bcc158029521acb5ef41eafa3c5156a194e368df3be5b010ab612561afa632fa9b423cf1fa8efd290c54def620d0172e37745363dc994ac63f93f546f0501817f3bb09fa3300e3aa64a15ce5e4be4302cd40e7dc7e626dc71bde2860d55137e9101a5e6eb9f0ee7c3b921c22435eda754509a5f768625523be00ccf9f999a1a6dc56afd6c8575f25295f654ab4fd8aa00400f2d4ab9869a8925b7db4ed1c44df4c4c3c5ca5837514175ac8a89884f96dd8eb37b90d4eed341a815b08c497fe1ef45fad66f64655d79bf87398e4e8a077eb4e191d0c18b7de963d6a6786efa6b6f2731cb362050512eae2a8c655f561fe0b960015661c869df2832113921e27184586d43c2454389cdf264676f7a39c7f52fabedb09d73003ba25899d7596a100ad5ba5cebb556e08f42123884b68e5080376458334adfbc270aaf8d51ff0be25beb0f7eb82e344","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
