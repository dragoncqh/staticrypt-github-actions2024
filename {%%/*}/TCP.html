<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"684116c9e564a7c4aca0ca52c558f0c42e874a37b680bdf0e47008cc97f3b05c68669d81c2372592ee62c81c72746c8c8bbb4b6ab974fc2864de2a71126549265f39840e15c0a7740a1a79bd012d6039968bf156d6e6239c1f67946bf5f51febbc121a31e670c6956a5a2db1bf8f6ab3be0a625248eb36a5d449b2419300abf1400b0b36423f83a5c9a585467efd6544e493ce8ed1f42e2d61f9b8e1b324aa5062e4cd75f6efd969a1b7212245a71936f90f25c27e635903680d78ce246aceac3ef3393d8b9c8e3280c57a15e1e90ee8870fcd2ca9598a7831abdf420fd5594ba8723441e61c649673480b006870b2dd1a2c69ae5e11b99b1b9c089604110e93d49cb33d34246ed3ca197df895fb19cd0f0b05f63c7d13621fd893b1e1d762ae3116b027e70c3893c758fa971ade79bec25fcffd1bc256355d47c311f2c4a1806989715f0cd702c591241dda5374bbf97fe19f105740aa9c5a96f80a9e82a853404da6fb51ebaee96c2d43afae68a8ec97108f5ac953b068ca3ff5df9178c0ed9a3e8e61dfca945c4a4606be89c65adda589d522b08f5a831ef1c7e6808e030fc128f374c01b60eab8b1fb2dce1ee8dd5da5b438f2a0c88455e7152494d2ac85e258807bc4c87ea3228b1cbf86d61e17f19b65c9e6f93811138a416b9aeed6c9a5b3dfb12a2b9c06bb953f5f7007e31372ccb5849de3b97e2a87048cc791479399a5dad97dc99f3885d6dad4d441e62586ff726d5336741a39f792fbbc46fe3db180cd8e0c56dce9517f8bba0f446e52f3045d056ac96c85f27086d07d81c575d31d31f9c03ee0d84507c0ec5831c70290bb40b0cadc844b76a2e6046ca0d36a572063a37ea59ef18e50e197a12100a0c5e3aeab6fc08b73c0d63f64aad85610ae45988edc5b3253c08a373a4b4e9717c198e40df5904becd19ee13df787ca970d596a3e4b59a161b0e2ca75a74527023ba95d5e3850af9ef0502fe4bb1a6a937bb6041e9476cc4c461e26e4b25dea0ebaa7de479a66639d289dcf3f5be08871d6ee1404ca69391ca7f8c115ae86c4441e282ae0294edc7b8da67957b1d1d2c1ac18e1388d81be1734c20ff1abd85099880537c74323f18cdefa30bd973ee1bee35431405f7e384d0449ca5f150558fb68e734134b66ad8ad873ac9a121c4c154b48645c0dbaa43b236c24eccc6350caed76c76b764d3570b6c0004563a0773f73ae4f2114eb5fc7a4a241aa908666d2d94a0168e4f5b7c5cc488d888556353a580e065a440a0f4f42a3a0e562b4ed856e2f00a1be390a91aca9501afbc43c7127113bf12a78944151b6f6d0cbd951947a3fb6ce88c9bdf5a1d1a0200aaf3c7d3b4f5d7b0398541287e9a7cbe61cc0dd81c8f077f9dd4ae4a95de12c8f15d9b6afafe0a45e12d6b7364ac2846f5fefb27b74079b4ce5666c537310a291e9b5b73bd3c553b40688a713e940dcc634e449fba2966bdd6d23478d090ec47ce176ca5aad1b293c94e9e01e182ba7df915df9553a7eb629e0090f30af25107589b81fb0059aa937825b1b92bc0facc95e45f9a8362aa8d2fee515f18b3fb4971c75b6b3a16e12b2d2730eea07c38bc9c9d9f251d7dc21a9298571d26b18f9a6c07b51d1eb35cff3d279f305ac96a38e791de81898acb81be825e7df1ca9a44523a184ad320961882db842adc3803479c0e4fc0bf6013f38f6cf8dabc6189035ad45755843a5049fe7fb2de87eda0939b453dc9e0156e9dc8ac4749ac4474f9f2f3958f03014cfc5fddb5dc81130950f26153975a22812f489b048e1dc5c8177577adec4f95d26ec70f0b7ee9fa3a57eae46b06c2361bfa46b82ebd217ab2244a44d6cb4635aa5a0eb60fe9afe2395e38c57eff87b5f895778dfbe8b7ebce083b1131b79117fa8f735da95e7fb38fba06026bd936ca1c1b262e0ce48639bda2871512959d02d73f9cc9672002cec8b6e67c855e7d43e975ff07891de9449b3244866dd0266fab9d3458b3c19e18ae7b7d43db751e2910f38ba86c7eb3913d0204603b2f894704d1814f4a8ba52c4b603033cb9da735a54231a13afa67d7e36c057bdb3fec2b047d55c436a0acd2cbed0e1db54cc6c658d2522e2107b49dbfa58fcd11a7b8da22a730b08c369418fc477e351e25cc900b2bbd8043aa0667b53f89a72b99a306c17f40d74686d1b6ac790f284f18637674e7d7fc1dd714a6d25f86551ecf7992f31de43a4dc0f33db324ecd03af8d803bf2110ffd133755caec64467c0cc29006bb2aba87d59f5224879fadcc1e5fe6c17e3fde652a73d76fb3e58b4d291da62e5224175ba2597276785584d33e48d0ff66418d37c88265bbb9373c4c40a7a11953c216d899178c7b3355ddc55cf7f961f5aea8e67c07a02f53acb9de8fea2e8d1ae648fd5db0a6caac44fc4c8c8c74c9f5afa0b1af7b591885cf9f5c5ad45f888ec75878c7f96ec8bfeb8af996295be3b5b9e70af57299827c2043d83005f87ca21a45b2c1b645f6d6b9b51f55e463dca3eb30f22cc9a3d6de5e2020df53b2127bd57e338e6dd973108d000c7f778f8cb879386c8058fe9de9faebba38c71245ecd6494b39a467ecf89aef883f320641a9cac6c4d7eb2fce183905caa69bac38d2b865a2172d6648c732d9c417cdb5c53317f904447c60f6baf5decf897930a7eda51ee0a3aa2b4c9f6cab894f6bd4a7ab29f860d9403e9fea41f0e6ebdb35b238eaca314424a2a192482e6e3ad34c6e0bb9a8511d71accdb15fc6a5117d2f2595fb91a1c641b062535aa7a0ad02d65a0c8d814fc5fa13ef0b2af8c13a5e95d6995dec9f9c6f79b11e16966486565087bb2e1f9a83173c8eae53a7bb1ef22fabeca472821eaae77e47213486ac8523f5cf74ddad1b12013f915a7f9ee690cc4da3be3d720b36410d2cb9ef14c4332296c03ec86cd3bc654e3231b27d4bc0311d529cc22b7dc4cd34d6eaf6bbcceaa62b03dd9018440d3477b9ec1aa0b431ac5ea4c4e64ca67da559290f3cb2521aeafce908a474fcd8ca3c93d77d5fb65d6f5b113b8b6e71b67f8e68db9c6cbee42b52367de75c88c8b31e6a49666f4d952f173d48fc5176e2bf9af8711d93b6fa4ce3521be12fa069b5a00860fbe90cc1196ac07a79e237d2a906c4910017aa593bf27779e744cf99113bde4a50675f35769c26a17d89b95bfe991104731efdb95e5829df2eb055c8183fd092464d25231ce20a13822597ac407f37948fd64ac965197bdefc4a1235df3381be42d2c309ae6be226acdb5e546b456d54531a9d06aca3084c7f2162b85143c1006e6247fb60e14bad356dc8e2381dc3325576ed6a707d9d722a2b8f05e9bd4aa34723fc24e74d4316bd72e377e03d1c09a876a3557adb69eb097a75c54986ed1a13447d46475225a57f7b9e8badc2153ac10114948ae34e33bad67c113415d0794898bea564dc1ed6e1bbea66f03779740baebea9249b9481190dddaa0760e4badf4dba88ecb0fe4d776a553d9198f78c0d0cce5bc951fa90412dd25e396add6e7209c6c266bd27f9afffbbc1529009647fe5c5fe870c44fc4ae39a9c7fe97f8b8292e649678f5d78bb1923d45fb977be43f0d9f1f544a205cde5301571b98c5b01ac5875c00d652e541f96ccc1877964706c8163e1694f7a5a53357cbbf626c9efa7d4ca167d679f76ef86b718aa4369204ba3278512e54c0b19228c71c9b016eb3a63e2d61ed7153b64f8647198b89e74399bb7c1591183ab8cf6acc371e72fe499593b5bdacecadef81160922bcfbb956d878971c63eb0a8f6445b4a0a08ac25cb9594d0ec2103dec54a09746499c3c85947e26682d2ed97b7d5c097e0a64182da83d6b516ce36c8d2e11a48bcd91d0cf4ad45caa5c8b07b35cd29ce744f90fb247cfe0aed33a917a8ce1b6f99b9122150dcb2ebad6faf5e22791f742c40c0b1cb9dc047b9f98085df14e5c0e451917329861b81429fd6718d352f974c950f58d486327cd91f3ec3f657dbdb0c1a28ad934f083a932eb256142d7bc9518c25d7d827896cb8cb4e068fc50f9df8363879399d9f8ddb1a2336c5350491e4baece915738c5b0902321d675de001bb47ee67e838f6447c26a8aad6508a1321c9953647e6bbd73e9148a31ca177a94b239455b6c627746ba6039e3e93f14653ba3852bf26378956cccd7e50b9591a8a928540d1da0a9fd2b26f3a7462fabc9e76093def4783a5f0a564aae8e62b2daf86b65d14b09846f1fb250eb72acc0d6a63062e05e92bfb09dd2af83ce2fe1c3d5834fc82403eb02ddc8a67872fdc40b94f3e860c16770d21e61c99bbc73f6aa5fb84336ba988724b78d3a26b889b201743c0a39f2555822524423aba79b74c7300890ebd4f3514aafca1dae3ebab999cbc4dd965d9803dbbaa2eeee39a41231cd97ad71077c9fa04182bfaec0f549fca9b5a908c6c58b098cdbb6de37489a90f39642c81d8a5aeb7d6ef28b11d71c053d8727f686c7b6a0fe3653dfdca61254778212ce3d38daecb359c78146b58f21e2b95abd0fd53b33891e38ac7a6e2808a3c6ba06afa73f050c4ef4be041f59149b2954a6609d91086248d7630b3775009735dd556de2840a5755a2c67cd45071055440205a1aeaa3cf95fce27b26455e315dcaa08788c6c8417afde0f274ecd98e6fef3a05f8248cf67b86152278de630d0bfae4310c9d327ac82d7f56e43f0f03de6a63a5deab2c8b6c277a0600fbe06174c6e3e80fb342fcbb1b97f781760456a3908fddf66253e0b5ce62e2983a3887a5c24c3e86f2da1c560b502cce03440c9c289079acd647f82999d7aa53a80d553acf4d27022023441d8720be7ca046ceb5f45eddd4d0a782e6f89affae91a696f8e614e5a21e1f2b0d41c968fdcc6a98c405d684d3d984b22f970b7401a52451ae28f5d5139b69e7d36384fc8aea9078c62262e30f4126a0fd428eb202167bba4017d61425505f60c1a846878a075ac68273f8ff67649f5155b26af35ad880e5be4db0b183a04baa424232752f1f6ef961353c5ed4d3d0458f60f05c77b08a68c13938063857e6a9aadf01921da61f52f8c7a7574ae8d489387343faf63fe8a88f608968c0bf99577c832806fa838d5bf6ecffeb51fde0a5ad2b2ab708195c8d032c84bab7fbacf6e55128fb942e9beba470d604e677724943f2342d1ff5d4ed118bbbcbf53dc64e5b1a96fd72621d8b0ae1c31cd558abe7524da996fde8e4d64ca4f4d6844dfd80dcbff633cc6849ad0384bede61c418a37944f18a2f3e2bf6ad31522056f6aa76a91555e578a0e7207c6ea5a4d9dafd9ad27b65306cd6e751af533a4ca723ce0f90e611519795ea15eac1dd1b72307fa86ef6936f55f96825641aa71c62e8bb9d97f4d4dd00ed542334ac168e1085e9ad0f06c117fd69f5c36d1096e94d2ecaf86c3125f97a1afccc74b6c42223defe37f206f5c65ef7c4f700136c8494cf18458264a5fce3b72f0e2deec8b7238be70b2828679a56e812cc301df76015a5188fe35bcc4d64aa21d63086987ddd691f750f6d0bf0ae0ea482babb6edb43bd29fa7c4fa436216630720d0dd1ac522bab42d448f20b4dd05391e59b0b49b93bbe0b509e7145147122814a7bfb3e14d7a750aec18f1e935b59c43f7dee61fea0268fe8246b7ec731d3557023a4dc698cbf0f16ba8e86868628e60af374f6d59299f0e099d468282955ffe3a4c5b4d1a069395ef77136ca012df839d30e7e8dcfe906757120aeee33b2c70484657084458bfe6a3fe2b70271722a0a2e43957d9fba49a77a2568723299c5c6b26f809640a346487ccc9e20b9ca284f653bc5ec10ee0cd3f6d401a5cdf4085e1c0b08e93343baec1393165915c37fa608e17288f670617bd546b8e6bd25e63df9d587c769af184a7625e523b7b6b4fe7166e9f744a1eb2c7641b1a437eb46392a30c64cd1b5c4d9b0fa4bc6d5f61e844efa2476f3891db754505d17480cf4f840113c9c85966f91e3300b89a92bed613589c71daa6c3ddfc6cf5a79b4e191dbdced178c043b8fedd15bbc2db6444fd6eb3e3cfef11efe42ffc3d1f99d09f9ad9030f49e35314099ff6e39031c47b3fc731949e90f64c4e05c966c40b01e68243eb685c6ec3da8f63d694f4f340866d98a7c4bb4f2add68302ced4599a08e20506072815f1f89b61239ac1224c06bca154bd6599e955fa8221684b023ea7ec16c94604be043cb0aeb8158dcb76bfb707e963f024376c84d87589b007766aed546afad7880a6e933da84a4685b5e31d39fe5f1845cafe576bb6141c528829af00fbd6bb4202558e8d1a048842a61a5d6b3ae5fe4a98fdb6133314e256b9c0164b8cb7b8097df3711173ea145f508b5453861b4669432cc18d8700ca05b2924bc8e035c267c6d46a061916ab0ceee79c85852cfda7646f325a798c94a16d15b42107a49aa8c8d6ab7c516e0f803d78a1aa04d913c066cfb61e726748101c05ea1e8d823e4a0af3b6a4d64820b0b85a33591b60753f72992698ada4931ce9260b5c5b73f2676e91ba04b0fa45db60fc3bcdb71ee4dc3d2b1e6d283d7586072ffec499e07fbe12ebe0a03aa727cb6eb06c59cbb0e1e434dcc7bc235899d20692ed066ac1550747f626d8d3257b3951d3417ea539f86fd2ad10e49d1ca236f0f5e37435611c1ef509ea9215d7652ee39555666d5d7196077e212a8ca96346317857949c4d0692ec0035b5cc0f7ba452ad2c438cd6938def34a618e97800357228d6db458e69dab1eddda4795347440d0c94215b8840c5609fb5c0b2d07a72d7b461f8897dbe5dd53e0cec09fa140b4821a179ef5ec8f878a936592235a292b200dbcddff5dc9f8e7f1929b471c1d1ad3c682c9e3cd60c1f84ed52358d7d7ae571d378e2e814c2ab8abe41c0efca61a4bc9f4e702f6d368bce277d93816d5d1b7932995a4f111fbbe1392b2bff9faa18b8cfa5bf9f2838ac70a866ad8209c8bea868e3864c4bd54aea731127b29384f1d72ceef260663fce95584046ae01cd898cc64876a98d0f9dfd4a2bc2aa0121e946c92089e5d4940f4de83695707ca0237b9c3fd50f07853d6c0e7e9a69c2b237e99f756341f34386812bf37a94731e03b00847935641b3399cf40a1c1a4f347ec1bd876ce6d26619a87c1ccefd3c35186baabbc49c84b7dc04e39c54c485a4ea79bf148d086c13b17c8e95bec551798b4f4910973f4e04a4e7da660bebcf477eba4f4ce2ba0bc229f2a423a795dc3844cccd30c8583b7d4124f156cc8026e28d73696a6146fbc2012fd4826efeb401060ce6031742de53b7ee3e5f6971bca2606bedabcd07a75cddb948217b510b48a36c09b0dfddc97d931defc0bf6f9888895ef3cd31e93d2945652c00fbb76ddd045db715c6842295442c41b18e7cd895f66b77a914ef4c1236bd16d749df74c1344c2b5c14adf3d7080725af5eabe628f439288400d081566f34605f3890afa62040633ea98e51359efeeff58e7fd9b83557d4054783901382890e2ad8d97b58fc3e5fe3f9a52de6c60d813eb2ef40dabc251d7b53d5406a5ce26be403d97797b679f9fc43fdb9abc5c40f22376dabc24a18cff5ad6218d65503550913ae535cbda377fe476e672254c3edb57812f2d0abc2c94d21e3322ffbab3ef637e8cfc6f885727fe1f1c4dbe0b41946e873cc61b34c827e448dcfdc37261df7204ec227743ee85f507a9b7fc103d0a948605bba6119aa45b750e3ae0c1b2ff760e22e98e5780c34cecd80c24ee8e408dc160a85f0d7ecef4190554669a3e69fa7205a3fd3fb1151fef41a5f55095ae7eceabd1b31cdffade3bf12df5ba864100d0866147bc6f8013fa0b44e9da8d1c24a865b99415cde23919d65ca07ef387582870586397c3076da4611e1f68b2cfd2c3e36708835d6ea296a6b4f7025d34dd147c0d0413c6728ac4bf84468b5ffe9faefe23f84179a2dea0f4dae5286493d5e2848f6ca95beaa32fe0149903366350e4a21a2154627f8ca898b8879fea1d3a079053eaee284169d97188e277a1574be522b16464b2f71f8ec7f4287f32ff5de4dd8688dce706f469795e11f6b267621ccbc3d02d681ab2be1b734cfe440844f0c1aaeeaf5ad375f92ef16e7c994d4b175e023147b74d38cad9f7a136756fde6bc81b93dde0ceb8f46d9fc4548b5acbfdc2e1ba49d353e43b578204e41494cbf494a4903d11821b68221e3fab43365fc399c38a947e5eacdf5a7894748beedd1b261370ce73f3b78e18dcb57391dd5a90a34df5397c4a4b4332c9fb5d45e02bcb3b3bc818ad0e085f2be1ed5e10beeb439c9ced2ae6a025b51e8624ab840eb7d7fc264068ff24dc78696e456d4a78ce15c1cf89f48929a6c997d19f2053fe4b19eb41a566556c509baf0e951c38eae21e6615fd27b62eb904ead0561444672f8449fcc4991d71b0b877c7ee8c2c655b6688143fdfd7a9ee8d761266c551584068a71e77b19317c14758cddf925d51124b1027f1de7472a05edc040057a90aa2ffed61ca7f00b6d45a635f420d0db6b0ab2f1ff1c9544017173c0e2036ec2ecb7c3fb815d5b439205db0ad7222d798613ec6e7c356adf11258def308c2e03a836d5fb3f11fd1599c50c809fbd61bd30593a2bc9f502954486fa2ad1e5430303324825a8f5d05569017f5bfe36e38c12dfbe44ac6ca97b23ed7fc7e46c76b2ea0bc02c9b798039aed3f8ec8b75a2493cb33e1d4a94944e59c1f9d3af9d5b8985221f4771c07aefdd1b100f5b933635246554004b2ce9f7cfa889ebd8bda9812d7c7c1d9617374f4c5354c609a03db2c7d77952ea69a7644a9d4a91fdd5bcc0dc5bc7f0067c15cca31cbbc20930890a75ae246786b06410d849d5c3ed0c1d198b740ad68f50cd62cc23950aa3c324ba4b88e0ede9b6b8a0c12ea8af438d75c34059c0e73f66256b605a63b6bda3d8ce9b7ad92b12f02228407217d14382cc29f80938b7fbbca5898e905b049ff928928d7d403c1608bb873cc19115f6579bdb58cb358ea0384d7119d353a370f62e04fd15c5f550e543b72c4132a84481394b3e5411fb1d5346a15615819aa0663e32320d16f765151064658626a280efda291f80a06d6021614c180e0d7c39c478aa41ede704c04958cec166971b2845ca8405834ea00af86461750f963b83bd1d728f5348e04f191658fe40e6916450bb7929137c9d0f0f1ee89c6fa8dcd63cc36e998853602b0e73ea692c2d876d930cdc40a73d5c5efe523bb38a71700e183f1ac55124e87445c0e622f4e57d6c04080e3752ad23f38a80215f3a8d9076f16613639aad18c4e4d2d91a37fb8b89d4d76ccb97bdb891e8be78fe9be683b1d77651f62be84b3c4804b2f3cd7fa0189ed2fe3619c8aa1d287888c26d916d274869a2630e5cb675b94cde42c1d7dd9a0691215a1d08a8f98b85bd8188e88260b27859c01733ce82d28546926cf5ee4275f1c67679f18b5976bcac97c5cfeef9ff7d23f563793ba8d7bdeca413eb10c0e6a778053c150e188aaea67235a6b7d24abbc64088dcab9304b331433c6aaef179112a5106ab03bd16d02972f2504458082d1676a07ae2c46784d8cfcded1e6d00f7924031f712173d65bbe3d361441b4386161b5fcbb6fa11f6c2085771b384513d187b287adfb9197c5ba4a7e60417f16311b55411403b1ee695696be488e900c5719bee959c8b054fc73e17a5f16cc9bfc71b8bb3740b5fbc2b6c4d7d80aaf64e29ace828da1cc1f146661379d7dbeca3a51e1d827f2aff7558ee5bf0f56345b08cc031d66af32ea6f440afee25253806cd4e0695ae241b4d50984c77aea08dc8734bcd2da81711a7746520ba2d306ac4e15a20d4ff7f6b51afdd636a9b10a25aad0edb4772c990308b0ee82175fc9d8eb7d008a3a6d9eb3243e73ab2c1f99ea785be94c1258d1280b2f22dcebe0002a747823ad0475d39a94ca05e7418b5f8852d6639bfd8818baee421cbc89f0574556736687ad19febaec2cbb8cdc3da35302262b02cde364f137ee149ae52d5a41885034846a7af557577f446b584be4cbbd6eeb8562fb8bd95c12940a4ed057852f524e9d8e6a8ae9babf5d2f7acb761fdfc82dcda60a7bf0383608a11574e7853ec0e5b3d40fdf6ba7209bf2fe759590f8e9cfd10cd01f28c23266b7b6cc6a23bfcd259526583876fae9e308f676e731ce2d291ca8630e18592817090a07a9d9a4e9ea4940b5f98b42f6d244528d55dd6d8fbefa745fa32d108a852a42c9b6b41f55337745bb2d466509c3624b839c6b689000ef144f4a1f2318cd92eb35c750db2fdc5c248896a6a0eeddd812c0e6d5cbcbfdd620b364b0a30ebd860fbf4093d8c54d9ed9bc211f0c9754ef6a36846d349ce238130df0cf609bec38222e53a1176c408155ac501e61d1565862e167ba5953609bf6e0159898ffa6ab40b03c45802f0cde9d8da58e91bc17bf55777352627c44d1c4f32010eec183d1ff06b83a8d39e978c31fe8af6e0f514e13c66af8363e1736315ddc338992e35e03bcfdb3063d8b74158e811a20c5be73b5c61918eb786aaf48e9bb61653cdbd1d898d676082ef9a93fe1cf626b53b41c8686592e0c58ee593b4dafede96632e4d6ec992b1eeb51d3fac1c2ae274b6e859ce110d72d128c303f5d601a4a8fc9945d08f6736e405e3cc3bfc11f08b6c1a8c1476b43526c1343300c06a986e264b0d3803a2fdb5d871a62e85507b97f5fb7fc23f2cd3f488e2ea57d44c089efbbfb53c28e7e915241c72d18bfe99d9bdd790228d6ce6e1236ddf52f88011e1bd8d689bd3a36467bfcd308753ae266a2d3397dc5faacf3a1abbec4b765b447df58fc366ca6dba362f1476b09c5fdb144ae22973c7d0c8d5ad88272430b024800c11b70b3dd7c4539d990e1317490b465ce0b0d9ea6cff362f8dfd9f8852e2682063200a9ab6569af6ecce9366df74b987d9298ce520bc1264e8b437be4af548eb256f6800133e77187d9d51921ee8c3ad5bf8ede8c0e2de4df2e7abd6a5b1493d3825cba6a5faadbbecb8968a160b109bb554986531601ced4a413678a97702e84aa11d51a8639663197013ac1d6320caec30f7b0987a4552e0699420d0020c9d09ccbd0f3c4a1e7fba7a2bea59517b98e6e7771a476cbaa32608d5536257de67cc09a3ca9a071b0a1624a65ce7f35ec784fbcf03112b7302a4038f9b1007224240fc86d078df570f64780c07a6fe61cc17b3fd37e204457de702bece1b4a2b38d93d2cb93a2368adb1498913118fd61f699e5b7ad96aea903ab48a63463ada7d8133d264e80b6ec1d9505437f83870b1baa83840664f56ccc8231d494e0e4c67e8e8540e2cfa0f9460d83f1ea9b830406e6fd62a1712fe927e5300deedc3e6b166c75888ca222e59c52bf3b71de6c7e9258224328598d718c3aa490ac22bfa5662a5d535a42571b730bf50e25698273f5b0e8ab45aef679ecf3297c9416787ec41715851b0a8c27bac9424de93c0b0eedd4a278d93ba1666cc35b1af66f9c11dbdf1b8df67d2e831590381495c79076496081c33286eb9889049607891719884cf00a404edb6dd67bf9bc9a8e1088672916f038c17f5086241cd4e2262c6be7a088742a1460096362432aa46bd717d804e9d746a561726581a1070e4cb622f65e56feb5b60fa62cf54acde00508e0e0df542c7e4c66e51189bebd7ccbeb19362f25b0a8a39c4fdcb21ee9fa863c464d11c368b5807a7eacec8eeb3689960b313931ac67a3ea43aede503dd0a6770447acc4679521ff9330474c690814c7fab9005f555130a9e2c87bb90fc50f6587a4225ad6aaa729f7c196a91306266b58fbffe335d547b63a658e6b91ec80d3998525f0fcbe03670a9680b8c12ff62f81fa02a38029eaf60efcd704e5abc12975079557a679deb318b60db7203adc14e5f2fd0537c529942af038764ba42f5a1d49e125e7fc57a4a16516464ce0140b5780fd9264f9477f8f821de8f0790069441e98956d7ac0ebfe9bd56a2ac681c97c64fa871a12b036e39515a4557ce294d6856ce1c187c2c5e0fd7514a64a0882622f9034b1dc9bc8461bf57efb53a4d0cf639607cf97cff491cb78269e9af916fa475007c779dcc18c01dc5534bae6d69a53ede9e9cf445da73cff0b964c9d5c2aa0d3a9ce72746fe93518ead9293d203d5369eea2183954d2d5d3a8ef9fb4904e103654d04ee9450bbb5b28f9d692d2a8cd8fa6c4de873094413a7d6b6051e6979a2dd7748f832efdf2ad0812a6ed554a81633b6e075a7d1f4b795ec1a71bacb8ae440691fcd9dbfe416bfa268a550a0aaa8b91a641c36d113ba109c2a19622215cc26f42a120352e2f069ccf985901107cd641c18bf11d1f702867ae23fe9ec053a89bfcaf6a02e986155d7d0c8f2fdab916db4ffd180b252be329a5f6077c8b9759300cf16bec1b3c1ad64070ee2e9b49d1a5b47a94beabea6f63e96c21f1528e451bf018196719bc2dcdaaab1a12474573ddf4ad6f1239fd307cf80832e940ddd5ac96e2164276f758b9a9f5a870685b2fe1c664c51d5d5fd959b91f269ac5ad00f1b2492f1461a3c92acd41869eea786193d70277508f88f2643e4ddf6c0abd7b8a798a33ed2bde630bbd2a664cb238dc7a7c3d63b2303673cda0ba44f8b0ee5c8b5c42e761d2d3ce1e64445ff8a8678028c9aeeb49b0a72036e1e7cca459d9bf5238b62ad10a903943b7af89f0762b5a961a3c0809f82315907a181e4181fbe2e67c239a10d69bfa82c09ddc969c7fe2513a9a7e3c1af62971302ab2e18b4f4e536739f532ddbb6e639307df72ad92c0cf0c9d3f07a89c5d9423cb75cca2066d1f9f288532879f55ce23940a0773c23cad0fc981099036508a6d8a59416cf4ee909c2d44d74eacdb98bcc6d38f0d367b264df55eaac22f271f5620fcaa2531178bc1e9c610dbe8522ca076c5f6287b919b0de808374ae5c18fc84cfa742adb93f9bee8c698d032536011a2e955155c73647e4f68c83adcd3b09393780ea01528ba6882137e468a9a70ad86c70afd6b22ccd8a5d03f73675e0b1e75dda8038f7dd7a7096a90c51deb2f46dc1e75c190e9b2b38b0c6f1e15ab8d3193936852da5fe709e3e2aa88b761bf8bf2997fd545ed2136e665c2a659ed10a3ba668061923368f0704f4164d0d3df571bdfeab50a5bad15b672ecd7a9736b13b9add534e6a392e929b233dbfb3398064bf48403a1f3aed9b7d1232e01f7fe7c3009482cc74caf7b29879f128f8d5db3b0386e8cfb89a7104f08b35c827ef20001d75d0057f8b981cb1aa116a2910fad78265b3bbece06c88ab619ed8209b63977d4e5daa17f97ba819f498700859dbeab1af8a81bda75de45fb5e2183b7ae0fe43b70a95e229dcd8b825538635d613bb76a575a71765b8dd8f6709e55c266d6cde5e6c8f4408d5ea8c756cedb1fbf5a28820bf96756a3d8ba0c4f2a5dcc0c016804cdaf903f9d77f4a8a0dcbc334ab69af3671dd963c51b188753e019ed708d3fbbb59f20e177f1d07c83a95a5b0cac75052c06a3e47ac3c5f6b8a7b952da069dde4e56724b44060f51f2559b0c6209cc12c569c10792325d5c38512d4774dc20bf7661353d18180faa18356dae07faca5d23af545b10441b8f6bb003974aa44becfc80f83d54053e32c4a11a4298369e1929d3bc61a5d7509a16580f4bed1f6a348043a217958f2d150af68db29acbfe6090f3dc274e47fde382c4be4bfa1e7ae96366e3f9cda187a0f7b6e9f7deaa6ead43c264706dda6f5b2c95497bb7976cfd4e5656eb20af11ad901ed9a978c60d6b28aba88de593440c0b36a15bb88516d8ffe1714ed8bc80bc42d41a192f5827577241bae6b35c7f045806b4da123ee3ef609524563dd030350e19fea5ac2887204f60eff26360ee4873189e5eaca045c244924f9b1543fe7505d7068db9d6063fc0629c05240252b08be3a61fc68df3aacd1281052c116ab512fc2e8e5813a68644dc39489fb78006070103b026c6d4b0081ed7785faa75db539e88a6095996b250ccf78598876e8dcf21ca187748443525b5da76054221b770284ac513668d457a8ccfab810745bdb9783eeb705dfe04f64d493391a5754af5942cad8594d6cc09a75160f489e9bafdeb965bbc1c20cdc3ffda1c69e3fddeb0b89788ca201892171b6c2641e76448cc106209895ab4dbbac2b90e6dfa15336a9950979325197931a0ff5d32a6ea26b3ce32490251d47188ffe4d7ce93959ff8504ecb4e870349a9a4b893b37d886a6c44efb8561e1500869f91b2f5909974fba6803a22fe2b974453665d51bb42ef0ecc1d2ee33abef7c0495a83500dd7ec42df421c3b27b713d24b878a118fec4b16eaa4888663470a65ced91488bae1857086d9baa8637e604230bf1484a3c8de758878cbdd5c206ef8a95f4a84caf422ef252b92b49400dadf1321d0d241f28e90cff6adc9196553e4ee65849bd87d2234e8c1856d73b37c190283769f98d94caa1b275b3466eb0e1b9f472e20629d08ea66110bfc8e12e8c9efbf902c619d71d924451ddc179bb7b5323ade13d5f8b0e990434fb634dd673e48aee11272cb71557e4c4c827a2dbda9056f19beca2379ddd604fb718ae764b2fc194bacbfe1ca6e005fdf4e82b5420256a1fb1c765a7e6bfd69e3e9f079a84f68cbf1b80154ae010659bdd0a4eda11a3e56c200ca63de4503bcf11214902259b0643a0969df64462cb065493f555c5a6e57711112eefe20b0f6f99c19525df498ec22f77e47deced6e3befb06d535d7060323d7b2cbf39cd8b3d3ebaddcebc00b1fe0d143bc3de19fe4ffde00ae582581caa9b03234775c968cbc9b7c206e3c1faf1d04c2b12ae555bc4ee7f295c7023af2d67252b365b64084dffd490493c90f4003af5cc47422327c0e78484930dc4b0aeba5f545bb89183bd2df5d61f579cec44ad82caaba7b1130c3b0ca3e5a8012beb63a28ca91a84c4469c6e174704e2882acd69c2238fa68e38a04b562e175f25ba3b613c2f229a364b5025965d11f05165ef9d284f0886d5b8ed2ae33e83122a3224d60aecee43ea5d245e60c1db5ecd9d7385edc9ec229cb33550e2a36d98f623758f69f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
