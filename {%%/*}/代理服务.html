<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ef5d4ff8a0df1102ccc0ef2aa9f6a47e6d9f9088641afaa8b083a68af3d8954afebd4fd80eb7e097136152a2c125bcb77898ada76737d55905f1293b16915570e8852e157f672da30ecbbb1ca5a7c9545785601a513642c103901534a291bac590f9bcadbe42ecf3ce054f2357b9d72848ace113414ce4ea41cd83d30ee644f642a1d14f8d1e3d19a0821cc58c79b97696423a21bb4733e64643f95b07c25161980d941f5db4849ea04eeb7e0e695b6990b196e7d422a6975a6c115fa618301b047cb95ef76ce8122c410fede12db81414e2df5907c5fad9baaed65194e5796ab00f59d143ff052003e46c72954105b215b26af17937822562d17b0172731948b32b6fd4d116833723f59f4cabec7c8ad86488efc21387b4926f46f453c045dac0e56ece831f816c64c8c831aef287fd34c78960788c4bb98234b4605d82327939176461c14acd46940ecb68de01609d8380561c5a28240f71c3eb90f81d05ffe2553524cac89e72072704a36118be0a8ccb03b09d1046e73ee75c5501779720a3628c2ccb83a943bbc6825716d36e8a45adb63094859f533d64a93db3a786c1f15e85fe2463fe2c71f35919dcf56eacc54098b0965a0158b72acf54020304c2ecd01d14bb87959a2fd97808b4c28493386aebf3ef79c3f8b480718524cdc5b02facdc4ecd9e7362d81249dc24d226a71b467f4c866613af0f132c8b2d05f1bb40278d24270a1729ffbceaa0a8c38a6286a06631aba933e00979ab47756dcf4ef9d080f955a3538341c40b7169b36caf6876944fe7520a7ff65bc397407deb2eb3308b7e5da89a649af37237fc3d358fc35ee03635803595190755641d28fa19427f8ab631758264418e6d6adf23f65edca02fc9bed64d9130796abf97141ed509c2912db28a108cba4fe4afae9c54bc5e2572c48e7ebea729f852de3bd627ba4932890cf748abe139880c5e442b33365e78acf26824052520ea9980cd799b4237249eb3eec8e73bc5268938d001a2f55d695d6985ad73eda0f1417ce3ae0cce87cea391dbaf5099227b651911d1730fc24081ab387ef6f8d7f1ea4e1e39a8a9c40f5e5e79e2143bf5422dc6d9743b17b947165ae9aba9ce24f42381b44497f6d9825f2de95b706ac133f81d0de3a703ea09b00b3e07d5c04c858377d472de500179cd3c4782606382e9b4d2337f72b85aef236f2ebf3e8cb71fd38a72f06f40d26656b4f15084dfa6863e143580bfba075b8428ac52d02609975575b03589aa138ba357b31af0a53625646ca302db00663ed35de166af22e6df5b5e8f1f3690486e81bce3dbdbb8e7fe9704b1dc798fbf8220368a9abdc15273f511d6c6358e3202c205f557a42bce08c50b4c11d18b87f32b979fd5391a685d1f66e2638c832c2b743893723f4f53bc4ecbb1d6e8ba5a508540d8cde23a7b617a7a077ed60f0ca950f18a76d341f050850cbe46abcdc3e22b59966c38e3a9ed7ad1ca18086d689fe551337a75cc1497f4e07c1af25b7cda2dfaf942a408684b62a92780b9ebafa1c7ff43590b3910b39aed662f92e8c097fc03ae80e4e07df778d8de5f4d816eb16ba177c099be43281b15846b91a7d6c94583f1276a1d6f857b9a1f3b14aca534a85823f37c38449ca47aec549ec8538b99edb54ca961aaeb988ea7bde448dc4b93764110080b7f7a6e196e90f7edd8b0543b9c0c0ade24e3a70d1ccf2281ff5052f8c21a431421aa0b52fd924c88335a6158dfdde87ccc3a32e4df71cb27519f0509ad9037e5f3c7705c049b5799bbc5a29865ce27d3343c787626254c52a38e691639e201116951c0198aded41b1e92aef28c3194a4c2b53fdaad201fab9d397a47fcbaa7e0b1d2a9a7fcf4886437fa7b6e6a2ff08f8ceaca0b61714aefea5dc7b628c4de55b5010f8b4483fb5c4d442169ba8a9daed14c00491c4dca8dd642623a7b4bab0684cbd17d9c086924e7fa7cdb152d424e1f592fadd3512c12f31b2e7d9aed532267e2be2fc8c60eb9f8f7a50316523c3e8e5c46a38afa3fe119d455ee4ce9d3c367e97d8d8942eea5dbb5ca56cdf112dec4b3daf2ab57e0ef565bebe4aff3f438dbf01f3b7722a4527348463bea150f37259c1ff2f443f99c143bc057474cc9a74377cf2bf5e4f7172e8aae5dd68a12d9b3b477ff54c863ac96c7670b0e6c3b612a1a33a6dbdb6733cccbb8186dfe612fc2a428c835196777a92b08da4a4e6388ff7ee5fbea0bd3cbc7992ab6574e87aed8690af4fc1c37487f8a93421fe28ce6b6443eafc835c56beb6e3d73ee4af38081259bf8bb7a3631abd574aa3521072f93872b78ddb7a6a7f4d8d7715e20ef808f7a2d072dd777dc0ad06af89c4a547354b1e31310c3b1d8ca58f2454ae23dab9e5459a818d45da45a8b67a2208130ae0f0be41fcce71b6bf736cfc971b03542f55d2edf6e11fca36c5f3232ed271523a0f2507e310bb8f0b0802cfd9ee0e4a199dabc4dcd889808328ab80e883b0184d7f20d0b1fe51588e2bfac000e1704e64a763497769b05c99abc891f3fb6c6b4a65ad0720bcd06bba4d96c475e1686922483777a71000f47e9f4f4ffabca62955c4b4686cf815320ac51a86850555699ee6ea610decdc2eaf18e7741df8345422666a84463e32b9f3ba224765795b9071292468a8c38b8fcd196555c8c1afc69bafc74eb0bfd2610a1c2ea7473ffe5bdb22a8232475f39e11c94abbf7262493260f3e4008a0de07f3b0df8eb87520cfce5e02585e7e47bb5984466f4222b7ad68ef94875bdc6921733a6e8747c10503a0bf272f0a05436fcb7aa6a9a292b36d01e64a159595042deb19a612a7ab770eef7e5b4a42b22f59868996e9a97904548b230180114651f07544a39a261e818be6a30081ce32ef2be03048f646fce58f93c983019136a8139a4f5a866fa5dff05394e4092398f815073bfaa54cf6b726931a9a2b1e62ec8d01a5b6694b5c44361f746add46fd46722eb88010275685b133f46fe0f05d70c4c9fb1015cdf7105d2ff3f5140c6cc079b5c859d28161f6530e411bee35b2e8a3ff2f8bbc809f938b90f7425b1fc3187b959f18bd0076e269e85c6845ae0e82d92813bd2e8cd596c703de240e1c87ac28bbaecb74a6688dd517c9f81023676c11bdef6820b6b88151aaac9b10b1e37337e500fbcc9a138e354b7a5d54336aa3b4c3967c8411bf7f81df3761e6ff8a5d7703aa188f672cf5222a1c904d640d3448995825f91d5cbbb3e827a17ac617ccfbf112f6d6b596a02e359d789ef708f59d80f3aa8f931998457e0fc0c2c5d77502bb5aef61ea7c38ea536323637b8bc39f83f4b30130531351ef64f5cabe214d737e9ff1c995817e31b99650107767d003086215998df3c732a793b931d0d3dff79d2c16754a51e916ece31c77dde3cead27bd4bb42605a6d5d175e28c6890369b0fdf2de391a20cdb2e2df9bac9ace70f050585c16ee03b39e3171c765873c3b3a38f3f3743cb68a0daa457664a964fe811806d05d33610e9ad15549df155929fa567473d890627062c83f16ea361779542013d62d30246e28b9ee10ad8bb05e07b61986b67b47a8068a596f83976d592aec1082efc29fcfd74376270083877f5a31b747a8ec71ef65048a0bd489b2a8fcf5195e87e08ccff7b7a3b2d5b99f3735f7eec2834654c6470f0d91e175881116bcbcc8caadb167455192434e180cc5da7e088d9f5364d841c9f8e90981de8fe44980c924c11ee8b22a821ef78f99c19e73ea7a170d04acdf91aad7914334461e495458a4100b872770513f7c9d54555df179e5334c168c5a4425d9773740ced50d405dfe8278a1132d2964580bc048c1a6678553879fa8d57d2fb5870c5bb6e19d820dda6a6f24545e7349e8385e476ce1ead03bf8c37b82b034296051d75b15fa9207cad5a88c843f794f08760e1aaf4284a1b21ec5790ef6dd7dfd3333808383053845b31735e9573d313a360a78e061e12dc8dacf8b14a29c5cd1a8bc826cdafe729c3891e49af9d0413b427694ec7d5a627e9d0849718c56e8b832edcebd0cf98416cc9bbb49c9e9668e0058c893a5a88403127c25197b0ae0b8c03e08d006df5d4399e7e591c9942131b9c7042c3cd9c126b9e0e0dbe43c7a911a067a8b7c679b1cfa29ef65d17e781822ddbc3e68fc14e0bc9b10def31d2beb0d6696e193a8b82d38b9db82330e0752abd3204dad49c80c81c92812ac1f0640f606563548423b07323021a6f905ebe23841fded611e3f5fd4a69447a2a97a1d87b35f42c05b8accdaee9a496403823c6651aed5c0f108e27422bee1bf8bf60f6ac2ce4ff2fd2a61887cc618892fea95d0349d2cca12264451d5e162d1f6c6bc52aa46531eeceeca7daddc356c53fdfb488ebc61d200a2cd2511adf0569203120114796a45455743302539b28848ce72c7c60614d45c58ce071156d7122c973ab15cbe7ad51c12350985cdc0b6c3d3a0f3152d54b138f52aecb04e9571baf1dd4859c166eef7b68aa492f099d095ee8f331ead08688f200d18fca9db52658e2e93c0337a4c78961725a635494b63231e4d5f42ee998d6f7ae18f492820ca185285d43ce6a5b924e3201729124a9cd53d0611cbe12688c36e15dfa92f7b90b274ef0f05e838fab6a0c46903ac031d650f47faaf9f47ab285c308c94541e7a87a8899ec2beb1324df6db34429974b0db7b31e409155751fd63332d7d68d9fc499e918ba98582f4cfd4c07366b9f9da20134f01dea4a395b12e0576aa4212fda2dd10a67f8d5fc73cea12be8ea250d334b4828ad89012ed7f3d055986b7871480c5c716cfcdcc377ad9252640b49b54cccb56c177a34805b4e58841cc3a257b5b3144af587432c2001cebee0882e40b0d39f6d04a5cad0a034ce0ed4345234c0f39c5e088795dd5220795df1eebc4615087dd83c1c6a099907a7e7b2c6ad1aebf855755832cafbb885b0809f565523f5469bac884ed5e359954df1b7dd000172c1130d60f86e46f57c84d606f62f7b01373dd8b8f92a12fb5b6203d29e146dced1a0d68e1af3072b21d82b214857fc6948a4dd6e56300213ce3f8b989fec2a7bb92011f87c270cf8a02f111255362f2df7779fff36bf620300038c3f2564aab0db311e6c742c29f9ded6bae989990032a79641d93d2d5d0c96def5ba630c587ef083ac84bf8b1f97313ab9b9ddc63050b661523aa164e7556d4f63cc54f1e8cba0a11846d77db614f3ae753e6cea6e223a5adf4285a34492a7ee0d14e97262b6cdd3d5474556ca1c3ffffc809bafbd454bff9b9728eaa4fc96d0b8344778a408d1190c981488f4f25cd77a697599e3b0b17fe7c3ced41989f5b14c9d336329e4ef6151c0ef21f863b900cdddaa0e599b4906dcac90cc2cb8fa5da7835763fb8217ed85ad6865dd87feb9ce126f69ea8c475dfec7565c2b5c32af80be2bf575cc4165fd115c114b4fe8fe74b8808348dfd17dd81a5cb172f55a73a45c0a4dba043112ec201a35693c17bfff01c52dc389871c8904c71a70586e87cb64def706b7d2d7c88dfe4b54f7279a3070e649581a4f82991123e88820ea03403fd4bd604712679c713d7ffecd1f1540a4a318592c7c91b0db3d161a0a0370be12af87a1c54fe626e45dbf54fce8e119752251b7bc2856c3deb25999a23e8d06f467381e48ea5a8dfcc6cc6bce5afff4c2c64eb35652251844cdb127744b6fb43bb4f18ea2f3daea8f123d9e8fc3e1afcab3a50f610b4d09e54b9b7161ba8b3beffaaf5c83682529b8a28912ddf0fda05f475c9337ca6060769b4ce787935aca16f3492cbcc65f004017ffe0a042c1bed7fe8f3c550bb8b1454d4cca7e443d324d0ba46ea226627426f01b66d964d809b947d6c53a556ef610c5c4d6aadff69cc7971703f6da7b287189e03c95802196e74fed2f0d863624893bc643fb1ded7aa45aa8b954943d21591a9420875aae057d11e03f9aa1a83f23019799eba8cd1adfce3a1920dd3252ce5f1886652237492ff8ad32282e4e07688e4a32cd0036d8024219038ae5d0b0e62ff98151276086da52e4d57beca98c8f79321a94bfd49255bbf263f8f02e3e71916a3c1a75716232bd49aa2dd884e4ea2f9ba28c0ed762fd17b6ecfd66bfc926b14580939b643271a3b8d32237b9d5d756a0b431634426337b46429ec4e2b80d5f5d7962c9a02684790ca5ce1d81433b5c1b8f90378fb01065a86f4013f2ebb7a364e61824f99afb32a62153cd945882563a62829b0c35f0b5e81bc8cf05dde25930dc16b1524ad8d22d16d38b0852d7853517058d646084de415f4f31023f6dcf96401b7907452b0b21268c67a677b1677a272bdae82056355de333357006b393465dae5e07af6c696e40c2f8864c62358f8b0a3768545ba5a2af0ba67c70f93dc27c3e21004bd0a43fe715e8819280d268b079a8fdcb0068f7e9764467dcb1cef6cc2ae4cd66ed085002692a31db1eb2629cf11745ded9e835390116d5925dbc71ccc9f314d77683ff1166d7ba6251bb788b125c907b203e7718cdaea10d5a7488dca77cf8985c5a53b4b20a2870abdaee80aa9db65b1bdf2874e0ef0398ff39bee90af0b88e705a608dad9c6050962823159f2330653537bbfceb4c69d85783cc5f5eca30cae4f1483b16a54c50358b92e4b514dd3f752d0a3271154fe149a4e7f97c17c9106b73ce69adc5b55c3f67d976d0a90b074f160a06efab0743e31af4b4f3386d1fe012a5ef5609cc7bcf32df45a93cb2ed40e5e06302b2e69757ead301b6ee0c81d48c50e2aceafc5d3bc2201cfef8dd3307be67e160c45c696968dd4a773f1e2f1ee3ec56a0bfb06606d653a2a49b26c13957b536cb86b86723e56fc8494f204f5fb1f514c8b4ccc4fc05f2ad7c44f202c53b8c3534be51205f59acfa6f250152ec58e4e72ffe31d9089935c8a6c2edcb77e729fa2e98773ddfae4f9f183b64d9786a8c2028726f1fa0112f87646d4bed42844aac925555629bc3a1afde7db7b4093ce6ea641924dc6c9ccb7697a37931d857d75a7d420cb30413f1f0cdc8f224a45b6a95129c38ad193ca775611ad79f765057c70fd1235f19f8b34f901f5273d1de3777d741769d6f6c2197fbad83cee25764d4674872542b19766bbfd92fd162946d5e2a0e9eb0de78fe82b3baa7a683cd0d7a77df67bc452c834cbad05683643298106c550c2db41af8b0722eaff605d7b96abbc2a9df14660c07b6b3a52bdc7b77ed50d15d85f20513b906e70b3021d32cd29d3bbaad72f241103f8fca4b16bd623597d989777698119610cc7cf4858a260f38e2f6855ce5444b3276e10b243542a286cbe311a473acf964e3f453f734f0a67d9f883ab154f515b541c694def916008f1fc61fe4115914276daf978ef9b9fd6dfa491f07225f05031307f8eb428daa1a606522560d1afe9a18578049eb97b9bc30cc78597270dbe18bca96dd00eb01feff17749f0fe3c5a17589e6f50c783579d517f009e774516bb02a3a86ae2f66a2b9b279466f57a5d74a2a2c95f4907a13ceec73ae8743f0bc1e0c2b6c14e5cf1d0ddd9fc09f658aa255372503f8262298b40c62b81e1c83f3b7fbb5952cb8dfdc9cd40169d22e5daded1ff04d752f3356220ad1f2926a3ae85123c25490ecf5242727673a0395585249d4660c5b1a7d37bb059c099af9cfb3e5ecd13df8f5a740f7ef1b99195ee6c541b10330a54c9ca0c3852fbcb68ad8f62a3e669c0ec9bf087edd78ef695c0a46574c7abed05fec0007b3749d6cf917e445e43d3ab7641a7fda9a0ff748790badcb8654678b04be5514a6068b1d139b0e8e1e74cddad4b86baf1cdc7901d6d0ea693a9be8bcd0bdf0d4b86156645073db0888e8d84c9f1b9d95e8563f542a7905bdc9317a0bb183fa95e88330b8044e99ff7ccb990fbe8424149f4a588b73929b870c374a6dc558d0b6e6b98ef065a365382fd9331d357bb57615c0b3f4412696f922ea9bb979dbf37af4c5a057031a64a548da5747ab6a7ba8ff2e304f4a5ce7ed2a92e03f5220a7905c6ddc54762ec48d41d6710129e7b185d8d7dd9eaeab1bcace53cb819879b038a5307c2f3f923f335773d516beb6a69d2cc9048360c36d53a5c44aaf41a802f4e2f28c2088a8e58a7efecb175fd570c03f002c66cb1b0041015152ccad8f67b1f2de79b7561bff58636f689e87a03fbdaa28d3b657400a73a63ac9e362d81fc9ccdce2b7906aab30b4b15b5b343095bf23906a6e593aef974494c82c25a39d00c594df03cf05e5d21c4db8a46eedf9c89ebfa0f4fc71b04573d1300a02f727927a2312fb3b0b440c6de844600af64d85f3aad70526af877ff87278435c70c84b63ec0d984b537adc8b288efd4b7da6916e5eb006fef81d004270a12032403934a0197d93f9750e27baae36677a900416b59938b5b15fa90c4350940105ce0bfcd11b47e8a443adee1df54054a8927f6a6ce6274a53883e9b1251004817b79c70bbd9f782b9c2e2c84f274acf806783f3d2972ba7d1a139fd6efb29e4acbc59c061c5e8c9ff16cc189bc90abf1c137ebab02534ee7c6d73ae30ecbe5621023b0b0b94ed101006c92440461a1ec8ec82656199e6bf0170137c8357728fcb0647b15f209cff7fe6bc7ecfd1dc31fb15ea0e84d40399e928cfe3c3c3804ec653ead676954d8d4b28a9d284c8a7363213d9cfd957751ddf3565d3d1028792a675303f957e79aada6afc54894674da3c2c87b496a812b05c63f2796543440eca7c5342e0d2265edb9cc8b082d783ef5445a1611b3a678033018aa1e932ccf2c752590ada6072ee5dbe8e219631932c0d9a31fba4ce43adacbc8ef1dfc6f08fbbc99729d164bcb475382202580005a954a39d2ec308267013420f29661987d4108421f99e3b491b96d1de427f19c2d49180077f914ac1485378a85cdfbbee3ff3eb5a3ce911eb40f81a6a64d0286b7af87f8e8f7ab8521938dbf93056ce29d5d9996280659ced1ebbeb2b273378a9bf2d977266e83ffe20a3aa18edeb34fd9c094d231810116723c7892d9778b863f497f6ff7732993b1ede6f5b604072df0382d9c0b08b5c18638e50d6db53a5e0400c5136d40150555ab390472c30dcb062b4e26b62e9220d18068b115cfb4ca4edb43b49961797359c0ed0fa1d99e2064ca3c946f1120461392ad4e9d61b0445e890b5ab2e7e978b99e49d505b46a3d552722e3dfe87383abc47bfac3202d604c82c311a00dade508fffdf4603abb3e43c6d6c78c642c1b4103de0c7817382825f3fb1e3af97032a84aec8cb5138541d9b37f7dfeddd2ee7de5c1fabef4c8aa83dc52d66d294c024dd608165f8d1334a2b8674836ed25e572d061aa556177a095e97321ac1ac968e963d602b51889dd88780a8e27964963a23c32a13e1ae9f39a7759c0d414b3d9d1bef824db8a8b22992182022c0b879fb4c5e2b6a4dd0793b8d1c5ad6ffd0690c377955f4d6ead0073938080376e790739b641a0bea4bdbfd73d61f51cd79a1a498bd61ba0f8d139992247c84d551a3971365ab0ce72eb6ff4431eed6cdd1dd24f43584a4bdbffe188d7420f83263900d28f2b768292ed2d6c8cfe961b723513ec0eeaa140f4de441a8ea1197dbf4d5e44f1b22eae32303de1cf0abc270d78378083d4e18d8b0d76c8fe58d9c6e2446a8db1b99bf46041aea861fe6ff212bb2761cd03b08f0ffb544818d7c7786f11c2bb021d5b7920a6cb90ad3753a2c4dccbb2944f48c5c6b9ce396a3f7b702f2da09e379f90363c7451d2c52c6b55fa289374cd9f6b73a5c76e443253c94b6ba5d084dbe7eb10e77799a4ce1b834f2b1e3c41e2bf7f21e97f532b1a358f40ca0eb9f717927b63a06f1f3f87c3af04b49a42305cf4e00c5c4be4952083e5952ffa550c5bab1bbb55d5645c8071a2872c77507c1b34d92d13309484a32cd5fa44f8d39ced82d643c461edaa49a6e26070a014df970fb015d628dacdf7f6bcf5c914e8ee1d324417d048fb76ce8d967017e4387a1aa93c1bf8dd0bc88ab4c0fde12efc8ab6189f02f3384a610cf35245badc3f17e3ffc20cb1df16f6fd2d33a19debb7671c70b5713d616532c9ecd2a152bdbfc7b698727f69f1ff78fe733f405ebeec58750dbf495284bfcdb09e0b41cf835ce410b792f0ca1aa8beb8a6a60be15285998bae054f1dc9ac0c5954d915848ef9dacdf6bec493592e9e1d23829b4780e7f24fe0ae9c781ffe2294ddb97284eebd682cd7e9b516d144791c2458cccfc447026bff4fd1306a4118332cf33b578e4f764c4506d71510a6c6cc36cc9e6a82704e9bfb4b6486ea85f405f3545ac0f1e73313af5fa12cdef4a35db3361bf072c87be656dd3060f262a371227f89d18861cb3b4dd2426ab7ebd88ec3536b5a681b8ba0eb395dc612cd635831f168fe616c3fdeecb22b087c8a4cb356c09ced1ace9b41cb228fa5740aa29164289c2a9533e13f907d461b65cd71decae4166517619b3b3d04330c537faaec935bdb28dcc562078d63d73b4a1e2023dde11ba1b6ab79d68d8312eab4c2b180b4e1ddad152428f4eb2a9354676b232c04dde019262fc1b44e2b14651f46a6e1885c10bab46178ee1d677492c6e9b6f8a865f9c9defb5dfba5e736961cec2d1f64cd1e42ff5e7c3f493646b7bfccf588080c8d59887996a9cf225e917dd6db269b7d4cc8304bade312f55ae0785def5e8c682bd1a9572ec0ccb60c1f8f426c66fbb72155b1a933403bf8365f1f271836405cc290e37ed639839f736da886466f9c25f1368f43120d436c32df5ae6183337b67c7089c5ab0b4018bfad430905b60b9a6fa41498d4e4f7cbc161321e5523da11d1f55f8e4743a961841ba2bd36240ca3d16922e803e4cdd471ab32beb1f4076bfa191e3ca0ac4724ba88b6864d8b33aec9d38327b381b23bf77eb41a32d34c16363b236cc39f41b322e8ea32222bcf3828d416798ed2d229f4db6672ffdc87cb3d178030aea9bcb9105bfda1b5c7e275850b89c92c3dfe6e3f51c71aa22db975cadb57945816b786ff76ee895fdd55c3620792c4854d1671e1786b695d8d28838f977f7e176a1de9744c75179b5248336e98c7fbee5655624618da16e63cdc22a349ae80e3a1281baa3a4813b9a1d59ed07b93235a2f7c2a6b719335f4c75c30f05659e1b52e4bc1ac218212880afe6627e8142ced95295d45d31b8723f3f64eeb8323a326f1c2afbe86b4bcc44e38fb3f1d595e5d5e52e71b365bcddff69c9b49db68517c3c71878afcccacba19c96598c4fc9aeed67641ec628cb079e0bcc75a8203333a99116d87848ee8b9833952da6c90adb95d411ac79fd3d23cceef8b4fe8d93145d93aa4ac916c6b165a7bfd4221004b2289c968f3d1fdb9eff10a563dc95fea9badf1460c7b0a4050bf343a2ec65259e77f090d366aa326a1861d677989aa439810a83c53c129c1e68014f9c746441b9019882e7e2a7fa90d1c4b2cbf5371319b5300a53ab44d99568598c9fc1c09ed601e14570e11ec3a17b8871ba1a6000629d3750cbfbffccaf5f2b4a3681dbddb09a375c920d72017cd1eb7d5e81eebe47696b39e1a8e82d389fa2ea6fd8ea0c7e8bdceff602eb456adf516b1e3db50ae55a9442b83cd4b8e05bf0df42769481df9150ee621d2cd54579a9a76374809d2d3a493e3da8d6db6c5fea4479cae9f96690e3b1039df81d6e7ad392cbde3ba7079149ee272d6a4d174a130bad3706aa337c642df4ed5806676a4b5c984f7e4cbc950a5c8b3daacad1bf962aa5e8c755a8b0ca528b33a1913391199843373948f42f6172bc40d6dd89658ae301bda9e7c7ebda1e25725e21f470732b9de9955da06e28cb881e4c574a352684b3f9acfd73fed47cd2fe07c2b234d225ebf1677aa3f64329d62dcf4fc1df38eb70f90964d827d0b31eab087bb5be14544b4b1d979189d5821bdad4539728154b66b5981c206a0750dc9bc4e375ea9797a072f5d6937fabe9652a31e3f0d7913e08e3bae9b1962f529d3813b3e1492672d710fe340693af417fe8efbe28f8b48b59e871cd693ef26adf7220b05e7941c9b8bc7286604355b3ec57b6521163671845b16bc3b44d9d730f306a7b805719e2414879bf40c54b0c4d876a8533a8a023ac409c5753283292024f648da7d78d8afacb16f26ac856d55d460fbeeb8017120c803db98e754944207564bb413e387ab67f07c734a5d4936e9b41cb839c31994c6ae8c1b8c822ce417902a116d9d1ed920170bb1cc2d16c6321ce05b8b38ad1105ffe1d6598b4545af576012552a0d5ee58ff8eaaa52b5ef7161034d7e9fbe74548c50fbe43a5bb0fc7a89878357871df3915377c52201ec574a4477da7f75fc3c19c568816a331e530d954527311f7fd1d7d93a72b0f41175c7da2179e7995c7f7100cb7225e76e2de1a34f706753525a8e332fbbc67729618671dcfc2ff2242ba234add730b37086fae11dcf42937e60e6398305a9de832d39b48477d750bc0ab49849a3fcdf6c6e18d605ad23672d89f88fc3d6d71b5315cae700a78d7a33b613add37c082fc4ece7b3b20e439bb9eef56caeb9a1ce77267f0075211b564e256d7195ebc6a75f8a48ab2591cd750a51ff55f051fe2f97df53ba1be2bac433616018ddeb713ff9a041ca4d94fb7609c8c7552eef4144082f28c8b091e9187b4b09b34949ce72b9c411f17f5bc7ca85f2e3d402e531bf013a33672d74f2ca6bbfbcb97902175b927c1694cfe1875464c8353a23f9bf89013a7b4d911191e5c858c6eb6e96d3a32e6f200be7c639eeb8d397f29fb913649783432ac9c34887967ba901e8b642ffa1f22cc884b5bd465dd5543f1bb2b5dd72eae1256113a2472524226183f4da311838c39e1da39a173006fd7cb3e2914cdc3268ae96541743c1ff74e014fb56a914e7bee6f34909c63f39c324a4704eba5b4d18b672fc133eedcf77886550b5a84328397edb1affa5c1d4fdb85d66bda1fa57abc5efb456e9fb8dcc8729a9d4519732050ce289e5a9d549f423d63679885d821f711cce1802c719a80316f14d1902965507a80a444238527b6f49b6f887928b4cea756b8d746d41e30c6915aa9af2510b7cc29359741cc0e29c88c48208b2915b30be77bc5d9d6b16605b7dbd5df371ba1e34e6c40608280b04111b6531e680878f7738c27de7bfd540bebf7171a4d71dbbcdd7ad205dcaaa5dee8813111fa502a8cc91b66204780dc77508169481ca87569b680665aef04fe19b78443d275f9f95874da2c7f103245103890c6f690f52d64f0e2f81e716b441f247735776f650531d591e919c4f68642cb5db5aee815b4f7e6309148288fd5f5b414a0878111c83198d8e0ca3157840d1565c598c24f544303506b7eacc76fa9270c0baebf2395b6b164b21ba0ea94ed44eb81a08f26c723126ebf5c89156d4f90b66c8ceaf0f7add4e3fdd305f6d09556c25ac2bd3690129a8704d9c4277a4bcfb13eafdb63ce14bde45bfcd19ab585aea1ce21108cf5301c1fa5bbb456c2998f6a73fe3b55de420898b7b736d67108fec6b8010c29749b747d3980810cb7464483038726cd2f1d73d469c2a733b5a7cbf82dcf7f24d1032b85d5e9750608fb22445882bf47623577186a9a9f41d66a377a09c3bce8382c46e2e3d3cf656c67493293f776b77733c003de6ac28746cbee4780ae2dd42c644e36b8fb596965c4094c5c1ec438e7b3d472a81a88488cb7afcf439b69e8687e2a5a4c92f27690b47f160a6675a6cec22f2afc5d5942cd0f9c65a3165791f531e6f4f3dc61c48fc81ba8a190359d1570ca4e9ab6e97218e13fe840a5cae99d5d84efed12cde884dae7abcb2352165ab7fa1aced226905d30f6651dc5c39e2e4d3c34f9216dbd1242c7026fb72b10ca903775d2db04d62ede4a34c0d080c0d81837dfd61063af2586ae9af8d327b95955179d2dc8f77675bb69f3f3d3813f31c36d6e80891a778344992371333d35718f07a6198ba0f912f9bbb470ba82fb910c037b1ab6ea5e69e0d3773aae6018dd9fc7f49c40ba3d5cfe0847f513285f469adf5b60451fb994a40c77bd4566d7f5d892252462b6689c0455fa17cd54cea79920ba4f76403c1e024ccdb06b72ae45c6ead9e982df87410df98196a021d289c68b35ff5aa575e27c1ece97cd8d396e5981acd8bb1332191512ef997af406ba8906aef7767c08e1ee0cd4440384ead5f0b6c3a1755da7f62eaaceec5f222c22a5508bcd4ec2dd066757c772338c17866a313f267068e1b506dc11c891ff3fba06692a9838718ba425693fd3bba793f045d6851f754092e7638aee5214f2fb775b1253b1abb37ad1b1269dfd4d179f60962f6b7073953d87b2503aa6e84157d24b02b2da2d831053f70f74481c96f126a37c6f1f83665bbd76d3b36268e75a62d936c70cc461dbb74fb97385b6109c0e4349febdbdbfba5920247beec5562aca346a84218caf450d4b1901b0c42231aa297de50f6cce879077cd647c5710ab605979681a55410b51221db449a99eb309c33f00bf0f6badabe46100fb43da0783754b45d5910e2a5a6b6d73a267dfc0f54b6bd2f7d2d243241db885d073b5e3b04b1c84cabb153a5d1e8eefae18d3a9f4f0d0ef63f8de74550238524","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
