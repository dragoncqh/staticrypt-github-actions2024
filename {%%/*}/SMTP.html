<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c5d5debf5ca09f6d88bd06eba19bb2a62f232c30485ace2a414fcfb47a94065468e46734706dad8b7c50d12c3e658fd9f45e7d8157c388ce30a3ba8324c0c194d97c18c6695d13982e500aefd925d73bbdaa9670e787447f015c713d20a18767e15e12a9498b14df3c2055679b352ff7b4e6af8e5c624c867027a32ce673f48b805b712bb6a37efdfd1e8c07377c4eef3d3e40d3b11fee7501a5f50c03ba1aafadc6ee90c6b512a6fc488bf666ed584b7e0caea746fcd94b112d83ec57482b4e9200bd31a611531b42213f7c3f37b1460fd886c7d053d874562c7311e82f27ff31e6ee116851839de2da55de59c3d59e9f3530b386f4ceec93e0521949011fdd90803731ea2d78fc7b48f84c1f95d7003e1f25cc664e640002d15149300b1fffaaefa95839fe157734e9687970c9dad0f1baf592ccbcd430bd4277bc9562ae1f35b29854cdef60accd9db7e5726d5f6e61d1f09705ad0540d2cc45ce0ba3e95c5b546fe1f94a773c8753521862a30e04506c1535d4922413a3b704f5437cc20b38bfb1a964d5384f7e7aef0678a45b547d5fc36b19c391292f8303295ba22c61e5a8700828eb39757762027bc1d93f4f71409d795fdf76a72926c32a878b9ecc3b80565543fb86c857c5c98d1e669818d3d6b34385ed2a1daf9757485ba989d97253b4009e72ebf9b8897bb3cc04ba09703181c9c93a19cf8d6bd16ca0783624f8e364f2ead91fb24aed5b9f3beb872cf7e0b98a93d149b8c9fe73d272e2a49187430d795073d965f1cd9881e1c90cc943cad4126e46654c654c3b2b96fd163d4fe28e93d8e0213cb78a1788a50985351a2c2ed17405041b7a728323e065c1608343e4155c597dc1ca483ba62ae03c32afed4be7636c5dec4514fbc0e6fd37241636eeeabed63125d0c3f75092b89e531d5f625fc138cc849e373186891837e7515cb3499daaca8d081ac0ee273b6b38fd291f1b46b63ab335bef86f4cbf7f49df7a76e08a005c857177b0b3c5df6ec922c9b5f79f0a6b111c22fb8b6400089e29fc8893b23c85201e91561039c5080c2a16e1c8cc1b98af8a703dcf8fe4de5603de3cbab6c375eeca1ba41dff5d1f564f6d03d7992e10a8e4272bb1d999c7fdc979e17dd304a1e25b7aa55c6e1b81ca8a85ecf31e0887f7c4fec0ccf25eaa38e4e6db1207cda4bf1c03d7610cc2ce2900fd7ff7c98531f423fe3ef63f1095727b2fe84fcf7f0a27b64765cb46cfe40abf7895ca46c7e75cc73b25dad8c9f879cd5488ea6a1f70417b87e0c0ed41b9ff5579a7ce029c1b399d17e4b78795bca2d245e4c25866021240f7582d90426603e98a0b476cedde82daeedaf22073240f85263e86cc1a86c01aa6dd4cad8521cd58a229bf79c9e75d8870894a141a920dfab4c0f7c313afbb7f8d50d745f86e633b326c292811047cfe8fb03659ad7a4b22a0d273ded8cfde126a2161a72d46c080da71db412fb5c296839566e4a2afb11bdfb3d2815f29e7e7fab81d5e3d4ced9e880ff9936d80cec227a50f7b730b97480c65ab623fe542e108641479ab34c9112810d4d49089ccbb6ff0fdd0db7d23b82c42be4d53bedb0e592b2ef7372703f204a52706321e389aa893d78cdf6d8b421a3ffa0329914a8153e92bfc9b5a7c5ef08b78b7a9dd8cff8232125ae467392a233ee84e6bbfac6cb9115701e98156f0834445a473632ed55750a8d33530fee30b6ba3e675c3c0d8608d1a86219d1675d8e6a0c9dea6b32d599a94d67f20bb43e26ff8dd351eabe95642189314a3e07fed2177c5374d62d7c28622feb76adce3c78c843fd19cb4ed6b2063c27b10e7ffcb0c34448d16bdd977a78f4db4b59f350fe7ff66dd8c3d9135c8b4882a34102acdd9d898178755682ea1c560138f985f597a3d25f8630b0def05d18bf7a54e41c3b748311ff9d9a4660a1cfef9202b429bbb58a857bd12bef3a8ae27e43084629a675063b7b924d4162b845d3279fc60f92fc678d9b6300f60d2f517a21027861e226d51c5146df4a517c4364a5d8965b9a3cf0ae7bb85b620de82b66dbdcd53a436e154b3fe284f720ce10d94cd350b73c8d26b7204e41987d5ff1c0ba400047aa0ea9e83ca9068e1145c3965ec69ffaf744426338841e82c3d79336302ecef70ca62a0625eb83efa22bd703347444002547aaf5abe15dabfc0c7e682257be63e32f3fe0506dd19ef928f94626b56e41ac44591180c1e273ba4cc8e1adc96956fe249f777bcc24192b3671cdc4ccfe5d07f151e80169c696232aa39d11fcf45f790745782f2dc5571971b2305887b233e4a2d15fde8c2cb07739959adc711afe0fab44a187b147b0a6ba739576838da8b41da613978727fded7ba8a67089ccfc75785b2cfd70e58b61be5bded239e7e1bed86664f6b5c9f5f76a2e1d941ee7d38534d1b0cd7132b223af2567940c37f62c4068c927e736256c50e1565ad55b496d93cd0b83bab2933d0d243b6b0f6c36e9d7b33ff75f72e6e68f156fd5ded5d7128fb179282f2fb5adf77a50991f831270941b2766a79db88ee6689b62d4be888d66bd77b112a1864530768eae34e28dc40daa41a25080ff02a2abb1a5b75c2f0dcf892541d796622f99f66743ff740fd8e7d21270a689d6cbf0cb69ab1d2dcb0ca22e2cb52e7a6ea8281feb886cd53823439b497ec1a0c34586c0087cf44a281b8bcc311de1c7d6a432121967039004d98ec0283e5a895beedadfeb09e2603172aaf1e91c11285ead051b828d4665ee10392ee8fd19deca59f79b043b968d2385733020ff52547e63f3183261fd0d83d83f6120c4ed9c1561de03a0ed260d9b8f671a25c8cc4928fcb30b422b724c035633b8da3106b3f9917b079705c33762a4ccd740986c6b8ed8f19de5efa84c14ade255c598bf1bd046a12ce8f55f02a3cfc0c8d0851b58c00f0250966344713aed7745472e2548ae46c73ed91eb99f87ff40d80446a769944563e8fd1d22f24c6b40bfa4884e5154585e1c891c73332a1cdfa42ea1b0715b60a5d160b60f0b0f36221a41fa2bef85611ed416480b9af67650f52c1bdf922ff90c1c4993e20a7d7fb2c2b8f09efef9609a3fdfb29616df219b79087467f4a7ef1a368340dd0500219a9ad7be96ea15b293645fa7c67c2393d24dbc5f4e02bc833b74105edbcf434cc039529fa459af1a908698c1121f1834d8b7bb4f589af24a45fd04d1aea3002bb8c85a77badbc3b1544c01d200c214a8a630672e113e66ab5973df00bdf5c1b87b1a1508690f676d795905c0e90d7921df7d51648a70863054575778415b8278a14691a0acdc2952f983f2d386962818b8fb335352e114ca2e9416257d0ae00e1336de24bf8e51ab5f9ff863d256ac5699d3a9fd3a905f9964e6e5da986fc6b69bbfe0692981551967082004e76e7c3aaa9b89bbc5cf4e3d807e295317fe303a9461306d2ac6f98d97eee8f440c3e4dd7668e76806c67ae55adadc11a7f201c9b1187a68ee86d2cff68d3d964474d46fb5adecd3703651fe33ceecdfd48d0a3a3c71a8de114a2a51f4ed772a5e7a2076ab802d12e7a821dffdc991cb070bdccff6499f95c52031864dfe8802f34e029eefe062e0a457b4c4c413c3e58384f05e60d74b0383e2ebb45bb9920aac58763ecaaeff692a29adca53501e6c7f7992449ae40ac22a70f758f37fa4f2c273cc058be9bbaf0f767eb06226d41d5bb1c9929c64b2408dc9e797c4d81cecc65b8ac4c4b228e34379fed60092f5ab3cea33f4f6a340c9fba359c9de89c378d9a421de3698c07ee8f7b30c22cc8029bc25678e5e562fd845e7cf071b14e75b9b3d014b290acd809feb53acf11a83b3e75de8cea6595b229cdbe7f22a1aba4c3f856ffffcd7767d53b393d83b7e930e957df658350051b90091ddfb4c4d90014112dfc3be462e55077f118a6d0dbfb0fc18d8b5eeb91fab55d698de3028c61cb35a4d9fa8304c0e7fec02006506291441a4b4f2c50bef4ec8b3858f2c225bfdbf8c8e0756e1ca461dfe38648b255cc81efe4ce0d81ec5e97045564d6f19a33f2db22438b01ccf861d879a8684f044e7756bbb9416ea08a4ad44e82aaa035ac33238ea44d746425ee861f43238c399d3af2093bfbb30e3927906d14aa0167a7451f79d7d1cef12149d2553705734e6bb965d430685843a5d4a5bc9cd03cb3aa87eb99551d713dc8b050d7f1c7a854097515f967ee42a45a48ce42a18ac6278daedd1fade25864f269445218a0585490e3422841a4748c619cce2e84cfa414cbeb1d05d0022658ca9fd813d6d03a89072e3a4189f96067e64416e6aa7c6998b6e99ce097e5b623ffdb47b3174a04705fa80af8d9d26fa72489be2f07e779312998a47259315255f1f91c062acabf0edca1b8c6880b4e84eb1eac90fec1ca36d16ed50b8d1aa34776ff27bf8aa7f20f8cd775189ea15ef652c13bac074954d3268c590f23bea6381a8dc0ae7d4d556f127afb92451d49d843631a6b1ae9181f6839377359776c55bf2968762855cc8e863bb80980e28e10b95fd8cedc5404465b21564ec238d3f7af72c13170a087656b5b9f935abe62fc1a9c28773f1bd56eaf5ae31fe1a525223765085671d1e46bcc2751224c8a46c10e4105b2158da698f14a72c407bad4b6e2a0dd513c22c90f3725401cf0b658d3a4648f5b6b51a605f42c64143b155d6db0c7f3b44a6078e8873ba99bd3998f2bc2bda9bf094e01e41adc5c0c952f405cedefefd4859b1adaec52fcbf91f182e0ca1691844c1e4b2cffca3942b4fa6d908e5fadeb1f1913f9b5abd9c665043a3ada9ddc5817b04c643e1dd37baa7641f2928ce50a5a30fef7e0fe0e5ba1c49db3683779211ce89e6fa589e35239c808d09a425444801f2168b8de53b9cac37525d5ad5e0866c305a42e85dc0c1e404892cc80757c9fcb76823727e6995817e5303fd70f8a6e9d309b7a7ca9e14b110b0701f2e6b28b5a241318e42b45536c2359a2436be586a756451273c7cfcf1c7de0349eee06670804f34541a9c60cf679d6ef4817d6060da61888ae4ffc9c04a195a2433615c176d7682694df0d6708bcaf1813b6ed33f6cd714cab7ec1b75eededc9ed04fbd7443ecac090472d9d492e00ddc8bcd0bbf9475c941cfe4486a26757f6ead70b0e95bdeaf3c564742a71164e23b5cebcc2a22f0dcbcd4dd132edea097e8a0ac2a2fe66e9ae96d594f8a45a5c9b47cf2ad5a42552b860fe7442e80ef3973ec42ba01dd4d6f5955ddf27e3a0f5170cd47bc45a884278f370adf3e798c5b47fd5dbb8f20996dd4108872de94624961e048a4f7725f8298df6c66cc8145a0e60601a47069dcd0d999c46b2996c978edb56db54d3a16b2c84e003fc6f9c987ff923932d090fb62ba2c9ef379889a270427cae625c9ba3f4acf4f882ea8f4fa1874ccd52898170fa187ca724e851eb995dcfd528a87a5e4d24b2f29880e91fb492f6f0e51d626f9aa42086f62267a4d973a27d0683456edb9683c7e5382ff0f67fa3a91353d914f530c2be2439e13592e3f9c1e29ea195acb7e15ffffe4fce8559efa55b509a7e593d48880fe6c09449fa2460f063a1287d1100d43eaa7e416290a9318c0f5237ee761723d03ad47424b7a243b9e273097e60015c6ffd58e0dafe8461065ad39338d42589e9b46812df4f097095841c0daf4a28816e21593b9bc45620ef1adbcfeaec16ae7543e0ce29688497429908f8ed0ce4712f9e6ac695ecc003f7dea80ce9ffdc4f2c01c6d3e4e0e46b5d997a6b265d0a12ce09f0a87f24852fad9e9db0d4a127ec7372b8d516c27720c32c6d40d5f59ece66b492b150dd517d7bd8fdae9d84948d1d3a4e0a40344456d39a25d4d06b1a0eaa30576d3b81018d7eee8f989ae4ff949f597da92f694faed3ae3f60657bf196fc1513d109bd41481dd70dd19887f819e57726f218f1dc419842c8a324773e15cae38273a0144683f9c4b7e3e34c77290a96ec0c88ce5d520f30535e2f9b70e5b6b9faed062463466ce3b815197500c131bc2949e6bc89bf6064985822ed49e499e131437b84d17daff4622674ea56d6812b91a755f20a8618bd3f373060176f2839da9ebfc7919168a2eb9238e3219eb3bb10b5c27c589c174d282ffa500bff92ee057895685dd8bc92c09a84f1ff6d509c10847c52b1c0de6d361cd6b1d9313250e6c3bd75cd1c3ba5a9b8446932e1c61bc13174e3e7aee821d21478368839a55ef64e20aa247ef68e1c9e16cade5097279099e8e38f42ff05840e58146b5e0d414909210b5a158a9ab669937c56d489f95836873351c6e36b320827361f5fad81f6ad5001ef81ea61c251bfdf5fb30db7a57491818f64612a09dc52f65d9548ee450c4cfaae8d01954fb2cd0fc49ccaf454024ec70ccd8d088d4bce8b47cb9d4ade9f3ddcb082ca2d67f3336d3c5bf5bea8ecc7128d048e32ff8af3fd9db47419d0473c03a85f840a7f039b1bb74779622d26d9bdee00835fec890fac4fc81a412caad84c41135d7082cd14a180636d10fe179ccec555a5bc6b86413169974eceb71817d24c0d51d783b5fd2ce80b03763f20c1810fc6173aa0198fde9e67eb942497036a72e4eea63260e2d741bf487e967370454bcba659f243382b7c8f41cfafa3b181fccb68d07eca101dd83036764622be483e69a6fd5589497c4cb5d8c2e7d0aa89939e5e9b10bd0dba83561b636f6c1094991ebb6c187e8db2a6e2c59088dfd3a3eef2d5d0d82f2d66c52394eed234c044a34fa1905254ba505ac69af4fb3461c7f7efd06ccef68b7786b76e38f1788c11568d7a9c4f18636733ff2f0f19d731bce8ad9ba2fce1489c107ad5c66a176be3f0cae9a491c00a1da7d9309df8448dc7ece10a297d0125c613d835f69db1347cfd49a3ddc1225b5555cd843cdc56dc7403a7cd6623f1fee23a6570a5ef51bb01454ea07aff82c140db466c5832e1aa61321701065e5184c9bc4b665c3e89a2c91a880384e4ba21eea047e8d7a5240651afaaca4f2eda360321418a96c8c1a7803b2a6381bbedd7d0e37a4b76841cbd8f1418611dc879e10ea42576032a3a4d0435bf45c433cfc07b4c625cd5b92fe63e9d846491b774c4db0e878f3294ec9b2394f6900c07756e2d76d549c07e20843abd7d752f242dbe27e32917ae758448e3b669c98f03d2541654ec514c71aa69fe28ea87bfdbfeb6a2316b4648df1c65d047eeb32f4eaa624536b4c92f42c2c5338842cd77ccb5a17b255bcc79750380703ed21a6ca3f71adcaeeca91bb57dd9888efb1399215fd366b05b2a96d3dec1acf1cd3fd8d5a5b8c5ddd6e2fedfd10c8143ef4faa83335e81a649c3bd151a44ffa59dc4626fab264d6b8391a0241d0480c6ab48e2bbd0ad6272f6a54f2bb4de50a379b89250d951dd78b5df49bbd0943f1e909e82ad315ab9ef3027e8ac45910084d6505dd392241f2b26fa5e2257db0a8d18747ce55ad2613a793e02380cfd95bc7e4b4f1659c37c51b74cd9d85ce8203bc0d8a05f7c2176b57ebb4903baa7160039044b83b9006fdb64ea53a7a8db3a389e559aca6a123cf2be456905b76419416d5dddf2c3aca1d7c78b1b030c0bae22a309ec4c5ecb27214232579b042e7489b1e3e26e6da2bbc8ff2928f0960fdcc11952d550f5b8bb38f735a6c6336ac5af2a2bc3b44782d72d4a0971ce9155b2a795827c568aa117556135065629e5bafd40ae65740343fd837325b3256bb9d7f9f7cb320c2def0f9a7f00ef0edfe9c3dc29c8a23cd551fdcec1a8b9687676eb32435af52ba03476f013dca043f642220c4859316a657f014bfb086b36278e29c9f5bba7f0bb1a0d4f8e4a5761d577ab3d13494181f844c8877d970653a34e4228ae2d6c25402984eaa8bc787b0019fdbd8cd15a6a1e7337fc4405353f13e6f8085cb0d2fbd3f599e583e5a84de6344ddf6b783ae78eccd3a74cc375a19e8d98b502d778353db1d026e453fca5c996bd93c43498b4c8b8138f37c9e52173d0f946fda7a54bea9f4dd11d7f89863f01e60b0817bd14ef04fad780e1ed2b6aae982f7806ab8db877c79df61e2140d450aaa3e9caeef96e202f77c2eb9dada2236c21ce0becf944e5c4db234e5683d169252a82f20161fb6a955fb4e091b7cc69f1ed38c173a31cdce348c835ea4515f0c59dac5f192814f9e48cf714ac41e50d93a4c9753b7390e0d8857d00dc32c31baf2c2ab1ada4ea6172189c7a68406766f5b5c9a1c996eb88710e30c970db2a91a969db2efeb38591d5024d7d49242abb09d4fdb8ed5acecb22f0834860ac45b087b471a53df1634bfe332cc4d85002c8b1378666e7aad1c8dec0fa47cddcef35b17ee967fc47df0ec0857a279dfcecfbbcc0ea386b35bf9bae438c4cbce62006f7ecb48f6f97f6208da4bad61988a369dee7729f00d5a2b5ae450302432f13191e3d4e5728a65175aa44c459e40f0ab0abdd1a2e49198c20ebcc2220c85eec47b27597d631135ef0fd07b9c02475b12551dcf1cb4ee5caf1bc49f6f8e663395281d7a62f583b806086c9341e68373bfcbd019bf5edc2d544d6d68614ef5ae2721892cccdb10d5621959903800fde623c5acd3583f58cb68df42e696ead9fb8c9418ae684cd0b4811280f5c5b4a604400be20e3caf88b74c93ebc64911e811969ed68e7ba82613803a96607d14a45e004df066db2c38ef7162aaf50a2f5d0d660b50e58c549cef3cb3d9062c17835f133d925af9318e3be8247be4c8a455104161a55d811b967707a9508a7bf2c0a66ec0b41ba419e7d2be5730475085aa442cf470ecfe1e557afecfc62fa121427e5a198cd9590a14da7517361599a1ce732554704e9fd4c3d85c7707dece43988f65bb9e85c7c6522fbc1d2c7a96068f6ae549d81f331c5a729d56053c41e7e2d4234fa080d6339cbc96f87871dd0cef6bd65a7f0b14aaaf6e206d58d522e7ce7c981171eb6b17c09beeafb5a55cb3a93ed20cfc40abebb5a364e1aaa97d90533ca5c4c376940943f2c210e4c0e3f2696f5e0dd84c4f0acf9498bdc22e234ed35ea35b0c1a1962507aff2b652a1eee0146b47e05952013a93dca9f194c521ae1c88bf77c306819fd9b6c6cd9fe4c43f51ca9c237fc1bf939861c20c8fafb0633211685ff66889480c83acae7059ae89ccf4080983dc820b31ef0a1fffbea58176c6c85d9a8e6c06fe6d77c98bbc4d0e4f56ffcc0d446ae6f216d8f55bb8fbb5384bf5a72015f588913bf557e3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
