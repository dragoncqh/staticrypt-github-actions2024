<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"af9620332a6840f5242e4b5039dd47b07df27c9257a7fe8b02326294a13daba14fb05306fcd324d8109bdae66cb8323b1e847c0cc3cc479753f273283af06ac0e599ccf31d84dbd2d8379ee378035186614998910e3133a3d9fc97c72cd29b9b54ec483c7fd6c3f9c636f9584370b7c00a77fecdc78a568066a9ba71ea8bdb10c24e2550e329ab5d8fcd6c55cd914c08cf06838cb0d5d5c9478fe7f9b644e4b05a94f4746f69a37510df58fa431ce46ca7b373e448e1660cf007b509e72ced03e2bf264e5b36996ea76b49f24e1d7f38cfc67f8d4fa1210c0c887e5b1e7f7d1f73856ba0a15b838c20a353a248f95f9acfa620e6770976ae577fbd68b753084be1c4ce80408de2a7f0731146165bf2c107c0ae0dd2fc3abb55304b851fa7944abf9345c0c9b61a01b8acf72dd0b6f7ad9ec1af8920b04042dd784ec842977f7ef094ff6713efde25f45c384fa1f29f6b684abc4516c124467ccccb0842fecec543cd362e39c2a619c86f36e636b7426d5ecad7427c899b9f37209989a2a07577baf2452603d16bf14a04c888fe75f1e783b8267d61b1723ceb245439cc33be7f7107fab6bc1a38bf262f562b1e841f21619c1b0b7c4970142764637088981ccf4678bf06162946edb7e5b0cfdd7ed233f51894905ed7077d5f92eb2e48eeaced24f65da37fef0978e05e5a126b0661065791b35aece019afda2a93a2446af42c37ad0393f7dbf2c8bedf9d5aadb426fc076fbf2df80adf75db6f86c2f349bf0bd03a3c6ad7f700d75a379913c723c529b97642c4d6552691ef5ae3ddd31f914e58fd374745692b4b77197cd2b952ac4da596cee6ed5d723d19614c7617d06abbed618fbce606ff44944ac1cb09e263025726146cea43f676b01ef61a6d7ca3a21a8f3a0d88954db9dfbfc8fcfa0748a0e64407623a41f11b09630f7fd8f3990cbd0d26df072570a7de345ad3119a54e91d2e4369634465fe1e2a8746f840d0a4efad3c4013fe8f9162083b8a73505a1bd55024c5c29ac33c2c21f8acc2b99cdfb606cf8bb3932b267d7ab5fd640b33d0898add8d471e60e135af13e37b4239c03d32443ef7d21ccdb3e980a8678dc991e9a5495cf01e694f95bf5621a93a27abb69875e9bbf215186f2805d95f7d5205b9dab1a304a92406fecfced207ee2d68c706f3c7047f13fd6414161efcae87392fcb8452c3089bec855082d1d6eb85805bac0bc1180650ff4690326f0d3ad70c1fa5ff13bf4ec894a22eeaed43d0cb2c4baf186706dfddd71c002eff0dbd788904d3044cf01557d588e92420b63e64d73248b04b19a6bfe5d94aea878de2f0830b10d735f9c36f1c0f5234bebe73ee18987d9101f69775af21e190213eb6f932ed28d06679866f6202fa0aec7048e8fc7f47b104029a1741ae28e433c4f4b54b455e03ae5bf646cfb774e2085fed519c4ed390bec6bd136532aa8e909ed3b8728cfac9f9ecebe627f7412378273d75145ef1e44edbdd17149c4ee66f2c414ecf60ee861a02dcb64a53ce2571a902f24a986d5d159a4efb205fe799bcd203c1c0318e5bec19e88f21d0f1aeb1e5e1bc141503415b3e9e28b5ee0e9e7d1b1ca3309e0b22cc0adb64c50b3a51e9ab80b82ef1e5a919b1fb634b32eb4cd20846497804d0aef029f32ad3c92511428f892d94167860b450562a859795e3d28e4404c148e55be5cd2f7ab53cfa1e7b803d9ff93eb8ec65bde6b1e3e749cf336be81630a1a2d87395f62d991a18ea3b33105fa5537ad37d4030eab4891032977535a2be1c335e8e857b4c92806ec7421bdf3f1f90bd67c0bd0221ebd77a13de4c2163c365f0a8af432c5e49b1762629ee498fcb5583b9dc897858067f4decab0c0f949e8277c48225a5eb6a6fbb5a229e62c24abf14fb5862cb36b6cfdc2f331fc0578b0e06baf2542f62c1e3818f34dd7b27f1d9228b281665df6ec83e6acf3d044a9dea2ffa2e57264a8180f2aad5e91a87b0f2c1e275bdcd3bf7db1e3ad6a3b0c3b250753d23761e9f558276d90bd9b4d1311d0542feef9b7816c28ae9c6e4f17b6ac6d1b222af934fe63468d242590b284ef0a927a328d6a9b5d962c1dff9f2751267ac04f4fed595565c33f1510bfa70496b3e1aeef38d00ae21783b79e77ba480b2f4c7a59356b3fc892d81f5d609ba9e4fd9b3b6c8ee08a82ae400e41d594803e941bddee590c83ac0075747d660e5bfa15e946e15f12283b0212c925d33d5a84ca99daa4c21e0f56ba2172a863741c4e327c76c7b9574d91d88e6c535fd5f9c49aae49e12c224f0ce1e3e6d8a9e17323e812ced6b47bd6ce78cd70a33152fa9a27a39fefd26233a0e62be5998c3c68b9fcca85830bd9f55d00765b518198b181e90743882eb5f190441d938e54594e4ba7664ecbb4797a3592bb284ac0f63feeffa3a4edf20657a1a4d1ad5b6b96e1ac780f6d8d45e4d2c8d0b0d794b1b81c994313844d52693fde999d6a581066a5795c54bb261f83323fbe9b578911ea3751ab02eed9ed0b25b6279a1aabd3a75db100a10fe2977c8108d949f67162750276169c5c2a9e9bb333c77d54624bf1f6a09d727e49fd612a6f14599edd7378006906c419910c72fc4a6e113776532d14b3125dde96195e3e1d2ada993b704407c10b7729077b51e28966db7aa70055ae0361f63436448f5031318c859e861ba1106ff642360ded89869272fbfd957c8d95fd10014cdc244741985b42eb7b9b73da3c3096782d38889b7ee50bf4c2b2b8d5adb9556f108c061eff8062680d43e3f74e2c51b50dec46a3ae2a1151ebce1c6b4d1e93b82bbd6a9e39cb9604b4bb640b22410969e87bc356b2bdb7e7158adad7a0f35a4e0d3e28c2ff946b0e684d3da7c931c593693ef4b0acdc58de44db87f6ef8988942ff423f4b1ae026689c1e96276aee528d1bb2d4abaa8b015df2703cd6e925ba5fa5d5259771163f0370a5e17a8fa3b35b9abb03a4f247ef729ada65ee2da7c1f308128901c840bcf19d46a61c1198104f0b45fb608779ac61d852d05ad133e09e2dc9254c121b728c1f77d31d236b3966cdcc81835937ab56c53340a9c03ba3fdb08fd8634b288208e4fb4ea7929716d89e99235f50871ccf70f187c9c406d274ba01dd468b8f508440cd5b4045d0272a86861d69db80491b22a9c2ed223f610f8208647a84e9bdafb988ec01cdd6a102a249e7a087c0d370c9c3753b26e4daab9dbadc5970c71486c981ac4ff2b006232d049985b95d668cf88d9042598c585eda71cd1721a28b07774b2e6275e6666f8fc963741b84467c9212a39aeddca29a21ac88d4da4a4d049b56263dffba2eb9b89e2f5b442395e0f951000d61f6791507e2144ee09c0b937ad469441467b8c7cb139760d60f9cc203b8478cf67060fddf110a8c23c994194df50da5ab317cdadd745917901dbf180a81ddaf3da54c8cd591e046f7634f084a5df452f6776bf283085e4e619cd2914504fea24685b4838e527dcb873bc8c05b6533c82a38c26e1f949355c008e2eff807e379e83928c524bcc9efd9b84a912be039ef47af00a1abfae082a27be77e90c4e028a027f0be45280d043a347430b0dafa6277fb6ceb8c6785cab00b9b8b7b16f4ac1e007d7ed3402f73a8911ee5469cb1db944e43f1f426b3333787226acffc104f8ffe7757916cc91fb2a9653406a517281c94213332e0d0a45cb7ac680bfb7c5a895fcc8b7806685a9ab639bd9f34c09545fa01142a1e024370f881a6d8d57bbe36c95c589713f586ecfe14d8252722084e11638804c844221409087273b20c42906edfd394e18ed081b8cfbb20c021f22e1e512ed734d01ad29180bb5dee01c16c41840e82a042a652f0cddafc9a190dd05a4806e17d8b4fda04b7027f08a8e7bf2179f4339e569dec300de04d62f5004cc34333af54ddd3ebb913ca217a798ef612ed34ad6453d6e2d549db2480ec851585d5b34e6a29f4f1d56c20dea43c26db9159c3f24dab19270ff32a8687f726e9336108825dbbf5bedcb1d39b02d21e87ca78afdb2c1af805fb8253c368867186bec31183062c2a9cf613d8a912da7c56b4b612285ed80463b41b4197aaabd3251defcf5745d0d4be25c15bba45e9ad2f9200ede76deac6bf167d67d27003d745e977c48c3f4824af82ad0865dfe5f29c72fd538101fb6e49dde33172b6f47ee5cd334a2c924bbaf9fe06cc6f87769e79dca8723cd447764441062c712ff89ea1f75f073cea989f40a4f4c10ba219efb65874cf099844a4db672febd4d44796513f1eb6c52a683ebe7b646072a71769aaf03c2215466c65ca97a886bc9d14f1d8d2fb6587ba9f8849cb005b8a3fe3a371f2c1dda08acc524a5f5a33375d93bae3c39e70f350612f2d21636fb93bcdb8a0a2eb5618e5d059f52cdf2547ee6cdfe3bb2b0f49e331a02126fc1f33e27c374e5aa5fa08f529f3465d007cbae2b5fe589a7790604f2757d8b95618f7c218d10325d39641d0a9aad114830fad8767f14d2f42a4309373455350d5add481d8973eb5e594e0fb04e45c4c2e658b319e050f54134f3ab4302302748244484fc8b16ea9ad522ee8d4b79768211e77b8c58df4b67b5e5c5beb54ce477dfa18f973730871c3606c456ac1faa79add90e14594a4b13d1ddf42dd77dcdb005391d73af23fd76e6cb70936cb321a0b5d39a214a067655dde653144f135a1d6a0758f312c054483ee34319aabc8acd1d118cb39479c9da70c3356ff6fa558b1c233c4efdf51c8f088cd84a07901f32ba6a8832f97d383ddb82978c6d4dcadc71bb3dafec5fcfccef1ae94cbc3f0e409ccdd63062148ed5bc113100b4aa37431ea571d4d94fc9e7395e3ccd8cf6c15d19c2461e1897f9dacc3aee3d802929757022bdbaca916ac54fb0bc33e5fbfc2ce6708619b95628e638016f8776d317197395b96de64d0e2370086c5b2661949eb4bdf383c30d1558a72809755a3f07f4df3fd7fc81a61be1ad6d5cf42365669e7f77465a96bb04fa3a242722d461cef3f59c3247abddbad21605f4da3446500f582c7ca7b60ae9949af0877164951cffcfb374fccbac8322f0d70eb1ea714a5709f89d6151ffbdc8e043a1a42e36ab7f2455ae4f745d6b1ccc66789aba3aa2b4a97b68c2bf7c96f4f392ccefda910e6b91c842702a05bcad3803c07ae370d3e6f1830f6aee60751afddf9dddcf9c489dd8f04cbaea17f5a3155f1d432d894a8292bc96f1d7c5e1e781d191edc7420d470631cc9451e2e754fd08a9a778c67102729f98e2782347d9582816b23782a02f81c5856b80890fab83108fa94b616811ace255313095869f5b4e9a58f842a4339aee736b7a43eb6abef9ee83657ebd934728f144945a05d059761e07ce01e4df0358995e30e894eb1a889c275dbcce51cfc80db13af80cd24afe3d47ac6cd29f3a8ecdbfdff351e6eeab0beec5432e482890c0da4c23d944606fbc268ebaf2a0edbad0c312111b327ed6ad42dbc9a7c8b34dc1ab71f8ad029c2f41f45fd3d781161bcbce8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
