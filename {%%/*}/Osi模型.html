<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f293d024808d1317b920175311e94ba5621ebe649158b86c5b92a6aa1b69dfb12f381090d93bc3a75bf1a8a5b47fec803327137799bd77bcb74350b83e8ba0e61d2e47b32acee2b788e862b215456d9952b242868a69283015140ad5b2e8ac8b5a8ee75449af2eeb4092a710f769c0a0535856561277080ea61e0e6cd74d04b8dc6b4bcea56020926d0531628d9b4667570d6bd5b3174f1f272a5a74aace35d51576f52e5e1d94b5723d956bb0aec0d6facf93589add053774e237093d05bc87143eee25e4542e15d6053873d4781f150005c92a4ec70ad38a744924f4f3abc26f7199cd2fc7eee2662867dd9dbd61bc633e9970ebf7304a8d8cfe9fad8a45287bbe3746c04386c5b02954bb86763cb303519630076823b9463c36c88c693f3edc82ee50d72a010253038e435afd29cf0f18ae98f247bd92fe976dd04150286a4934f2e4f4d69660a36ea4768ad1ccb0c2ede37262e32fda4c3fabdacb970d10db0934679a66ff9cc5f999965bfec834c7b9ad483f60c6b3ffab8a96160f089c9bc0bacad549d7a6fed09de4acf2722a917e0b1c95446a98b5cba1991340b36cd92b05080029566f416457b34b18588633722869c27fb7fdab815ccb4f15e6632eb6e2ad97841f1b09f7e9ccc23db61d4bc6a35e606ccaa5ea0fc1c33b22d77bb21c7cbd8667a5f4c5d8c2fa328b06dc46823c7a012ae550608573ad413e6f754cfa04960ba6da1e485486284757303729df562c5d54a54ecc1c0f84ae97c1d6de167839ed9598221a31572af35ab2034a12925ddcc38f81042c12a9fce2c99924737d1f9da3f350081187c26aed350fdbdb151b0c1d616dc12d0510a60a317be1825e901df8da38ef0d9ec3c151aea9eaed0bf9b005c281cbabb57195288e714d2cccf6cd1ff9a2a2be59094f5bec2937e34682abbf726c5ddeb26f985e65f3f7d564f6aff94e7ec7da1f168eeda88b6ad4b5326b260f1c2f9ba2e1357c3202a0cb6678bae07013ae78d8d8e551ceb84e871cf506c4d8a145ae5f510bbe898e1294293200fb11d0ff3d88279cedd6b14f9f7993c7c9ce66a7fb9efaedcbe541efb062d1bb42a88f13c5236bfa26be2db6daf992bcd525b8d364ab74159e098c0db388f7f72c25fcab2754eea9b19069e3a841260a2c602379fd0b384de86e026e04d6bbffb6f58daf6a658e4c917118c74ef44b17a5dafa01d82ff6cf9bff9d1debf99c65f7f49745891cd7d8b0627331825cc319edb6f7fd1694c2eb24eeaa001c978744083902000aa1c3cf60342e0a56441da9eb6775ba5d5a393fc804375dcb6e47474b662ba6ec78897dcd50855dd677cff4767d818233549be0ecf2367b4a99d0cb37c25b9ef303dad9f1f1dbd90a64b352ea544cb2c2b3b9712be038c8d0614b47b4561b78ead32ab309a64f2c107eff613bde918dec3ff7a45d606f1c3701755d733b9ccb7176b5b0c60bd69b5d77d61a3586bdb7737304d95cad0613f6471c4b811e9f8baf6a31e8f3f833c63c4c56ea86b31b93972f49f95979b07daf211cc1ee7b8c19e6c503146480969143fa58e59edbf8ff9d003f701b98bdd87ad2cb4b932e910628f9ee41e79329d2b0cc3a57009b2983344f006d874c02091a8578af47ece0c7921242cf5c9663b879ab6e0c25dbfbe132641a7617781d629558feea249a5bfae10fcb1ce7f90a9f58c1b4c38ddc2e9d10583a9a16633914e0310c8a6360694539c33133b8bd09e7d05f5808ce1aaf5ec9b8490fbabdbce1c82cc8f96f52d68f1b8bd549f31b377b34f1006f4dfb6b8e466bd30fa86ac2294c3f3416e70efba694f44ec3653a06f05038f7ead7663a1e81d7b1b73f24b59f34526d466f5f05587b2bdac00f2427b124fd50cab71d19108dd16a00aab9bae8739651ddf0b69f34d543f9f8c881d23bf626b28b3ef56c5ff8dfae7f4a6a7278c001e4045f90abadba98e46acf6dd15b8f8b40b1bf90fca9339ba5f34a58f684a1d930e990b67f8778b9f34688424d4bfbbe0f80072399e0de7e33f0c2f69e5b4165139d886e5630d34dde8815fa881a810e54c569f3ff64d286cc2250c52e710d586c11014d350a8ea67e9470613e5c0d243f248ac5fe56304f54792165e0185911a75d4c42b4f1e8d4412e87bed0cd858fa922d18fc758a1dd79195921db6293ab26c8b257dce216aa89ab904b2ef58b2a81d82c16125165ddadc56d5249ba4c1080a2dcd62bb70f21b93337ffd0395deb4af5938ceb6841cf255fca4573ea3467dffd69d9fddd5d457231abc43cbb36cbcd4a4f49c1f02724dccdf949d78daf553b18eb44382f3037fbecb30e1c0261ae81e638a9f192ec446d23099e1021ea1a2ab9d9b1404747a3383384dbe07b534f0d8c198d2cf256fdb4b87ea0330bd61d20cda220d09e29274706b56b71838dcaef3ceb3680630c2dda3634032238543eb7f360755c67523fe2912d3da1157d7faccd1fba2aef7e773c1a899740450a06715707ba83d31a574313da66f1892308b4c8eae981b7ce38becaddf99524f353f23efdc57ec574c26a29a77c31c269f141d92276bdd806c6f36bf005e939b9be30f097d806299170aff1a5153d91da12569523a08593b5afeea6923aaad12ca40bf68ab09fa839af5beca561c5c27c6232272d71b6232c955b2eeb85feb6dc76d5e22ac8336cef366e26f2365dceecda1ff9b7eec6b30a9b185ae0a094e003c380874cdcffbede38c0b94c0f4357e1fc84a8a9676e69d4b0394ec9a41aa680a55097c6f6188aa58bb52125da90f919f94eb6d4a9bdea6f09113cbe5f05a17f4f0857477beb0dacc33e6ffbcb8637cc52479447e6af3b9081427049d8efaf484d7cfb184dbfc9ecc9d67b12dd20b82e7a34ccfb9f3293ca00d2ea3fabd0a3222b14d0f9ec6f7c15ceda1e04a831e0ef366f9d3db8b77d2777e3c7b7949ad356303cc6cfe0d04b750db5e29dbc936a6ce9fb3bb8ab381d86633b5831cf3fdc71ab7d983ac38bd50a665ef83f70e2a646bf36cd543d143f7bf7e5e73e1e9fbc021f5e07dc9472961d21ea384f5d73842f2f89e0bcfeccb167b1921915e087071cdf7d8bcb5e5579db7bf120fd1b2b8e65c08c5e341ecdff27ba093e93d6e72471c42055f105d414f6f23c8f57ff40f33bcb95f4524607cbd0f8907b4d40b8a7f779a8eaa4e349fd357ba9d1757bba12f2bac86e621b349a49c8616a830ab64896834a2e569a0af286856c1842d5ff35e0a02bde18279a7fc52f5500c5e8e958dbc9b3ac347961a566d054ae6ab9096e06f54a0fdec158e976d170fe12c44aacd3cb23ab92100f1577fa04023e59a4492f7389ec8a6b501c521b4a3e9799ff81b88ec1211a8f97b11e56bdee00b88bd64682b6c88507cbb97cc1a67ee8b8728c483faf5482f00ec7e2621f27b669e09538e8ced574051a4a40d8dc6d3796fe26ae9cb3d263495916d909335d51286a5beec6feb268928613fc03fe9d5eee21a3c0a702668cd679e803b630e6c04868ef8599872595c592a5f7de59f92ee665409d6c3e385e1d9698279d9c01ab73beb11fb239ec8e9fd33b497c7db0df68220064cb921fa0c5f06f269ba8269a570ff15ddfc9cc6e76823d9f7155e4b63ac61a1da6cfb5a6a1899b875532709bb8a81c795c172a1e6069280b533c82e67d86c4fed8433d60a81a34b8fd84b5f86d284b26d447614bac5848eec92943bd927778bb011509c057efa90c12bf64eaa2d909c3c76a87999d7e63a1efe4a5e8c8d6b3dac794219ef238301bf1eb038175a8ebcf7e9719afd979e0b582c35420352c5f47f51a751b701f9009ab587b93707fcd277172bc2e0e3f51c9d4a827f89b53f8570d5a8fc95ff208db389a096a9fc4bf4c0c76de126bec64b64f1ce1802007c3e414bdee40026341791772db304dc445667cdff8f1fea78c7b5472315350dbc7eea021dcbd196fe6256276b0d36267c539023332e63b074f80e899682da77cb6fe82e9e573854b75e11e99377bf8217ba13dc4ba6e96280a4c0dfb3553dfa2370b16e90a4f3d02104cfbacd64a8783eb06bd98c977da38fc230bffe3db20a2b54c6dcc1f23211e39d4068430362f50ea8c4670abd8f46546a3d8e529059df7359a070e7f64b50d7680e8bf7c5d8f204faa096a336e06b3ec5fd7e1af49f16f7b9e264f23de65f77d0dbaf96250e9c1b7f056a6c2ead8ed7d13a173fba633a8cbde92a69a99a001c9bafafeebc77a1e6e85971fb7a9c5ddbc3bb607032b55af109da360ce983b8e2ff6325fb8cbe317b2df9711ad4fba1e1ebbcbd296401bc0a9c6452a17398ec7ff16ccde76548ba74cef1406155d0e382b3402c2721d80402c1e5be6f8d539e55f0b5476103bd9faa9a326e9aa2419d95c296594d9fffbe481c5647299606755ecb6bc87fc3011c477d49a6befc15a6b144c695eafb812f1c788ffe377bdef0d37a885342596761b1a274fda3bd8553506095b8fa1e53bb7cd8a9422526f5b87e621bc74cd3edada291c0dcc5b283d9d2de9e7c586f27d9eb2656184bcb54da3ebef52a9c7e7bafaa5ac775a9fe9cb7c7ca50edb80abdce6cedb104f40bb15778bbdd1595d51524dd2c964e17f4719722ec7856de1a29f097c3e24e42f17568f5995e5ce7b673fc8205f37454b6108367c5cfde37fdc83f5d86441111144fed1ba04b19cd57e4cd19838870e8e70496cbc3048d2a4957a0b92ede957204dac2c5a7aadbddf7ec180b12316d0da8c226d103638c69cf5bf7e4fdf253cb73f9094a55b617f0fb0b0b882bc7dfb9de0f7eaa151a301efcb5d5537e92dc7ebfebd4c0d805ba8e25f3e39c975b868f168b9c64fd7e629fa2834c06522806f6274cba33d74d70348f580aae62c1a4584070f5e17fcb9dd34d13d9f0982c7686d1c6d868ca76bb8aeb339721e745320ecf97d4dafa573d530c99f72f27f6000d322201be81feb6585e332b0fba2662f8ae3dd3e122f689a9ab343d47348ccd3949011ef50fb616dc82013bbcbdb2b600327b5fca2b1e940a6c20808ec9140c583cea01912abddc8878001847ab9ec046f575d5634a6cf7a2f450c9d5466b9365a55b392caa107faea1addb74153a4eda28940922f38c2ab9689b5e0fdbacaaf3405f4d182f78f067c544d80545a4071f496aa9ea4af8817a0b106d7e8afbe3dda7ecf5873f2092a98cb072dd3670b4b923b8221e27938d178e92e250fd2b4e0475eff620d5453c4f171bc87626235b6f54f4957bb55a969c8cfee635cc137a0a6d29f5180869fae12235efe641ce18bfdd47272002add28c6360cc1bb3fa35853cfaab2960e82ba048dfd19a1dc68458d1364344b7cb79f9e158ddc9ee1c4c0da847de1590af915d93e30b404e4daed149e508939970d76469eba3f5ab3c7fc1716bb892831693ff1a910305ebe9e34e37a9e2817b8c1aff760c4ad2cde22e5475b78137d6bb0b9a9f13e0b91f7550223b61ff1c5cbaf21b015764c987490e54cb2f4cf473b6e27f89f2bb07d9416cfab62717d54c4c4917f71c39b9672672d56362a2337432aec330423a3e8904685eca5a8152e7bc16ea51b4a70a29f33ec48d07d0ba4cf7c0de93a99fda56849a9cb1375defae009349f554d041a029eae4c816a4420e030e6e03f10bf23f9ac0875d08b26e9af17ccaccb3d3925c60b003784d5bc99913db31d81219d255a1f7a42a03740521086ca676d48a63634675b39ee6f7323d4fd92cbfb26d554cebebd95dab8ed9d3ff0b7e14b7f38e5def67156b311f4a8f9b35bfb14266d61d0da5be51a9bf190a211e1d6d88ce9d2cb23a620bd03376d39cd3554a4a6b571a2a0e3f2f1424c04095e39678ba0a97fc6732bc5670c3f0849548a88eced56ad5f99f3fc70dec6f4a89076f7cca714de706dc818c25d7b2f4546310b0d0329b62343d25dc85e26318634ead299c59effd07eff7d603099a7ad5c0998281452b4af92828c116b9d91584edda9564f4f45ff0934a9cdde75a1e7d69652d1efed47ed0d0f9f439ac558376969d4d9495c3c5663d04b7ab97c8bdc49161f9ef4075f3a667b629787e76e42ee1a51b8b7081239d9df5b94f3e15a62bb88595bd0807720294f4a629c769a1b1ca91e0caf2e5273ac516c34f6bc3e5f58bf4ffa349d679f23bb8dd6cae0dd608a1c788871718f7757e219ff320a7a1fce7576849d85812227e45bb2d3091de505d1a15e09b1814bc61fbd1eaaadbce95e4da95c22f2e8c64f0550be62c30d140a1bec0cce225fa22b33f78af11051fc8f2d35bd4242bd1f37ed168d50d864bfd598ef5bddc86d944d73c3f4722423af8077a4448005d1daf0d1322555b34f64fde581407fb5974af23b7db98909fd3b034e16a50f78064fce618ee9a771930723d2d7f08ef9bdf8c3d3c34bdaaf7a55b3bb2284ef828a599b362c3acfcba18cfbc4d44dd7cc032b1257371b9edcb0accac3efaadda3908d6682aecaa6e3adc16e43981a4b7b2c0307ce005c0b2084757bb032d5764f7d45e2db2859137f110c6a81af994788d912e2b1980d50b016ad462e4bfada1608873fef6555a1f92f393397cdca7929f83c82e622626b29736621ed5a3630f5d4ab5bf6ac8a59910717ef068626da501bd30cd61e8c119bcd38d8aa424d5e50712c0b23ef362ad3280aa2f9e4231b8f972b1996510c5aba9d35aeaac580c1e4d577db195d710859789008c470becb8878c21c3b40ce3eec0e2aabbc376ba270dc5d0adbc5489d3fbfbaa5b16d19e34a2cdf4e390fbeb4966cff0370c3829d2dfbb367beca9377d6fe7c540e40b52b4fa23c847a5ef7bfb9c6577891548cfa76bf25930760154f5121cf047ea3ac666db637e8ba7fe6bcc063a19e87eafcbfc422833dcc6beb1a0a91133cf51af8e58f1fab3049eeef85bc599811415c6e7035d534f32ead5747a5385347db46ada0821c2f6d7e72ec0637566f8314471867ad7110258569ba6e57f0a88fef7d8491a9d9bb252241ef34e2c65715b98ebcd27fd1afe58475491c2ddf2a660fdc6ccc1dada3f92ea00684b175262e426fd54a33cfee687fee43b48ced8c0562b17b3a7f371964c9b230fae09608166ec2ab0b0f0ff3e7b66e9cb609598682c223e96e018e4f2b7b2c81717a086c2fb905002562e57d27973f34fb2b5fbd88e8e0d40b46354caae3c71a85facb79f5ef40a5e78aa6854cc333de7fde91b88f448a87c93e9bacd0a7706f35f67ebab59c6f0b846e313979196898ed76a8bc73dcc182fe5f580d6ee4ab7a2dff8a925c03e7cc5d75acf86490ed11866ec5b7a4517542ce3c7c550fcdf02ecbcab1790a58d1e6a99faef41f1f389dbd5ea9f0d674c8369536f0be4295b1da893b50a4b45f1e813c69722f4b16e5271f7ca583f010fd497ec929fce11b31e19810d4dbee0b27e5d3d8e0107c151d2b1bbdcd66765ea416ad4fc8ee85da843cc8109cff1b6509d61fbc038d46eb85c0766d728a334527f3a1a9d1a7d72ec57347c9b2c2b8f83c0e9245237405974523a915627d3387bbb27675cce291b89c16894c6694897c255d628d6c4eea566578d464a504cf7968050a66354a2d334dcfad4abd4deaa73dd9da5053f936fc2a4ea31bacf768b3ee8123acb475cfab5c6d019073ed31605e262e53daf7ff95ed749ff19c4f2dcfec28451bdf1abb309e79070e880c6f50f5a43e84e07812e5aae6ecc0259a1c1934c5d53cf8b0c10a4124270e3d137867d80ea33ebf98f3a652617aa6d7bdf28cbe83be922726c57fe2a02e662ab9c963c21aa27bdcc13cdeb70bd6f68ffd680c5bae395f4f37f094b1a89d73d715becbee1e88b5e1d83aa5f24d7de8b233aa573d5ed7a630d5c60f369a4c8b1afe290c6acc255860da215212a2105ed11753999fa9020a474d2ff189ede72395402f1d739ccb4c4907f7a01f1e16a8e2a226a9c9c70b33cb8f333cde700fbae724cafa232f623f0657912b2d5d0444abb3be2827bf7714f0dd0eb4310be380b96ebf9606392e277823fd2201a6533c4259f7fd6014718158141ad8246d2c367cd7a8464bb11d1f264fc140206ccbf870e18e4ae3a02286cf87c974c911954f6b83bdfb68ee47181c62d31ef01bdd7720f40546817e706769f71d4affc5864834dac493fe2126f94ab57136d34a84b00388d7a27d201240df160c67c85a8339c375382cb2e306ede1937352a2a84c2506da8f5aa47ead245734c663c04d99256958f2cc4ad393033f92e5c14c2d73330b61999792c23691ea74707db6c6dfbea866f7ca8a827f2ebab7111be89dc3496f0b58d4dd55c0834e7af09e2b2cc6fe6c1e3eda281055087288844681dacb53e5c1d56b10d3e68212f85f61e4f809f216701fddf29716ae7a9d4fc2b0959d2c1740a7a3574362af97b3d84639d037acecc51813380e9a9829ab409c3e289304c8a8e64a874361c2317b715d212fb86e67247cbb3ec838aea21ccd2ed764761a38481816825077d59d6903d88677482636f20992a27ffc123293d7e997b904ad155678af7c62f0690b5168c7e5d5ba6b976ed757b7289e05f12e9b2eca40f25525045f05fa734c4dea9699d6a29a7eb174096bcc4c4c0c2fc73a6c694cfc7e79ba17c137ca3a8f126e90b3984d5617d84b58ebe237b71a5cd7059a11d87eee87c9b57854574f3df600d3863b61c789429647297f3c936def18f757a9eda08fd134210dcc75eaa9895a0914ca105953fa08350f8a5d6d0e38d07996fa10bdad442f8658c58bc38235f8d1c701a5707be17f84f11f9f55c1299c0163ed6581b2398a09c1f5f8596f2023840bcea5530396b9064141a566bab38218b2a274b3d90a56b8df83f2abfafd19efa7af0e2f312c849d19047ec0d1211f03dc36c78db8cf16adeec9c2bf2d3f8cc6e5da50bb78c5329b6c05e2eb28ceedaac768648dd219d707ba4f865a1c8faa7be8d1d969d3f147e2ce47c54322109b62dab3b70a954ff0f17dd9578b3b5f5319574dc1b0ce630437d9809d0ea596bf0c1ea1b812865deed61a6c91669c9c148e6968fc9987a0c64c85c96f00ec9ac47971a7c932b43e3edb88282266a4340d7ce2398c5e5cc79bcc915f296e124566c27a3c9d1bdab9eec5e18e7a60fd9824b055678c1898cb28e1c9b9c478757e4ef27b5f19dc073873a96d295ac8845e4ddab2ed87ebdaf4f974616f7c39a29723bdf019175558c85c7d363c7b74f403eb7ffb901db53abe9c03a34d403a1ce243a5090ebe748571afb351ea4f7c99a6eba7e709f5844d03b517366c2697e91afffe0d9fafc664397863b2f46f9c1c649c01d9434ff678ce89f7b93894d759aa5275d897dd9acdfdb75c08915ba363a3a053f7a539223a2a0cb18485e1aedf28a7053938a167580db4d5399bd382a98aa831aa6091368b4ea56295753784d99b2e783d1dbb0e2483a5fa7d9a1df8b1e00c47d0b49423e3a1630dc396b7f4f6dd21aef54c140c4cd2f9648701264d6be157320d40e478befb9d4d9328a144d213b0cea6f44786689f62907fb28ff34be211d67abd6f249cdaed7598ca355b41521a52fb60fc2e2bb07a84850793ea562eaf122e6af8e81b7daf5520371d0261311ad0fad7e0975f47b556cad8973f39e975c7641f3dfc87b62d177fd1d9eeb716daa9e6aea861eb0eaf444923e1a3bb84d2a2bf0e1aacb228567465e57c2b816184d7b79527bbd7c9a42a76d0214558c60e6bb39606146a90f34b377f3834613772527dbf73bb4dc8184b367075921e49741587864b91f5c805ba881cd4f5f03bb25b24ec7c703768cdd39002eec9c7653d81a8ac60e747f96a08ead47278abff15713ecc53700481e55c4d1c0d7cd522d0ea8333bb1e9fee2c66b026740a3e2bd10049f30868ae3ff1ba6ec2c7c518679d2f016a45fdbe20b4a02f57fa2961be3b57212daed01c68101d6c72330950f3d7ade38d91a78ae23e5ba6b912720a4caf7392ecaa7ecabf3bd6ec66941affa09c7a175e2451007d39215fa3b83387f462b116d086beda110946c429762718dc6a14fa170c11e1b01c8a5065da45db9fe2fec5a50d0fa14fb7ef0f4a6e950531f6522737dea8cf76679ef55f372816c695167e6526884e8aaaf53b76748267b7f234731512da71b71407f060f090a75ba3d2d5e87766331c738131f49e95f1a48b324f531ca1a69d05b1626867ede317189f784b013fa37ace01d647834d2c213e3583ca19b15db70dbf6bbb9c067ff8ca2fe2218959291755eb7b08d5099d743fa2aca8f6d5aabcb31376b031b915072d43042a5db2f23ea144ef44849b926ae6aa558d40c74511439d40a662d0748d4faab3df4aa39609d4e2fe44c38aaf11e7402fff668aead3b551eb8670f5935e76e1545b0bdcc70df6d13301aaaabd03cebb9ceee31fe159ac9f1ff3c74d4eec892f0a12c1c4ba9cfcf472a2ac63060553b037507dc8a05bbdc8f8a1a2ffa58d792890ceca9f61a5de301632992d3508a170bbc1a0094a0bc38396a88bf663cb9db31d2741fa5ea09c9e518de011323992e29382658ab2b4bd2729a8861b1e360c7d024db88113b21be6c228d728260285c5f8f89bc68f8b317fec9c4cdc29fcd5013afc1a5ae654da8c270249756a9abc5ec2c1a1a4db1b04fb1a29394bf28725889c42dc0316af7f7e83ac24e810b13fe2ff69c546b20dfb8ebe5882da3677b88f17ebbce13c927f8e20c7f89250e0d605259002a0715b9c79e78e407ad14eff6dafeac7251f29c85ae2f5ca51d1d9287ac99fd4c862be75a81c828fc5e477a23195b359b8bc54140ad9628e414f5e5e10c4f70ed73524922a8188cd80e535ec63201c9d1e0d4f6ef8b1d17872b8ccda5954436e45d4c3df099ea43583a2afda828bf8084132d29a122bdcd53da5aa94209a1e1237d558f222b214a37e848aebbf38cc0595bd74c2dfe1ee3c139a26101b846b82808785389aeff063d993f704f6c059e69b3997d6e86ccbd847ac63dcd4703995bfb60b517b14aadda473fb5321e83d55421436896d3ea6ec687db6ea218579f233f371c3a9a7284309b52668c14e4558e21eb9dcf8633f59eae711084707ae22db53845f023897289907e3e09dd76b3c6287b64a694fdfa2f41fe650bdc737116af40b0f798a3ab6c277e746ee0815f12e9467c59b97b104b7b11b6830a949ca2431531090c1a282d2ddfca91678624db9a083a2159142cce538248c17811e428dfa79dcb51bc6ff8c8525398be4f9d1bf8f0379e769ae43ad4dcc974ff7a5fb2aad77f44c818455b82a981cfeb7ea0d6279eea4e452b949e5acc26cf424cb25333cbdd851d8f0c52a351a62806ad7f95a578ddf817901a48939d7ceb0475975711aad291f3d356ad86b86f17af377863428d38f8ff35097c017bad97b832f61ee36b2d1abee685a7c7ea0451dca60c5e349f925b831ed960d40b26c10642d23d112621e51ef786cc921632061af9b8410b9a3821b1292c98be1ce5ef78d35b904bb7d6710a1ac58cb8c664fa3e830f93e6b4965cc072a9bc20cb756ddb2d8ed942abed06c6da8dd164cc47af47bdf73e84356ab5a05d1fc0247a123807d0177b0d40f62f02de82968691906a8c516e0e5b5790fb0ce069e6e40c8746ac943a0f0b022ddf03c097b688a440950e06995eb84ed463162cfe0a6c564f26109c3553bb249b9dacb73a64b1f19345f1a46f0d70638411ab58c13c2320fb62c0ea531b47e0d59c1e78c6357b395467b561a3c50e84f291c015ebe8daabf9e680268cbc61734ca97d13eae0372bc964607fc9c9177a0e1fdec32b08fafaa0c0cdaa9603630470ed1ec8d0a85413e27ce42f0796ec77597b9c64b9847f0ed44aa5607e88b3e321afdc038a247c9d7485b8ac5aeba0b470a3d3ae47874be82181f41c8948697398f406c62781874c527557ecac5e755c95365891ac4474e684b1f0164cb0ce9de116a186a179fe39b8c0ee456dc90be00538bf2c56d1cca0b7bd08c541152a371b1601326e1f7127ce6cc33e5ecbfc84e8531ec6195dff8cc62ff7f6891ba0f221ea4140a3415b86f9d54d388afc214c954d88d4e9811f8884bd1060c3a8f5320ddeb5aa11ca5e88f26983a30e71aa50ba32e40eec040b2d0661a364664eba0b835d017187cf14ab48814dc96d141ce49aadbb4f656d60275da3279f7bd7b41918b37ee5b77199a22c499cc1e722b56647cf2e09dd36e6745a2a7aa2bfb7a37ce97fa4a0dbd60979f95da2a715d3a215e5a78b7b9be7c5a4029cc1e65cdfcf8b791198f2f99255838c6c6d3a3ad5e978c9b88e07bb044fbd52e01e3a79c60abd8c63ddc3474c3e8ee150d9769f3f8538c8086a504fd5ac0f2da91cf7cbbc0639b8563d66d54a3eb69486db90f08eb057a245e1444124da0f23ed99625c9e661c0dfbc914603dfb2b985a3e36730592a9487fe306de561b2261c28ad37dfe7b13c33985766af1729fcfe582bfdb4b444c25b4d5a6c145efbffa402285ab748d1f77844a27312b6e72b017f5582b4345dd52970ae78f610c30d0fe0735fb63323ee27c0cd74773103c4203ea5868fe3b9cd215f41ee74c00ff0002da88be5e0770c3908617eb4679b5c455b66ea1b03f65b7830a7878bac927f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
