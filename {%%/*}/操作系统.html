<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ab3f9fbfed60e6dc4c2dc72477a42d5ec8174462177625581dfe52f672f525d220411df2d262f6207e650662f2f31ccbf8f497d6596c23ec2103a779733fac21202c39a43d3c98652b0669226bef9e1d48de160055cde76ba051cd14e68ba1aabd4c2eefe01ac4a4767c9326aa76d440d2c0ab4478b78ed4cfdc94d770c2df4940699e2127c9484944b1f2ceb73f0345d0859a3387a788077e5700d4d0957424d4996d702c69df4bd5b78575829045bf25a487f3d0602f28e173465e53f0123d7dca7924bfca05435e2a2dd10c1e0e5d6d82b893562a7d2bc862bb0d367af0d748f363343a9795b56ac1ab69fbac69105543fdca77556540b7ec98fd4ac5dd30f73e2f7a39b387cdb1e84fc5fd9dcc70b01e46a59551638ee605b4e0aa5e7cae18be760387cdd22040a29b4184919c61aec9c421779ff5beea64b540be5b1206da9c60ac4326614aba68461195a0d3933c87a97b6188a83bb9b05a592a776a85bba1520555ead3abefcae73d2b750837a5836527be75fe82914538c3bb309c5afc6d22f323a85aef30fef8e4acd22942155f535eb01d885133642e5243df938fc028bb118e88c94185e36abed09efe623cc87e22822a12a63a51141562a0c6a1820401507d4bb9ecd74dc96f0a4e51aee0291fc3dfb1cebfab89b1e780edffe3fee0331353b62a44eca47f253c784be2d5bd86825af88e71b0b29d9d938c85fa4990505888293fa8f92fceae83db9d3b44afe66722c650ec8b1cc570de50e4fc7be6121bc4849188249357632d95c183ab46a4aee417c929472dcb571407cf911a9e2a809ba237b128ba72019f9252e51e1f33172c3da73a5f50bc25fea93742f17f1d6b4708461dda91888b71c1ea4963c7cdf6a4b034a7430baacb798edacece46a0b29bd7d1b5af91ba63650afbaa8a40b5a18c1856caab65e813421631ad4ef2b47b80cf2cb2651e6a067deccf30739198b2ecc8347189a7d72eb4ddec8feeab8a5a5477fb7be08d6fb62d1b0e0261f55f7b41ba8e23bf69a191dc2fabfc3d07df82bcc3f9d5edd32c852cc67cd384f754cd8d9df86b7c10810f3e129d0c2e3a08ee363fbbfa4af47a324af73957ac36d3de039fe7f6c2ae81ab66f37a1f00bc89f40734504e41acd43acfdbcb17df07f24842853e5d20ec3ab59c039f2e79091be5482b25608fd0fd1efeef91bcd6f52b5514b32f3feb682fc426e2b1da832ad4b48ceb4e67cb8e1ade20ca32f7684195db8ac468773568c539f5745c414c8e6fce3889005d3f9578cccd6d90d7fde6ac9485c3ce010ea3fcbd0266872777f9d6b4fdec47b0b0ce17d785efa09ed5854e9943a199c55cc690ac87878effbb550412be261fc70dedb2b5428c356c66d0814be20f45c642f2c14724e7164b6b0364371099d39d2930481e969c22d713d4c8efba27234daa96f6a607de23d58b9adf1134472acc60e52f69f67c7abfc8fe83b070a009d01acc3738ce2845bcd098f340f1f81af6d8dfdd22cd40bf26b90b9311d860a006b6092bc5625ff886c8e0b71a21b00fb01b4cab4c0cc85c79c17094f1733e4eed349bd69ed5a38c00ec89bf07b890de399fbce8de75f4ccbf42f327f457a53f0339fa42e37bdb6ba8c1044f94fd4882e3435bac6bc14739bade4776b9cbf2bc6e59b7ffaafe17fcd5ce778026927a523e038f7155574d7f2e1b8c17c4bfdc91d7beae6ede99226c24dac2339cc4c0155d18d99d41f129ea6aa6fc0559dc4052e0ab9fa9a98e35a6056e95e841afb949ce33d26959058101b9a6e0dfa639859a3b5a6ad0f39df54a05ebfe81e74524b9a38d35345afee8950e720565d666d1dbd49c962766891ed4b71b01316139fa8eaf32f3fdf6a1f6da909f0f9a7ea8ccf7dfc94423f9cdc46fa261d81c9efe067d468b071fdf8530f45499eea626405eff5a15d29d165135aee968edb31957edb298d1ab3fe9dccb9ee412542ebea7e0ec62ba8600a5d389bc2d775030851970b7c5c0d463396bead0dc2ffcbd3e3396981afe46ce568894acb371b5779ff6469d9a2f21e9638158b6523a3a6cff0e908c47fe1e067682d3d8d233778617b96e10a58aa616ca1f2fd633dc5bfea1910e46b39ef8410f4b971f984ae9f96c805c5b8373f2c89c4c21c6c1a106304d8f3d9b4286f44a6208f90efe75a226d7a232e20b3758de92e7f9902e7514fd6a6fd726cc6a6d448ba89ff1f93ee4bc448f819364efa822104d8773eb0514e6a569a5575376108587d348fe449532943b90f4ea76927293beae0ef6f04ea5677ac99226cad7fb5c9813c335ae5404415c5f293e47d649c69de4ae0c7dbd5bd3e98cb2b985d5178c89b6e48678d598c1a670dae98d3bb40dd7a1c8842d341f3f99e4e8e11e128cfe728cc9b804d877ea1a46e4b95cddf7ac06293cf89f59caa89b2a5e2b37fc990ca7a05cc80231343086c0d7fd3126bd948d25d8cbef9e3bfae2a53943af8e1d8a64826d7792ef40361c1540574c13955797165df37936814a624baf6a3abd525f10bb97a0489a448bce435ce9c3a5b904efe983b11ed7995cef8b367bb24098f51e2c83a572620130f1b561d8a0910b1a79d3e76eb6d9cb5b9075533b080bec90fcfe4fc60b3e69ca99cdf1864a6669e5e9b9ab82d5eac7d79c8400ae5649b3da9eddd6139eafe3146508e40c41cf53552d9bda1f3d010acc8e36352e204824c313b8682fae798490fd45cf5bef1d5388d25cd8fcc5d8bec125d1f00e1a12f472fc099df159cc318a4d86c85fbc81b7a0a893d831fc3f811266fc739a069eb97e613094495ed5e5385421e6368619d5732bcadb9dbcfb543a52b960676e99836e425b9cf8143f29c50c36aa3e89f92d98db934d5ab838221c25a51c88bf1cecc4acb985420a0228f51673f2ca0eb385b00584bf96e6dea56d360729f37075e6617147649cbe1baa1111642ea254bde304394d2cc5e91a80549e30b65389b9a772e9e5ed5bde51ad9ec809c3304aaba56297d9183921b1b6848b31d1a6f01eb599382710671b4161f162ab7567edfc3dac06b16d2fc0535df7bcf96ca4b39911b667f2797ddb4e01383ffdd77bf035ba133064fe8c21c5a64ee0f0fb1b8464e78b7a5ee0d72dc744a81449f61fed755d037f2a6170764b0dd89f64be6b08812fb2adc821822e61070aac073c640ff1c6a6a0e119e6d655ef9a265305fce179c51f056ec7813808b6f73fbab961934e8c62fde44259f3aae0844f5906acdd9af86efbd41aeb1235f13c264935e63f57dd9516e4c13181026383eb88d8c7fcd2e8b4b3f238afcbafe4a366629992140096940b63be2830ae146038b1e39fb52100a7d5637eadd1a13f7f91dd03e4f3632a6dbce4613e9c6cee8872eabf6c2e54e84dd011e697481a552e03119e2991183c6814db33614225f8b73447c2b84317f1711efe561d1ad27d6b406deed7c6ae27b186457a0f9b67dfab151a8abd834a369173785bba343c211560f24c201e9bb70194b303b9d3c75247da01d8c72a0ca281173661bed4649448cba954574f157a4663fef420e4ee5c21a8cccfcde3c216cc26b1ef86fb761a7276d713e8cad47557c549646abcccac1751ff9fc36df0dd946dd892c6df7f0af84c015073bf56fd708e288a0bf06d31975f464ea33fd19033fd7297362619d84e8493a2c787ab5c52c4f628dac778ad2396ef022c6f3ce7dd35a7d60460566a623bfad05cbf8edcadf9b21163f529e7ff8a109f8d7afbd221cf945917bce667d0eaef9116e0f9859904737df2c4bcf2fee5dfa79cd6700f5bf4f14ebc29aa5cd1c006d2c79896bfa0781cf57dd6b8180c18201f515493f3eda89cadb59c8f430a46fd473c0b753699665bcffc3f5e0611e4aacd563243d6ef57373cb3182b40ee2120e1f7ece9311368c98f7ba9aa00f6f1a7c47edf6fc14250348d3876bdda4b0e85947b411ac5c06e612c721858c0312d24f5370ab71445cb7e52a550872950d86399fbc05f4f2911b03d207fca667dae3a53f7f107d7ff869bf6bd71a52ef11ac28fe6699ea263ac2269a08e68851829d502d43f979fca8c32ec4b2977ef32b12e3217e95b12f1ddff385a4599946f64b9b382830b921459daec540bcefeaf0d2cddbd82aab1c1dd29560fd3ce4de47f74a574dac138182c584d11e7f3a6c294ca4fa907b291876c7144c25de680193fec59076b15f4abf94442031ebdc804e62f005be442a1ee554eeb308093ce3414df01a9044b687a0cc3fac71094f626ff9d7fbf654575c75e20f7b667d515791e44540d83ec1fe334ccddf3674a848bf766fb797ab238bd2d8c2d3ca76b0e0f49dceab2ff1d341601ec5004aa3c3a6765fa8a4f4d6c76b170f7ef6be960b94ae1cd3e90151e7e7b89b28d2f5f6100546f38e293ba824383221e973b4b98a04655de65d1967fbe1bfa6f23c311b172c445eb354bd1a170dcc4112addcacaf8bd1f83e02969be05e94207bfcc9524dee668da6e14d77540982f0c5bd25a2cfcc1378d0285ee957d838ffe7c85d9152e146cbf08d7a67c556c43ee4df8f164d06d7cca23f01f0916a2e9e2d006cf598d92baeb191287e8c1c469bf478749b9026d2a531eb88e07d1b7ef92e8134d6b6d637365ea2c8b6291d338835b0d0495a4976fb91f36db25d24036f518f234b5945b4eb16d3a2d6868b8ffb567ca92fd93b2046f6d383cd5007cf2df5df396623c4f548127bbb64ebacc73c7c1f1d3142ac0d674a64fbb6ec9b491105810ffa863cb8d831ee4e2aee1799e968ef18105de5133634bb4f7214f7853aa736374dc186d27371da2b706921bbf742b32d3d2152cce2f76e189840236239977a76d2ef1b786d58cbbf886d3088ba2176fae12c0aba9a19901541af1b730207e41e0f99cd42738b3b8fd3f9f724f3e86c49d7a4e38849a1f7d0943572332c5f9be5ba88acda82039af28c8df678c2ece7e0e69e4ec88fdb6538c766b1d05ff242cf8dd153f46887216020f1536c21cd0c7b88b5f51c6406f19e3c85477f8974ad60e2d8e193233bb61072443da6d347e7b3ab0587e6c37de5ffffa4c8173dda9856ae6d410d8e851f56a9be8f459bbfe47cae87ff2819b245999803e523549b5649b7d4368be21db41088ccb2882f87d13622488a65bfb04b3b008cdc851895e73800e5a44f3cfd73f24c3136f1ecb12f1436dc53bb0845940857cf9521653c1628085a27418052f896c783fef0bac76e0d1fa7832c6d60aa2b34670c2abfbc546aa95a3f0365f68d16197e99426c4f17f7b0671f4ad47864eeb8f415dd8a94febd94e2027133aba07e55ee234a0f3c8fdfa1113d76dd230f373d2d6247a391cc8555b8de36483ce19ad654b3fb0d03eff6c090b5c34e8648b2343b85bbc98ee0165bfcdd9620a3726b65ec26109bc591a9eaa0b36b5b933663ca8d5f22cfed17ebfac37027e180953a62a8ec05017b13a6d44179a5e121b30f0bca2cded1717b3d86c691350f58b3fa17c0d5094743bb016b91ea63e7f278dab45bac0182c0d2293b7ef5b05b18658be17ede1b297e59aab7060a82023edb279a21de906cfe13c0de3ec865a5adad468c0c7f905e9a87dccc4f2763534639e0086b30495da5895f3637e93e67ffb1c66e495f5e65ee1e067335b749159b50c1be011117b8b3d270fb1303d85ec5034e65e044b934d1fa8493014549121269a5944e4877a9568caceb597a513f189353afc8f9cae2d65d1a839ac0d5930558b9efdb2515e86b8b865abf34b9276480c0d63b662be3a0d4c1045a90786009600b21d3766edfdda1876962ac48af6a71eca88c799497cafdd5e8f6d7b0a00bdfcab52c7539f6079116cfd6a218d57bba6bfee06057f4b3a3f26da079f8eaaa3f6825cf3b5ccf40346fa78b65dcff71855c5d6b8ff92d2453b1eec6b3ce9721d5f4420383ef3a84fc4662598229f37a9689474f4587e7537c97e77aaa67d4da06f26140d731f6542290d651f3384d55c30c3f9fe97f44f80b0bbd2a145fc4c9fe09094b641c0a53a71558a83a4d407b13e6a1750f8d909507ed902fc9045e464caf513ab5fd8645f13945e37e4dbd17c69483bdce810cce40b7221058a79dd80b378e3d1fdcdb7eb6de5bdc33f2fe79b50ea2dec402a8bf24f8295f699836cc68c577058fc41164b1b1cee181864e490b798fbf9f0a0943f3471284928c186e808e18c12debe60d296674dfc5fd87676f27454ff2df0603d0f0edca44d864377ae1b818f3bb6b59b5eb394830df4921aa715d2efce868a9f9edf82d4f96f61d86450be5ba9ee8a44703933cba365ac861e18bc1eba26c27e4dab50a6cd1a8bd674bcf4847000f00fcb647e154d6ba6d44ab7677c92cf67653c05a4a355ee7ebfd02f9d56064dd507b632df65a3746be37d9d7c94e45a784e6840d461128662f28235edd487f24ce3f9db548dc3e5a10396594d682e37dbb6102a5f5920d4e23a5e708735d2a38e94faac1d36921113a314571a70eb264b95b6e04743efb926db205e9ee6af8bb54ffec94068aec8f45fe45816729328c0619cc360ff295f808529aaecc4eb828f5e89909877ea19b121a95a2cd58366ace20b293a00356d0a74f84f87d272ba548f4f3cf65a30464abe2119a721ca4254cd46b0b0f56cc9cad614b2c046f6b314c90857046353e1f3599f3b3040de50e91758f808d214088c8c8424d817ca6085050e2c05aeea4601ca753c8762432180022bfa958ff44e15bdd55cfd99a1a8fc8e96cf629e1a9daa82f5309b71acc8b0e28142b9c73680a68b4604108b248c0e29d5dfad9d24e37d9ab764ba03d1d0c54b6c4d5251f9f2c674d8500b1a6de1458c9d38f9cb6ef1e19c509e241568493c0c4b990fba58b822fc410e1f1ce5e1e15f453f23d23878d635f223177d7b85b51463ad057073d6bf253d3840e84dcf8c1e59943b97da6ad462c1f3d163930b34dea533f524687645e29789410bb71a54a9383ca5c6f1858046aee0a88fda8a4b8a9310278c79d3512d29e190be0369c5080d86e7c6917a5972efa97577239e96cdb8891479d334d17c09af557dc98af43c9d7a00c187f3549d856e02d3f776b1fc42a6575a5da2fb39edce362390c3a91fed82ead2451d502eddd1316aa5852bbc7fa8c98e984ce404ddf24e5a3a1a07a775a6143004b67120be9e25bcd4a2fe81957cc56fa1523794a8e0557e44fe9cae794a5088fea4b23f19ca0e0f472e55bae5950eb2dd5087745dd7cad27166dfcdf50b9851ef285a72cea45a72fd431dfbcc3c43049760cc151531cac0900bc06a05fcf3bf1a733e5b9cc25a83dfc4212e0c3c1bb21533ac7a3149b1b6841e4acd4c25c293b5f94d987cf8f3345fe6faea309b8a6b99c46a42957166eb82619469b0757c80cb9f6fc308c995b3cb211b01613defed8b1799f693c5f836e4db443e2d3d413a3e42dfa82daa5b98585b83dcfc9ddb6d43bb8892f0ab86831bf748b48751ae620265f439414fc1010cf8601123884cccee3682aa7e58f7c6b32a430eb97bb7929b16a5e2cb51afad44ed4baa67f61fbf5cac29838c60a38068c7ba66e5baa02c50a58b908b27617424a022d4e9020a14fd5d39bde75fe1bd66833a5e23edd637c142d96ad478e7d7df4518e2d5d78b5c3b33ea5801c4dd974d6e42c18a28283eee7a5af9ad3da658685e013e338528de88f7a498f3ad7a6c8204d72d73fa06d5e30cefa1082cf84466f355302d5e9f091de9f72aa5847d613b47f1f8d54a417dbc28d70adb8792dfbecd8cd7230392998fca2e2bca788c19b29259b470eed4a5b2fd9cf18e333e17db53690bec7c9372e79bcf2c714c1058d4d51d242830eb9d7eb1d80c38621b08c4ddecffe8ad4a3d3cac030a0b44d735f5c3462c15130eff648daa97d57e93f8db0a4907ed4357514a19b798b053e9bb4bbdbbc7e3bf8c53dc7442cb563ea378d3fca0d06fa70bc3d36424099d172ae3edf9fe5f35d88856c091892bdac8bd4663f8cc22f1917b3675b66382789a9eda8df758680c2002284f6be521b43048e7179f3d08184e8802b3189839c04a52e5208f14bfe363bb7091de3393d858979047f7aefe33875c0b36584df641bb5b21350643486fb18fad28a446ac6fa730d5ded315efb5c5873a7374683062fd9ec1c3d8a4e14da5285676dacb96ed8b93e8ee537995637b41eccabb645eeb42f93b973502e0c58a6e262c98302e6a03b6ac5a8ee2d21071bfeea5d88b7c55e5ac108e65f2cc1b531e5028ee61925ac2465a31c99e22982fffbe0163b599e076abfcd80cc0ff80e0265ca71e9c6216250f54506b3081242afc6f9400ce2af6e5657e5afe5331f6e69b586eac1b5f7af45f1bab31d4caf377f49017fdff5a78e4563bc2fdae74d937f34a78bb93f893f4900e8c8529c075c57bb9d06cfe40098b90c350130919df02b464e53fc5ad78e937adf74270ed36ce9ea7761943b32de9ccb32c4c9af82b17053b56ff3978b9f3be30d302908d8665c54d94af2069799bf838585af9ba4732ae9e3bf9abc615e4380e145ab6c53c1f8094b248d55077cdd4e8cfa6f4fc03e5fda57bc76d34353f28ae7e268b55c4e91153b6257e00dd531dfb982919bfde8011bb60e57e4afcfc5a333af6d58ec678bec94a7a1ee717c2fb698bfef28f21f37aae768bcd16733ec40627598c4f44778f1b4d00573e7976171d9a48d1bc7a1aa021376e57913ab7b48d6d9ef80275c3b7b5553609d0bc3e217b14ac5d5ba78fa46476542b7e1ef44a179f84972bf0bd670fda453533e67f98f3742e5b9175f1721a73f0b7a325c9cd1071a237186be0169c875dd487de4317e7453dc49425ada72e7eafc564bdc2d86b8f62e7582b1ef6e2aeb205842e84c5179c0f209ec7819832c875025b0d68cf76d686f429b425b07f529c0eb7216219b7f74c4be887ecc79a5eaf1147e2dd1087d1b37fa31b50fb86a767ac9bccbe8f3780cc7bbe61ba0bfb902aa8ad3ab075b783df81c2cf6deebc66d54ba532d6cd2c340c3811ce7c8ad4f6c782f49e61ec57216ef107a2029e0e26d8f69a09194f94a72e80015c245ad9a3fa37b6e5506c5a1ccdfebc7306af116e33717e8595db149891f3722b33df8a05811332812d1f92ef4d439739b54730c34f99eca4061fb73c1e79053153541728d4168675612b6d18b24ce005c33abe0a455883b7c43bf6f0063e763e433913341f0948da61800d6e5f0b8a8b299ef9a74ca5b60d133ab4b4f685d60ba641d8efe282d22264295194557a2c73531b149c9c3cc9fd171c7e8fb73f074d8c1aa367566c2b61c2eaa632d238afbd9d0d208d6d030e354f68b64fe6ac27b1b17e662a65d7a266eebc30a2221d66ebb17c19c48135d09fe0f3ec9d632f52887f464f09c713c3c3a1a22c89d74e36d71bd3144208f395d89b391a58907036f8958a6f3cde21557d4bc8cc18e2a6842cd0a6c5f72e50e527716aa705f147a737f0137264a79d2ee35a2051b97b423d5a525b82a3acdc22268cb134381ae457450efea581611508d513787f649a9e35875477a45255f1297a8c96fb36d6e777229c6435770d92cfc8a4026a65c631c2fda90a8d7cead16e0f5a89a524dd8bf89618406a821ab286f45ba415294705c6aede77aee299329c5bee4a80c81e435cd7f3eec968f4cdbef0d156574f0eacfe8d311612218fa3bb9dedb4cd335f31dd9b972d0d2ae15b2e27cd6246c52e2fb656e83490ab9de899ba0c571707c4fed0617247c683545a263b8288c2c72ded87984678fbc70212f1c5e8ad0226e677de615b8a715f11a389c9125c3db480890ecd94a7fb5ed94febd0e67de48b2fb37183812a91e56d956ba224a92dcbe4510c09c5466e34268cfd8490660b9f24993fdd9fd11f5e69282d52bc9a0b25f1cce9f28f85b7cacb7b7812315ee15d427b90c8d0fd7a6f7461933cf096c12050fb26d21972578e55263d27fd64fee50270dfa75a879263c4a14fdb9c37b8a6fa674eb6801443964abe2c7a36bb4a3e6ce6ce24bc9f797bc3805a68fcf77b8980097d80cf56144542c25336278bf9f20414e1ad4a7babf3cd09830a41674fd0f871ab3003d79deed40f084fd6647fcc0f5ddf17f066766d12b155112aee9d0c6739773e2c7a332c776ffb1bd84f0052b9627389f65bf7da99730a7ec1a75b38692840ee6784d50b10d5a230e6307199126e9d59a7a88fdd63f23b4703b1896d21ce6321a839cf32753ec4f8d7fe966e943d6298f9861c033fbd2ae8d5a8d0c04ce896992ac6eaa73c18cf37a22e86c3ad8f3c67bda64aa93a3c102de21d61209126c95537a187dd35482f9bd21db1a7a3df2b008ecbd4928035b9c91c9acb01d761ac22f54941bb5c675c1174bd1c870e7acc9641ce8c1d2299f26b89b351aba5f397e5707c049d6eea2ef5db9d3138aca308ad9064d4c879bc7e6077d0b622afe253b87fed757bf3765f9426cee6354cdf7042cf4d2bd7f69a4b0765b06146b6aef881857215245cf85cbdfb74de0512424365b677bff23f6476884aa75d8c3705b439b535a5928820262373819d1bbce3e79aa27769505b2dbe2b2e0af045dbc7e22e1298ec77a503cf02b033bfc2c8dcc22ea84ec7324151c675b7008857e944982930fb520e086615c51a351b55d815049b3b644595c89c035dc3300276f8b3d323ecb886ffbcb4778ea0d221134abe0972dcac920ba0a2b05a400e4ca06b8894e3c52cfc9c207ef072b9b35b9569dfca0f999c7baba54fff970f4f124fc54a01ab6ebc2a1a0696b699d98845e2920357b9fa48e2155fd71443c5a41a51bb28e27fc8a07d1539dd6e5088d44612470054747694ca3b8545c7bad4c687a571217a3bf1a3d02b5c9eb85936190ee37ab24638f2a6ce6c14a76c6292390be2e84b57f52a5b14893676a03bef87580b6d2c82d2583c64c12601b035d8054b06ec7c0f919c84cf86f4424ad82d8c80bdb424a47cc5608fec41cb5bbb95cfbacc1a721ccc59430fecd94b3ce92957146252f8d8067e552af76e29fd0c9219bcbd0826e07ea99e0e9e3fdb20f1b7e1da6e3b20cde99e53353c2477640775e530e1983df76a21a35774d298f2f38e59c0ab1cbe2a131806f50a25946d66c007c31a4942b3327e4c194590402a3ebe07b9bf0e748ab77b686c5072379d8ee5265f4da21e7186913a2f58144d86a06365be4672ed64d155714c2c40757398ca993ba19a7d83749a37c762b5ad148a6762992dffafb1bd120d04caacd4d23498802f0b1b1e0ea7184b24474430e0a40a60922e0b0c2995d7b32eeb21a9f564224c1b200bce575f50f95e4a63c06a9b2133cd924427ea4aefe96cfb4353b1998178aaafc6a29954dd061b35380081a98da4e2701376f20a09a7241750a93188ca79187b3f0e2c9a1a7a3bfc25933085517ada310a05159a6cc9071116f82e363b0549de313a7316d324fe3d8ad351b934d5d1104021cf39443bcb7aedb701680e2b89ff980806dfb4749b85e2fa548ecf5f964e4413127a9db31f3be314deef042e799b0287bd504f9040e96bb1b31c603475a39b9ac6cffef5940b610d16c2fff467d9ae23594f6827e2ccad5d71fac7f81c96377c4b0932b1f931dbd8a9c3261c8fccf05153c53495136d4758b6541e28391f9dcf56cb8b0ab1f0715313db91a3e7722823ed1488b99b68ec7e2f762df6c21e7679fb394caa1247b0d499f724ef520e7922978f046192b3ec15bf92d51e3d01a1644682d36b276ad16f56424136fa28d5b4cf56bd8f9835a73915400752e9298c507504023aa575ab512e767d0a7bebee84ca1ba3e342a8f07e6627e46760987b3361eb24f34200a304941e3fa5d9470056401661b2287590d44ab3472d6e2257d74de69128c8bfcae05f2e976f06a523aec5120badb5ce937c79f83572ec77db41730d4219fc2df73c72b04960bdb741e3029155e5341d6a77bee84d48055a5f9cd9ebc95c41d69a5a14ef62346326a458112fbd0f2148a631e2a1c2c4de70772687ef62dae65add1870c5b931635f4b7ddb0e6c5d9f3dd06a0df25a8f92de6a5517ccc9d5dd85b7d91a5039cd2e0b56349229f08ced11951a5d569a88618d51c8c893d52b488b07df6e41a6c13f1b35cbb928e0211bd36d89798a4aeea79c727cab5e47fe2901ea40dffb9dab44a74ea591a1554ecc9aed54b87100de85395728714eb97f966beae87f27e5789a03da7eaaf119704d7bfe85550e261c38f471e584536cb6c22f84dc33de2911dc9fbc623da33874858a528ff0f4b3bd4980143695906efa4a4bb9283063a7f7881c8975cbe68ef7fcd1ab7f1e583e2a049ba80519e8e4134d772143d68f3166976de4cf722f9db7f7b19882ff1f019316fc91d94382f696ed5c9e4cad7f0de8c1fef4e316c76c3a6d905511fb0f6a2057b69e6bdddca3fb3f9d27a6a24c27f3071647d0464eeaf9e6fce5caf56b528fa4d7b5916962d10c955cf3e579c1ddf47a3177e3d6c338a9b3d92bf3807e18c8b74272ff1cc55ef926d5ed75900fead769c98e004bc09e6227827e66599f7fbff23524bc069c9105987fc394b863cfa6fbb8d28a2e24c1c87d1866cead96170da6bef51ceb197cde6bd3e1af64012411370609af42555d58aaebf871682878de767c18dce5d1915da936ff34709dc63fc8a5dea72158c6cbbaeb1ecea07856414bb6464c2d317fdc2282fcd1e1f91d741ef64e4a8d214e291a9edb8fad9c959290aa29389f2d77365803f57108df0ae69878b676652fc13746c88b97aa853c69955ce44a697e14aac7e4d19051401d7d7bb52725721586489d224cea9f89cdfcec7ee2ae1aa07e5b73742521c8eb1d2fbe5cc59e7995324a96926a941f8a750457b9e8a90b2754d69b124090c41f49190b5d80af0916a19cae0057f5a46f63a561a129ac25c51065718ad38ccb64bb3624e4ceb63bdf292a340fe78fa0af7d8c7bff4eda385a37fc6339d83db1b3cc8e2d390cce0d70841efda595800c51fa99f774aaa22afa67022507645796ff64031296f472c77d8de4987e711c7e7aca160c31b8d3d10842cd5b59b07402abd0ef3b7d0dc850bb6a2052fb109859cb46ff83c9be95cc8e0cc352c12f64ad9358e53e6a516795955ea11b8e48e09bd69b7b3900c7d5e42992ec818d45a863a7c19762f3bcfa749f17cf369b1eaeb93d342458f8666fb879ea7851920023e7f175bad22308e243641090b7858aa73d97e4665b809225dc52058b0357f7a445a03517f44f9a8676e2063581df7421c472ae9421753d6e63c204839cfcc13bf4bd5cfb9b97c247a37b1099cdc1d9df5fb163ba710c4740126df39f52d1bde2c41cd868bc69af89ac787ff83dcef206db2722a368dba82de56edbb7de29d15af42de7d1f04db3f52861fa66a9a30480beb6c9588f9f21a15e69cb444e7e4d67feb2e4a53a7b029a450f95891e8d7a5776a7fa852c6d58487c1643296745374f948b8b6aaaeabf0efd4bfdb0f118b16ed5a4b5383073d926c3fb69a46a64641d6a8d802556b8da0aa946c75125d761b18e4c8b69f2e634d648a685375754814643eb26034dc8b8ba2f7a5e1141d85ed4ce788eae2510644602f1927d62dc0f82024e5d91ea85adfc682a3eeef557f7a0fbb5fec9e6002b03c8d023a255a4223a0b5801fa2827431d53977feea5d7e6b67a7f86eda0a7d7ba4fbfa86b55d1a14e019bc9c96975a936fb21bf76085cf6eb9395596624855e40d1455079235d8d6db07532f24b224094157e36187171e4f08b00a83bf6cf743b599f9f1a8775ccd332efb2daa13dffc86b8f8c7d7de3445233bc0a136c57f3b71cae49e39770e13eb388cadbceaf135b4bd1f8ad87b877a57b97a3adb28d1ea719764fd3a552db904a4c9bdcd29040c5250826c20b8625627437b55648dda8835eb9cc6df01e7fab39b2be6d1ade3ed2896810f48ffc8f9634419cfe87bdaf2f919aec87923191be206a07ee7363bbe19bc4dbe235376ecbfef0142cd1d8ca00497195d4c3adc681879e80eb92aa1b408ff545c4dc0b997c959b2845a88946a4c6f8ede285361e3dbfa52bd7ac42b4bea88ae6c3ec4dce3ea335aa3c939f568dcc62993afb7c2ba73f6376d9f8cca2ec03177aaf5900a7a4297e8295fcc8d6e70d1305ddc27f393281d7d3265f0b7964065600b9e41a80ef0771cb7c7d5a5818d37917e4c0891570a7ea8735adf8e683c0fdb40b4d6436690734123e9851ffe806894c30c64255b9fecee3b18f2276aeb43375cc93b0e0d2971d2653bf914b87145b92096a8e4d8da7e183fb6a3836df738423ecae0febb464ff47947f804b7b6530f03fd74c54fa0d139eac7603a57bb5e91ed777e99b72cbb20dfc441c41ba5b80e7a8b5290a7f729a4134030e793556b46f538a6a8b7f91ebf838fdc0442dfde0e37dcf9cb8299286f393019b24b9b05b1300d07270b3513d6eae8ff772580d5d4bb381a1506368378ecc24b2cd766dcd2f800b86a0514ea479e67d7ad9addb34823e6b413b802f4e1b149851008d80d81f4bceb054f217ea3f125e546e79c720f38ba83ec7337c77ac279e163a0c5fc8e9c588875ae36f7a6556cd0fb96d7daf1f7680bc0b8b6ea019374f588d0b5334af9a3cd9ed6028572ab7f54e2cdd2dcf0c05b607704e7766c1e309c57a49cd49ceeaacb66e75358748d66b5aa5e0774ecad4b9b07f5cb2175facfa9ed18fd54524e1f4295ce4e7b0fdcec2167b83901df88172e81989b381877935cbb925485c97848316b24b4824a6ae5a8f62a5081c90e60f9ccfe4880f5b4e7bf4e0565b7fa76bc031d8bec28bf1aa21b29026cbc6ddc4710136b6c84f77249fb09efc659760d3cf75ec526d6e2d7c0da40bde5bf2d29b6f91f4adc422f4100b89b4084b4d6373fd5bf2698e9884b75574aaa830af1ab227d19b7ed88dc6a3accc7c8575518b3e927b99f732bd69890a89f83375e75c4399dbd1ea95a64e517542c77e0310d9c25b4a59f11fb5f11f16c826b678042bbaba8c07cd07295d80266838d28e7ba54b662bfa09a822c386b6d2e26bbb57328c5e7b8b6caaf20e88dfa24a793d2857e6ace81f73c77a31f8dc959202f7a4c7888101cb381290216a21a0c5ff11e520e9a8106ea800478e57519ffc9104c1b701e39b1a5e2448ca236a8314efb32ac1630ed61665399d164f4db03cf3b7e8786b3b1b0d4f82c3ed899c8ec0b3eee8a052449ef9005fbe7c7b21d3d8bede9588fb04028f215e0a8e56b77250cbaa540724870cf604a09714df96677ce9a8a120a70aef7b7540c85231f6a815daa7e933a97f4cb7d76cdfd78163b564cfaca187ff6d72ba2f9f7e345ab313912554a88d7bab119b74168bceae05b477d463df1478ba67ca4214ccbfa006ff3736baa0152d6d1075004e3068372a2e820db2878d90bd39573310478c612fe9241e663b3d9f6c239e641ebdfe298d95ebb8e3c81199c43997442915a61c791e9f0bd3bce02d38003230418bb3cc6fd819e0a1493e73056938e7508529b3b270681c083760f88f30e14ae0fcf392aa9f22a2b04e31e42572df3ad75b965209352667a4bc4bca7ce95a82d17a4d50ffe40590329a266be0260ed02deb7c0e9734e0b86e4db358d73ac3e4a50364753d70eebb9021c0178fc817b37407faf10ab00407ea7e78ac8f094e97860dfbb3a1d76e936c9f48234f823f97158fdc875b5e54efb625397e2465321ac01d0c82bc78892eb8250bc282aa16c566cdebe4aeae5bc676384de83e1b6e38bf0af2ba29284aec339813a9885381c4e9d4c7600c2590b80dbdf63b65ed5b0716d6fccf01a8db5ad0e8e36c00373c056ad928e44b9813562c8d3361478b2621641c20b3297ef162fc6f8e6f8a832dc9899f2e174790031347ee27afb95fa6b2fc12019f281e21c00254c75e38665d81a1fa0e5bebc20a1bf77131ade5ead854eeb283d4231898fd29ef7b87e5fec72e3e19ae08c9a1ece2f69ffad237640f88cc2508d0a4de370c5b49b974584dc321938b1c59faa3dfbf0a2e25cc480f2802ad60543b21eea2d90db63b464d43c2452c40ae6c3a04e747cdf34d425bec220c2e7e0385a15f681882355bc32bf48ec2e278035497578b2d1396913977a9a2519462f3f4b12800d167a188981fd3f2d1cdd00480cd52a3cdbc18c439921f3ab69a2833e11566953d09361221eaae9d35af156f4b2c43308d85d101384d9f1a9989074a0339d7cb170566da16467b6be75dab39b9109c24281c6f36235c1947485478b4d1ac401db6db5e4d340edff54e15cb6be57768cd4bfa9bbc60a0ec50081dabc9d181201c297d06d962cbb05ed44b637c95c26504c1945a29162643fff21a96476529ce62f87684ea9221d90ef231176b3d1f5c21b731f4b3eff9d2d942dee09e9d451b9f43eb492a9477b1d27bce97a46254078df91b88d7df460b931353e9773f3215a145b27c95e361f9501d14ff6d3665382fb8fb721b32ba6260fd670a52c0511db375f0d8816753d10aa1eac336d16429f5997525da1d272d53da5799fde87b46d8ab81539c17adde13a6f2e5480df442679e13efd06087eb999500ec8b06d08c00198deb974907f458a55c6a53699f2606ce892c56c62a10dcac9a5cdb1d26adfdabc22dea146babb532e6a9833f5422bcca1a70d0e1384e2413ca811d09447af6cfdd45829aeddacbec7767c37d86d6ee06ce5ff3a5f553a8a1f82603f6a9316b256fcde909e45536071853e1aacbee5be5198f0fc6c1e957d890be5f9d7d2ca2f4d679422b0cc0ca74ed61d5bd498c96a4bad70ae84a6a4c9b965d44449c7fc03f0aad7b8caa0d40940a76094f1cf5de372dd39b9587d602633cf2c4b46d7fed22394aacf6c55e92747202d8f8363f490e99cde3f4664f3a98770882dcfc2726da63f2f2567341fa701b96aa62e8bd15ea54d2564a3d7e93ffc76955724dabfd18fb048ee74f40225622d4a23ebafb48a5421958748ab2113514ec454d4e7ccee8776855eb8186a6254a57c5aab1de141d831b49d4fa23c9aa006dcebdedbefa44c5665b96713f675d7acf2935e5d5a04ebd8df85dab89da3932cec9b8357b0428ca102374ce631ccc7cb2416db3e2e8fbe43b76e3811d04cdc3b962e0a933cfc899202e554ebf37c128963b9c2327fa6e76c29e5c5fb7de2bca1b192878d9fbe929d9647bc10b4643c1d65246d3c06ed7c58dbeca521ef563d5253c7d996fba04ade0ae3615a04901fae1c0539faea95988549022eec9b2eddc103f081de377891535516a2c926bf07f1e20e07a9ef373d88f91631c4d9f8f79ba26f8084a22a871835439a5d6f28be741fde339c5e61fbf230e4771c2221285ddd1441281921e95cad17ac64a29d21d2955d28fc24f3e30d03742dd4903ff9377a7af421349c4cc16761f19a7da2807ed2728a7a7aea14e994a5b574cd39ddaa73f4128dc846955df7a66d32a19a138137fdbe04b995334a282be00e4f36b1a26d738ab37b31817a36fb4e8b5825c3bbdb9cafe3cb1cef76815186370439651ed0d636765598aee80005008a164d0fd4bf0f0b576c88e01332c3640dfc694acdf9fe095b64e34874c41d5d987b259cde1ddd26d6f75fa66432071b07158797635e6b902d8eb4c71379727aed4427cd9d7c57533f04ee27114298e83193eed3ce511d846c0a550d3384c6c3f46fec4cb7c514305535d9cb0bf320b7b6af13c860c4877756b5ae30a10232d3e5b632d45b288bf45a457446e7180f78de780dea920a0ef25710055706fc3adf3c53548fbfff65039656310e06161d9e18c6ccb38d3a02cc3bd4404e9ff4755dbd2a3372b89da8da99b3d5db411fdaec9623c6c0e5bd1feba4e6282f971acda64c14d8798c0a8d39dd33575abaa4c5d5d811317078a8008d64c73a3fae8e9ee0e574d2e1323376a9b01ff58dd4feb4cb0f6faece76fb4c4c3b68b03ab67119476ba4897803c9333a17995bb4ed605d6ac1a4c6048992fd3348bba2886b63c45d9c74aa5b87a788a474ef8712051147cb83b1c6546fe7b26e3706e1d3eae8f9e4c086a232d053429b1a190b51ac8328e6f8232e1bbf6e7be1104e1f0c16aee4a3d33cde6ce187522338ec92c0a8b1805d994c6212c7dd88a78ac044bd9c190d83853444534290a7a967263c87359311c76ca389b4915ead0d2ae5289effb1bf790d3d3c1125d4ade7fc2b899a9a0c2f3e7dc313602227685309bef00ea8a29ff101a77e261ad84743ab0b034a68d110d156534d89d24eff4530a95fca8a0f3bc0bf804f697c254f91d44882adecb892a397cfad0f018499378629cef301b275f16926fbec829ea4a395893137d776911d3b717182a9fbf66048b135c7c76743a9381cfb0dba0d13fa8ec0e93014bbf033960a14c84490158c8afb3867f2447289e0f2645aa888ed0bcbf0da44f9488f385f824f99ee1c32775aa020eb4215a2927af0a1eeb2273ccbac992cb59399c1e97e882fcd33bb97078145dd407d8fea8bb2d388cb644a9e028da4e630113f2f98c50b59537f2668883abe3f214fa86ed0553c7eaea5c64e26de737b4f2c62f568edd14fea436f09986f01791b8bf2a3072879c05989c3fb8c174a543b0c1fbbb9911be2cf85ed4bcfac7d06fb30f938ca67cdaf158912b185f15b8319dd4e9c80d19e77d13aa85d592e15ae5cafa1228fc93f54d31fd3d0b94849eee3d574132d1b4ae2811714c51890b4f5fd6bde4fc0bc471dceabf0a00f29f103f0a6c3c261b807779bfee4a26d5109a6ee1455522a673a8151da02791358ac0442dca0c2106c6fa4cb738ba0a327f183cb48df266ccb8b735d17beb67c802923c5f97a0117b07c066d058198744cf756e7349488a3c6a4246016d7998e18a008871440876c218db297ab2e5e4d4beae270ba6bbb117f721107ca26b48bd5769760a59a8257a9d9457fbe64c7a2d6dccaabf77ee4670f77aba18e9dd86f2711508a16d6d61ee49014d0c0560721b04991438fac951e478b66a181c2e84f62476d44e2f1b8a6805f61a9fd2050286a3d00cbf0225db65d907dc506c03e81a96dd630cca928745e0f99f557865dd27797880f37ffd005a1d09b9bdedee2e45ce427e97b262d3b21f8d0bb83e16275e453f8cd422a61263308cdd428bd78707ebd5690ca46124d33d286197025c1df1074e9071a1bf9036c5f095b0cbba502acf3fd0a35b353b0259e0e72ae6447f5ad11235ebe4548a26ec1d4f373ef8afd07bfdd31094f698c874bcb8cee67eeda7264565ca105844c4b73d1cd5ba8e7208ce0dbdc34bbadee6af565ecfdcff31b05a208157325c2f0be0e699c358dcfc178ffdbd51a0d549308009b6bdd2cb060483aa5a96dd5b870a509143295471f6c503f7124691cf117af8006c43bd47e47a21f368c0e0d1031f6d22b26962c83635267ee65ce28ab5df7af057aa9ab36336fe9303c26557dd3ee1bc23a975a17e3c66c75dd0bd5ef4556b38d4a250595117402f19096abcc1ff349bdb1bbce27f5064fe79e1dfe7705ab9ee9bbae7eb10852860dde1fed1015d5ecbdbf17c0e603a3c276c50729097c20ff8e5cb3c189cb9445e7b83ec7bc23c71ca500ec4af86af5b8533316de2e2266d294516e9c88fc33d4e6c3ac6d991b07c2bf545857fd69569022789f27767ac53e794ee7e4c1c656e0c07513af70000edd30677554954f9c0b73e79ded688bcd16dbe9fed473e57917255aa8666c40ce7469ee723ad4ed00ee28953699f0567baed05011d3e52a014cbd1ec752d9195b2e9219f3c4f5ab6eb619deca35371a6134241c9613f00bfb3a816d8c385bfd89a3b476b69b0ac8447411d05bc7fe8607726fc28e9ab757c45f6548ee96fcb86f97465f4b7b0b9fac74d7e6b53cad4ba616cb29b186bc71a2c75a7744be5cb3ec1f7bc05e050a77e313493ac55281ec1e963a8267b8396aeb8f0b70b575db2f19e76383961ec6e43ff271c07c719570a2be0d2174c8bb4ca267f0eeacabddbc432fff918a640f08ef0a29acb1859f8acd31015a566c40de53370c4d9e3202848175d5f67c03fe6ed9a6dd65efd51a6a90dcc7001836aa493fb0af9bc2b61bb26ef4b8d12fd606acd1942f653ea98ae2776b1810f9188e0326dff870fba0e4f0ec54deb2daa6f6d5f018cebb0b215ca7f14aaed95982a8117b89b33cc0d1e2cb62064ae9ffeb81186b44059cf409eae8e192d19ca72a98dfef01f9894090eeb58fa163e5e57e914b40effdf32a62badcde8f24f52a2858996a86829c0afcbbe1d415f5d17652153caa93b976ce1a86cfd3537bf7c1949790a6eac9b3ea9870d27ddc56d912d06c5452d8c45bb1d5a4d9b57ec207b000c887bfcc0ba3f1efd2723b0d18f70cca6b0d2f6555d2b0f4c4506999fe9b38873a348730f5415dbbaa28d1abf565123ee454121d3b26a09ce7020b922dc7b0b1aa656d1b13c7a0816","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
