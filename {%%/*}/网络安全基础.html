<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"809c13ecf2f3ddace1e65892f19c7799a81cab6c196b567d5c30a98b781a7163af570e89c074ef6b3f44faf8b9680c581bbdac8daf28e63fc0a3b3f167819ca4ebb80aa200496948295cdbae1502cdbf957f9f36083cf645e7b8d9ea14816c935c36c295bc004270e208494d97daed30789f67b3c68762f10f782f9c2f2228a24d23ab3cf8fc9f328cb9289508a87a21bc5d80385a215e3a4b5ab29e4a6486f7a077282244de5e6229f1e48d0455984d116b5b0026ef9853aedcb36e12de7da95045ad96b54d4f586b92c3d0c0c540c89d4848bf84b0cda553483738e8643f30b87ebdba9c961e2479f64d362edefc358254aa7349d65a50994e2add1be485ebdf34dc76fab3c125a77a5635dcb9358343460f2c4a2c4b75302830e715ef007d2cf2affb10976d3b54c84b96b6d26bf510a5d68c01fb1f25e5317d94331cf2be8054f891e055a5c90acbf755272cccc24c75f9c271983d84a93be44c86dfc044a7e41e15c4cb9f991fe016544753fcc8d03ac1cbc033ca897e2d424bdbce9aeb3a59877b4522ae32fc010ed9aef585c96a7236944cc6324ff7af3c97a0eec46de2222f312496d2ab96892086002c31ba6d8e6ee0ba74c8a21d090aceab5c7bc79cec9d3131bb6c06e18f07b6714fcbef570c18a0963b16ebc2aad949d03d90c423a14a0e569229611f2d88102bf479e8d09000c3b3dc63bb4e7b9bdf0b9b1148153f53ccaff79f17fcf7c63025f3dde7ef19ffe24e70ce57bd680a34635ae96c9b0f89d306704f989c6f33ed337b03439e0f5cfd1df8c2ea4130accedb5c1a5fa2667c1a588f149b4c5056e02798b9f718745929e69b3e70482b7de3e0adae3e07c1c19d56b03fc711da32a567443fad0212eee8aa7c4eea8bb2323defae801628ded08fd16d9b1fabee3a8abc49b712d3bfb1e11b55c3b50f17457238c97591eed323308436ba4cad40ad3da39fb70f2add1ad7b230769fb37c0b09c964a93a9c36dd6fea6cccf5bb41cfd8e50145e550934d26c456962f0f5e4f25f0b01c7ba92bf84fbf3c6481834e61d677d93f198fe5a7c74acbb3a23153c8daf25c9148d6c4e357c9f1228dcb32a2cf69e11f1819248241884584d54f5383a38582cc9e89958771608f1e0b0bfb7d41a343248fe9780d2d73853d2d9fb79aae29f816ae286ef17b7c2f4b6a390c923f60124927f3d405573b4705f831129e2d93577bfe9b095cfe97dee39cf95e67a783544ed61e551b0a231b86b1abf293f5bd9c6d6f5b02f75a60ba3968d38505c0fe9d3cc0cfa204dd9a8a832fb04b704bec11bc5b7f0999dc310ca9c202bcf3c4ff88593888b9c39f3a811442908f57a396c7972a8143079eea4a72f16f749c87d70c00c9293e59cbca3b5fbf64bdcb70b5df596ca460fffc5039ed8aef97ff8113a329ecd251c2aa8dba02f11abfce154e7fe72a1323bfe47df5e333739a30a8d80d79b0f3e26083a29d8f6a26966d619524470aa49d37a1d501521fc7aa2eea4b07fcdcc8a09ef3c5502b4f2281fb9d203a46ea93ba759d3f041c4ca22528b9de1f638f1dccc1a8ba25bc6fe49e0143463c8278b7f12aa2d7f1af35b1fb088d9c8ac9f3a3520194c87c58768bab117b4d3f5401646790b37fb9a7ebe950b7a9a71c28a834bf8e4349e1072de01bec5710451dffd1e254b2649819e71a636433cb12215751c991fd432ea16c1e01839014ae143d40c1918c6a594fa7a0e085bd740fc81c97509dcbcaea3d9044ac992e3b840360d39e00eb20ab5a88516d0bea654247c7801a6c7bb870fafea38c2a02d26b8a66fa699111e0ccda1a57ad15f02c824835a97ef1922d5f920009f9962549fd0b71969ac745a3ea1e15c4d80340b3d66729b4376afa89dfa1d3110bcda8e62d073a2e32c98cc23951a9b2d9ebd32ca1eceda25f8d10b56467743d5e3873dce522a619159fa06bf3d0898ff70c905c8a5596c9a854a6806e39ac76729a365834078eac6783b2a093ea5c0fe49b3b2eb177e86c1034ea55222f494d12a1bdbbe43deff9986f4440a9c48c49558b06af679a931e29d24576566d9fbe15b047488fe495791eb674d36d766378421e7b3b5dec3c42cbeda7319124954a3e48b176d9711d0803e44202ec511645779279d140521b0eafc93a7f60b3dc7202129e7428c31b6e5c7c42e10783cf8a7016387ad5badb539a42e1bd39270438dbda4858fa49a510772b516963dc68b8f4fe2417f1a4ab4b810a853ba3512bb6b7e609f020ea2ee16734dfe604057d765eda17b0e95137648bef7a42c3a6b8a796871fabcb74b9f7a6ba3d5afc8631a194dbc2033eb0d18513473a0a70b489171ff7e9cc7ff949a3912cac128f40d000d8aa6d8d883d2b50f696a7272d9c1586adad4246fca25a254a88d9ef559bf9568e7e9ee8036211a3cb4d7de273931bacebd700ec4f0d879bf5eda64491cb6a866c909280b1fedf14e7c6992bba5ca14bb0690ce6ed85ae96ecb78dc1316baf6b0ee9cd1bea9fa6140885b5ad5457e329198f9e85c273beea385b9ca1d1ed626a8ddcb184ce04b3d8a6b62fcdc678c886fab47ce1dd587ec8980afe6e5bcd9c707cfd1f702386d96faba80bd88b07126b23a45dd27382d944fad0f0996737461b02036448be43d40d74afb79ad4015b365a201ea7ef33a69e1a88705a9ff65ec82b7504f495e79286dcbbb0ace45e3b7495638b3f648e97441aee8d522fbf2e2884e2b329826a68e774851f52e4fd6500fbd483c7ffbe3fc49fd6e53e9902e103d96d51529cbb46e2d06949b2344f623afc1786c887e1cef357b6c8f8b9ffbb29b96a92bab401661db55d2495e0ef22ddd43fee2931f18962209cedf7260859a29229515cd0319f0fc8e81d767cfaf591ec7134b0759a0f27870b8f3007117fc312a73bc58290e5741809030f0b52122f9c3cb54f4c3c2e9e50bca198ab331ab13cc533e9d15ef5463b8057a5b472e3d9771bf29f050d757e4f6b101295a0e137ff7ff9bfff6351003b35ec2ccd4421ab5ba83ac26caf7e21cf0de8dca164ed05186aabc1f862045299b4420c135a936d4929e3895f36cedb245ba28c0c6837ccf6aef065faab8c3c68f73934195d4afed239ef72f4163315c225c2eeffd1593d608c5bbe62b16e3846ba4f7f75f04b428739035023be0dadc4c343ca8d3a7b97fac9a3c7b32b1f60572c370cb37a45f06eb2166474d2eed63eb640a5245186f2d09ad3d8bde16ea5e649a670908fda8138875eec52ee42a952243af046447c95aeab77de8a1e0bd14df0626adefee8684c0a293385015a5d9ba2abb1f70d3a72e582ce19f811ed75b3ddd1d29997c3540070fefa5f7b80899c28794a4c5d6718cf6200a41ae6e85311784c9f66b3f87c1e1016dd9e58b877f83d2a6508414e1d04a4eac845f241143a891165b3e623144e1a53364f1c62473ccb0d7be163a5d81cd0ed2c62bf3528680dd26dad628c58e654c0aa2e0498d1c662d79787eec71e1f1195120c88a83a67f68ce9b5f283930d250789b40508a12f3c062b69ca2547ff1ff884af8e84f389246d7195600ab5b5da0085d13262a23313676e14600d8c7a252dec270b772e39fa99fb3769d0bde93aeff3f187b22248266a277bcaba1a73c1770aac7ebf1a5bc006776c07f380315ae7abcbb45c08678960b4841ac2c6a4ddcbab43cb88da0cd64f7baa57d3302da50bfac22da9ba2866cce249435e38f3c85388c90c1c05bc6ed9ff5caf5be32cccb371f6fb2704c0eb2a7deb3fc5447617f454a14ff62510a2709c08fdfeb3517721141bbe722c03c877b34e7ef760ea97735a4cd0bf2347e48266165a625fd90a38a6b907bbfb104fe583c723a3b41954c9675e0edb11d1ed0f1d18a2280c6b25d0042f3948003956c456e52d128a102092fcd92c518dada2dac9308b79a6b87dd91034fd0b6b3569b853b3174cbe20408df89c8a08835234752f9ef9d454d31d95fc505bb2f1c2e318ea4b5572ea0228e8f23274273cadab92556e84066d0a160744b469c46884e00c436f0fe857e689126326382de3e0b43cbffde09db1ccf6ea996de2a2bc98dae765d22e4b41b318e0478f65151cf332d4b35899209b44547c51bf173b326bc12dfa2d86240c4b7344cbdc5cb799710ddfdab25206bc03a37382454315c9de53cc379b0bee75d30a07a0e3650bfc31c23af3522230e4d48a01162bd17c07ed3a61b7c538692b4ec607336ef3f9c792b46c67865049c7c0a04b706e5b8c5abdd2060203d6a47a863b59dcba73fd2af9a2ba96011895b27b5eb13564747fdce14a20301c920bb6587dc7682d39a2934cb2bbf50cbb3cf98aa1fb7bb8317521bebd58b969cb3a1f16095a2de769f02cc9b89175e601871e4969eee6909345e7cd72bc5493d9184dec041b5c49912f2230d15baf44f1de2a5c5a0526acb2ca313bf133606bb69e5bb87e2014b1deacccedb6156d8382b97b0113d095ebd9705a3e11af2916794384dcc3d0c9e7e01d29dfd248440b2963f9b3d2c565722ad641ad39a9a47ff23758e1dc2fe5554b58f06d67c2ac42a426166c763fd1178629a7043b277cee9d1e77f6c8fe1a16c45c0c37f7b26eb55d0e46d460b991cc7938cfa7146e52bebc8c5fa8fe8845f14646dc2ec4a41af991885ad1db0dc8f49b3a95e0af8fe3bd3ffdda0b64da4edc22233ac43f3ab8a8561b0da9a1105cf1ff40fa5302a841d97654ec18fc82aea3aa1fc45ba02cbf80a11eb5cf6637ae3f60e3aefa964da95d3a495a50289f41101b8e7209a32d2e3286a92a3cde4bfe29e074825d1390566c63b3822b5dfdb2a556342daa0ab9192e07f655cee4fae783ebacb94c6224d13c34ba1557b66e895c3a03f909cbe2d548df6685ce1b01f2189c17bc6ebb4e6d48c5dbe04de8f3c53c51bd3f6d69914a7ee5c6e88c3a0768cfa4f9ee73c7e34018d2cc81981fa200b1e52669dca91e798fa6801fb69435ac7dff2f69dde3477f2649db6fcc418af10e02a57241fc098d296f89d5eb15c4f015d17bf79cc25be68de66b8ae13370027f9ec493a6c616d329584bcc7dcbaa9d8ec23fa5e038d936d81c7ea9140f2926be193408ea258ac6aab3c115b02de2fcb9fa97508c1205278261dcc5c2c68ef16d81a41ce9d1156f1440e5312d80d5a2ecf1d9557414c8b8be85f9f0388e164ef9a74fb00e42b9af3bbe1f2c9bff10bddafd298d0b1789cef6c88ac73048ea2ab2daf1a2ca8e2c65b1ad1d4593fba15a3bc2273bb27020f03320f6947737004679ee57a85f933ad72d9f987b0e1e2701a59bac5dc27f6602c0188bb618c782c23a9ff3b3c7db8a0484a212da28eef7f7310449d694a9017e5e4c6bb53d5fe04654d6b090f989d48794234de657f25ac579c78cffb4e84a23048739a3aa35daf770fe2af1accd348fc0e46bcfe133f6805808d2ee5805d79ce39f9beb45740508ad876ac382a8e17714894f3fd9bbb715c287ff74d60816562741b3df3121afe8503c44511c53eb3327f459262853370eab87ad97446bdc622b265fb81cb390c05f10800e6d763b69776ecedc4b3c5261be3251dfcf5877eba8fe0d3b262f57ac009388feec74c3947c887071142dfa02f713b885b42a510d7c3b5dbfd85570153b63d45e02409996eb305a06f2a97361bb55096f5d1f22456bf66e5c7315e44e73fe56cb3c0115b2dc1ccab18c102a61693d66913c9d69a69217b7945acd8bf798e111b8f582fadf20074480d3d27ebf6f0693bca717782dc6ae9b83d37bf13074ee577bf404364b154433e5f97be81de57699b21f62db5f04c78233a14b5fd6616aeb1a7e8dadb43d858fffbf6f6b1f6b3c9977c38b9fff5a3dc9b224b62d509984268df2a2cb7188395174eada84cef780883474b30253292d1775473b52770c2984fc6c13b0218bd3bdd608b269f1534d768889a1fb3fc556637104f265d4e62f7b0e2f81d437afb47e89f4aaecf6bf92a11524e7454a5cfbadec56baab6d8a7dafbb4fe3af0304f2a84fa598a2383311621ec8a06d5b8b4a6bc15454ff11c0b9041a5d40374639caf1190bdc8cd9698cc649ed53c9eec232ba6820f37e229b56c660f41a7ca13665b0b16f764affe375dddcb84a516264a60a8404579faf528e895dbe286c92edadf88e6d9b333ee2f60f5780c9a391ad5023bd9d3fb395a5a585de78af9850732e3ac045e452e8e4271527f157347978c6011aa01337a325caaf0283f45f0c046190fd42e4f1e32c5b46fce18021069da4090806893d5221cc23549b1209456f6cb25e9010177b2d18e89db94aa8273f327c6f3a74688720ecca0850e917d7f06cc1dc36c8893125bb75bf0a82bc2ca8c7c2c9750d7c34c3b62260213c28ee4bc658dbbf93d51f5ea984958262b57f5f0c18845109ada4f28841fd575fea589566c71e8ba1c95a712e7038f734c0c5e9b9c963b15e43e6887334f901c12a0ef57b806ecc04cbe494c78bd0d447f08ab770f8b41aa3d29c1e504b8afa5adf7d0a3889ba85b2fb7ad108af0f39145f49bd73e57ec8a873fe02471df74df3879c93fb57772340533ce2812649483018177cfbdfa7109ecc505f368b8f9dbe4ff5ebf41938c6fcfbedffda6c8a05291b31382d20611e1622de002956b4da045dc12d5d9098e3541fe84c364143e92c6bdcae534cf5e22ae9518b2ee6e5fffa7301aa0e99980c92308a15a21b4b249d1844dc9822023dae00dda92759ab66049204f892d9f3368bdf8016aef9c4a0bed48197bb0cf5306be4f87b9c770c925579eb695a13bcdfc19267f6b25089f1037c82e180473c572113c0977a31ca07eae08a28ed148759ae04e192f9cdf6a61bae48ce8dbc2f595351f4e0a6a7d371c85509769cc1741706c2d2add197da4e66b2e460cd6a5211c13e9d2a33ae68c16ef88bd5d8c2ead1c3c020a3da983723ec4040fe4bc7482f3ac82c85b972be0e49309fd2da53ece294d9d3a775ee2e61370aaf2ab9ce3aa386f7f224a3f25343149e4ddea1bc7b34595730658ce3cb451c0a2fd5a74cdd95a0551c7318c52456c3e31bbcd55cfcae802d8dccf98b11df769292707c51f968ec0007c8cbda2a51da2e389f7316b545392780c0dd03f6dd5441750b6aa04d06190de3d837d297c0e8a5eebb38865841e4675c95ee446fc855f6e227083ccac44383a7b7ca69b6c037e238f0e71639046b7ada85df3f9a8eb8be345fceb3f2d0eb4c6957d994b9558bcba7ef10aa2cdf7161027325ecdaf711e79d2f5f205d9d2092c905298a644415d97740dffd3c558b60ce264d793982b68663d48629a5850b99bccf213a84f12068a05fd0dd6a9334bc225f3025b9eeb7244bd60d1dce2b36c0861fe925abd3f7cd6e7d74a253be6b40d8475107313128d966aeef77c7b6b6e34c8fa3ff5970f609468d0097864a86e145188901c561a923b17f57b920b8bec8a4531ff21d1ee0cd0945f88dbaddf98498fdcf86fd5e48998346d75d94be362186d1c530bdd3667c7997375a3f8ce72dbf41ec55e8a0fbf98163ed5cadc9ab886319e01d79d684f19a4b37bb481019eb0179cd169f8d9dd78b574f64f212f96b7533b9e9105728d0ca02042403079de59869dcdc3d997726ece7ac7be13ec0fc47b23b1c96e21a9e10be06a79835cc9c8cc0d76fa348ec852b557a65f5bb7d1fc56e9b4a6a96c3a279f4cd20de8ed8142face49db171ff69fd7a7fc365bc4814eefcc720175ae1a7be5a3e96f7ff0629a368c8568588f28864f33815eab0303fe6aca06a8fd98c1d21836164f0c69246e8ed50d8b28a14eb25d06021adefbb71e86033dee04b1e7bb6ef5df17c79e09c5e82e4284fdf2572f57a0a3d2fb7733250d9be9f87739ef11af4047dbd4564146d03790c235f2c7f8c9b8bd6d4478ca192b3a352b62f0b1b50fe23c142efd711b0009203408fd6abc2b7ecbdb08f0b7718638d43c268a2754541d7fca83536151d5249820c7b30e2124b2f0e822ac47304bf77ea20cabde857e60fdc72831329b755799b67def5f27356af5dfc1d730afb159f6d81c155fa87e3f465087e9dcd2143baeaa19310e0aa74fa35728eab64580788d8e45b8b0fc5c2d65a214039894cf5631334cf88194e4ff90b913d8b26ea4582bc56db18ab43cda273b767f827aacf7427850e5c07fc9fa526f8ed3d86b126c6637e4956102667790abed941a22255cf967834328201007f50def6c93b0d3d79bca02305fddaff29aa08427a550ef8e283d77365cd7d6711b8a3b7f13c764d6df2810f8c1a614be02a2bd27178bd5917d79b5be6034cfc9dc09e8b849f256bd50950a476bf3f6bfc61154c50f5b5a838f2b19bc4b723178d23e5899d5e1805900b4c584a963fd2f163d0d9d4778151c8b19a66bc574e4538c065782c92940e401b2322d5ea0e9c9f45eebb8558c8504953d0fd0a2cea667f37341127d48e0f42c60aca45e83d51b90ef355a668397c4c3f08c93d150e4a5eb180fd2e267512b8339527130cc42ef1c77b71f6e7e93a6623f90ee39b33285ab3425ec88cbd0bb31079a6646c895336aa838c30fdbac984cbaf763e89e2ae6c1671d4e5ab380f64f50bcdd6bf5ee0b36685d72d6170069f51eaae422a0705f7e3987b79e4dd7766c16f22b53abdc71f5467a46dd76a69d562b5baf81d2c774b756ca5e70a3ea404f6c223b834f0973469f25817c1b204028cba213d9367550c69c94887a7eb629087e4d9666ea2a07fcc9ff3fb613f15f30bcf343fe2d683b253d296d06f3e72cafe5a951f8098575acc3ff7e28ec3fde0c28de2b16bd34aa8caaac0390f246e622902466a4e7bf424f32302f56e0448a042b4a1f39375f327987100ad66af6be8278b0c2e75f41d5d0158a9514ed9e6dc63696aa1237eeaf2e376db4fb2e85c9c7ffac6f500cec4b29f99420fe1e65770b28bb9171c20829e8afad76a898bc2f2c4b3d2efbb832b2b95deda92828b4fc7f00e98ca49023236c8256ce0658f75c092d7a94304676afc91c6e171fc46b2708ad20151098f238f5ca61e0f7e9af0411573b806e58894706c8e5d1dd0f130b3ac02fbed31510ed231684ca92ec354363fcf0efd4f8a27ef9df394973245ed57edc827cc7073d6aee806bc8be69c26215f1a17ed03f2811bedf7211f0736f1be065cd421f3e810ffe42240083ff50c331146acb79b04f151fd2cfc8a2fcd87a53f91bfb2e2a8fee910ee588ba9c8c9998c292a7c6f4f8206db36167f5c57921beeb5c181eb04275a881489954db36c9426a2bf5bdc947f4efb295a6de07df59242c2bbdccd27f4df80560458031b1b70491a34c1aefa21e8c974bd005f334c7b0199159b4f3cedace178f94a7149f03555182fad599fb1dd98cf49cfb3127f3e6502d77af1d16569402eb8c4d9500e2b1c9fbef8fa0519cb96deed4a568ac1ac5f733888d67a62f2a9d9e32abf4c7a96dbbd8c395254293f58c648178b399da6b2b28b1c76f70cc2ef96d74ef8d68611faf3e400b6ac592948f4c0650468d0d3f4f44753f969bd49dc9d3d84831fb08cdde21d53b616f6ac1b0c5bf3ff54cfa9680351428122da255557935fbc039271664079045493d53ab35b1e8137b4f82d590162b4440cb688e532f95d994a5a90c4a62d608903d6f10767b3f373cb3ae2cdd6b2e0da77a5fc678f3752acce2b60033c2fa7d12357b9008b4de40aa68f88c9a6c2f52171d6b755c8fa459f7d9a3c4bc3bff7a5858483100931d3279e7d3b5bfa7804bf868cc779709619d44703f17c6e9c0ccc1674bc2faf18dd83522a94ba89407524cf9fc6e4d80ecc95856f952412414029809f9523363decac0b20c4fd6242638a439d7e316bbdc213a2270b93b6b6763b88e2bf584e9a75675fe575ad61160431f065f9f8778c356e5e12e609cda302c607b8b1dfbe6bf44b766df9555b5be7007b0700b709faf83a8587564b6926f4ee506d40b42c907cf04667484a8032cf7bffdb7cf8e7970629cef64e22cc8aa121b15479d062374f97a92524f156141779e7c83fdfd2d857ead02cc012a6a0dbf5f80a59d30f99d3e82ee0e3a7acb08fe9ed220cb858fcc678bff2fbdc0d59cd4a85ef62e2e9ef29a5ff10d4ffa41751a0edc58e947c14ba936e9a809ab1315e6df24ad2deb04e492891bcfcdb95e9783c855c14322739b2159c5762c760b13489a6ff98492a990adea82c1d3328aee4f8cb4001182310be640829381063a3b508806bc3bc027cf1cef8587f944cbac652d6e35e1ad8d839795c2fb410aab01d08265e08de2651fbfd2cb7f6eff3d1e302f70ebc96cb14b85af4132c159fb130522998deeccd183a032d22f636a043524802d2c03fb69df9c68e188c2a0b4fe3f2a6195912947c8ecc7e18e51a5edb4e114b704b80b1fb9f6c8cebcff2b1867e83644e7a527c978e60cba78755ca41a25b8393f335659ca7b4f1483d20b432a67795be0bcb13d308f99520eeb61125e335bbe8a336cf2edcfda31adb98fa578f0f5e7171c5c97176d2c8bcea012f4b72e103cdfb4d2cd90534c255c6af674d9ffd80538b9fbee4194089f5c8b32519011b5eba7d7e3be5cc90edfd74692acf67e2daca25365db8bddbd1aac7b435405f2af0b8d6e1efa957f130ae58c4a11ba733f4414dd7eb15ba2832e38742e4ff67fca9f4e575535fd00888a67da1fd14ddd70bf28a1d97209dec45fbc271420c54ff4baa3e4b6fb1c405e025c2d167f76080248eec8e5d8194dfb7fa0e168b0730f9bce31b197df7e292fc11e36c82c22dcaed66f41c488e8f95e9bc5d2d85f40e5c0725161157c4a70b3351a898ad6a19c085afc2ed23c708ac8f8c0e84492666f244a2ec42b9967af97498b305435a636a01084c2eb82718ea13ab10f94514753041d42ead81ba598fe1ed099efd5f5b07a5236def3fff3ed7158411972cb9977ff277d3657d17d8659c9ec9afcbbe0956aba4b1a9de76aa6d168872df792299044eb7dbab73bb17c6026ad1fb3cfa06d762141e666d647d402a0d1a7f56e207ead7eafaee27674d33d30bd89ef3af90cf538413f2679e9d396c712b0a570ca3f65ce9b21be84507c80f7eef81fd5f4bfa473214631df7fbf07d4e5d33f236c45810d444725542552ec60df31804ca2a1b2c7584946d2c0ab801317898550313d1af3fac3a9097ab0330b201be5897f4223dd4777d41a740280d8d80b9dbd290261b3499e4b22a5f04ca68479b3c7ace6bcb67b2ee9923b80f4666975528ca1f62b7bb5186f201de3eb2d939fe4e75b2e530280ae85277198ae1fae06495e29012fc3d48d97b03059518150b88c92f6d417cf793f691752c70bc46a5ddca25d5f78cc7ee29e4e4dc4573d380a669279d2ad3f503c8e4541f307adf80ab81e99f198016c432b6025532f73baac24cacce8b485434c7b1d153da14a64a14b2876e2f4e6204ed26910a7e1efb7c888fac0c39dc68e8b4b7b3234f4ef8593202ed93f74a9979b2b7e2fd1a1f9d01c982e0a12ec85502bfa07d51c7727cf18065a25138e5bcccbffc38824eb661494995b24c9871fe885ffeab7fcf3185f55cb21fda6c77a02170b5660f319f93774e88b92f582cb28854f1cc99bb6df0a91635a96daba358f5cc9308f742626c1a3136c545dfacbbb5f894a15aaa4e51cfaa90fd73960df5070e84e0afd8b09016b708951f3e12a8050ead0b1b81d31b054271c109fa6da7939a632c2988fbb593b1ae0afad7dbdd7c43c7301b1107c6f70dd5642050c85efb0290ec2ad1483d785d735c3cb5fd8f0ae2d2d2adc845aae4ddae93f41f4f9fb5c528252d91f54df4e6e875c8563e5833770cc519cc29babf997a7d8489a39f2e52b821d2dfd2667d595ee1f84a4f293738dad8e2a36b8ebcf88f207bb406414b39fdaa78f2b80d53f70c19d517bc4c61c1f5b948715ba5f395bf948090d14ef030e9a465927d91228f75ac595b5af02bf5aa5202b7d3032757bbd0e2696b60fb9d3cbb78c84e10f9ca87c7be16032edadd34b98bda1ba5fdd8926cd2dc3c61cb63279f066e0ac2fdb51445397372860f59b2119bf7c2af87cb9638ade66f3fe4412e859266228530f3cddef82bdaa3e7b9210e728f8d31ad541ef31ff9ff7ee4af1819033876a045b65b38acf6a266e997a9ba37a855b35309cb1c8d92195ec88df36f920b8897e0e603a9db3a268bf9a5ea7b4862a70c5ed68956c65c243318cf8260e60ea217bf271caa344b11a413f87a6437ec8b64eb3c635cf5bda89c1d18b6039c2b6c4813d11ad2fb6193802b8f1187a638c8300c39e4e5b7079984b2325cdad6cc19895ae5a7ead2e7aa879e7fb6f6a46ef24bbab2c764cd810d1c09c6c292b45b312400cb85d3087b111262db4a6861be1f2913f7a18710e1a95c861aa8a883ec77054a494235cb270db126819f9005e27872418efce1785b0da6e726aaae18278a9477a1181681dd12500cac4028d2a960edf5ce7a883abbe868429d2f94d5ce302a6270aab14a07d3e2235c5f4d984270a7ecbc497587d199e1d050686a7413fd563c99971a2e709f0f8ec9f5b5b23630ab04d6a5eefe77c73f58b92b6c7d9dd19813e67a9e72d23a67237e6a69f100c3393b888facd576bb56cc1d1a504d2717733bbbfe5f5c7fcfb02dc47ba3f7d160b8af7ad59bc3d41e89787699c95e3045953be1c83b3b3c358fc0c4a606e1df05bf4bd70c3f7a9e971b230890f0ff8f20c2b4bb1786a71493508d1962581d3680158177e4b777db9cd86df434f6007cb78d0d58725dc00ad37cbe9c3203fcde28dbca2c20fc6d057b7d37fdf8b2d0e51f278260f57d06f1df323adc34f9e8b7b854cb2a646a5784d7fddd51f636266381ffd2167f884d3933d36e2680ca601065669625b97c850f53fea96ec1d059c203d77101d2c5ef49860e8cb8102a75d408a14b69c572992798bda70461fc2ceb7c9218a6bd5d7f760f79c128fdf231df2709bc7faf8b92f390fd408c0765e4072178de542da4cade1fc2db69cdefb8ed248004b61abb21f31d8d5a1673a851ca30eaba7ea06efc082ea463f1d929d465b2e158f4e11606c82c2d7c092702becd4de0a070fcc077f830c0e148a08995b237fc54a8a80ccdfc1e010ae6b9d5241cbd81dbef8124aced025563dbf209bbd91a777a52f7ea99ebb253752df53226ac0fd57bab610d4b807f5b40a3ac183d371113000cbe89e1e7d8a6d5dc3cb843a860ff9d384f9200564439f39904ac782c9d25fc9e1f9873c68a509fb1ed30b3a396dde5ce95ddd9118e635f0840c940a940509c589762ae877693eccb6de01cee7aacd29140b6acf647f6cd7f1d212633475a3c89f8a4443f9deb88de1cf295f799b426efeacb382be6df79b3cf4c060e38fa7f08572fb7c6e0b713ec041058c0310fa90b7adae25850f21ccc73c70bfcbe7207b0d88fd03ccae202378cdfd947791a2e2a22c4230bada056044d44db52be1f23c0f40359645378a3d315426175a14c719468a672c89af60608dd18f23ce4c987d92568bb8531c8f9ae781cc68840a4e56003360006cae9435572e37af84689751ba7aeb3b7f34220e242db6b51ac487d2dece839b61570a68811a0e4043c280465a0838caef7cfaf4f940f7b77f095fdefad715cf1f8b52f99030446142d325e3710209727428980c9ca4e406e0624a74ed07a2392a6c505bb2dbefca30fb7bddf762160777679633e69fe7ab8238a922e836105776d7943361a2d83b40c3ddee4a23bcbb863a7b1e8c6998a7b078647be7ac59811a049e51c239cd0d4627a30e63c4b781c212faffd8fc01a6db28803efcc6d76c0d32eb115798777781d54f1ef4d0bac35cfd543bd82b1608867b73148cefca1ad852474f1724ab44ea13862d5231dff42220d52766a4332a5659f812abcc0d97ae97e2c14b1668ce6640a832c0a98426417b7d530ac6692e81fd45add26c810f81bb4afcbc89cc419eecc9fa66d798804a5490ef492b6ffb42f6d3836cebadb6f013e52dd8fb0b1a4cc7d67dcde0766b23b4c945058c3c47c51c0c52ddca1db678b7b901022effd372912547d0d00e89a391f419bb0bd583d1d44c2a172471fea7a3b669276409ea5fe4db5967aa94d7d7bcbc69fc6f5230b12fc206280a715a7c58c85f2ba0bbad373c3490fed8c5c0479a0f8b3576b2443c3a2a77b09deeca1cd6f586feba1092d00092fa4a81dbd763ca361efa0a644d81cff2a8b40f29d93d7472cd2195259d11de9defb96a6a477000149050e9b9dcab0ec48f9c1cda3e722abf1b17b8bd69c1729c7517e8a41428a27de975312d89e428c3e27f76483a607286f68b51256445ad4d0be1c9bff77815f61ea5774ab220fac35c1c49394a5ba40c6b206240200b73c4947be1c0ad00e283ad806fb22cba603c6dde009124cfb8aa0209667134d6a588fb794588cc1ea580370c74b6ec66e94ac0527c46f75b677d846d144aa1e3d5c3376c984de00d0633194f752580f334434445480f62446e4f1f4fcb05287cc5527988b81e84b7eafa46105de38b178c2fc81cb8788cebd070304e42ad6f89d13770b0fc7e013459a139022320a42184d26fa44d684da0375cc1018356a4c1d0bd3df603988ea2f8f54b0daa4d42db2584239cabf8e642d394e101768026674d5e45582117511e32300ad1f1ae17d9e4b6dddcbfce21d2527be9fa12cc5205308c4d4df67b61f74cc0338b6bd5e65f492b83a3f920689c88e184c860f171c1b66d785503aaafe6cd1c1a21e3053f69368d2cbc37c117d2da2c4b9e27272d93562f56a63481668156f3b5c0fe358cd3556b6c0028714be3aaeb056105bcf6b304a1ac1198477ed1672185d4776774393e1322f01e03ea3fb4a87a8a125d97fe2310a312e9d681f8b2bf3aad21cc20fdd28443f3dcb78ddfd23289eaec88fa3638b4848147fd007ab7054634d22e962d7df628a246d8e9e94bd613e3cd622bff3ec2f537db188b2de7036ada13863378fa4833ad3378a58f0d733c636c1e057686c41740fd98dbffc6d5e1985a96644e5303addd5de0f0080e04dcf8c9f9490d337d56e2c654513f49aa4f69acf967f44d4c1f8794e0b0f22d8277d3c3eac77672ebc1db3550069666ebd364be483aff6053299f82dfcc2174bd25db515914a7bf7581e0579ff3bcd86fc91e6d5c0601419891385ed233a198d5ce0f054fb989e7387557710aeb5d698e51ef42fc7b667acd278e6f3b46375e64903382cf87b30659d27ed36effcefa0ddf3feb1731a89a1a7ab8aafce7b6a9907a1e2924bfc18cee77b605850b406c536e1ef0c649b5002664f3eea53e845a2e65e34d3e98c4b6dff57ddcae167ee1a48e68e827b741828dffddb5b968be270a5eda0b0b905f5cf2903017ce10306474b0078465acc20b2d8e162a4136e9fa5e3bd50b515a21b67fbe48cb9fe5fa8f2abca7788c08ed4dd252f409b86b34dd6f7f90676615518c0b6376afa7a0963b61e27da909883fa09070dff955f7a86a81e1e2a9f4a4b3092775441cdcd4a1fa8a8d5bdf303b7500d8b7f5be27c80da0c7dbdccf9a325962d2295656ae83c6aea71e219245d709d8af4e6e86961f5e67f62127e74986e4329a74b5125d3407b95e863cba9cdd5804835bdfd3cb311ad1f74c7c55649269113c433df78842ba96dc39ec36a816fcfc7c7613cac67e666a1e7ee08477623f54260359127c34111e2caa2dc7bdce9f9861d1baba082510e1b55d99ef408e9e143df59d6d0bf66af291ae292d816b5e47c616c00609fa7dac9db349d3bcd44cbb24d97e8cfee6ba6562c7505b413ab1f02e5301c68ecfdbc3849a064fc2c109a31195c298f0db1ecc0273dc3cfd98f9aac36a2dc32591baac6cb3731236be150e4030973ff583de3b9f9ea516fb1e346c6c0bb2c8054132090f5470e05110c0ae390cce07acbce61e0b2b0b8cd4a20a52d66ba1b0855ef63b494e49d7a70a87ec3125df0863a625cd1c44ef3685c95883da4dac89a1920daf62feaa5f6e1a68d5b63f06109538e81e51089f75761cbb68b012a8061a3112f35e15dd38ab2a0f35d1e92c750f11f23f06cb88febfe4169a14bac601828804267b5bccf7f5c66450386dbbfabdbd5ed534a2465890d20c0d3d106fca6576839a50c82c9b740a86c6022e0d5fe6f5b3cf8b4151d550f1f1aaa61a6ae3fe02373e86e930e1ed8c96ec4c96d73479f3d99550b6f61c2f4f28bb76260c3b5d58ed2496bb89247c038293da67bc810eac456b3647f5a16855e9993e494b79c92650096a17a1ab3bcb133a14fbe0b20e43ccb7def08d6697473623df753eaf8c8f2b768ca77fffd09503fd33a949c6cb8bc5e6aaa5f92d49c832b6ade5c16dc1b5be4817e7f498ce75dc032599f8fa144c51f022aa0589c26ab60e8cee6a2d116b9434e5547ffd9f96c8a6bcabc57b42dccd559b81eb12cee69e04ad303494753e0a959be02e77008ca2e51b9a1e08a89eaf44a49ff56daee461283e0b4fc9e7a7f7e4507d02a8549672639d6f2204b432a13775381b835cab52fa848519599ee22a6705b298a04ae6390a00bc98e2aaa223ba16ceca152b6c8d3768d0247e542f0c73781f42450279de622a63a3e28b837c74ef26b7ab864f11a21957fa2b9a8af777ab075f7f899ebd57fb14e41d2b9099c702991ab14253fe07a7a8e33033139e960f8f861135c15f22e98ba220c346e374ae0b8940bfea22acfc7cca57f014652b444bc8bce36ce561e4b9f13ea0436484fe0c51ef796d705956e6a482b6fa933b296cb99415321d4e162d92b8c16dd36fd145fbd96dc23394d1753d4987578ac00c57e707d4e911eea0a40b2356c08a582d3f33520554bc29a7ec2af1ed55aa2fe9ad731d0087752a1669593fea6a507c9bac8eb316743d92af246f8af460d08c68f1aa8e0ed825eb7c4ce94c72af15bf9aa45f0e52be6d2152d89562a780c725d96981b45925dada63c0bd50079b76065a1dcf33a12487c3804003100a0fa643372446b728b4a553d8ef439a755d4c62dd3a7590d7735085ed11159d842a3ac390f9584243d10e974e16b5c14f9237ef9d21149e81edf1dc188e543a2a5c1651b9a1bf3cc95cbf8b8b3f4fcc1c182e5515aa9940b09d80b05b4e818152fe97c1a9b9abacc82de61677438d4a389126e2774ae18e005f97c2e88762931dde08d8213f3c91fc6d13a60967d3575e2c02bec5dcb7eb4aa4d88ad6a168723dbb1153a4287858768b9f63d8f602929d0980f14b9552d8692a87d925143c1c6f0f8aa335e4cac0f92a149e93422d1a0023a81682e5c8dc190e2f46d2f336ed5ef29a7e8172a3fac90b2c9a481299fac7525f82a91b1c60249dbb6fe7f093c9623df3d510f74855b2c28e119183e0a27dd3b3783d8b8b54922e05025ed8c32874cfaae0d5b572380b8f6fd977fb5e0ea695f2ee87df96207c20a4eb494cfddcdacf8b08cbdeb29ee4193df9079f55ca9af24e79dd3b4fe834166cb2cf6e24669f79e148dfdb2fb4125c97de64e32834ed3d91d8537c88affc75aed4ec669e215604f0e31831e57852a30367aa9760408fc04bd0d13d8abf8e4f2addc041ef794d301eede79e51040f77bd01469e20a7f5dc7ea8d7bd0fefe2355e0c9b9f057a15c1344db8f0d4f7d17eda8d7ddea796c67288bc009bacadd9991cff65290f7ab5ef24e81419e9486cc3ef75a4cbf81bebcf4c270baa28188e4c9ba571bd8e00bdccef5a3e532254840aa27c20257580bacf6cf2b0d48e649a87cd1d8e9193c9eb47156de33b9f7c362c17c58f36e8aaa6f635b28d550a35a40464f02bc8af592922481f27e1908038201d3b2a01c9b6e0e988c5ed793657cf0acacf012f65dd641ce1a4c639fe4a41235b4ed4c589396a85a10ce349016cc48a5a362f4f405844ec4d7f659c321c57d61468a1efc9a41ebe472df552c7706af0c231bfd537067faf9c836c4398e75833affc304fb2f837a9bb3737457c87fed26145afe3955c8996498e415c302a501623c1384e11c95dcf6ee1edae4207d04c72f07c063bbdbe9475f501e8326c68a156f07d0fc3ca3456961ef52c19e2cc234c90081a4a17876fd0e90897c12917054df198f75a7274521dc3fe2faa2a7d76a0df048b96b0c5ce405562dcedd2559d30795700c8528fb521980532e373a01df638f2c834d2a61f22b22ad7f318eb7b396a8ffc65bb908a3ac99d9da3a92ec51a921fd6987663c0f7d0f86e967563fc055a9a69eeb0a162073924485aabd030fd85db19410009399361e74dd9ed77031caa2d7944201c04e499cecf341ee702bc66955ba11a19cc8e65b7124f27cba446223ed05b049e25708ed44bd18bf7ba0c414bae7a4842bd8dd5147e5ff66b42ad6351d8aa7e39d1113587bbe1664cde51afe6cfbb9f9fb01adb3fc331c82596fbd9e1e98339a71373d64bd1b666491fd898198552c34b2a7e5ca67263738ffba08b22a1d60a6ebce53ea8d27f6373932053eb658a235d0648c5d07d14df3bf05b46485e7c7feb7e67f7b1befb6ab4a587cd438337b83cf9151cbd1253c1f2103bb00175aaadfa579ff81af67c8cd5893493da4bd8721f1ef6a394bc897cd4cb95de5603e0a0f3850b471d7f5fe964e70af104be531c0ec9c85bc04989ae6a3ac17858bb80796b6509efa6b056b7ead28c4003314e2479429cc0adf67e5114f208f28f798e9ded44f92e6b009984f8d3dad7c70ecba2c50edb1945b8d98c34b1aff52cd7a2b7e0bd5ba4464c82e398e2583ee723c19082d2933694f8ab70718057af2f92a9e403e0cee7f90b8b41dd32383c4722670779c5609710d1b199220d1738cb62e7f796e187696f178f00a57d7d7623b6a37595cf99ef642e9d2d9fd5e47b1becefa20e99550d1fbe3004a4719e24acc4aeabf3a85ab4a990e482d55b6bfe3398c15847517c734e7416acd425132b5e794277b8aab52b1d94fdc48bf2d87dcf21c31b2f0bd136d0249563ca6462460ac5d1fb0b62860fde68cb510758d9cfee5b2faad4b911b4168e16e41ed70f842a4d9e16d0466515b84da73a537699cb0ab0caa3a7648b17f9cdc6a4b07aaf46f44c638aedf191b6d04caff9d7ca88ac91e67873f248ef93fd7d40e9db7b1dae5c671b74ba4556f42088e4442f10481ac81cc902abde207dc959a3ab02d29048965fe26f9676c90dca2babd515953984231469b8968714d811a455df335ddb53576d88f7942d663506e3791088fae86cbb0a939037fc15b7181f0eceb6332a742d5fe4c8dc4633588cda3eac7981aec96799d1eac467a97fd747a98670169770d2c30278fcf9fc755757b326386a16c54fb05fc0ef106402cf059dc83f0777d234664fdef8e1f69d275935f3a11ea61a81b65c3036cbc0b5e3c54aa160fb94dd77e66fa36ce844ffdf11080eea8fa4dd5f8d05932419b5cc4649eec3d06215ef3302d82b4a98b13afa75d54b664f0c4d667ddb96ad0fce1aaa05e43b4de1bd3d5d9d62ca9c0363344af1ec3cf17f3951e32f1f93cafd1fb4737c3bb403f20d8528a17692ed756ffac55193b9f3ba0adfa4477b99b3ef46aa16f9d2b7372684787641e27280a58c71714b6ad59e2082e5cb79edf42a35c2510af8a3ddd0b60fa1ac8d0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
