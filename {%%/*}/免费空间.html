<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7fbd61be4b2ea7855dc495af20e5b648692bce92c820bda8540bd75f9b5eafdbf28594623ec4a86b6a1371eb2f456d094cafa001c95ac3d45685891a49a38bc1ea4ef6bab99260700f89a53c98cef86a7049975c9ec4c63a17c62e90d9b26d3684c75eb080004db36d9cbea6e69646d6ab0c263bf0a8ed26169f5bd31115d8253d21bbd065812175ce3efe433ff4b157f7c25268efa899d0e026e068d61a195f4b9660272aa72339e78afddb20875789e6b4422dbe384f5625d5741fb746880433c36aa47a84c3275a5f79c8341ca40efa1b063640af1338f1dc389190a45845e72adeabf7842091844527b920d4f687df8ff4fe120f51dbc7b7fc3219631720729a3d6c65a14decb25eeb0ac9c429239cc0f0541bccf2c2a626c428f4e7abb4b0c9254a0102af8984b841aaee4ffaa82169606318f394195518d6741bc04236f9f9a1e8c482b7cf9e919dde6755628ac3012a441a3411e702f06732db27873c04b3507ee38d4c1c41e262ee6e13f5f8ef09f5eb38f8a6f1882be706536f903a27adc52f7bb86ae1b7f15ed40eb726651ea0eddda05844c0976d2b80a6fe57ab0d3d67c5d7820231156b88d93e88aed8e9ea0e7745aa5bdc91936a2b7b08f2bf4f6c77664ef3dc3b3d20b669d030111971c5de3c8287ea310d3332f1293ab4d64a23afd91010f9ae7bb73a9574294a3b19632f5d164b3311b11c0eaa414e7d094f20a5b027e626028db436f77cc5f08f4979f738875971a16ca4e5c7e9e173e70e8e51c4b6c3c3be575b221509ffea5d64ff6e57dec3cbba11ab155fe8234e2005813a267b4965e1a117a3bfd4f3ea8e97d1b6c202fba1976f0f5ed1ca3b1179730500054a78fd1d636adc7e1a24540ea176b0e3ebefe94b64fe32feb718aabffd98a11fef6b6a25f03f1ce746b7e5b62d9d324fdaf9d1a6034ae995a2b79e724e5a716fda6e0621a6b868fa50e799e14132420e679ac542c8918b703a45f1faa52f66aa7d5e9dd6c7126a39cb43bfd95330e02e3cf23c9c6ec9806c0894bf95eb4f612d674a2676cf10c2dbf189f73c9fe96899b9bb3a931a45df429a06cf55ad1585aa00537e735710f10aea1a5d5529bc43c19839562bf6b7da430a710f8695a68ddf76d8185f089d382ee06c24cfceccdf4d73aa5d5ab943dd9360bd99e0e5b8ae07afff0c6b88ad71826997574a8fd905033e9c735d46b8992df00ef1e402a9add3ed25c8754278c9df0ed190aed496461379d172b7491b007c56f967b31832f5643cd31aacf693ac3520d6681de1438b13e59ce0dd83cbd505559245febe74a5817a48b418fb8346513ac512ef5c85666756ae5a5ab4e599d6141003a04828bb1a258d3ef3d09bc9a703c41755ec9693d7753e2047769845de36a1094a86caf0f5f781aaf5a606641c9685c3132f3077ed98c5557079d134edcad7cb52041d65423041f55827bfc99936bb22c0e34448bf45fc39785d80f84f474e48846ca7a6aec542c9a970675ac8faf550bbee2d300d10bb8b11e5a9c5397cf24cb828bb8439e2cbf60e99abd391184227847830a301538fe21ce12ab221f5f3bc5683643c6895963a223a3aa777c0b473726ead83ea8d98b266155eccb1bae70ad7cfeee7a2519b5c0c520b1e9bbfd27c100a31d118554b95ce79c743ca8e551b3c390cd170e52d05cd8e79709d184857269a42d38afd4d0c8636a473edf8b41e8ca9d0123630f7b6d9ed122eced1c4935b95e0c99bcff767159016e87305933d1d5f1a91759f6e5e480eaab6d562e9d9ddfb3e9fb2fc460e396334ea5a7c8953c1bb49de47fc788f48b7b2e4ec35fdb2e7789669416eda1dea751c894d9df0939b64c4d6cb0ec3ff570214e616d365842d02418b9b2604ffe31d7481b0322890612f6827f1fb1270a82fca4ea425bd6ed5088a161e8975ac00ce805e990297f7f1ba032c1def57229a8d771bc85063014ff0887d8efc7b5bd2ebf5bcb0e2778da2a28bb9153c91339d1c022ddda756a4368834b2a78b7b9ae4463ea841060fdcff13c30b953eb623de8e9509335e1b05cd5fa590888fcd370a6542d2c5abcddf6502468aa60484b489ccd47d4ff942bb3bb97eec75e87bb012bf4f9dc141210a62fd12dc4429278d59f2901bbc259e1b3020147680e95019d73706cc6ed445465b776a3463ac642f17b96afa13cc0e10fcfacb9865c5493f614b8c25f531032775eb64ba0210c38cfa42bad2c671f9f868888ab2f1df19ee049ee6a26478050cc8df1c4b7b0b6424f7664c6eb6df8125eaae862e85c793020bdf61266405d05e799b5439ae52b5243638e96e0d2ac8c6227bea303097e9fe03a71ed7f23550f7f48d32241a31c5f5d84085b7fe35f0ed627761e720460549c5e5a1ee1e9b634be7a68787b6d66acaf7afe73e234a53db9f858fbeac17f8af2fb59aeda0e595f01b9d8e6022b3f73ec4ba67a1270fb9006eda4ac9d8c1af896120fdc733d40028dc419bc915725d87d25222d07a4e53e80d794f4ad3e562949b428346f421e057a72a055c89cf1c30234030083cfb0253ac17e661c699fd1289750daa68b90e3be0207d61e9bc8589c99e08098000183ce2c6a44038c5e2ff795ff20d2890f8dc74b9c9eaf79a047436fbcd393c9b5f0cc5d1f951eda2f9a8d6688e171beabd0f04fea6206371601939382d7f6a86aeb611a85227677f63da51b2136ed68c85ffb31bb7f28a7f6a6e3f93bff3bbd3e297949f06f6db79dc3475a3874e2fa346c8800bef14d2ce599cb2fe57b0e53ff7ebfb245110542afb8ee277df48690b2948cd1846a0d3e5260d0abe9f332a13c485821487164211f3268d4ed66ad8e0586876e58ae9a2f57bbc376afee96c374f7517b6d55b63708cdd6dea47f9dddf1ec89b286ec38d3a6819dbe410baf6f8ee19a09973bbeb03c5455b212c089524b9e344093c6becca67c1532c5faa2e6bad23310bab63fad4f89e635756221e902d05ecf51857edfa2de43ac40af786652227fe641f0de18892cc54fdd2da73ceb2b3775080830602094e5b395a0f28c646c403dac328ad8e01ccea1ec9648c57cf06e1f954bb58beabac413c07701b2f83dc59abadc93f3a4deec6aee2f3405631ad8734d347967b3aaca441da3e031ea3d6c1e52a32262f43b93cf089a219f562a56281a9c2506f54b55e17cbb6412c91e93aaf7f7c55e2a7a9606e1199bb62ecd8b983fb0dc8504169d5f8f79d18db0a7193db2909ee309c772af47671da9c85f8533575cf6c140f1e9033e9318d69f6dc68fe88a4b90867acd58baecd8082c7c4dc3b5f52348b326e0728db5c24e5f6572749346746268d1c584dd2263189fbe3d6c43d4ca6a8ee00f1f859e5a809939078508c7134a231e74367e76f4828e1302bc3dcf20f8e2576c139703727b2fb7f8e3f3d3670277e290d17c5909ab857c9101aa61241a175db3cd54c427ae6fc1595c7d92f3a136956a445295806a38c60a43ae442d13b743bd1781a5eef9f6efa7e6684f3507a77fb850020ef606741cdd45314697dbdfdc7e562035d5c5e5047f318cb8878585327a5157e5a9a0fbb09db8ec1171795cf8dd23fd5bb3c8831a700951ec60c937d0a352afc9d42b9b70fd3b6dea45e38c3c4ae31ac39184cd00b56743709f5bd907fab73d90ef0e7211ab2735a62a05ee4367213b8591234d28ac292a430226cd862b26020182c4d8f0e1f6203a70e66ecf0fe3babb7e88b068835869cad0c648575933278ccb6051bb965a4fe4f5cb0c4956606e92b79f675750cf2ddb6f03444b8eade5c46ecf3025e158d02aecb68a8491fe0f5433e5f6526e5e4fc274d824917f342dfef3ed8750b56f1a1ada1e06b7d5609cf3e54ce70ae23b07acb047d806a474c17f187e14f104313cfb175745a2258b33d1e08190c8ae5dd621c054d3ff43acc6752df6e310c3d6c6532093190f52033925a46281f44591c02eb82ab181f3407dd09b8150ee7995b9d7562eb095b3345539cfb8dc0fc4ab794087026f28bf2474323a5b85a962203df6a70a782233d87e08df604cf053d1ab688c1e18e50ee737cdc18d548999cde8a8639bb2a0713d8f47ae5aef0fb870e91ad6991a8bc21d31e320e23f54709ea45127496009dedb970ca77de9196fbd54e6b1504084173eff072e3284cf22826ecce74166ce4e11325dcf5ebb6a50c6d258db3e9d3a10d424929458e7836d10704e27ed1d8f8bef7c819ccbc686de54c7bbee73f023a48acf3a0b07f690d5c7837a233bc4f423e16a5d1204a55b857cf9afba7f8e1eae5339faf98f7f4f73776e74c5ddf424c61b57b54489548271cb50e24fecbaaac622b9cd89f11dd96a66384a7110fb2d0728344d2e170dc28f767661c7b8b4df338f10d4a0e67c40875da373a5eabbeb75085636a779adffd60cf6ec97ea7cc9d7a44bdff01b87dddb394f7eea952d81c6a5a328f17e26d20823c791364c2a43106a4c24eec392256c1cba1b563e789e2cd205b1d5ed6883882aca120e45865ea077fecc4a830d8be26e312f643710faacf763212cb822705d39b65bedac0307a06493558039bc9ab8e3426fd34a6c9a22e276926a4ba93761855c0f20a0f5ed9e6b9ab0ce764e3dabed63b02b73d8f4d1acc446b222f40d9e78421331c1579a28a16e2faa7d00f49230d1f954c0b7db360d7da25ce9709a40fb60bb260ef69ee49a6511525a0b207fe8c4a2acf13333488d731ad0a7e17a9cfed76132283555e4838e9590a081ad20c2efae4c49a3f9ed20b78fbfab9b79c02673f0d27c844423dfa47846dbd69533ed060392ec50fb57d145f5653afd83d313fe0435328f2ee1aec4ecb615d1d5e7ba52224c2fadf0a41016979e43beb341d633da1769c216739b07ad82cb27b9a58df71365b89046c2d2517b306f6e9ff088f3f5ac2d8da4eb1caa9a3fb0dd3534c6b374e0e9e49a0bd0814d72c3628829df3b681640a0c2169255ebea3b54eef62cc0dc389112c6cb58498b83834cd7b51b13eca129fb6598b4d7735b2a20bac306140fe79a3a3c0994ac548c2660bb479be41691007f07583bced9e81fd82da28fde575591e4fa86c493b68621cbf3b4f77bbda07693d270c9447121685e1c732851e2ac0f151d856b4b060601c491c945f708c415b4a2635b147450ed99523c7fc495792ff738bd692a75d5fae45c244e69ac8c7b9196c10bb54d5930fd0d921e1eb441f2d47830d05a0478adc2dae5c63ab7e861a323f6c8b4439a359591b48474f4fd30780c8cb0253848a9f2670e8470906790d1d4dbfdfa4d9c27cc7a2f45401de9b16dfb6311086bbecedfbd18f94161151a3282f73d525e7c89f7974ed6dbe09c4b384a3259d7ea3a1b644aa29efb5ce897add9ba8f894bce139aaf4dc25d3a395d1276bae73373843e3146a681b1112984702dd4892c864d8892073383025fbf09ae1ad4098cdecba7b0093941de308818d2126a8f531a6a11e61211205adf31283a7d7c7bc5d4a25b1b5d9e2bbd63438c49fe3dd50269e72f9e4f5a6d47ce639d5c7420183d381fa2dd439d53bdc019f22608ab3cbba9b9fe4aeb6bf641bf49a7bbc001ef4146bcd071a5bd75cd1b2969b584cbb4cf2747442c665b9b1ed5e460d8ef02439a59d4849926f34792ab17f9b601111235f9808cfd36cb2f8a0c04af1d6968220407e2e4d9236f427939e6409ad1e380024277933c642da0e88eadefb1e6d007cdbd6b6e64f54eb88ee2fc5810faf23ce2853b59822eefb69eccc62681961f2ee404356aa49fdb5c13c99865eda1628c2758e92ba7c875bb137395e19302f8371e689c47f7a3dd0ad7527fcf308f77c4f4855f91d586007d914df814823526b511afeba17cb4c41646ae90582ee8e4c29ce4f47670d5f1e6f212002af149dfcd1e3959e4fc9c86276bf787d288b8e5577810b05a3267e170741be011dd87f814fdec5b217e07ee534666c344aaf9059100692adbb4160c73003b8cd4cff270b3aa49791d22efc11c4e027c3f786735def3a3f8bedc65399f43ef0038200d6cf29ac7878777d9eea0b158775a46e4e5935d542de2fc8d2c91c0ab780915d32fdbed9996c9e189b78a7be5475a2932424ca6388531d845aa7970728c0529af62ce416127eae5deade03199eef41efa318a9c61cead1b3fac5e10f07771b406d0e0e31a81474610bc03153e13fd1a70c394014f8a0a889c0dce22a4de000e9f72433f8c493cf11dbda6cf629ecce3d324c82e3bbbfab1fed9b30842efa66282fe1f84b59ef611be0453e3ee7ded1984fab084b32e481e2917aa1656f58ca505fc990d465950c0aac95a6d69a947bbfacbf22891094fc648573c557236b0dca576fd944bfd146383d7337d0bf287646b426d554622bb0fcb717f4bd203e70c451db3088cbf6d5b00ed4a3e1303e54dc08eaaeba9becf56da12fb1dbdb11e6313febd7e44e7aba8663abd5f7768988ac28d9beca6f479b9e07a56a4b10b3616fa60ecc2922441e789493d705fcabf1f437634a5066b68437cfee55621947405bf420cccef872edf15983c9874aeae944ed3e754f9e14ca5be9a5e0b846de8aa0002e0c8201e6f871afdf9dd2c7edfd568fd1bb5338b67b200b3fdd35060beaf2fdf39ba5f1aa916a901f865a32ce5d52b2be1fbe39911d75cdb82eb0ce94b67393f450fb8bc75c6b71561251ab1c8efa3f64eb769cc0bbf4290a0570d4a8ae6c76a4aa025ba29c11335210cc568adefb066c38c237f32011d018667be09ed8828f3f2bd4ac43f1d1ac5e0e72a2dae990da00c934e9c7e21163b96f8c4a0c6573b1d5f2811729f25def4bac723060264f8dc4ea4de3471fe7f2ec7072b47977fc6cd59d498ae611da499392d100e2c2045211a78220417533bb683fe9f7f3b75fe8d0982acc5d40198287d48db80dce72c01bbd1781958305cffa9040043c090d52427f61a4658e26a3433a9092802bb1d9d7665d999cc9448cc2ac733cc402c297908d2e3b34c6e2146aff88a6c5fb4060a3ad9e61fd6aea890da339c3a0cc555df4a33a876b2c6ef69a72d000b5f5e66580292559f20cf871c215ea811b43ee3cc7a5828c9e72fc28c13fee1969b5d2f4b4ffffe0873d6ca17a9debf7a2975f9f9afc319026cff9d4f7e0bc222d830f14ccade42a6b8e279c2550e0a9b454f496a2f7eda8b1ab4b430d10b276328b6db00eae66a22c9ca5724f3000d561b0e451204435de4346afbf7ca90c4b92f776f010ed9015e8c771e49dc08c330300b326bf70745c81770977b96ba70ac21ca78822c5aa90dc5fb9d5f276ae84d76806fdb6d84fccbf74ef6322e346c3af86ceb5f1b6bc1ac90021cb65ab7024d712898dae98c56ee596f69772939eb1ea7ccf3eb436f91dc7b09b34bb5dc29d708613fbd759c3204eb395dbec366bcb5b83818a6e025a5ec8e70aa813e0ee41f1598ae84950d189bcb123aae4714693300d3155e130a5d22086ed6a1f638856fb4386a764a8b8b34047d1747c085b055ea9b5f6265499eacd11bb14c4ef68b024e4ac3d014bb579fac5de8ce35657a3f1e8f731067d154da258a15457e028a40988daa01e2e3a2d6638543aa1dea718fe9e3a513a1dd01bd0450897ecb2e8f997e42cea93ea185e2a56471207f47beb6945894defa0d8d84a738e5a2c3d4b0ff1725191809c15e83c1fb7cfba8026df2227eecf960c7f7e4939eace73b09556fdaf7e8577a8dece444defaa9334a56d81394254931796bea70fb4ee1d1161ef5019ceb12114945dd5f45d3f445bb1268fc9ace90e33a393370d1c99352c37fa092c14d17acc594e76fd629ced1fee4281a082dfbe01ab9fe4060ed3be1c25d2a100178c12d63df410c06f40f6fa06ad85b5268a38a92d9e291cb072eecb41f0085dcb9ae80f69d55248faba0a0fa60f78e97236addd1c4c565296431ea4babb6e79944440e122166181ef57257dad72fa966fb151182e997f03494b879c6b93cc9ff9207e3cdbecf485e7dfe9fb33819697a1ed94bd127221a5edcc38be20eafabb12cafbb9016b26d4a7b209ac26639930b14c8b4a556bd3bf97fe174fe32f6bdae8601fce89c205f0dd5d38e9078e4712276380a67f53e3ae0e10ea962d47ffc297f52ce65679b596064bda0d8ea04132be35f4152e80f95e51c0693e20b48f9d9be7c00dbfba57f77dd9db929f35720225a4c9d806ca9b1ab29d548d3826c8b1ae2c19c222dab77c4292d1548d9a51bae7892ff821da89ae6408dba392f917ff13cc2775013974d4382d9b1af2248528ab58f8cd6a157b55c10c47605f7711cc73db90ff1e03cc927d0ed59b52830209c01e02bbca6c7f0d98368a10e3b1b4e317749d67d93def6dc25d42f06e71667af52efef8852aaebb50cee9292cb20f8dd04406e1f68e89dce55c07d4bb4cc8c87c8a91c53ceb6f354399e2349f9803014f984c96db9d168c4b27444cae654621503114dd711dedf389b1a9fba1f176673ceaad3a3ab532ce213dab13258c6fe1acb552a75a7a8e8d543634c10fa90d33381c8a524b6fd36ab8cf1edf253730ee5f704c2ae618af674f2a988c68cd1a181f1e8afb21002324321db1928606ec00d09d2f5142c342e57619b0c788f82ce4b2592e478c59f0405bc925a183492c19200520bd5fb740c710696f793eba864631314c278de0abf94e87f4a09661bce6f66d18fb13c9098eaf7a6c74ecce2f102dfa23ee13959da5cf46abccff4569e431cd4e1c77226dd17c2ca0790a3727fe7164a49adac60a194faa7e2211c7056d43595a9ccd67026fe73741aadcb9de416bf77567983396fa94e96e3f4b9a40d75ffdd1cd0be98338b01b3ca0bcb45e8b3834fc502f0f23ee9b040eb873b35c7ffd3bf01fd8df5d16f2aff4de752a77552f6eff728990127cfb3577b011e39847988311a6c4f849262e909a89d2eca071e5de8615ada24104403387eed15fc1b28d7387ba4826f69dfefbb5f2c197e38cdabbcfc6fc44f7bd969c16458e2cbc1cf55ba677c9fd3aee231b39abc150afca1b033f80aa1daf06ad01d11268c2547917a8243bc4de0291996a8433579917614d35a5dac2fabc2b151ad60bb311a692391d098518855dc7baceddb4935a3f48201a10798a256bac504c59728ee3038c7a4e73e6b7a3d970d416ab62396a7d559548885ef171dfd6af785130e6a2eef648c0c051caeb5e12298c9484b2a403f73198dc5d16ae5734c9f150618a809ce87723b1c6c3ec9f35b440beb497c898a769842b4a102bcf759852761536fa4b99ff987ae1a41f83f5481cc8ddfbb006e5899ca056eddb3c43d9a75f4f6d0b3b6374e00829b2a1c085cafb76d3cee13071cd2785ab64fba34bfcb8e4cd5dd45f42f80972d10f853b67cf5f3002ffa87a778b69739fd8b241dfdc3ea80ab189e82e59cf18ecca9176f135e1d3e3f772e2bf2396f2031796b5cf27fa9bb30c9b06dd3ad970fd88243dc586a04c17464d3da1802866ff56dee364057ff9f6927c5eb877f62e1faafe260b6384e04ed88b711c8d66bc120d00b2db852e1d0635da4e1aff1856a9b52f7a6163813c2299beb36d20849f9530ba01950399ee02637ec857239ff78106c916ba04cd9100c600600002e7e318101ed5c3702fe9ffbf1629f1ed6461b4a265c621bfffbbfcaf4bc45b2e9c15b4c6f1037babf38fcd4de3b5eec4f1a66e5f9d300dd8a2fc660ee4f82026091cb7e416c4bf6f511bd8913f1e1ca6799788acf24514750b94edc0e9445d012985d788937bb6729300485140b504aea6997a4b78c88f46bd07cc8ae34f16b7f43a3737c27980f00aa324e735012bbb6e4fc03c5f951ae0b5ab7a4b8ef9e154d4db5e4cdb2782972eb57ad33891f2e02c47dd399a6d9f596698638f51982d6d397f50dc69529ee60a7a40f8e27dac4907c023f88e86e11403b50f468460ebb32227bdabbef1de86bd9e5afbbabf50511efd003bd429b4dc77d702d3c648665f3575d433c77dbba79eb7023a9e7c2627038a6981d5f7e1c466ce8dd7078eda21536806e8280d7d5dff9ef58afa01e04e2bc0b06e74b183e5840a4b88c09ee7404d8fee626587b25ddfc4406cb877bd5d2cf20a14a76a3666ddd944112053d98f181a7cf4b985d8edd1c35b70c7a6b896b4f9b76bdeaff1cdd74e654acb8c67d7b838a467a27365935acab036a1411a3e50ac6bc36474523df6e1edc906ce8feb880a7cbec962e2df1d98170a14f5de6b7997cdb570bc79238d2aeb0923afb291f7a1c42e7fd961ad178b02355cc905a58f171f789303a1994a6d7e8aa3ac0dd8e85d21aa53d7811f271d456ff1622636048c1cba14c787af0e896e9aa3d35af71b58d7309baf8c68166b87fba91a62bc320cc56208537facfccb43ba4ffa77ed54bfce960ac17330ac523f1c061d701062c7a1a6d4871aaded163e388c979f5e34a8c4f7251a7af3e6ab8c31fecc5b0709c74a597a4999aa432b69be39379522dd32282131f73137ae10153785b972a4b359ec747c0b028cc9b5129739ca842cb8e1710af71d7502b83a2cd9a49dec790cea46858ba41d5b96f4617e1e4fb602dfa5996601f5fb271ae8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
