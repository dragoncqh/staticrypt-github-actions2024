<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c9fc821318eac0e6ee599f38905e13906cc8e543089a07179ce26477af8ee29643197a237a73f23e63fcc368f8a0363c3c995298f5457fc10313509e9e6774fa841b4aa62953f2ccda85d4b02634b5c4826889e765084f7dd13948d1f76a163daa2ff76b5b17d39284443d051b97763cda1da01b6dd549843ba5c86f19484192573fb0b3e68ebed0313235a2a928f35d5909c4df3f19c80407bb69a6a38144a1be2dc1c28729da4620d254eb58ff9902d1fcf46c7f08e22e2b7ac6feb2a1ca2eb9cac30d5b426f2c992b90aaa77f8925ff494857274ab20eb615255d7484fd798b076a4782fbd6e2fe9a4e4eb30dda9825e8bad95d7e164dac8b8c7674e8f99144f516315f391b3f07ff97c763ca22747d141c0722852ad185aa6aef934e0a4ae82df1d91cb60c16d0db2ed87ddbe2295ff4fb1fd6b641b3a2694000f81364b82c65dc2ea817d0f5dd3da6984212f224f2efa8fc1de0faf9f9c50444e76b52ff12670b6a00a53019fec2f140ae517828d80714c96c666c77142a234e68cdef966f10b67acdeb56a9a5f44330fca9a8f54eeee3031ba564a2ae8b02bb9f930e96631d5b04635b18c9daf0db437930c91f8fb19a1a9ed366188e0b2f33bf0d1809a85a485f8e8d59748b272df6cfdc0208764cb08f24a614d397efb8e684b4c0c90f45d508157f4f70e7a8fbcbadde12ce4be16ca0912da00d0803fcde593e610c9d4b8e0bbaad513acf3c33be619a53babcb8967ddd243dccd646254d6a868a7d23558014df1bc88e6f45c9229ebbdae9abe1d45f2c7e58edd455583bfe8fdf45024a1c7566fe5d1ad9905ffb571f106ce7d9f13454f6a148a766013c600b12dda9b3a5aa59fecbd0bd70b03dd2c76740e7ed08cef4e3c9bcd60856135adcb2a69c92e81cd23c12b7a65e740462a9db86b6a05fd4416502968f7a8a7d9754de5cca1e65cbc857d971e8fecc683b692b4ca76f9200f9ee4832a501f240961aef4fb5db9aae03c2ad20aa53e66169f7ac288c8cadcb300f4ed8388add956a33f94894e3933a59f29b4455708395bfeaca3d1ce8c82077ee5bb9c5c9e9b0036955bb32cad5bd0c4b144910f67f8d4b5e8da20613b7120730d94ce64845cf9968be787610dc5e8af4f5a34f71fcbe498adbcc783e1ba08c3c554bb6991e533dd2b9916da5441bcdb89f41618f0c03e895f42c8749fb85c41aa40c730fd714f68a8eaf1dbc3ef30bf18792b94a76c87eb32de66da92a83210086eb61c2ebc4b28d0ec4ba8aea622603ff2d2ad5b20449d5a3fca6f41425e4b38fe3a9441686eddf29ea22b253f8466ddf33b387269ec88d917784de16e7ce96d6eede45858809556e0264f4601b28e2bcbf84b2c3c306d7b63e90594973d069a866305490fd7f5ce9d24f5f071f3d3f3ffece618ad1ebb1d784e54689891ebe3d2f0f4eea864b7924cbe0a847fddda58865f3afaa19f214599580f5127b983ef11d8fcb0a30ca512550c449b8169a216d8bb62483f52e6220a596e9c2b10f6a40ae746ddc1d3434c48e94deba02fc6b01cbfc921f57f9440a5362b137f89a2ebf5185e4e1fd06ff093625058afb9fb23f74dde0542f4c40b5871b87d5cf078b8e18ca54d6847e9cd12a24a67c97387ea06a83eea9d59f4659f113f24254154a0ac6f81ce5cb8e78eb1d8d8ea473a2e7601c40d64733bba305b239270a38b44df564a999f2ca1a5b79512f1c9f1674cd100fd65f8ce299ce3c7a3ce71ee83cd687c26d1eda96b1641df2e771ac4f5a6c829b116a0fd108780cbfde567d3b967671368ed6a0998f79027bae9a1af090165fd653e3e07fc8a9ed23c65d235763bdd78cbce751d28801e4123236a454098f8841b7f0e99c17b82a049ff28d5aec6020a6effd79802ee19df8f784752de545f32db137f50edcf03e55542cc34e19f5103d2f0a61e3887d4cfc1224dfa6d288c2e2ff07a9f1b6dad4f91802890a9f34cb09330cf1cc76dc8740bab937976d38026340851399e5d352838e9ad9b3afb78a0d645726567f68a32c1c0a7913a76f133662990b7ad049088e11721faf152292e8cdbbb5d4b62bf936ad213c55e968a183119ebfeb925e251a754719543fb2e29db47d951bce826d8d1f450c7482f54531583226b96fcdc34cc3c1197167ebc54f350e86d2510f7b35dd15b4e506290896a1e2b49d88e0589453995fe7efb698332916444aa3eec5a5b375c9df97b4316bec435dacf6e88aa3a792086c9305f0bc08d55c40b83ff19d3d17d3a2315141fe7212c395203b63e25c5761ab65d359c7918fd2527248c5a5d2f62ced390766651e80bda3cdb0c0873d68333f0be72240a2e5e8267cc60abce8dcc8870b8d881c5806c932a05d62bdda2b0cb6b24d151f2bbecfe5edb795bcf5b076eb144b18aa6a61fc21983c74af83a3990521493fb5ce6701fde33f6b27a46f5bb590044f47796e2c40ddc963d94cb5683d1d2fe9164e13c4f5c8a750595b50027dbd37a660adc6b30f2e46c0110232eca934d49d5b54e4dee33ca37ccc2ce54e82f25126137a54652c9ae1fb4de38e89971600cf00cadddb778899edcd0e0de1fc001be9c8a9eeefedaecf8f1e72a945d1a662830f7bf612db5d0a60812f56d8df1ef2b6606c51ab519b1cb83c255c80817eaf6ea262c64409bf4de512a93758d8d9030b3c61fd3c419d6beb7efe57eeb2e13ab17649f1461405148722e7aa67b5bd3404f7b437e4c8c831348c0e079ff5b87a47219053e85416e1e9ca50985b0b88f2d713825ebeb856195d58454ad8b307634de8f82d905e7bced7a5620e3daca247242ed8761a7a58697b0c12d84709664c3718b4b93de5e16643e7fb9333367d07d5af4ecde8fdf1f4095e4fa5b12e0d6be05e152ebc40317fcea42994be5c0634f05e327af6ed80c9591c83ce152ac54731693d689be39f241aee1f5f97bb3bbaf4711d830c5afa4f99c20837ac2f15c7b7c25ed1128e1fa296183c2ee716a480abd67308734049356c3943ced475c1130ff8db220f9cb2b3c4cbb3d233627b5cb9cdde04896d48db9ae33731fff84f23b3134ebf7feeff32c0084ca2e734c6971edc32aa5e55869ddf44fe17c14ae0f64bb7103dd35c53a7c205e7a94ea32ae50840429e3b928f54156b6c9f943b76a275a19238d7259fe7d53311b0e7e35274dd1a2d7a3fecd4c94e056eb020756a49baaa64901510da4fbf1b7b40bc904f2b7193656f0b337ed52a7c063b8c210be84ffc793cfdfe2d8f00d3d0371a33d795d01dc7373c286b3b7372722c7998cf39605c754fedcf5da321fc9da6aaf3ea5bd2501d2b52fc7887caa55fe93c6bb8414ef2ba6e8d1282d70459be5890321e2fe3b4a0cff2da4495a4a3ee7264de45ce0eebad9bea5d1950f32ca80e9fea38fbf4ef3ef56c34476264b2ec92dcb1ef7ff6fb5008dd57ef369ce4facb1f4b656d98415bf0a2f50919d7d5606b51c95945c9de82ba042e044e5b28ed07281d755594c7ca6d612acb65b4196b19981b5ffd122d1bddcdd157c707cb9fb32294654e5c3f07608712e9e67ac3549cc8444b4912413322aa3ce75a1a389bfac8ab77bb44fb1c02df9ff1cc058a9cdb1b35225188bb7680c0ff07b4be292e9e1e26055806acecdfd70638541fe0932f4bd2860fc1f07d0fb49d009f881e977b004cd0b5e76a96b7e94f587f02c8cd254e6fb54d7905f35f47f71e3719104b14b03259377ee71ff8d3818bbd00c466b44ec660da3a3df8b2597e8b44fdb9f3daab3322dcb4c0a5ae14b8069dde0676b97b4681b4aa7b738d24277e4b0459e02beec4fda8c4bd5ba44e56868c7ca0fbdfc457da5662cad2218c72208a1231b4daa0de5b1fa9d6daed1e9198899e02b5d3a4bc9967f62758ca26819cb87487caa1237cbf2b2f3a1e8a03433517dfaf00e671bbfdc52bb5dc7129e66be5c3d16738213ef749e1ed7184e18040f71bb474d9314ef1bb0607a12c745e2e60411a28a8e02f6ab329ff40458c23b6ebd2d349c0c31b7c98274c1cdb81f29f72a0172191e3668401852d22140c5ad904fbe2ad7f714455b6480543fe626ba3a2a55be070e560db1814aef57be32a5672a225008ad7bdab5a6470e5ec94502baa0bde5adde2f4e307dfc640e39c60e92a68ec9dbf6e63506e893c6d9ead1a88daaeb6b79767c16a98ec2b6a8f9c418926870b57cd46e0fdc40837a5f64156ed53f99fa4bd6595f2ef15fb6f34ab25baaf70307df50054a80750abb42da584b56205ef5c03ba7035aecf8ebecbc2d16294dcbad92e08858e47d6c42b82413cef506b50f0a28f72e3e43077120346359c481daa038f2f65c578ce3cdd9af3c86fed72de54c4f536eaaab7dcc47ad59204e16be869d6b75ededaeab36540bb9161e6786a50809774b97e3a44a97381512e682e6ce9c9e5ba7bc21c0858ee1ab343cbffa0c84125d74e323121694dac771bc03034ac54b7beb03afbeb99acb8f6a13db971f09bf1c2d47d9f3c2c2d8c97a8b4ce9e3a977bc00de2b97ba8713eeeb7dd04122eebb401eb532e9fadf3c23fd0d35c275b146baf1525a7b63ac434b38a7eba809c8944505bb6295dd0a40ce4fab83c3bd8403a0bbf76bbb1dd59e34c989f2b1b9b8a5add1682fc9ad2b20e9a16d8ef7d6510e0bee7b53787ecf7ca0cea74c4f0f379cd6c60bd4199ceb6d84c531028010184f8356a78830600cc302b694a0b792f3345b2507b70baa5be61953e519c4d8128cf33515b83123f24e0f390fff487775d2abe8b8a3fa4b2bea40575a0e0d88675d6b5b9f8af69dd7bcc8519ffb00685be9956e9e1baf4a58876256bf28eecec50309656485e712e1d081b592488a6bc3f3a0edba99c04b155c154d8db0cfed7418148af2a569fe3c1e348826226558ceea016627e27e6fbdcd3be9caa99d7ce49f99880ec85479ccaf28008412c1a17bbab73a30b07eb655023ef0d8c5719c3ac9916938a1a5fb1363ece45d612cf0f88ad89e5bc84873f887c0fc6fb217cf9158ac4f5920b3c99fb41c4b3d455102a3ec6fae796a6718d1d1f6c6efcc5e0885fcc68bb91d7f87ca2ba530d0310350af90e650fe59b18e7d26dc8475252081bb51932f3868652735b7b1f838073c06a8781751a88b8d1d20c597d2ba7aec7770940eea1d538dc2bf8e19ffc95e45167f35f5d1df5c8709c69876169bd822d0e8e7d9fdcbb71755d082e69054c46238fa1381e373e0e5c8833ffee4ca595815f80776c65f516db990c62b20511a087a9829e252dbe905b7ef68632a1df5313f339dd1d0c988ab13574809c204b58d86b231e0dea8b0e2d5812ebe9cd8639bcd7c2906ceaf762ccc5a2c96d60cffafb5e8ed9c339474baadde51f596abafb94b87255cdc9c31cac0bd1db8c844962e4a9c8dc8321f529e4cf809cde43e93d9ab269477a5940effefbb21480e93f712816b0d89d061da42cf82c3221c3cd06c37ad27a8dcf6288050da6d1115755ca265f0fb258a7a35eab3c95d0be0753ce7aced1f4e6b6fa2cceb00489a764ae3c7bc86ea99906f159839a13c56d902f0cb2ab1ed0e32ee24785951cd145d7d6518be21f21aa9ae4b9bfbb80bc21b057b681d6bc43123cce41ec0933f817cbee116e18cbefb6c784718d9510e5331c685ca33336ccd7dd4536497835c006e03a2906d519d557b92527a6af2b98ec05ef9fdae912a9dc22b8f34ff98fd577ae0a4aec3a461f9dfc683cefce050f35e6f367ee9f18e8bf148ff7c19ff654e77c2d0faf8eee8ad77df3a343102428b4c711f538a0060b8bd9c963de6c4dd865b67e0df9758e9c3a78ad7b1f8215ee4e18e3794896b4fbfc90c4cf0290fe0647456bf05c8e01cc01ad67cbb836ffe6421762a16bc65dacffeb03e03ee6f4d1d401c25225cb6a91b235a0b62ca4c81fd0cf0c571423c75b167d7c0eee29c60e817da4fa0b353bebe05843909247e328e5b46121d61dc169ad810253d7ed51a0087104adf5f7bd7e666b83a7378f3c3245fd20e80960eed5c01b8885c3d3855fb216e0a648d109f4d77b08aaf6fe706d9f4109847140277e7ab69d187d02ebce45f33573a50150546554f32cee0cd52098a10d2d34334e750c5d9a539d0288c6023350da1c87f577989f4b42f48329f3c412042ad1d6bd881c1eb9c01a1437c404af75151d06f18acc4139d903f5de9c993e366db687bb0c04dfdfba94399833fd2e91c044fc38d75907b22ca5229a6d0304493b408333a01fb6e45080b1087b5e57031d161e322fd37c8fa6957b38bd15dd13cad6d76bee82b7307970c86714bb567bee9f57e9f20f5e99ad40b8ca7ebc4dbce8e5d5e24adfa0ebd840b12eb4058cb213613c797b5e029f0c1abe55d1ac41bc8c7cb455105fc575c0c6da139895d9f35dbf556502eef491405b479b5cea9faba71f2f94f4b18d169936eaabda86b4caebeb4d77ee047db8f624a605929822f7ad3d42615e9a56d50660579ba58dc9d412416cee924b62d95b7859c5bf4dbf39da304c06905c7a34e7557a59fa6ab1eaf572cf19bbee7b417068b33296b48415e461f16314b6b205ff930159b9dbb62cfd7f9ec2b56877efb27b7c0a19b10c385ff14c4d70ba6e1373397f3a68d7c8f152d20b13ffecf0b0a3c22de0ff1f8ab7ffff4a51d6530c285679f0c1c289b5c370597704a6cb2b8b93dad2cf7261e8268edf2ceb8241b83eda62865851ab796b67a1ceb8527362cd2324b40cd1bee006fb41ac20e391e20ce76a272f2a03cca61aad0ed35c6f8d36e46a227ab2494f0c09aae599a5f78fc73132e9b344cebf156c98e59fd98f50223f35ab657e4e9f5224dea70a7641c739c9d48cf9032fa2753df663aed39afe6132bb9b48854c18fbe5282d97664e85d3a34eb95473e1f998dbeff25edb8457f30ed995ecb83e89273fa072a67fdeaf79bcb62a041ff4b78eb3e77fb024b8953ee8938c2b9c7294fa3d607f11e57c901b29d7ca7976ed283aa590b25b828a96b4fbf0b80f50a9a8bc7572ba79bd7c27a0d7912b4be5d2b43793bb5ce7205b7fa4e9692612ab9ca09119d13479014fa36fbe62a0afde30b67a26be83618dde1f1b65bf01d45c84cac5a7f682f69ead14c6e3f3edee6d886e860f14e3e62355fad1755effe76f56a290ffd2526c060c866df84406543c98730fd71dffc409d8ae4cf19499be03ee63edf5dd497089fb9211976588d329643de65cfe13fbf8ad577e5cde0d764900beaa1189d7d12f8e5ce70e75a529b17a1b4420a2af695b287cf66f4c46bbde7e828871e63c0c0d294720afe5d48d863af87f0e5e21b97021ed27422220ab0b6ce362533391ea9f9a8e2673429e0a4158cf2b79d490b0a59b27a942ab7530e5623e7ebd9da2958688129c1b021c179f53504a101f52877d2e1396e9bac9b098830c76c7342f0224f652c37910cc1eca451305d76e486f0ebaa08365707e8453a480fbb774afb22ba692fb34273280ae0edd6b43e837469f00d43b6bbd930a3a49718e620f67eb01719f3a285464872e7cd9393c842a0b909954afd61745afd012b5d7b38c1049531e01934c2732f4440de4d02f3044779669ebc905a3fc197acc5c3c786fcb30facd47e40f3a484c69328c8a32fe4ddf0d85eb9b267697c3a5aef64571429611aeb93f726b266c9436f342c243a682211936fa80e656949b39bfcb3567238ccc127e5292dbf583df8730f3a3d2d47017bb365c989d9eac9d2c6098c2ff6860093fd637187a5ca6629804b42e59b0dfba8d088b554ad86107f9991d57cce9be49c5f53ebbf309162c6e6bdc00f8db30e1a1d3df7b8b00faf4a5a9ac402268569ac2f187744484ce71ab9ce23c1cb3122f7d1e29b7231ddac428727149210271602c0076009e3b59bf187fed6194c83f0c4955de32101a588f5c114849922611eef39078937818ec31efcbb95cb0e25ee1dc1e080607002cff1149b66f9908cfcf9f17f9a717adb7bcd9270cffc27bf80ea4d9215f105d7854c134c27f256436159cfa5d21723d0c12b5a91263a0ce4342f68efd1e9d30fdd453ae4190e5a475f7c086103c93fc15efdced3930ccf32c247bd06fd43bb1167febdbe283301f06632b7f3585732ccc9127bc24b47026dc21642d2ce7919627911b37089e041666ca29711bbfa2a0c47d4e02e6acf4e98437e7a0241daa2d84b4585b77e2b098a8a3163d3d4d4242106336d1d5a410f863f2eed7cbbe27821259f5a28f1939397e613ae55df0d59b6d111a1bdfdc17fcccce80e45fe3d3d285b83e5810312adacdbddd3e5a44c592766b38f8ecae6d41c734551632686aed0715d4a6f37952c441009fc0619a36eee8721781df3e3667afbcc1bfa8a01d24adfda4a27443adb4329e4180982d51ec47c409b402c299fec3b553be91a02d7c96cd447d7a088e6d507d3246ee1e4356e607af5cf67f895da377fdc8b21cdc1c32bd3bfb63cd02e551fd682f33f9a1fcd812b580ea41f81d6ec581f6b1ec4f46a995e4ea0cfec29e52ef1a633d948a78b16e8d5bc955d40b8c27d96f92e7a3b3722e8aee8f64e13126cbc01a1fc63e2e6acd326998e6b58cd3a53af8dd5cf9bfa65c3418ea21171858cd4eacc67a796654378fa820c8fdfb146340ae47b5d977a813cc42d99c3f3aeae721f7a1eab3ff0bece47d63ea42df701d508f5f01d1d3d97a61ed12a8ddbbcce8261130dd3e783479ac54a8d116836e627ef5f0d802f069841b1ba0cbcd2852dfed4d5ae8eed9596cb57a81a6f2d15741e97db76332b6db5d765be9affe7b8590fee6ae569e02116c83706b0480c33823b9e9c59be83185cf30bb2ceaaae9443dd02cd5af8fe5db1b21a8374b96a720ad98ada9d949bdb5483b281d96eb95a9b25a0bfa9e951b0d5732ee54cb38165f596c111e0012cc5134ea3bd367fdc5bb0fba6a275181f106ed3b1f17523a1b96093be35408b566fd637f665c632396d3f526b74549273576ca753ae8d4f1e13b9e9ac4ba9d050f06148caf70fa02701c2eeb399cc0666fb357b1a5a869c1ddc3c627e2396fba2246f69b44c02fcecfb773da28193638ad2517e5a9fa03c0a20bced8e2e0ec65e199492ca9513509671c8c9217b46391b0a9647db0a454d00009305d8c585e95d4c720df62a16088939df27ce8f4fd66f57104df89e6b57b4e7cffc14359682248a181ef6eac3e6e220238ea0d282e56c9d4ddbfd1018d9fb7930171e5f7b3589f83d4aa1111a1c1a30bd99f676c9551127cfd7c18bb507415ab11b287b7ded9e48d364684fa14f98c5d6b54456e9119b9eab2475415326d096703c09873336c431e3c0cdf344e719648ede1e05df2dab06b2e6a1bd3a0dde500cddeca9d360bd2f2836f37d178c8110edee0f64da533dac5a2d1c4d031946a8733473210d1507d6f9508b16689e58255ad2e9f259ae9c2292530ec4b2e2ed1ad33a0b3547f3b3e4649dec7efdff3ec20b0a80788f5ae49d46847a7f377c71e8d65a4c6949ee05c7af71038aeb4261169ccb73f693a0ca7df99360feb093fa53abe6f7cd3eec089d9fb6d5b86ce1403043d48756608586fe6ff527d41eac371334a09588f49c985fba270c23398271f8869defc5811f1e06e583e867383d8ec18839b6184c6dec1bc1a677bcb88ebfedd51ce825db5d33f19c7667d12a77b56f06070f2a7fef2dfa87e1f898b36b92b6040a748724116bf90590184eaa80b4c3972d8e83cb6df095f06a41a57d7714f85570458e2029903762f3dcbc7be5b7aeaa96080661e5608b410710329b3ba765198f79e58946e736dd7bc070800886de150cd34c1848c264c40478c73db8182d1c42cafc65c4eeebe99cc12317ff5ba808f85b8e830274b095caef43d730d004068121f707e98bc2c21b1f019fa1538cc69c90065dad6ae3a3bc9fcb07dbc90d263051c8afd6d280c5007f1cff08c2e823ebbd054f887a175e00a07ea37a9eb746645e1aee1edcd99b98d0bdb433a0276cebe542b31084ab6112be62c4a2000af58bc5e6cb61b117122c0139887e7f0eec4641b9bb0245fed2c49026ed35d508ebeb4d06c8505484a0327e21c96fa8cf7510f1754874660f8b318cf5937de651440f349b2418d124b4b1648d78dd71942eccd00cec011582acc258aa9817b40d903535b59dd7febda8346e6535035e9fc9f9df82de2e076ca5eb712f0492daf5faefbf5e00bc2e01ea8c37d4605b1dc99af8c2c20c38e86e32ebc50237e48eb5883a95e938a5043376f3325a6c243d1b044b811128fe103af60fc33ccd731a7521526cf89f95af88bacfe2699f9e41230f54d136450a4d386c4c4275f271498501ac141f69e51a45f07a3d7856bd04eb21b2a520fb449f4a09b253cf316af4468de719ca9b4eb9dead493c09399efdcd68555faf5b44a36300266dad7c6c1afab74f7eb14ff088439c620cec2990b3870e96ec79c25b8164016744fab421f791f36808ab9d5f468a5e6d129dfe8fafe25d293172a309e185f4f59c9998181395571596a88c331498879bd503e57debd1d30c7db505e39717a69b91a8da68aa3e8567dbbb55d30a1b8650914510a0beddde3a2e9abbe7cd53ac595fa4851e801cea3fb63bf7763205bb0b4706046347b73c3ba66fcda628bf3fc26633fec18ef89eed762b5f33b68705fd2d2b28a0f578144df036ef1036625611328e18b598939817e427249902c02bdaed89d8bed7e0768064588f770a3a2fa8b4c320d0cd41f6687da61f7b022efc7118821376d16138ac134058e839d08e0f22aec3092418eb9a7ec418b7f52ade1c1494e069e076e6bd4e20fad09cf023e68612a744efe334c05825df62f6334f4c32d3fff2db99b83fec2eb1ce35f93752e59a384309c3fb1ac174c8c34cb357c33934bbb7bcb499345451de7c2190ce52668b6edc8c216ec937b2bcc764de4b1440e7e387b7a4f66b3dfa45cc110b37e03125b1d0b16f04912dabbb46d6557aeb905a43cc13fdd56f038246ef389108a5582742c4a06cf10e362782a03d8626148ea6f508ae32b0f7fd9ded3a741fecba7e8e159e46895d2ac7097947a25290c9662afc8e804c675ed428849a3323b84fe573768a4deeca3af29dfefbe09d10fb7307e1a44793508225f22d1b0d42e0d5e452563dcd69eaf101cd0fe66f42e349ff85f4f870eb11a1f79a4a06b7c1bb352623cf15261b145689d97e1a91799c6614c4061ed503b9f99f6549baeb6183f190c7475a0b080537f7d12f7844a18a3d83b646fb084da0999587940cdd0585306b8ef73b2fe72a83d17b9feff3eea6c704f167faf2c460af489b232324a3bfc2f2cf00614cd0eaba433e49aa1e66fd47c9c14f948126ed706b5b081360baae132d40e2abf22e87d9fe31fe65293966f166b3cedb033b1d7ff2e5b2d4d87048a54845d4e5a97bd9d4a02a52d36cae4468cc28233bf27735938852f375b1108cb01469947ac18722d21bb02471b29e8f30d1b6590fe9f65268ad631cff8491c30000e83f5d6949af8f311cccd72bd8aa303e29f9bb1b34aa4bda0eba52faa328b0b7c5000bac616dad84f1745d5792945da6836c8e7c8e88af3a7acc9d27444df4138683ecbf3409b3905e0e3d3093596936f73bb1d51bd4ad9a5945d91400585cf48e54b68f6740885e4ae80d102e06a17a6ab27bd630d097d1bf229cb11ef1b3c77722d49647562c875f4d6c08199de0df386e98008e4fd9e2426c8a27507102fb20253df4aa34325417af33c717cf67613d3384073d15372b36a4a9806b2b8ff98ae35d6c87c95c783afba326e337b7beb17fc0218c3ff910e3f86173121e88c5d1393a87a169d60d1864a4752b53240c11e4efbc7426ccc266066ff7374e0cc34ebe26f2d36db3610e0615fa2a2d17cef98f17684a81eced5366b20d991fdf6d29175459aa103042cf9770bea49779823646a8253deaa091ba035342be27f412eecb91a39fc4bf7cc1be75638f2d275fd54d4ef069c7a7c36f16f2db0d0bc02c9ac366044f4ec0cc0089c59281c8de8bb5a4a77bee5fef0e396c6f0703b9c7e974afafb359f41bf34ecf202c04880f5b1cd2d6a7f7e52221c5d007d864b14ddc316746aeca2001b43e8f6ec04901f142029fd5018b6d5cf7135ba6bc579ff1d492bb58374c7fa72a1ca1c36c1f3c01b8b0a2a38e86c71a42a0f056df2a2133de8c975b2153ff9c336eac09ca0c3721f89a5464ec905e5b7085be1ad9ccb89b49e335645815aecf979342d8d46921e847d87e2a0b987db67728eb18d33fac1451310597333372bdb8ed9e0990451cc5415b486b1da1cda1980d93e09a076f5e62a37904965e0efd54e8433810afe98e4f41258a991786b74e48ddb89c2ad2c5f5294a40720f1b41574593aeabcffa23654df5a63038c38a975148443c49423f0388cdac39ea32ddb98d80a774181d9d1b1185a16df2b7f5192518efd952a972ceed112a412cbb354a4a84e1af8143ff0c0796596c994eecd06fee5059d53ce60a4a234118436fd8cfb3bc596f503b0d94338d2a1f3922863ab16e137bbecde07ba31296993e4b5d7523e31d0430ce8326601ab8b24e7ea413fc6252e8111994b2d67a722d33bc8fef4a5e24bc80c5e004b460395f694053a23f4b0b563f90af76dee844a7edc52e4ef4202ba2385004c362d0dc3c2256f236a7a8872fa1f34d42b412e705c66a17a89a091e45f5763ab6da259b9b4de66b824374e8e238089b251933e8b7e237549638b026429400c382e608996defc9a2e9e5a8bfb9732486126933e81cae034be80206b5bf025c821bb8dd6df9908a0467b0fa1af6b29b891d990b9ce96bdf5e56c965ea954494718b19bfb062fff04a2d1e2c57d7d7b828bec597b2e56f213825b3d4af62ceedd6dd709705ee1ce1d5fc18930d75247da08c42d953e86a21c1847beb838688955e57a2808121a6be04fa34c4df017426108cbbc2929b12ade4db10e13217a39edf88006c941425b8172f4aee04e340ab975fc902d47c670f5cc235468994fa4e05936d4a33cc8bd47b4e176a91029b999ff7bb513ea3d2d675bd5d638747fc9ffbc21b2df9e4c21a6d3d262eda26e40184791cd04d90e2b6dfea93fdeb75de2eec8824d622d5bfd38fe9ec1cfe6161a17797edd0c267b078583fd62356c8751a2002696e0e8f5b77f7aecfba7365296ea965dbfb707da1b736f829e9799be32394734df24e8ef4cb3a803b408c7b20b1ea1a8fd95b132b801b5da404757c11391f4710ce8135d0ce940acab0b672336c1341123622348353c1e5959b7567580f54c48a36e66c979d7e1b78484d5e639bddb7f1ee0305fcaef077b7d924bafa50370a49b3136f7e2fda87e3443fbef709ec7d7a6434e70d60566d309875ab2aa0ee61481472897598ffd0b9554d1e726307ae88a0ae16f3e40fb4d7c7be906b6ef4bf4069feeeab20e371c02b349cdf4c9d9632f8a89eb3fc29166019d17e14bbd8cbba07c33f3bee41adada20196e809fa90d8cf2c6932c3c046ad41f69c6b624fb33f2062b3f9efb28e3ae131050be09d859d480a55e776cb2712bc31981cb88ecf96590cee76fbeba73944c31429c6c8c0e88af64033bb760f04e234e76ec87e69f5668f40c57c682290fbf7ed66b8a59f9084e7593d1eee4d6a2ec1016b00cf208c7e44418ba49afa8738408abf3d83fcc193e21f98f71c7ad54f38fe3faeb9ac85f8f743b14ab2aa337be52039fa2f6723c84923bea162e99cdae768c9a2b6e860d1a4b1eceaadd66dc41e39655119618a3badc71a8326858cad4ca0148db7259fd7244d5bebb8db64aa2a89798c84cfe7735c8f75a995efbdbe691f2c030fe5bcaa2449b58b43b308d2191b873479b3295132bb534ca6bb002674e6e5389dcb57327d7c5b22b27d8869aac771a15918437decff54b7c1c3cd0c9f593aa9c37df99e3a7fe8b8b11d2a3e5dc75530982f4b95af7efbd1f36cb22edc2ba89d5073f03b981ee1f45deb35ba9c506c2717c85889c4d803cf82a75aec8ccab9bb329ab2e4f93ab6ff236754987aac25b4839f122db670a734a20c621609cd9d0978b7d01ac771707a984e8b4e1585c471a0a44c228d51e756cf66b291a45c943377f41d5d7108af5a8905fea4f8ff7e027ee0666913b5b464f053a757dabac510281751c2172d33ac135b8edf2c48b327878a3d8e42be303033c5e62be67a711e8897b64b48b2c4c265d9387a3978a25c3f2761c7be2761e2af062f8becdcf1d9874c59df207d979a56e4ffa6fed93312c54734235ef82d36a0703025858d8c307b181fdc10669fc2d94a842142c8345f14c0e42b09002584c7e59e95091b49f26798da32226f0740b6df611486e4d2767bfc79d8e4ab68c6c746daba246302241bfe751f2c7e7db717a4dd6978f61d22c117c249f05f8978327eab4ef3336203947b43c2de59d2b0570869688289da9c76d09499eba43ad3d0d933d177c5a765f467c8a5d39a29c47a91939288c80fc7c408deeaf65e62e71472bb67c232c1154f096c6edddbcd538134b960c717c4be9620f76b0a5210c848267740c16709a0a6a0a2d861d4d25630652ed3f66e75e5d61252ebd75120000b05efcee5054614524069e8e507b5149099249c94eabd8c97b659ebf7ae54cb772bbd19683bf44336ad73995e88948de09271c5a678e1d031c36941e5decbcd9c6017b523c800d2bc3d4c6a2bc63f838b4d1c94aa1baf91a405887ac1550dc2d55dc74faba2abe11799a00734d5da0aa603313045e697af6642a47229bdb9107efba38527b5ef1d03e13e561f3de55645c41cd4bc737eb944f50eb20f77af164c9c442f0f9b2d9317530f800fa520c8838fa6839fdc8909d301908c6b6dff4a6837ae866005719409a5e8b1ca53e08ff6a24e309a1476d4eb1ab8cd82e2b72f27ba79b8df159b88205a8eb4a9fbe4f5e9607bd4055e82a190ba82b1dec2ca4b0333e4569f9bbb25958f0b544feba533b93c01c6243bfe8d1ce2880793d49940cb06447ee39a9d21433dda13323bf14caa2f5ac080f036866a00a888ffa41","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
