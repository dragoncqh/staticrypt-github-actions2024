<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6c7fa9f30c5c60188b17015992e7804e325653403e68cfb270c381e140110a4a8b44b9faf81527539a3f308abd3ff63086ae30340671f59802ef3fa5ec8e8b9e33fffff68c19c237e9c62fcaf99a7973fa3694e2a1131a11e20778acdf6daa3a63a9dcad44feeeb5fc5747234b6b8fbdb0575a5b203f6602a914976a735e995e1efb10bd98df2413a1bf12d088cb8bf9b3b3f9115f1ede2eb9c43e570e321b56bcddbda3d933ffa70aa142104d3a38c553c00f09c894b968c8050c12eacba89cdb81aa91c88110696514308b7029875cb70b4f6b4d49181a0269bdfad352650052fef8f8e66239302a756518046d5a72aa8e85056a4bf7aca852e6a4cab8648eb8270b3d64ee8bffdcec353d81ffc7a444348659620b2d2b7a053f460eed132756d7fb2e11fd2cfd49be0bbde63e7c5c974e5981d5ba3e68e519571d2c9441338d87dc9524140cacaf2559a7b284f7c34d690d7596dcf1aaaca30d3a913bc15a64859632764e8c8c2de56c13368f2a5200d260ddf75618a4b56f7dda85dae2c5a19f5f68da40de969b5fa1e50af54d6792762d9a7b5d2898f674cf6af7f55adebc9abb1180a53d3d756a5fb69ad04c88c119d6785112be4056fdf71f4209eb2ccc4456bc45398dffde92c3943a3deb73ecabbd6dd6aa9488bdb900cfb21717ba6cb7595e927d6f3c4ba80d446afb12f599660d35f647ba0ca48c58b923d0c1cad916c0b88fd969b695c1f284794e38caeb2dfa25a30f54d56a808b36ed63b0a700074eb61335a092197d8914f081e17fb804b2c57bc31bea680169ce0711e794c3986c0bff6d12fa160dee65782b05f57353ab9edc64bb8e3664930ad7562484f8497e63ac112b680db30e218e4ff1d647f3190f0c9c2743e67c67e68cfe88490e70b73541e14b7a2748f118c75ccc913d5f40a87eee5467a8acf501de2a6a9aded57c793514e7d0ea08d989a2e056e222b7ca71f6f611f702824fbe23cc0afc2997c4bc565b4069de68b7a425458f7b451f4d2dadcd17dbcb9d1af7f590ffd37fa049c1c18ecd867d4ece1130ac3ccf12cca604bc27be70ff41a8357764b7387adb3e72c45612231796681eba3a47de54e683697a7575e7e928fb300ccec74105a570706a7aede1195a0417e255889127b6ff233e9c19e500cfc51a84efc7976932f5324f166480f2e8f73e522c2d46b43fd51172220e8385ab4555ffd5b932594a9b80d8d07aa36db2f2f4ea47617599ef072775379a69b2964e5a851aca7c0fa7f41f383f90a88ffd7fd52b480853bf23771c703f924d8eb02b38418a6390e6ca4c28fcefcb7edb409cd215c0b7809550a0e8579d7a752631eee19bc39ff4338b38fd35d5caa3308086af2ef1fcd6d7b757eda50f833d73ece574544f58a91fe5d750af058672a5630bd4ce0c37c2feabca52e1c20dd44045bc2fe345c33b6fd0500f7c0102b2368bb528dbd6142aca8a9aab8090852d0280947eafc6d0088e4e84fa1d78d3b9531af0bb5702d536194f4e5d47f8df453c7ebb054b7aeccbf423b11c5224b79da0c87fd6522545d01f97903e6b57c274e8f34bf066d6bf30fe5552b5e9ef7b4cce7147856f58a19cdcaff655ec8bef9e4138fbe235970612d6b6a7a7f5d06a63576afd1e856f06786e0f68735ca6c184d60d0ec4090f484b05af730ca9910ec85402e77ce6cf03bf14ae73223dce3dcc913b7fd613797c35e081362dc2f7e155d46e08784c1cf8d4ccac52e987b17410a875740bef80e9bd15f36eebbc62ad69b7f62cab679f21cac3d2d45ab0a7c09b298a542dd90b5ce8ebca5f7a5aaa5fdd35ba52d57a3a10f1ff353c2387b944d24309772066837990b963606338d77a113450495a17ccd94e6bc20d78b30e21fc9b386859d9b1e4887b941a54646164cf3bb0e41db23c16b3830af46702f5d5d6eaba48c29dad3ece789962d078496f27d7a86eeb36a6e7dce9d615f5f2e0cc7bcf696d6b206adfa522f27fa569c25577d8cf708338e9a617abd012c3148341079ff864bb83444ed909c2f9c327839ed3e258af2ed7b0f0b218ddfd1bb946d339a4e3949cb61948fe5489f7f410457cbd23111649e834410c163a4a7270e2fe9308c99235d16d8b35124a0dede290921cb53de902d6cc1c0e040a87de7e28ba8fed89fa19c2a0cc87be2b5ab347344ccfe7b11a51466a7c4e0e21dfd0921c9e4248e83dcfadd100de62ca42f9f5ed730e554a534192d0c84da19250910e24150c32004fa9d5b12f5ea58ad8fd6a18e86a60d01c64e4318cf09a790d177aa09f1750cb9fb15ff2da89a7826f64b98780b2e3a7ffbbdef514e3f74ccd80258c645023141b21ca9d5c9a2cfdc43d8b6829baaad0f0c0c35d65bafa549932df6c5bba1738d4a289de20f6345c3d2acfb0233f057620f718ba0aa2848d7c7100e4e63bd7919870df59e4297e31f3f4a0025ff1b5a1de0c4446f31957f61c4f1abb09d26a221af3b50ab702c63c99ac4e1041993ecdfaf627071d036823d1bf227251e467946743364a8d4111cb9efe4b505f4d846d4497c529f6c0531ce759879e50e653ae6b4d9ed707152d09319fce60ce10133ff0cb8c651efcd1e76ffc703eb1cb8719e2c403089eaa50c64f93f4a97d51569c0b5dde6b51640f1b4f1932475f1a740962b31eb4c8ae6147b5f14eb2abd7a06d8b025a632e0e3436ddff7ee6f051d36588fb610e048116e0e05dd4103968e5e786b3d64ec4971c299cdaff51244a861ae4b76167f9c2ff320ca4fb41539957c51c32b5052abfc7a3a237ff837eb64591337f55db6e5bc0988a162759b00df12143d8489909fdf9104b6fe9ddd3e52a4cb1a047545a32eecf198b8839cac5ea836fff9cdf21cc1c721647d8f26e8fc7953ad063d51cd27abbd9ec7d2cc45a3cd480fbff030fac5b8f64a521c81831e695eb80a17a0fdc82a27c445138fdfe8eee678d8f8831de9da05c3da9eb435bea2cc0ef97c830c2d5a231d8e507de1795307b84ad25463bf9ca9e2af9e9e83a09d0f0c50ab8399d2027878537751ee4cc198159c00a8bdef15e86e396606f4e0430cbc8e3e521d0401f20df235cbf8e75a3ae4a0c92d36499e3ab9fa3d6729d2f53cd8ecce6af1dee5e42a17da885338f5737acb612ff2fc3466826c5ad314db0a2f1326aef0f5e392171f96c1787e7c40ab558a8f23785741c61fcc9e7e750f3c69d294d8237107f622a8dae487f72771c82ee69f9bb99345b198d2d17b16810841f3c3722e9a8be952d098b0ce4e033d37a915e3df0593d17523bf9cd4d5c885cdd24af4aecf9987be96015983aff5695158b3e6073d8d840c9517285100ee19884f2f00616fead8fa1c0914a2c59a90094652c864b351084527f68b3dc61f573b36085427ee1645ae678e7a0f481acb816b5c3ad634b79b66ebc89e605d5f464c707c8cf40f6e5c2ae6b03dbf3dbc7c56302f63a773713556d8e071c5aedf1126da8d6268613ef9148dc1f33cddf0bc3f8281d6d55c8f01d7ea18f070c538160be5a0bfd9037862e49eca4cbd64d5bda24bc8182da04117ae5755b334c60dd4d574dd60a0d46d666e2e8a56feb63330b93e01c65bbc329c29292b35bbf71661dbcfebb7f68ba4c03598eefbbad5d7203fb60e7722b42e5391f73b20d8e1b26d40ebd3d9e928cce80c697d534a743c7441c7d4506902b7b860047cee06bfe01caf5bc88c29e6b3f43300ce27ff6622cfbd0120f09b76aa13bc1be57c5ea6c63bc5f88977ff99c5faaa8adc3718ebd57f4571db06bc30c2868f93575aae54483277646a2673769ab48a72f31a11e66f6d65b5a22abf9ea49c19e251b2932ae62aff39a4b92b62ba34f8298577c144f328e691b861c9ad39b111fe4d826e597c8395552f4b8231dc9f9fe2c0a169b2be0caf883eb1cee6baf857f44c1e857149d26bc3e9f66ea37b7107ac22dbee5f3042a38ba3c28a338cc7fd41edb66e5ffae258bddef34dc8e44ce3d8fdd470ce371b128c36b7eea6bc073ec12df520d485b6892caadd96d79bd1189685d4f158471e9156a75ca7030c9010e2699485245b92af80db044b7711c398395ae6f99f42e09a1e3b3d9eb069ef217f59ca4a90d41a0b43eb7091739d91090909990c7f57c28a7b26da592191206563200af19fd6b7e788c5004d1c766535e280f97390590574bd7c66843001606fc6be6bbcd546cb98355ac872c023d27280c2615c24df9d37b745232d287612b477da6b3017f75c645cdda7d4ef02974c1b37306a6acdb05aa860f5fb009c65b0bf3312e2923bf8a2b29d90d3aacbbfeda05f623de609d3f80f8b281778111511192097638a4b721b0f2f97bfb07a38db65e64857bc641e267f9e5bc8d5176b3e981e34c55cfa9cd0d8bc89482d7c97b2167289cf9f2704a897ed61f7815e16d01a64df4b09d35536b18232627ab84ddad86bd6b41cf708fa4dcfee8b08e368e31964d552361ad4890aa720d6ba354e3db5fbfc453779bb9ca171cc28cfaa01b7299d4d5fda719dc13a09d6c3e53a30fa3db01c27c78abff28b63e2373d49d0c077dbc38ba30e63a261f60d6c5a206ac04bc7332b8758c7b2d4c1159454ca48b725c577c5f9ac522afdae392b574572adf5e6cb631954aad52005d04a395c4331bd3f117a4236ca346b8626d7899ebef0affc502ada0ca7b98ad43341c2b5f8334028814b20275ebc8becc2ebc4390fb57271f5582ca654462753f8287ebb23d8bbc808be22cc1c486a9027b91ae9cad4d31c5ddd5af4f85897a51e120448254e822a1b9e2ab0af78419a0284c9dc2820763fa61eb43a495917912f8b6514852ae671cc611979c75f37ee36d06479cbce894678688eb8315007197d6d67a5509fcf544667805561fb728a57be4d01cd1eb776a39590b0877c993d636b9dc35390ef85861a5cc8175a5c0bb4522859f0afbdb42e028dd46a005b47c3856f73c0548c5d27ce225178d0faae3dc0cc573d2d7b9a3bf48b1d96eba5d26746e88f347768d1c09b48c9494e60bccfe7ba14cb84bc5cf3bc040454b6a7faa32c81778e7435e912dd8f1c8113cc9b13cefc76e51c7e6636245d07c83ec9ed7ef0d9f4e565611063bb371fa81365fcdf5aa77c1b1e1f0feff79bdd115360f4a8732aebc3bde304838c71b9a5e7f005e212ec4c226c55d0970112c6227a8200334a8f10ccf5bd783d979dba2eebbcf2e7727d0dea4c0aba1094eca924b269ba6bd2f986664c28e74084d438b9cd617544a9fb76c98e855279f58d8011bfedce045f628f2456b456a20a9b403cee03fa64da8b320326d599debc9cbbadac06f94f1ca3a4bc399223a3d4a087a4d772902dda7cc23caf1266a7fb617a91468d9f7b0b9e84289e900bb3d8c783751391f6ed7efe77889cda65fd98696234aa6af3185683e7912996dc512a0aca52935b0eb69c136b77fc63c51015e52767a6996ae12fcec74a34171d9182d64b606010acaac844f1e6a443fc96623429d307b5c8673c502f4a15a5fffcde9f54d1df2569352cb0c5985654e5431e862eb1506e0370db83ce79253276c463889883d86aeb6215c6de29df7527d7bc86b56f002688c70899ecc83f79c63941bde08db0ed316b57d27f4af1f617701260324d0f50d732e23e26b2335dc1ed57b035b7152faaae54a3b685743ee56cf6c69b5caa0918c15ec34a54305ce68949d7d4b06de94b7dd0e9b0b82a04f07b752424a735f24a18118c558ab1158548dd9b3b0af74ec5ee52a9701b0774387e6075319403941f7b1b3342d76dffc669ed1e8ea9efcf8eb08f53d6442b44ba6f2a2f0f763f2408ed7092279c4701c03f43577d62e67fec201c5766554d2bec7fb7a1843f3957e45bd2c38120054b510c403b53186e21b038a71c7a8ba2f49756180b0841d58afbeffe5483f4e9b1505af5b457c49d00e89f9c7e2e820020826bf320452b1afc9fcf37617fb1a479a7d40a2f889220a296cca6493952d14d89c3d4101d7934703a46077da19029a01b86f4ab826186486ee0a342f770b335d729cd1eec40a2745feabaa4c225626da7bccc6a2ff5af35be2f5e9527b1caece5ff60f310f3c842ebe0f42b9f29e49ed1883d0471da658f29b35599f6c5d63a3c8ff4a77f9046e0b2ea216a1113597bbac073a9ef6ff7043523b3858412764acbcba74eb25eb02c45759d432c316c95ddc2dbc9383ef92f1f53a24c8ed5666c6f7a7b81ff516a67d869afe4da60d477b27a61d89e381eb2f1651ca70ec82766d744c1faca6d5e1e3f776311a33102029b9dc23647e13063be8c0156b4dfce3399db9450418e6b9e1c31f2934767d2bba4b4d9f6cbeedffcb07b7dee9a29eeee6b0c21c99462063915eb34f248a68c0b2fc78a948481e4ccee37b5594853a1865ac5e2c57b4ce886574fe3afd52b3c1b28c837af364aa791b9b65a2cc0fae2bf85fd0c230daa95aa71ebe86512de4179f68d746e110023438aa302f81d6b60521c4586f3c0b95cfe4c27a350d7969a2cfb8cc295ad6c4f307892d0daee639b1e12e662396f456eb2a5e5dab4a3e8c89bd29d3f83f5abf6a23b5c752b815004447e655f646347f6244c483f8075c49610083921dae9f34daebe9f533794f8ae77c586063ed133d719e5f33f550020cbdc2fa726d1d3eedb8bc26ea64c19d6827530a5c480cbc4b4b53f3482eee93a8c851dde8040af07ad41d286d1b3c7d16cbcd2e9039fe48d469e4319dbe41546aa8ac7e13889a8a4768cc39c542af250ecb7880e983ceb184049a1d25d8ea6a3dba035d88f5d19fb12c960e369916e0c541e4e73ffa19dba51b98d8a37ff1157287ee14a6bb707b7c7af82e241c91740f38107b3103254b178bd2ea2864ea814cf2608b116f58e1c9bac758f901515efa39efab628f934264b2d5ecfa89778755f2f63f06e8de284dbba41574036b062b01b7433b3ed742181207ac0e3993799ded26b49d4744a5ce517d50bf74334ce3585311c2c251f9c1e4f91b66a478c743e7e43de283ff87af88833739b45fdeff670ded9e4b247b173093f069d2ece871136ec7d61e312840d4395bf9b2005a1b4eb97b4be36c6b5f0a5c760521870f23659d54686fce153bbe62d06dd8e51a114290110b125f25c6475eb51895e4cdd2785a39aab7de612cd3516790b53a71a11daa9156bad2a5025a892e05f85cb44e746954846bfd823d0ca8b0f30b0aa4dbe550bbc6801017856d52044f1440ddd1e4dd0bf12aea53eaefca5c0dee8bf691863f3b858b5362fd99b19aa3c96ed46987caff607f238d5f99dd00f161972ead755c5b445684016e34cfbf429aafa4d9638fa0d6b1afe410930e1b2985145fa7b06c2d1ba270b4d78f560bdcac58f2c2d02c50a41398c975473b92c0f5df0b608bb9c94b624913bbb95687672c5b22ff047c478acf6eea66d0f68c6cc60faa638dd9ce13f2689dbd4bc32acbcdf04ebd5e499d46c91615282a47edcc7316523a74a84581bf5f1ea31a1d9821dddc77e2fff6fab41c93586580e44f1224230454b290bf0939aec9311f5830691a879d81ca5a2dbc4d69dd3c577584bdaf73da31701d02f0e8883ec9bb36d7d25d624cf141af0e84e3b7fbfe75618a5265fa4e2ee485e9588f773ca047a22f5b092260b102cbf9262f94d94c22526951458846184d15d030870f9b0430d4badaf563372454423a3fd2f9b4efadb103d931696dfb66da5aa1b408bcd9a4a7852975c80d272b6818bb694fd78f932622bf197f4fbdb4624edd56df1b7df61cdfe408f325b020c16294dee0788912d61960cbc7b5f1e9266ed15257d6ce4a2d7be1d58f30e9acf48189cfa725a8e38779b4e23831377fb250f03bc18e0f3f4ba46b8920cd08deebf8d95023c9a0b9f9bba5871db0ff56671c338d85ab271abfdc6e9efb4e74898aebe2e2b7080a95bda886ad303496ebbb9c9fd0eac34d93c7f789dfb69767dac515ae642217b7654a463966f635d171b0f8f38b26189e014acdb0af7e1f71c75fb85ae37b1bf1b6eb398192bfb5f9a6b2a8ad38d5ded34f046e44c4a04bd9b23fff08d2ddd3299605eadc10d340bb4d32907c0a8c1750f8fa421774704340ec30bc69f764990c37a7930c41f778049b07504dadfa0f3df9db3b5e7d8269d803326231aa749a1e91470d09e3213c21983a70dc5cfea1db021d878a45d52fd537533db0b0c2c554cef5a06f16fa59bf7e1d25a27422fac059b7ffbcf9d0c2cdfd67d26024603bb06de6f35f0a02390a3b95e9be52b456f9c6f805bc348eba031aec899a186711de2d62e0c70dc7e4ac574be67f1c8093c4c57b98983015eb2810daffcce3edfb60c5d0b0e2384d97adfd9221056a5c8cb72628b575bb2920345c77ebca3100932f7d15653846cabdd972f28a52e4627e4284b5a9395cfc994d6824c3baeb28b631b12e069677adb36b2c9fd92bf60d27a8484d075a624d270b7a66e02f0f18dc77c2a2670578376177c07641d3a6a3f6003d1181f321ac4fa7801ad77cd162a8a9c4e23eda466a2ef1f01d026a8338326ed56d8e4cffc882fb13f5a468cbc68cd022828693b17545b051f0126cd4a54704ad2a05d50a096f7951efc619e82d9fccbcb223661656524a1a85cbb77071865871e712f98035a8ff47f24e984d7b61c38b99ecb302cc3781ad7e36266296c30f5e818b44f86d7b321cdbb9140d0abd90c8426884812e5da58b1e182a4275e03149ac6bd77a64d83d80176fc3b83c960ff86bed68db262e993870e13e87d116f46241a5b323fa2a83ad678478977d85f72e6f686505a4ce60c3043b4f200ab5e844eb4eeb7c4c2e6c351d345a1c45f9d33e478fc16c142e518da018b28269558c0e6553569e23dff6924a0e3c7b9dc6c50f2f5f8feb9afbb987f5758e837db0f98cb13c3bf4895e9ac0648cd512630d5b828a7613586ef4cb80f4d6fe60ed87802308261e11bc79f6fc3c9a48eeb9d0a828eb9e16f84d822e99346db35ff52145e01d525015d67efaaab70ecd9930d5b9a7f7baad89bac48df94be7bb2b0a716e2a7c7c6f158c9e856b0c2fb9997080c782137a26149408afe204315284062deca055c5b041d35cd865d72a42986219742c217fd683a93fdfa3494efba16c037759fde2345231076ea58e7e5dee20319ac94d6a6aa626355d114e3c67c3714b21be2ce4380936f372d8282ec0adefa0173e76bd4b8d4d4918fa2d14c5d1705b8c4bc75bc2170d6347be8b84b3e586b0f02f370de27fb6a71a80600f59f8e500da88307c85e5e5fbfe16db21c9e256193a2295aa470bc93d44facf784f52ae8f1b859440fa158c60356fa5a1bf686ba504590968d54d070b3818ca3044c0f8c25951275837e20892a3f50c9f60387db40ddc1c74174a9f4afe566fdc5833c9eaa8c0eed359c75705d4bb98366a3360f023a1f60a781a77af71e056146eff46bdc673ed0cae28bce3701e96bf6521e92b659151f92114c18d6d8815abca005c248444fd0d7005b2ac2809dad013fa4bb992e2eb24b9b064dedf49573a09e83d35cc1d71b34ad6c79665bbe4da9c5c15e3ebfa05e56a66fe4890dd350f7dc81ccafea41a4049bf947066290780cec5f95f76b3f25b4cbde7c8c73a4624fd1c7a918824fb5959d8b178109d1ffd43f5aa3d71a3a32deac2ee2476f3ced85698a34873804723b5eda7af4b4d80475f3e3c05d5bc22a3bef93a448d0af4db3ab5e5a860094a7921925d36abbd2dd22681304227558455082827d04609962ca5af801aee307b785ecc7a5daa59e545592ab2635cb0af0fb82b5f03765b76930f85d5617efd9ee9f1df6d6c74ad6fa3bb492d052f9a6553e9e1df454765e45a22ad34e67ebd37cd519d896c9f291dc80fae6f360d582b4a5cc144b76c49510933805b13f73be14ff2bf59d9babe7652eca6580c9229a3e219256d5e28982e8dad5270c2d24c7a3b683c10ba7c818a7be821f9ce9849f0e866a1ef8cf6f92d0c47e62b62f61e0c6f81eaa7674abf99e12d2042a205e4389228d193a26cbdc35e19e3666bddf8aeb62c2201a5ef572249848f794ac11c55b1e9464e39b5db28cf2d5a3c8b80515e394b4b8e67ce7a75cc5b9096c596c2b52cc0a14a15fdaaa9f2f2ed4b3b513a1fdf868081877e572902c3c4741df735a40550307d9d0388eb13bbe33f41335414d09b658c61ae5637ac62eb4f361017a7d4901adbd293703077dc84799458e3ac2d742f5eaafec1fe971fd21be4db324820a60cc7c97a0aa8d6ff5812e982ce65bbcfe64ec185f97a1ebd3b9dadd7bcfa997ce96b5b3359fc8166b38f10ab736402f8b2e2c5d1385dced83f45262fc82534ea29ee2dac3b52f255785500e1fc36f9869999b2d957883db707808fbb25b9e86b81b93fde912031c0c63cf2e7bc758023570362b957562b47176ef569f3a60b2191d46dc57244ec498ae506d341d86c3c02c1c5c609a59739f665ef4c907811c587b8e37a735b63906fcc2b8d220a7449e3ec500a723f67bd6d0bdc0d6c994c7debeaa3cf212e10878f32839cd5d503be73e246246caa743145fa6129dbbac97cb93b8256d4c8d2d294548781d77fccb01ad2c7b7b500d00c768b13cb0580165c202298a6865196e82bf0c9f3ffef2a408151b751a24d92fc04f4523fa1319c72db3c4d57f7c0be7c3f93f73320a453e353960e677ef31eccf7bef9c206aa0bdce9fd0616c8789f95f6a08e502c70a6dea2528367f2b048c723968aa4ecc0872edfa8353331ae0972df9d7f68fc316c6a1b8a6c52a11364b467d8342de38b20d11a762b9bfa9d94dc457d8f461f07b1640b5eb86647f40883865a30d7abfb1b15b57bc111b8423b92fb0c9663665e35b29c9401d92e4bf2a00d41469dfb2606e2b09c90effe0d4cec12005eee28fcd601ffefc86be41d4190a424a5314d7d4e028c27448bd6d52a29e3bc1c6eea4f7b8376ed0f53d273ac2c1b337e73ce042dc14d5f4ec4a5f74032c0385f4d754cc4f7b1481fa8e3a4aa0710c2339ec2d421093e3fbbe513ee881894d4a623e9be8d079479f697bc296df57c10761d10dfddaea578b909bcee078130328ed18aa2ddae37c954014e29893a009189ced935e5cc6c1edfd0bb67f120ac33f3b17c69c83c05bb7bd469171c649b13656d52cc1b35d4a93accefb8c18444a70882964dcf3f4247b73624b70ccc8e1002605ce496c5b1511a8ca2458d6f16da48864060f699de2a579caea5ab392f62d8a6187dc9038d0f71f393863afeff21bcfb72d92d54ce1e7d4f0659659ada7211cbaafe91ed44d739c3327648606534ae321490a5bd57794c67f6821abedcd7d273e1f2afe66a332d2cfb0285aa360cdbb836e2131648134b34c322101e6de03680045bb3972c5215690bf501f5621b38ffc72c435534e5629739f28cd84fe1855e529e9e1684684d54a380b135e1363946ffb3c83ea9bf46d677786fed98f31976efeab2bc3ec1526c796c292e87a74d134530e945ac235f128144ed575887be311ab388b877d7c384a3faf44840c10a5979b3b6c1e50a2bf985b9f696836b7e1a1f3808621e1c4dd92a9a39450ccc407007acac7eb484d8416ed6edb659c6d151e38d253e4b2c4a7dbc455c66d665be1763facdd98876e54d70835937e09ec5158175e1947c7b8e53c78d2b9d65e03c5d84133908db86bcc83dd7f73a2e648d03cfd9ecd36467e002ebdaa591eb110f700205625e8eb2d5c2fb2a078da31ce2c8836765a680fbf0aceb96506a01bbae974f4e2606b3fa6be87733f17d2d8ca8d6844611e48ee0e7a5c7f840ed31c2bcefaa93b879118757f24ba8f515d603e0864f8058975ab12a48dc93d629c4bc9bd51124949d1f72e6a0c7249186f04cf27ccfb4941599e9b595ea6373b434e839c8000b8ac2cf077b01a50264aab1bf28b61b749e5e5d91b9300d3b375c7115938abe7170dd13f095303ed65fcb2328e7bae9bd883b88ac1ff5f5dfce5f1c2d8e7c52c77e9bde2434e1d62d0a2dc78c49b3693a0ebaa1a2173f19bde760815960ae59bbf77b1d980335f764ed99bb14a19ef16b60e01a0d9eb8de7f0c3b1970d289d7c0eb1fef178e3fca4bca5a855242cc7a3077f81dc0018c6a38ce6fcf314ad41fbd420797eaac4006896a09f1ebb28e43a58b92984948dfdcf76b5843c7c89aaf5b35b837cd9dd013df5e00195269497edfad539c51d5d0923c47ffb86a4f312f62907895682f994f8a5954a1e22fa67a014e2293f2a581ac5587cfb005abd2d7145b313f4a9a1b0d42773437e74c6635651363fa1b9fc681ef9653b1c75a93e62590d5b0f1a2b41c63353c1ca49c0a2b50d6a860239c02bf0340bdbaf3cc1895a24bf9e5729ac2e635a16527a0fab6129c9b0f4f25e21dc1b916cd4d54a1c0a5a4ee6372eb65d402cfc4a8bf61ba18fed0f173fbc5cd88be7002d0a3c4a78736ce46f9552317b5f2759d2812a6f52f241bf9e393db53456257241685845292363d2daba336","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
