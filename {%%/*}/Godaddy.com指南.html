<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6cc53d86cd4f882cb7902a7043af182434b982a25856b9fc7446eabdf7e8c8d4bf56f06e8039c27dfede1f4cfe9ecc7f73b87991f6a1c6a12fbe7da2faf405bd8cf95e33bda90936c8caea7dc652123ce95ad6c581181f58f19fc6297e8134de84289710ea7bd4fd55f278ac068b8e6ba04f9c733f978e42db022785a50c4944dc73918a267008abfdef872fbe7a10dee8ce062e51476d0dac75b661010af09852b02a8ae424af697f7f6e410f23475f49d7efa102d646211677fba0cf24492d4c31b37be0523cb13ab81f736148424a9e9c9efa0ddd13d0e92bf25eb63bf960e1611ea93bf186e540409a321a42cb1b1c263e827e0ef638cbd54e848c69d95e7e1fc343f5e22e06f794705d6dc079dcb01eae93f740d250a5694d954676259d29aba50d2203c94e1509078aef71d200d6be09e7e37f91b157dae0578fe92c19d49a8676fcb865267e80178e1560f0c464c103ad5d9632a9c572fdf7960d6df393f9a4cd0c51834d9447055344a5fcc3e0e3953d515d58d42995a0cd30bc4b9388912c52b77300f3812883089af7505da2c56001f6999f10f52c1f77f08355436afa783d9d9d9f426205d2bec182a5466d9dabc6f62750c893f07f65b8c7f7c89ec349a69a02f3f4ba10348de6c96448fa493ed17b1359bfd23eb0c004f73ff514a5fddcb010c1276219836e5fcf9a49f84690ddc9631d81a161c41de189c6ea3a4bc64cb51500c8b7d59df2893e3d477fcb815daba0cf5df800439cd0b96a0b88b0ca8871d0d925d6b41796658c99831d8bdea34436771d795af96546222f0f6257ca00551400adc94d6cd5afe445270b274f3f386883161509068c90b270673780dfe9fbde057d680c943cc22f73e53fee9fc2ed8f7977a31eae44fb1e56497af4755ee7836247a6b23e0136f69cc4cb7cca62a5eeb05fe0a4ae113d33328110e61178902360441295a5ca8fa66b76c2f38735958cf9f5cc9e9039d980441d86394f70aa5646f9730d8c3ef17d00807f6359d78ab4197fac3b543cf67d8955484820f62a4a27c66e5920d328db3c7694473c5aca6b267606272bc0eb684046dc3a3fbb3cae277cc2d383d182d95d180dfcf10153bda8998b47dd289de80b9a1ba5a1456de332b730319dab8e8243dcca3d1268c3224856a4f73685cc2aa4d58a8974fc2806e44aafe0ea4d565bb6f81738d5f5fb55114971b5d8fd008411608b9749644c338976960cf42c77327cff402c788f53f4e63135dba5a547d64917d99620cecdb0cd18d082694c35ce6d9139803e7805f0d731cf8c6fb8bf41830cd6b8bf97b6851d2f855d37190484fe437d1a5b8f188264cd198a5bea6c01702ed49bdb882ce42c6dcee6e2aa0e8e1bad3f9248aa99d425ee9e016dba252467ada3bcc735ec306c8ad363abb89c4307b0d437ab5728fe5adea61d7b39233bb4954486f5e0f7da47b07768cb36bab3529e00774a92ec162ab47976cd06b319eeef77a0abb2afdcc049c1f640085f352473b683256d80f686eaec5a73b79709346f506ce6b18cc7d6f9e32d2721a824772cc9653cc10fb2e61f8f3b80f93d5501604021c5d72d8695bab4ce4ad1fbf348be03eda3afd72aeae3672fa8cca2d743fbfdc5a230253e63f6da484e3601c791d94a64179e943158900a903f44f398ac2f54971bdd550f0e0e3b83eedc7e91836ff2b734db6f50b729a60e4af046b081cadb9ceb94453f917684572d536288b532cfec0b720cfc0d0f3ade537cb1e25c8dbcc494b11d2a4ea1bad8c40c502e93f4b03675a9b47359d1bbcb4fd876cb542f93bc6f792fc067ef4945a8fa04af5a7b1852486b7866fb26e0c6087f99a44cfeb077e6cb96eb096e3af33c5b5c1396d7f3cc987084b9e506f73848c699adeab32359a22dceb3ddd6fa73548c9a4fc80f9c16558c9887427c0d669edd22e7131de88b2d5260b21d46ad52edca1c0fdbc5b0d2c1365963316ea64f58c069bae105d7d346a573009e8bb630c3d7623b5d4e78bb085babe2128c80fcc9d61db475355919c9e80e0e5d7fcec1567f2bc494a8d4d1a5870ebd8413c0664c3997800333be5a21e432e4a3113acda89ab22436f84fb4b61fbab696125d7383ed34fa3bf63e23370f03c0defd7d18d76b195edaba5a11dc504b21b46a3f65cae26c2f2b6ec5c49fc0d586537d2256d47fe6033f6e9d62badaf4f938ac86a6254a15ceaab3bd7cd746cb352805c0be86aa4aa6915facbbe13907e81384792489f325b64f56763a51466282d9640ad29af6e6633426ba0dde648b5f781aeeab45fe9043c215fb2ed109c737634e660b69664970bb703b798d9dc7a6c92af2a9fa6e38a7e0f5b7608917852116043bf8bd3e329ecb1e4cb8bc9a9a201c7c48dfa1fe1ac97819f80356cf9d3f34b1042c15903d94a3cfa37bdf3e8db83c848430b463f7f32318df471f23eeabdf366d7a1f49b928e2a4060d6fbe5a87540db9729cb7f1061f645671df7bfcbce862e17ede35f5f765cfbcb96834f28285277d01517f95d75cc750ef8731f6977748cc1c88a7177e4f92c6cf8fc10a6d1424e376e66950f6cc4ed0962179ae49171a511dba4ac645c89366214a05e62bae9c120fbdf424616f24dfbbe3242b7af3f88e63490ea74f7496482ad6868f531e23b1386bb2909c081db7927364172c8159b9b48e07bf761c63c73f348d9798fb6e92054de604e10b1d6382ecbdbe36bc3e5eedeef174ebe87fba827910dc1487823c88b8adcb9de4dd73edeca358e00ed64fef804cb0caa74cd1288ca0caac3b44b5dcf7835312f55a8900ff0082c4ddb311902d7231de080fa6d06910c0c65a9db8ccdf6806aa37081c36fb822a9a46f3d2b63fcfd6bda698f09a47ae3cf7248a108a1c870d507921d97ddc9d5a560fbf7518bf65cade565773a8076d4008ca124a64efba82d4d988104a02fd02513ea641fe8fe608fe3859423a5b0d0f3acec05d77d34872c859c3aba0f7024fb8477e708260b4b102912600d62d4211c0bbb3afb8d1f4fd9377b9f75061450068ad95b8342570a51fbb37cc805d5ff78b703c5d407a708600a2db9c156a098f7a06e2fb05ddcb5dc34366a950392e1414b984fe7b8f6ec618eb1780eac47b6560e22f0f6fc2e1086ffba81d58dc2e10f80edc8a85fb7c49991b266b5a63e5bbf7bf69bf29f07587d1b418177d7e46f55f03f7256d2c6bd0f454032f64ab8f7a8f5907b5aab937d1a366087bdfcef2f624e5b4236948a89e4c55775eaa4372c064d9f72a73ef64aeaa14676dbd82f337ee6b62dac61b83a69af8bcf1003d5f671959cd9eb2e519f6d46d5f2f0348882d734f8874c91ab24440916ba55382e56b6b4ed9f52ebc9534193feb502677fa0e68c3a389f3f9e04276dc9120d2e5092ea2778dcc47b93b122ba56c0ae4f75ea650cd5bd3e958d363a50d91cff0deac4a5ad6ff66619174bec1225ab953f584f755e9eef927d1c9a1bdd5f15106a6e07e05d5149ed3f57a8e442746883156dab9dfbe82b41b4ea7244a1d3864830b5ae044af1e267e5b210bfdf1fe34c85c29b4ffb5895f277cc9715a9331ee57d17140b931ced3a96b59ef9d027ded42d76989e98f39f3399c0c4060244c2a7828287d33f3f6b95289fe1cc64f74079b1c55d916d07de91d562641591cf297de388269a72442bc41cf312fedd85d5d7e393a45212672cc83d78abbd18d363585efc23427f42ead5324e4431d279056c579b23be43ad591d3fa9c089a7814d945e5265f118cfc04482cf587ea3f3f60bdedc961b0c935f5662f90714d631e65c14dd4b69066c50f484d65cfd8ea6f54d87b1cf0aa584b8c85d6b6f1dd09e4e618d82aa32b1c6dc4e8cc24b620e0c80d1118b69188cc828d361cd3fd74971beb3b6f0ef3c3bdaf566707c891ce40bff4cc11fb7c81f3c51b83957ec233e381eccb9f11ccbc7978e0c3ec9317cdaee65292422638f955f36c74da59cce5e77fd598e99ed55a0ba95f289b9b120358928ee08b7c00452a8b74ae55a75ec142b84295b32c31e1c17357aa5900040985da9cf55e984a6901bc2430cd34f244d8b1aa6f3fc58cd7d2712359553ede4e775d0f9cd8518f0e9d4f51f088aac389c13aba95d6f1a8778bbf0e48da2625fe962f024c207505ede6b390924a2f6e145898f633c6b137284dda8b6be188526d2e5168d2d778c5b8876643798b74028a98f3d67aa012b166dba9d238f23d8da4a0686286be6762d44ffcc4ea6ac4eb9630177fd30faf1370cad75a08e1a39917d7b47fd4f99819d460774a55144ddc805048cb8885762d5b4ef6e7c836fa1429828fd62c18068787f1e3ef654ca037eb7c4cfb9f74bd046b9e563edab199d180dc3c4c30f918e2aa6a440dd1b153897f002a0859dd220b91b6edb58192d703b3f56d05d744603bbe0604f6640ad982c0fe2216f228d13bfab21ed3f76f35c3fb2d0c73d5650c4ab5b20c194aea930c88afd70fc78a7c897c708b71e4b45febc63cf35afba805999018754439678744c41a32e63ff3d3a544436b1f64fd8c1bfff43befd9d03294be15b1f523625205a2c0c54d85fcfa2654a67daee37a2b0025829c438f2b586e872f25016f8a4ae23322e8f0df48fe624b7e991d47bafea474a34b984eabcd36d8b48335ec6e2b7d9fb914afd382835d20d5ea630c1dfdb95c0f1e279007ad4b2d1e2df7dfcd212a3218b48aec84ce0c976549b4c86b16e7877722c7fdbacf90dd320ad16a91b2ae9ed42187dd6868317692793e645d9b4867018a8c36550a1fc529c31c64482e1cdde6cfbc7600d28d91a78bc85996cba12096a82f96d8251d366a4171fdee6b9c192a3c603bfc6877d16e85ef2217e625cf4f62e018250cc53a628212a29c399b4bcc93f06a3b92470d3120eec2e49bc82a17b33ccf793389da26f4b04776be8b027777a314ffee286cedd919bf69992a673e39c141b36fb7669357b220b94d44622a3b44ad0e304a6a6b92da3cb35a195cb5848bdc15d28ccc2a79bfc0f7c981880a582c9a940dc9e368705b52b1e3866181a44afbf5fbcd2036285da2898a928e5474d0f56990e17a34ca04803fbf4b4af9f8fbddcbf19cdcc1dafcc33204f81b07de1e3523cd9273276be2db8c1d2837ad434e7363cda78f78d1675081693cd5b1247218620bb299adb49c5e944ae4924664c879ef9bb4fc8ccea06af39b4b12fca9b24d64a6dbffa29ceec9e00f44df5fcdec1889d637254d32cf6e009fefa4141e93d1df5a18edc19d1b9273f317d3494c6983ae4d0e7148230b73ffaececd270006cb94cca37195a1896a764f3aaea710a63b2d7217a9e084c87b4a15f85412aa8f5f0f7037b6c2e7d29d7768a336dfe1ac6b1233cf8db83d02fa7ec5419db55607ee83c45631ae50a16cc802ae8ae49312c34569d10af96698761e6213c54bc6b9bb3acfbfd3057cb07f41b6d0c2da16f9d7095733bec89532821fcd124809fb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
