<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2cffa6afc27917ad671a9bd055febd46c1c06d2f4b1d60a5332d3dc10a2ebbc4795ea20d6ce0472e3397bc1c7cafcdc4f3491fa969588fe238c2cc504fec78e664c536e80888b0a72ecf59954ba36440457cfa325c150ed1a2e9ea1fb526f9acb3d5ce7b401f49cad0c9bfb6a9836114767af10a7a160a7d7c44f972c7f4e01ee28fd86f8e36e2dc4e53469cb4ec939711b0257106524a7e698a95dad1d259af69e5f317c0a23419fb0926b2419b9f997866874c9b4a7e32c279f32157d17ab864b1c65faaa7973e74cd7cc6fc619959760edd59805ad1d998ca9bcf5e02f0fa253377ac27de113bbb0a78dd82b6b1f6fe5f9614488b47b1b8bc4683aec7899c98d7e40b0941e9ebdb2455f867bad8effd2f7c1d7a239cd384a59c8ef683499d66f0d359226da4288be51d3a7db69db6082d732fa5c12c69151fc8612c61fdcbfd8b926e5512ff3ac69b75925bf56f42ae8c9fac9f3467a0299234c42d88fe2dae441526801e3304229129be93994e44585fe8ca136104303612f8eaf3d810109d4fda2daf527fcea53196aa2662d7abc96f844a82fe16cde8b8c45baf7504625a973d8e8579293b2ddef6aac2ddbaf29352bd4246251c870b59941368832afe9b60a52634a0e9d30c070e15c1cbddbd1437a348779045ba2f51a19c4502f2f92d50d4cb77e033655626a19265f2679b283a1871717c60ced9bbbc2df8c57a649ae25be1a85bfd19bf4e806fb0bfb8082f3299e0042e4d3affd5b8178b11569cd20531a0daadb4b80deeb1c1e317de49249d492611c70b2f0601423b8da5c13debb635cb88da696093bce90a9b711baf14840bf6a9ecd0118fd70c56647df88128d1c1d986297e1dc2255c53cf8dec3f0be49cea0e49cd1a268875e0b6ac6d24679c997f2e9c9ad0e88b39971368f18c4801de7a6d69c43c13705e7afec1962952020367ff1206743b760b64e559c9c81243c6d922394c8d1ad3131d7eff82b1a0468f4cb719728814de17979b41493654f7bdae23561e8333adfeb9fe718f92fe698eb196d4bacdf097845db5b7647f156bf74c302ab3d079d8f626ffab4eb1ce2716099eba8c98ac96b59fec60b80289b802349354b647957f943434722092b54523ee51855dec208e6b3ba28099a4e52ef11e4d951477ea9c37261fd65062472e03b3163960af7b674a7c278aa27d824c76229b7a9da2f7a69cb40f69fe174393d950e12b764865c1957d633089e8e52937982f1c3e4ae867f3bc5a0556a83dfcbefee7912fe89fa4a86a029aff1397aabb3b486562289933b6d6bcc50df506c961104b14d37b55bb42decb0ccaef2fdfe8c6d91e907a4cf1c5c76eab518ce04112b6b097feb8411ae90a54e1fa9079a342800c823fe534147da9702adc0d85efaa77ff4229b18af8553be60b5b423a61db071d4c98f7a9f38a9aa8c8e728b5b8eee25adfef4f7a5a1033af4b6949a89227dfd094fc91aa873a8a836d7885a27f64f52676f3d9852256724d003fc07cbd7a78fdb4d755613091970b423469f50973499a4fa645fce815ae43af9f47af5925bab1cef49bb19c01ef85b33b63d9c2c412f35804fbb36d8d7d30573d827c8e50043d1f2baf212417a5a2b169341546aa72c5be7d033a7cdeff7020e71645d79c369873d3d85b970499d43cdb53bd0296c6aa7608a8dadfcf8649d24498a19ae74072cd1a10f20686b0ed705bb286d6265d6b6574602cd394957ff7c33bd77406ab69092d4c0c61c00bbcdc983be91daeea8ed10227b84a8b9c28da381ded8604a62a8fc5484ab748020675614594ffe4acd564b66fc8fb200fe4bfdaf2167eaf518815f999feb82c959ec97f37ecf120c7a0c12b3aeacc6ac67f5ce419ebb3ac7dc5fe69dbed15ba38030774717346e112f802e250c98c2ad40b8327a7cec0187eae5854ba55245f23cafc8f744d0c8aef89b94e358b4fe6e683addb70a18c44b26ae5130b6337c517932b384de9537c3f6fca6cb01c73826851e43ac6f21827bd1591b7e5c41f05047c448a4263248be778d5db6a9d10c6e47c99dcb1b607ffc28cdae70b7327c87989148750f009d6780a7ea26dd846f6bdb22e633e4d9d125588b3a6a6374b20dbeed16d67d388a95e484fefffdb8919a063170a0d9ef482540596a68943c09fb1e21622ee14606ea6a8b994d70eb469e3113b06e9c9ec976b9a7ebdc73e561514c13f8eb81ce291b64b8081108f12162fa078c591a310700688fb3eabfab2ecd737a4c067e99edde1753fe9d2b42d66d8e5adbf9f1911b54c8552a048fb1816cbb53064cbf7fbf67babd1ba9c058a8f6bc298b5d9287a4882cf63c8d25e8088240f685fff7452db2641710b0d6abd841dca4faed2d1174c40861351a93ae8ddb4950bce5f6fe4e22e5ecb49a45a4c35db7671325cc3bfda8db1b84795944225a26dcde779a2220f4219268db134c300189b08e11537b460ebbf8a1dcbf17e20319b8465c3cc6ab536410f3c839cf4983daf99e09ddc1398fd2f11095bc7f3b38c9430dc3e60ea4d83bc8fbfa42ac3773904c2a5b19d2855010f0827b76f8a94145163aa08feb7468e1456a8b8ef216ece72c61119e2859624b1241e6186bbb1b58b6807c4e657bf9cfbb4b3b7467c82adb892289d5b21c94051be1ae54012a3ec728bb3961099484668de7dd02002587cb3fb85107960195a9081f2e9685d98da332853f8c6f95687c20532faec4901cefaed1263bfc9ba11d32235a43c10e94802498716b211fe8173cf354f2f502eb7707868375ac5c6de81318c041ac02ab4f3e3cd7f301cf8e5a16cd518e3312a214a6bb2206a08571ac0fd81bd39591d87935277dd2429d6efce3ef92bbfd402ccf07bf88b00e0b50d591a9069d7fc2d429a828536731efbffe78a91baa9f30711de8c87e5e79b19a460177cabe046962c6bab6c7d49bcd3e6f5f4c25fb09e8beac980d6f90a32c18dc3ef0db4c99dbfc3d258bc13345c005891ddaa2c4428fb648183f5671ca1828d9b18f1455315f742298714b56e1967ad44f324b855a6a4a94cb9ed111fccc6c1257f6c2402eb6d770b0e705f77435c351782ecf5ef53e109d4dbca0fec6dd277cd8e1851d27735d96a4ec93f83659ff5fdccf1ec8657ef52f2a811bf7cf282cd4062c601f8ec2cdd4164f90252b74cfca9d4b99586f83ca0fa5d238159a2c82da67ab42998413193dcccc62678998627f3f00348f9d32fba8191ecb7a8e8ac9aaef2f855d4c10a271fad8c993950ae11540ce3890633ef379f612e640a06384f7634c0f5e2b0f3ba70b5c6b19e54a00151c44a1e89d1f62e1470eed936df3f849446bb5e68556ceffe22566490e773fd91da6e0d9e89adb6baa36d4b9c75025ab6a9b2700563600f6aba00325cbb8c4ccbba7d9e04faaed93cd91fa83bb4388a56564b8b07243b80b99fabdc7b09ec6643233b29daffe77c8a2feb2e71dca3bace266e51c34fd294176768b44da2fc312ffad5a511b89b0027922481688fd9727e1bb3d538262c11ab2a63aca9754eb80c9053ed4d9bf93fcd64274605d290efefbdacee7519326e3fe322ef2a2957b44017c937b84387665b87ed018d4969533c6d224ab39874bfce071bd7e1c32201098fad9763aeccf65c18ca9bb31a14fabeddf46731a76eb651fc963a169d95b496e7361c9c063bf1da985331aa9872b135d5a63ff933af18ebfa47d3ceb9b8174aeee5e9d6a4aa2f2da4853137a292bc7e310ead5132879e70840fb8ac9807d94ca7424b8404f5f46afc40066189b0fbe54734b5a60751b308a810898936939472bf8373b2216cb46fc6f4803954ca18b4e8f9045ef12a8a5392b667947d653c7c1e5f4968ae323f175308d6e94fd73749e8df2292db7cadb70858cc1a1dc85d51472261bcf3665be7603eb44bdc84f58028f88e43337b7aa6acdcce3c52a117efb9917c5de2b62196c6e7b28941cec0b0ac9dfdde0731c4460ebe16849ef281b5ec6c1c7267588207dd8fc401bab973210ce75743d2716c39ce984521a7a1c5c2cc4459538bcbf304c4fcbe3f172bc20f396f92c7e5be3a0e0f7317b20ff162887e8039ec206fc18b3ae8328da8067292edddeb9f7586e567f543d5d8fa948f40d6289581e551191769132e47fc942e278238c86136d01e2d600ce5bb1a724f9b4cf8551c330230f02c70c5229248bfa4f94495d80b3bc720ea8d8faa1f2c2bf6ae910786d881d42b249dee053f4926a121e87b9c88c51bbcbb08d8a1a9083856fe888a90bb5a68e16f099a4456d21e83416fb99a38ed6b9a42ed0e095f984d7f6df15ff1b1092e9bf02ba55576fb89b3e39ce5bcea40ee79a3be2488370428ff16b4acd372d7b634d64232ebf8ba09d1055c4922323a99a66bdbddf4f7113be28237888e669df5edc6a848a14fcba0a65d316a9ed4c807f35f85158e4a11142651082c081f41d9e1378c83589bb9fa782726c0e53c1cc6cdf5932a039c63bb7903cce5dddacdc8e68cfba4b86cfe00812a8ae051a2af04f82af76c0c1ad103893c02d52f218eeae8f10cb13a825aa439e39dd734b36177c6f5ffa0ce1459cb940e244209bdf453ca9249c7b528ce3312b3c754f2f97220d7d62b06a3141da15dd1f1d75ae087c4efd6e10c5a247f1d7a2a9a5ce3600906d4af02cf5fd996b1d9cdd0fde5799cbf6bf241bb12b10d2edd6c1713deb02476245612fc34b7cc6db1e8afe239ef7cc861af71acf67b453a26ba63119aee4a712c9e31b070534299888d06759627dbe61aee074caec6a9c8be14591df33d730996a4dde790321488eb6307f6111c07f53479515b7db6ff89afd2984b1ea245c283608a7a487f47a9898fd327b4b605319e33743a68e2ed065558e939280981444aa5cc0239ee4e7d8a164593728f206f94f2a79831291e05591e1ac47a4ce4a240b9182534803dc3f3809f92b821280722a7262f33b9755a077879b418cdf87602fa4a48c67a93ea009e1e0999297d6fd744f0b22f556ec4a6691d8c8e86e9944138008b1b5158de8f30a3effb588af7d7c1486e52c542e31decfd9ccd249a6bc0586591cc5f30c3110d4439442946ba62f2b125509d5ae7a2983323338ab68a033c939aa5f030a303b27395a1f6bd56f522cf16e3d3e9309f9fe721e6c95c1e894a1dfcca342a9712c4d0bb5f5c88f5d48c6dfb92fe21335cc75da78f7d5f0d13a762f03108578a5dfe8af929d314a4b5128d068053ca4eaa7df7cfa19827235814529454c14c2844fc27d6777f4735b47d97ab2b95b3385a0ab006768245f94dfe9093deaaceeadfc3b6a325197b37b0b68e3dab227de7d8e4bc4147a6e50e86567d42a73a0bb7683c7509e390dfe56fe2778af8d322966973f563da9551284bb03c44a3cbaeedb8513a18363c0442b5f2fb0b56b6a76ff4457fa5eb5f8a824dcb346d648e9ddcaa1f71b3de8eae8af39f22495b6c597b7cce80c287e7328f3e41ceeb34bbc084a0cba99abfd084a35356460109c1dc3b45312c6a2782573d4e528abfa907e8bb34ef8791d1d925c984415ec1afc055ed6a1b98164d8c3ffc65f5fef6dd2bb55c471e8fa730d5a37480f10119a5646a6a607ba989ef6932a45ec1a4b9fee86d0dc9edf348098716190ca50bcf455a00676b15638d93975e3fadde721777878fa40f707bdc4917e6c62322b35cc47940c99fc28d19b95d02eeca1db459d6b04af0a8b968c58629de2a0fc3dca3e9d767442dc1a7821f62e38617b03c5dcb52d911b25b7c2ca0dd619a3899d097ac5c2d8ea99a4b82d169612de899105eac77c78f99914c860dac2c49fee17ebafbe1b565087441135e752d22c7bc0604f01374b5be3507db3b7bb932eeefa64ef4a8c708cd9a463580d57d20d2cc36ce8242c091bd8928150be59d23c05950ff4af05de77dba77779aa1e3875bbb1c5393e244b561ccb4e11c5431cd01e4ff99e25ee51ee9d6bb6e9861d025ba35fd8f80a9d7156b246dc7092fabcbbff864c24a241f2d9bb546da451c68b350a5c54963dc61aa70850f27c3348a80c561fe83bb492baf82bd279368ebadce657aea10910e0a6acfc36d362be173da6bf464969e9e88486dce8a81d2c1b288fd77791cbbcd65f9b4b1ca17772977ab4fe08791de8f63b841602b69549e8dd17c8844d7b7f15eb583fb238477f58f5e916efb267a387f3f7357381367c9f458e553fab747d1694d1c04615cf55312bc94ed888278d5b48a2b620302c5c0ad0c3bdf15846f9cc96448cbb3525294cb0af0221eff5711c44984348368350c7f9eaa335e64de5f8bcc6fd82ccb334499bd87b339a88e812064d2bc1a6ef6c67b62add1308ace65cdd4a5641bc443e1986be8a88f6daae265ce22d4183b771125fb12238b070a34a3c5acc2a8c2f2b5278604a5dec2df9a52d008fcd0573c13c517350c705df6a28380a167e3b9a029d506ceebdffd6d8bcd6b3ecf8ae403d3aeecd031333fcf0f4d9b6511ab10199b54f2d224eb85f776902feba7857f3cd726c25091934f8503d31de71d975e5050e5281c5b2e20394ab5814be8a31555e2c02d9de5680ea62e11372db94a9ce695dd2c857ec782585011f593c68f27c273dfe12d23278505ac8cbe5e129d356ff3d217d2370f7a3f99d39b69bd98eba35c6d02c0a860da12f6dd9f95a1f13a10038f3d4f3a6eaa7936869aa66563f8d47cc054ab658de044d26ef7a6e1a03850ae58cc49afc8d6bccd3c7179425a649c5c2ae7453544d30f9b33c71a5c9b66f87e7299014fb0c44fbd034c98542c7534033e0922d9907388e531cea6b0d0bd0acbc2f74224ccd4f90d3cc7d66e140bff051f40bdf84735358519cab2ac7a044ef17b62b92679b2d518f2f53102218324b23fe3ee7b15386413edfb31ba5897bd2cf0b399250b5a8b307ebf3404f3bd42aef4a5dbe4bc364ccd50a632c5d293a0d4eaa89fa9ec2c71aefaf860b9b412ab1ec10be4bba5d997ba4579a23ed60e9fffaba2fcb3a6dcce77dab32b4d59321eb6e8a621df05c8404b437e2fe6df82ad4364ff234e586b37c34147906471836ac62cdf9c82663038c92d3abc905e4b89d73be88b275b57ac53f4fa3761d6f191b798681870be27007d52745ddb3f76422d7d93a96834b3dc557b2061d7df5709de17fda0dfd7f6f4ef999f185c345a493afee4023417210b8c3d6ed619ee319b777a6e07bbe0bfccdef17a5dc2e20f1f0b8e5fffaf3427b47d21de41fad250798fae2e5af2ce974349a0886eafca9473a65aa1f8609c1b746bc2e27104f48052e0e5e5f67f2168dfc81192d43967e841b048e78c1acf4f623f660205f6e00a380966f86ad77a199b59e5f1a5341d4aed8c4e84ae3f564b8b0a122243a8a876067aca2cad76254da3ac1e6efc557490743da83439cb6718b02e2e5db3ef1d4b20bddaa76f439884b9adf79a2c2d79dc41a5532fdd6c58188e68c56d4fb237a442c2696bbd3b36dcb1afdfe2612ed5ff75778451d46f23b3ec8d8260ff68ccad821f6c2c1d6fbc2813ddc6965781043fd9a92e2dd7243473e847ef9ed4af93e12496e261c5456a10cb4af9e3d6426708fdcf297cfd9102a9e2894b40b2469bf2d74efb47d3c40b9eed7f704da7cc82a8c03dbe32e449a36ff46dcf39ee4f996a7773c36dc23924c9c830685455ded8ae2a40b9642354d77fc5b91fa962fa9219e1a66824aaaaf754c4bcb4a67eb05c0cb28aa0144e4ddda2996f9ec4309c13a33489128634d2e8a5a386dabd9b6355aa4db247c41232d13285b85591fe7733f59aa26c3142415d16c1351324fb30730fe7e707754f310e52c514ec19d32ac7c926532a485c82500cc2b55871703698295f5fb1a69dcc8d8de3cf08cbd37a47a976e4efbda7ac091dc1eb86fefc5d2b913ef7dcae51a46322f5be695160133fb79cba5c5983db5c4c565e557bfd7e4095c13bb0cc9948e3668beb926cf7b8733ee00823f79483b09869002d71a2fa9d3953ee323d4002c1d02200733417229bcd7ff08314ef001411a8386aed4db23981f452b08785e2b1b5900535d1693e4d92b1c48c4ad538d48e0d77d94dd734551b58dc537dc9d7c0c200dd9164e74a6ea4ceb91318f0599f80b766d9c5a4d48c9459ca8e7e6100aaa59e85b2b6ee1975bb7015f63e9a539c8b3546edc492f98128da46d6829aa072c1015dc96ba35b07d4b926f9cdb870c5c2a11ecef64e656466fe76226196b1909a0f90170a06829de728b9c30109bcbfe533a46ad24711fa133df509d5ff491c0fc44c7cd02c3d2e9eaa9878f7c9a5a8dd60a335abc8db6506c9c15b7e83b73472f627515322919563eea579eaa9ffdb0c6c3eb90d9a4be745514a45d585ce67c78116183671a1b5cf918f20e62cd53a4c9cb5a0b2eecb0cd02e0b7eb52232dee6e0257bbd9370a8bf850b1dd9244e67d4bb36d1e18001219b0d0c32329622b121b33220356a9db8b3512e6b5dbb513418e37bb9d393f57ffa7d55c0bc7b23bf9697ac4f091415e436044b6fef3492e4629eda3c4ff4578712c93c0eb907a2256b63305ef879614f252912274d7a4e165c6b6094e47a6dba2bd75f13d44d1a973d61b5e8a99ff53ab48ea644ce2c855971562c99f7315fd57089b2521c3178c15be6477318768222f0e4723930e7094d20be2ca8f134737a76206d2d40424ff1c50faf5c869845cd94b032c81f281e030a941f86ba196ffa01196f93155d1ee37a5f82f7e8a2e0e59fe5d9127aeb44b3156867c7c88b8e80b16fe5bfa4fe0513944a5b29d2ebbf57a8ea39380fe519a4b6ed45e5857332ee3457bf06611139ef9fb7043bcbaedce569698238f168467293b2cf25a107e01e8a0e757743d9e83ac4040b8fbefb6b19e037a0b21e7516976f087db57dd68fc98d13c94cf27209ed9442c65cc1f7d1788bab55927dd7523ca9d84e0036170683ae56e3bf8b9203d8787f3a8a6ab37daa1451c4c03d56b00d792ffa5fc7477fb3f309d0e1aac266dfa6783e6b85baf8f8256346719500b732f62e932ef6c89141749994638cd86e1c8f52fb47e10be767e0e87e358bf11844bccd89a468da375ac7dc4418968e59440c36c8b60bbbffd045da4fcc702cb9bf7a2906dc7dda88d138e2e7f6784d8bfd7f5fa95f4f3e2c5af0f12e741e2d999ad801a5348780414f07bb59805cec41ff2f5a0d5ed7bfe35f6e5f604e92acdd3472def2ef7172cdb8222b62fef5b20b865c7281a8c2a68903575864bfe3172850d0576c2fe568339e8fb4df0c6f0137061c0ff67c14b230c3bd48758b455841c57f804ce60789457c97f7f0c8722c4e622e41c517df433f9dcf68079bcf383bc30722ca4d30b2cc07fda21a037456d8dc95d8c1437ecc86ee356e70a896f2b5d41e0c1bf91f3d396ea60389d4664468492dbc66a33a42b90a4348308f0578ee1869f00b1a8ecb0ef8cda40ff4cf0adce52c4dfac8e01b37068474d9d95c6aaef043e46f9695c67f94fcfe0fa6380fd869135563c156f78e6a2ba8338d65a8eef4834f19f4ac0813362555db77617b612de1987130e4afe2ef71cfd2ce2e03bfb6c2f17e5665bdae42f008f047dc3ba3df4c18eeb4dbe5c03b04b471f98f7623a530a4bdfa7b3eda785e5d2cf01a7275ca7806c0a4a5764fc652482229658d91b3fc1e1033ab587feead9bf4c9cd8f6985bf859f24565b18d293a7a4339ecfc7899e0af1656c0ee11262595eff555c9d4fea68d450ecfe46477143daa7693d4de30afcfd37c9803c2eadfda600eb74d86d39d033bfb987d5ad8da040e4d1b5a5356475d229d234428d6c9f21bd20436aa4b777a05d6664733e0baac20e98ab4178a3a7fa9c6d09a68670c09302ddba4ad0ce3454d77966e32a20bc60f5083654ac5b3043cef7ad3fe4e0fe9613fc4e005cdd30eed67b447a580ffd5297ec364c9d9fa1e6be20268e9beb57410f89564fd0fba786aa2e90058dba4e8a79fb130b030bcf1b9f293185aab316160f61347b5b08a20dbed22d9fdfa9b35df329b0c537413e4a3e40cab4dc768b928f3566ac21c7fe008cf9dd9f7bcd606769a359e714c9a913d8e1b4ca956588daa08d068dd59be2e235805737909a2e06377697e60333b3f8810fac35839d0bd086f67a9e39576cffe03c14c0bb5629350270097c8ba5ee45db057439391ccd76f17e670ca0322080de2c45f1f01a0e18f2caa77e5db4fa3cefdf052c3149ba9463f82fd7dd1bcf977e87ac5b02b179155ecdb31cb21ef4633fb47b8477c267002460df9f8bd2413d49974d1309e69155bfb4af6e84d24ab1ea80f4d195cd3ea59fd7b33e7246481eebaeda17719e9dda459b7a1f254d988418c5b64c5347d466ceec71f2b746fdba0c050d9aa70a70bb1051ee5240191a899e65ab00ceb174256f20131c27359f4bf645bccbac2d2ac4c1894be03e2f7fc230c174b45aa2f3fa8bb7a027c75f85aa874d30d08593332a306eb586918d0e24ce65bd81230dc2927c6045d397f91ce28f10dbdd3259ee0f399ad275c9cdbd09e955b8176668574361b5a925aca3eadd0cea111f339d5221a0af5c16f1a17e2712414ec51e4da59c0b20f8ab0dc406edaeda9e158d39bab03bc418e687c9b3a88059cf40eed48951a38d44c49b835758637bd77b63ac6cbffb7311d4b69f99265060ff6433e5597a385389a642740ab78ffa36e026df16e10430d16ecea1cbca4752057b40d55c06cf179c2b1aa2c780fa34facaff2dd62dd51adaf2a4e0a218dc76b6c3056ef90d04bb86833be373d536dc2cf6a0f61c46b6f1ce4f801e476d38fd84f58839e8790a46f9dec4025387e9e70c05846dc45faed8b96cfb47953c56fd331069070e8ce4110e7542b3c6a4441e2762c3943f013f9e947855cb2ea84868a28303e379212d3d76ef789986f76b31e9cbf6d066c2116254b67ba2240cc919e9eb22a4403f82e3d94aa31841dc3ac3ef404f38bc0862c71f95c8d792f18c549edff5993e9b3d2d6348b379aba5c0b06ab68398d1eb29a1fbb3f66ae84f06145e896674aabb79fd32a13f682c2b85e153042450beb9b0b08ad591347c5f184e76cb839af49cbf84841a8ca114e95ebb22a124d879a349f680687f05ade36d14f2c7ee70ae46cd976047fa6243b9c95380aa99b5236c2b662ac74a019ec4d4c6a0c918c8c12f68fd592ffa56cf4d71d361ad40483f1504eeba0294fb08d0270d008a8a62deda47e11586e5f05be5ed5d10d0c1520862a4e39f29b307a139fcf09610caee27df309e86fb3878bc46f04303a8480474aa160f525e927c7d100f67f510192d9607de0413ae321ad5a851f602b97a001aace8de9ce29e7dbfe0120e8f79ce2e2c4c6a8602ade57bd9c516576ba2a471e9a47f5723cb9a4b1cc5f6ad60dad63d0552f9d61b2b13b6a02c0147e8bb35a9c0e966b034596d8c2248f26418f84c1b949bd0a0c7e35e94813796b7111e1a914e6e764a173efd7976ba2f0b7a7866039975279c8ee88b40d7bbfafd28dce56aa23fddb0b003ca1974bb9b6d579896dd00cd6aa8fb9f52ab210919fc6a8b431d502dafca47e1222dca1073d50c98344a69ca107690f70df7f4922d4e29628c72a25970240dfe28990b3d99437a7a728333b92b9f27b9ba5e7570d7839b78b3285af40b13da6e8b35894c172fc242c95bcf0cd3759c87e7b4efaab62e4f6d4dac5d5225a5d7bb2ec990439c5fa1e567f5ec5afdcc73358ecd5b05d6717cef38b7ffa9a604fe4bab77c5b6e3e6336169bf4fa6fbd2636bd694447a25cbaed6d433c12ccdfbde5cce302f69516da1168f5e5717b26b6671b7ae40440b558ef6d1392cadf07eae7a9e54bb0c72fe7a1ff22cb542a2ef1e535bdbb7b8d4d38eebf645d881527095b888c00701f03422815f33624d75d92240ca716ace5b1a9f19385a5ea1e8d41e939a834d77c67474e17db2e281c0c0d1be52efd8c7fea1ff118af1249e6f7c0479712856c56a29791a2632c6462e78a16ea11c08b36b1f790fd13d9b747c1a3a84af25d756513d0d0a74db4387f80e74dafb1d607a2db405ac26248ed5325918e09d301119472e4b0085517832277e014c93b425942e977817d955dc5f9ac4284b233aefbf201f44d5320ed8cb34f481389adac545c25abd14bf050a4f0634019620415026bcb0eda3e22701cde23b4a408f39343f42e03c21ee3c4eb7da77692527541aa0da5bbc5dc04b61d64f1da5c26954ee970970af6a906eb25451d37b607940d85dd923fe17e294777b2ae522490d07f59f217ab5ef1bd1b43a13322468e3f521a31dd70fca2e9f39bcfd2bd0dbcb4cc9f595ba190b7c4fcec59cfdb534d8f80bcfd9b1e5867cb2e7ef2348a90263552d877ec1289ef8db1b13182d69452613436a88bfe8355a5a83271c316efb3e19158ac07049cc4145a792afdfe10d3320140283821f6048fae3d4dfc51a5dd36030975383b35d4565a8439184e114ee5fc0002f41c970c2752bfe3eaa4adbb3163e3f7642b2b3a3b7623c287b88dea2ab6bf21c1a8b3cd9cf0af2ec4eed0a9fbff6a1aad8c71f7832694a31d50897eb5039c3891d4912b4d66eb758fd3fa3260a1b000153e48639350c3b2a6c60706db199141798c0e3fa459fee6671b0278453c8205f73db09d90acde29d41d02d16ba980d70f539b057d8194b8c60dbeb8633d6c09c416f5e5fa04f3f7500d3c7679e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
