<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c964fd5d1fd2b1a8b5395ef57e59fc662a3118fc908fe112a93055a46555b42231d2a4e71485c77d8e816a57f7323295f2959801eccaf048302a00b977b304036ae236fc394e17b383f05148e6123bc0d4445a6284de2bdaae4a18456e84937a024b6379d3377e5dd7b41811047b48e2e494c25057be3cc0e09e3d9ae17d031bfb512706c1cab32427615ac7398750654d2e8ccb8bdb9b3cbedecc05e07b69232714fdfc3f0c59a889af80ddeb920f8e639bd6d7bd23286a18e7a0458fe6397b04324ac87cceaf8eb965901d7866e5bbf80c327a813f2df939c2158ffcc9671a12488982d201579562792867b88af18e68f3cf085e5281fc66b3d8c078c26850a764124d1fa51718e59efc864c596e68732f4919d4c00269639e5d387eb9a180a0828ccb145ca2357bbb38aaf6dbf5db64f63fb54cf4d0bf6afb676ecc44882f1d7fd84f8b40d93ddee7a0c77db6422520d82932b5beba7adc5304cb999c384a69ce4f9c7375df17b5ccabd1b55c50e1b13db0d006eeeeaac6784f3789b148d7abf429fb1d68fe5fc866d753866089e7852b9cd03bb3e198527bd1aaeb57009556ea32b3a1ff4ee7924a4e12eb5283e208512ebd9eb32d96dd93c1fbb7ad380e16a6276bc1e560854b9b1571bd2a46a1e61f594be705d8d455e2c39ee0bea98d4e9384f1e5d279f31075ad18bb64c52492dbea08a660baa2eaa9c44962e29560861580fa1cba8a84e8a31979da32cf22189f5ae54792009de3917e3016d04bd8812ac48fe8c06b8346221fa0f87d3c483840a6c2b0b059e4391bde695e046215def2e1c0da21b84437c42a7fb9e1a7e720157f71153e0aebcebd4b9b67314f89c71ce047522833cdc0baf2234f7130b88968310509de7ae1dbd5bff9f14aece47970fd20260b4fbae0809ca91318aabdba5c7bc425a947e2ca2b8617a6b57f818f3ff560b2bf8c2988c74a24e1c634e802720e97116af88578df215491078c7f0c5d70c8d0edb5cba417ebd0064d983687133a2208f06206b7ad9c5dac07933b54d37f181227a818009e36e6d2f32e271e13c22f5539fa444710718eb0122cdbf8f5cc67c7bf5091ed8c495fbef6dd1c35d99efd137231739559a6fcc4591d918626a001d9b55886217a487ad1dd6986df787721b22cbd823c37930f041a7739feab4bbfe83a499a39ef92c8162242f21032a0625d37300a14ff259f43e6c20ddf12820cb35459621059f7eb54bd19a21d518837dac9f36540301e0bf5f01212ccafc8ec1b6fcb2f5a9b15f3eae0890fa93d1419c6473a828921d813aa4e278001da929177910ede5b84f3225ce181d30e6a1f630c54028e26a705ee529107f578d30754b08f54941d413323bfccf97d27e4d6c297798d79e7ea0bc2b8d2244d39670acdf05912092acd4457cd30f43ba58f6292ceefb3c96be92b68ca4e7e3d29bb7c9c2a5117cafbd1fa4db9943dac78dbb2b142e61364dde0b50f3300d46f7950f0ca952c5e9d6e0e36683826c742d52e8603306a1de7e1cf975004282d842e997696159d19409501b94a9c8189527c82c06acec82fa8db899e5ff641e279d33a8cbe4a13aca1c773c112cc70e18cec8c372e219e961aab3937054fdc4481e8593ed8e464f08130cc5853e65151cf458c5fdf514e475ecb46d79e5ca08dc16e9d745580a441d4af2d478d931b051e6be3794d7a65d22f9221984bee7014e7a90b689c7164f13107ae5e513bba1013a52575a63514cede8b3367c6f2325491f5a99011d4d4589b08cc4abebea179ba898947ca0eb20113c7137808d3e946b6c5037cfd03e51ab3d046018f1d13b68fb53e2ad888aed873a202e038c93eed715ac82d31d4cd3d71617b17b0a989304c5f79a4ca693126701cf2203d4368cd62daded1e6ce583f4d2ed9256d3ad77940949be16597d80d5326af2e042ed302cb2b9aaf6cf20c4ec36dafc45ac6250ec577225be76343a2d3fc3902c7262a9b787879a2b31ca9d697671b56b1d035dda76dc23b4957b644662bc960bbae19cc592ef4503f33ef15d841a0a383613c7d5bdb59c4ef498d4ed4e16973e242e7129ffa3dede3fe708d165d84546b62bc2898b5c128f8bbbe9dec2849a24eb2f84bf71ed63fc43418aaa0cb8f598557083cbef0be78a4c0bd95e4d979927e28415382fed60b414d9f357ef971faaedb072491c19e7f48238fc851b7d029a02e6bc70a3097f3359273fd21a9ba611d74d0d22a46b48e773a3875d29a54cd54339ca182c9c4ccd1dff6df963bae419578ad5be9e45f4b93275d3161219527ed9e0320fae0b4c20f9bf4dc5a2d9b350bda8fc82915a2fe2f3d1d41dae6c381fcc63f5cc49ab60097842f33c2423023d3459ddd97feefff272ea0fe25074064d8c27404355ad5b2affabcf9f333d651a312238a7ba999ede6bb8525366e61a53b02fea72f35b167aeac395d48d3611703c083fe424efcfc2de1a7881a9567fcc20a93f31db71cfceee2abdbc6df068da0e90ac027db12fbe26cd13eedbaf139ad497e96801dcdc55f04ad505d846e03e7f0a0ed0807e1228b6125675942227ac09ca4ad2161f122d121cfe1c5badea17b10036fa75e611e80f078fe567d4dab5a3e208fc859f16d3daacc4e555d03b0bc27c121f83788ebc2e2c878033277030930cd1781fbe18c1a551e1f33e41993e9428729b29261d45bceece4ca4a521ba2c56c66cb8368eb43d77e860b217790195121a3dd18ad849d8134cd364fcdae2ccd90dbb60d5dc711334042933d69e818857f37df825ea8163abb956949d15061811b91186e8c1ff60149c4970e81217cd2a2ae8f36997ad8da3adb79a786b383086b530d7cdb82a5a01bcc142e8150b3d378464aad41e0700f4153e7ba605850ba48bc9274747a0c4055e5ec4693d07875592baab48e30af494ec227b329307bd58b89d146fb26027a9934c6eb774156110feb9f6172f8626042fa768d13a0d1398d2148e1deed38412a07b0e4de5819327f8a79346049c6e1822856cd412e1b09ac302ac7083aca3d6a959a705b333ce6219f7b5cb598a069b883777904a7621463646ab6f69b0f665e135000268b4f9dc1a97191c7362eba8e082027c08c12d01ab0fab4278fca8b60be08478af555f3060679b73b57d3dfa89c47b818bd14e255ee89bb0516bc8b8d1cd56006a3687c142f38471901eb1a2cc11e75c1af2cd8fa01ff755ce116f1b83ccd0817ef1e2c755105d66c898776f0acb04b3d338d2707db8e155e1490c81fdc572ae823b7272d0c5648e6e392df2932e2090860d065ea56ffa3cf00dd0be7c25e1e40d968f2ea110d97c954d9b4814c7eb6a54765383b56c9a9aa9ce47fa2067a5a6225ef208ad0b9d6fb50d27e967bdd09835295117ea43f22c51f3bcb4257ddcfa8c34f3c1d0a17628fcb18497aee0fbd0a3ae3fd8823b01f3eda8cb6bf81177d93ec37339e1757e709699034a107434e180ebc9859683424b358269d4382815229efc2d5cbe4f21f1d5f2d646a3bad4997d0536f7c6495530ba14f8c7283430c24e78d581246540ce1d413232304da80006d4b5699231d70d95a9eef69ad77a3ea07a3d84a3a63b94a4ed6838a3a01e6649b5931163ee875b671aeac6ce8ed158a54805cd5db8099aaeb067c8f3125f12719754547a513563d660f3575c335e55cc0272f7481c337bf621e46869a119f1ae3b182df3796cd006d42eaabb48c447c7d4b4040ded8e68b625a7caf6c7fd266ec47932ac33a2b245c4d802e93249858041f1b178b2bc1d47ddc8b3b86e9613b45f599459726c7fc34e296244d09990f20a99cd2505f8641a49179f1b47e833ee0f6712153fdf3816552598e7b6008e89f96010db7cd0baffb63a8f9820d1a2cdd7784f7933289c94d715faa8f80fb06c3203eacba024ebdebcdafa0b7b53127496ca0644188d92b75a26d77c2d2e5df0ea003e37b3f0ebe065ef7e010bbbfbef53e772de2d9cf96bd1339903a8bef8836384ba1374b1c5b58ae10aefe5e0b3fee705a765394cd48d0e32513694edadd343217d604126fbed23eb0e6de37536bbdfbd0253510e679ef04c113b84b31b1a5fff257047834f12b7229092b9fee2778462d9164f50c72ff728555ed100b88877bc4a11a22cbf38b2819282f3a5d4f81e1c5d08c9fa632105e5d2ed61bddb7044c8f96b9c74844a5b220a8ab626ba30d94269bfeef5da58eb0e2f761af0db64071a03ef27ae402995eefb77c9733b552051d680c0dcb966e35264bf445d0a91b1a68925c506418ffda01fc0f03ac60401d83d538eb835e9ad2c2594c5200778266d45bedfc880153a60bd29dd2e876040c0dbf503d203dfa6b5f4ed8cd6da59efbad7c0c1e4060b8e0f7a890a751d349b9542cb39a7fbd9b60db0f6a777685380ec13d3235b8aac6744423f4c2e22ea888123a489889c819386ce9e9357c6615c99798bcaf113f7f8708acc096b5cfeed55f7e829b5e46be7b65c2b4e994479b67c5753a7760e9a4a8b523efa63451989222e6ccd6ffd0c51f4c6335a3a3ec3c8c34e00e4c385b7d01845e23e46f8a1a157fce32afb0304f6a5179d11112fe840a5983f260d8c7b179c7b685317498c2480635ebe25686d9ae6ebeb77ef8dcec746742367198b36e090124c766108393202e04af096df8806cd57a8a8b5ec32fa2be9caa5ca8f9c7c81064464021f47f8cec09ae163482a80ef872bf79a7868c840ae807c9bc2ffbde1a4881aaa45ceb103e8110f70097fc30ecd70090ad843a99561281992d08265ad81a46fce582edf6aa4d75ae8953342aa56de86bac5f0802fd58a1138e9fa608d60aad4e2ea7fbeccc17587fcfacc3840b0b4d045a11ad9f99595995798c55a2f7c3bdd2550c98f1d1ce51ca0f6dbb83227b227e60f7b439349f2534796aaed166b7e4ae161d18251701e378b2dbe73bfb80804fc241da948e33498750d6f64980ee47dbfeae603176ccd169571a371415100aa331b6c2bd75535abb5c8ef74f9401a976cc5cd4bcf054d0819950e01c84517665efe5c132d8c9bac940b52bfe90d8cc5e27b6aa761c8a5dda7eeb0be95291d8819b0cb55a3bbfabc0240222f91ebe6c01a5cdaeab9c36e105f3f17b3308f20977324b4cc0168864525c519631ee8e6e6093f15050c31fe525dd963e8ab5cb398973c76b981f1ed8910f593499a53b900ebb8447994cf4fd95b325840c13589b9af6806b73c53901e8ad03c1a86dbe56fa4101e1e01323a3d026dd9d02f800adfa3bda33cba4c57a4544eb77bcdbc2eb9a0cbbabde8db71c78ab2526145025afe75e7df95fff116a2316ae5e3ad7ddd48292b7bde495c3718cbd1a51f9e105ab5ccd5e740dbcd3ba3148441210ed1afa33ab2590a75de93d13cb8389a94ec7c0788e1f4597b642267bcdbaf8d620064b0ca5183aeabb3a1bf98b3d17d9b79972366953741e7a5dc917a8649393c87128dbb4fc5b365c48c0ec9d1b71e29a0d235657b42e352baafce177c83e73be0ae6fe56930343ad571d8c2b7c2b34ae73bc7103b0e143e17b06b7ca7c97f8fbeb6b5f84e6292d1f8bf1ba01dba4ae2deffef200b8f01e80d6102d60e1c44f4d7021c8f616c64c64a8dd0aaa5d3decf0cfed3056c0091178cbc415859785d4a48245b40a6e6582f545bafaf0cb0531882a52545003f495c13977d5d6f2992898fd5851e3fc48462997118449430b6360734a8963ad683a074a6b32abd7880e2a3b2a41c4bc2683263212a2ada5bf4307be27ad32a17888ca1fbecf96224e91a9fff3c00c6983c0d017f5683b89818e8f086933495a6d6a10599fb94591ced544cfc9ce0efc0ca905fdacbb7b3c6d3196449ff0cc90214bf4068a711396eea516f8472c2c167813121e837b5718ffb826080173f07b33dea4f86425f3c118436862f549e5fae20f18be62f7a651ba583da4c712605f0e0c5b1a4676327255b6f225294439a7b265fe566cc094542a461cc42aad0b2fe12cd4b037495961ef64c600b841c0e30ccb246ebdea76f7e45d3a7eb8eb9a03f6a69d93eb453fc932be2c04815d58f87ffdd13facdeafd054e150091300f100410d2357ab7f0826937bbc01b419b9dea702e6008e02e83c4686b85a05ff87c5859e7ecc07f4a57fd5de6b5282141308e00b8921fc6690638856ef0bb4d298d546466a08befd7a0de918198c8af71e23b398edd0bb656f83123f17b8bedf0629c5950ece99356ad43fa75976f2eb6356e9c3d759f0cd29bd705c0ac481d32a92e73c90152f9501b8e1ce112892f2605d4f52069fd3f581767d8c55ff743fadde1d9db38bd761f7241aa3fb0f1fcc36c5dca0afdb96581160b9909bdf3c193e54f44fbf786ae8c720f22b27caf5460f35beb911267b0e31624cafb20dd6b05882f1e0fab191c850dab7a668cada74237d2c44be69a9366dda12f44cf96c426c773084ccea80a3b9c2f5312ba462cad865ea055eebded2c06904bf3c8193856a97eb1c30f69dadf8de7d1d0cb517d1394358c30d117b0033f9452c8180e8de91201064e04ade8e640446d271cb5a782b71b0e8ea21dfec581976e4601f62d47f5ae915e1a628b04c82c53799fe4335d9b4db67cdf074e9fa8bd26322755acec6476b259a2b67e5520163a365ff0956593f9df5161b8b86ff4fcf51758ad8d107a16580588c1221a5336a10ca9a9d5bc6641e5b4850a58abd132b4f5ae5249e79803e7387129121d2525affdbb72cdf7d4cb2a894a3dca43c0f04c4eb7b5583c8112a2b32aae419f091a89289edb55d1e091bc510ea1162f1bb1286099179c5cc95a16ce965f7830d29c6b7759c496e80325387e6897855be87b34469950571a139942ac5f543aada8bee76d7bd44cd3aea8f1406f1088f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
