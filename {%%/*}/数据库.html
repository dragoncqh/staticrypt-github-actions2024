<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c4da3c0d18f9a49818b8b535f68f45f76b58c44fbf4b0311fee0cc3e59c367889bab6f32d9230eb43cc4f72e143d861c8707fb5f1daf1de28723cadf8cf73d879067c76e75ad847fb24b4a696b5b0407ff20a0a04fb95ad71e613e834fb7860cfc6182155a664fdd83b6afd13e8cb79110ea63f00c6355b42aa068e6ef12527d4210c0cd3524432c97d173770cb89c3f19dce5da4bfabbc7b92e6822a4beaaf4d095459072d7b4f3a968312dcd39286486c30690c0bc3fc724c8738dcdbddc0fedf20b267fb5a09d1508f5cd27936b58cababb03565eb48150715ed876892bc80a9fa693c0f05bce1b52aa0fe05dfd5285981edf63ef512e40015626929cb963fe148515b4a8dffe6ba1e44f4056e1a90b03acd0259e90979907d210e6f5123dd077af83e783df6181de7124f387f294b94fa12d740e789e86166f9497b91465a0e3d225d970f31ce3e48a145f5899cb0e4cbef10cc03be0424013acf11150b3cfd470142badd546664f43fa7fdb6d46c2d139d8007cf09eecd9f1e3317b71fc3d17c10ca838fb5d798f111ad871f7fe2351249ceed5a1c4bbd33988e77a981cc754fc44f4db86f5c6d13a280c8b9dc198ca491f8e8613746c2d9a56661a9370ef4c5fe1b9d407dbc4e37eadc48b8db9071e3571348c4f99445017a8d6b5787f9e281715268c7e39c487ed409f15a966540c8f475dfe660c82c5489eb4ee4e6925faf7b3a001d448418fbfccd4735cf99b9bbaa814ea451502dc2d8fd388d0eac908de0d03c431213d1759b05ddbb53e4938d8682c88037bb9b9723ed7786c350ba6b2e3f1fcbcb78880fcd2c4cae8d38ae886e483c79b05927878b9451d00c352b9878648d09479427c40f6d00e532fcda46ca250698b32a33124b1fa74475f3793dc7d5ae4cfbb7c2b27a9bc94a38d0d4be9354cbceca2405375360b6175621225ac48ab056e1aff417564affb7442d8be6620bf5b7dc34b5838fa3d16d0f9f66b76556e83f5c2be753f4af8bd9aab7880a4c6f1acecbe771afce30af179d2aa17ac4ae277d342b8beb7591bf2a7f25dccec9b2b6043aa90c0c245bb61da53140927e6338cbd0e8e5562b4fa8db474aedcd5471d7ea4906a7782ebbb48a9d001ae1421a96746f4470cea499100ab2031a0266b30422b3605a864a3da4ef249ce34fdb0466af94a59bff0b2bdfe3d002be2a48eabc90103acfc2c10eb451c247967d1d776033f2442ce43dfb885f6f63d7762e3a4cd1ef2ce5a714fd3640969cc23b1265b13f786181acce6005f14ec4505f35e0e9a148f6adf226163f5d60994dc3cbc4e40fc3dd61e9cd4f0221e7476e497ecc391f33d8102d1e0664dbf4e5c25fe9b903cf160875a77bb35b1ad560d8199b8840e9521c1c797585605c6df054cf4668728c132fac8d34aff678724a6758dc0c993eeb6e53fc85d2513022f1ff38706be529acfa398cd771f27ba4f4a006ab0febd569e4ec48eb4909999c0f17e02670c61bef2d1fb6fed8e3d181e8ad6e75d416989546d30f3b4b7d6a1b12382912b435cb294c56af55fe33ab84d67866c91cc5680fc09fa9e1419dc2d79a973f24d1eb3fe6c73ddb7c5adfcfdfb3dd741a0f2558b3445c4869aa2ed2bf56f3b6a5dde45754a6a1f6ecf78094f6040cf3c4a09ba1ebca9c785b7be5c5bff4de371aec5d21e386b3d446da40f5cedd2834938c05f37f15724559736a7eb9e5e7d87f8863ad2be06a91bcc2a9bf96fc1d67b828e7d6fa6d7ce691b1c29c954430728bffe64a47af420c241de9575694ac2e7172021c79332da2dd0ff8a071f42c80da52a935079e754e7db2a34dafa5972700bc49ad0d41df43cd733f4084fc2eb44f1f86e59edcd61d03d767a692dfa5256244f0dd6309c074f0f980fd61ff9e9558d19ebe954b876300b3085a5d29be71412687a9da0d5e1ca2eec5a943234da1f2a14b9160e8dc1ac51ea2e461ee8550914c775a73351edabecd62e2fae397f0dd0adb39e5985bba1ba14322a69e9152fd3364390d17e3f1434b8319bf99ac88451e235110abb675063f3bb4f3774863d7db15fb41d0a1e49c71eaab73689f2296cc40679701f5f9810562b7881000234d8bda8a4598efb198fb9c8d79caab02136ab2e93493097fbecd3460bfd93540b9656e98354ce1c8de7d2455dcd613be0d477518d101d6e97eb97fb585ce4f3cee2f545257deb9f98c83292933d64d8052dba4402a759a5531049ba9539f44dc3c320ca5300fc4f9ae060d725ed1bfce6c0b6ba2808ade045a27bc60eb65ce9f7434550e8d8209509708d918abcc4557124a88e4a1f8e3b2010f4a64622a5925d5f6ddc14add91c0c5c94bde490b12e86bff57eced6c8bf5148e72d737bca8688a046c1fb2348875f38e1b465b70d0771184d7a6249d0e39bb7888d2dc4a120dc8cfa905fb4acc99abef027184050900386c00f30fc56ceb2f0c047a0cc761a98fd5508eedaee34f2ebc09b59a7e364aa004e3f1a017e97fe622b1748281b84d7be108d8e0ea763f1cf031504b358c256aeb4d7f27a157f6db4c05742c7d887919156c7d94d61f08fab13c963de97403491bb31b17ce9ec334da59d59813227df4d7e5fe6be86644f79d6e69a4322f747e53fb01bd8f7dcb44526d8b9ecd0c2c470f91c8e1d907e3a94b13bfdb903eccf4929c13911cd478ad24a78041cb19dc7a30bb1d917c7c5c80944af66a8c147da911314c798d51142dac1131a7088e847d3847cbf719b9808ea96309ada22dabc9baeb25c36307b2eca4b5739b49e60fb4192a051e2507fac6f911ec4ad845bf7b2c328275ce090dd63b27e46552ce6f49ab3b3f0a486f2135194128ca3a6fad9ab0da0bacb0d37ea21b27141dad9d9fe931036095c5c741eb6207700dc60de0b68d286e5b8edce4cf28aa503b825554ca10c2eb8b291bfdcbe6b5262bda3e1f658bed48fec2e079bc5b066b3d1642dfb17461c6ad66c3f36d64225e136f71cc8baf6625d8fb2a3a3c7ef0139241ae5ce796da43e5a12d50db2e0de8d797ab89b8801aa7acc47b86e897b9876bb9d960818617334704e17c788aa6a3bd9ea9cf489257e94947117cb156015861117441a79f65efb10ecc043a12e96f4383219c9263326aef8b2cda83b070eca50b3857bc60dc0e3fae6c6e6434d2322bceb6fc85cd641c9cf4174d51834e10a805376d2daf4c418741d39be9786f2950f61931e25743d89ee5107a1d6d9b085f6735b58212a5921df4313bab32caf8ea03b588ac60aa52b91292f3fd1da11012cf997412c274890563a67e128720d0e3a0fd3ca111f1a4ff1af05dfa1cf7e29496ead3d83364be553392b5fe94b5a3e01d30897751bbc5eee03b4f1f66af57e644f092b6f28cb897df277c584ad5fc8da55580666b2720487d8ff0d462778d0b4521647885c08889d364ca55a7969b8615a9c81e4800779b08b75f0746e8c44a649c80298eb35935ee584c108615cbfde16b7cdaf4b572303138e0d7c6e318fa4af5c1dd1133f74b1ffbc4a5c6dd56a84e4faa60b08ea429a6669fc962bc48b188871763481d0dbedc63527488fe026f904b9251c30284cc09c426ddb40fbed10c842acff334405803295ef7ae0c54c0552a98d97d95d1c935d4f822eb428d758fdbdb533d34ac3d6288a11b182b9b1dc043995aca0cda398c784c070e34a355a97ca0eaf5a6296c9039b02046e83c4fcf9930fd6282364c21219cadcbd43859ac7abb666ec99ae1544e4fcf8d6061327a19255dc8c0ef55e5cb272c08956ea55ee6a8f8cf03c2a6cd37a50a13fa4a01b553e94971be7ed8ef5c8ab03627c2e027b5d40516576e3a5add0f2adb926785ba1b454b51c292459d42aa748ab4058c7e64cb45d5bb391e2f0a33bcbeb9b471f05109d890f46b8e4d0ad2f119836cdd5512be54ad03a192a03afabac275cfb67d47e868bbdda645dfd4458c61d2d70a2cd177fa088be021c9207aa10c8cd35d2417ba60197116ff7bf242caabdb4781e579b95376d8a3f42a2eba26f04daaed386d5b7124f6678322e69e4b1a4b6a82b2883ff5197ae9f82aecf037fa36c8de1e6ee1e10b1653496f4513142e5f7059f8658341d10b839320a12ee4633b7d7b1a2c6a837be177be4e6e368650efb8450ca943b1907aefad9169f8f4e6ea910b2d64c019faad50711dbbb3f9e1b61a66052fb3b37d7ef34a55ca475efcb78ee9fba9ffa7065a8ab717505f5ef52a251d127fa2fd5ab5752c1507a130db04095c33a5ef93ed8983919cfabc5cd09922369e61ef9a1a540d88eff14f21a37d276326708bb1722d3366cee87f36f96ac252f9db717b9ca85bb2dcba60afcc6250838da1bf28b1d2693d473db8ef99a5801cfe5cf827ba8446425bcf0920490c6918bf57a80d9c5bfc5238e1b86e4ed04633a8c34ff29351bc7059951afa1240964cbe66f1e6a35cd507b34c76d613f9d8298083967e2374a097f40e5b15e25e3afc4525c4100b8c615e5e35659a6be5832aaa9fe8a5841be5a2d293f23ede1c27dff4bfde880fecb095a100cb478d5df87bf4b07193e69cba7225db18c6cb1b1285a374bfb4db7d39ad680b0e24f8fb4fe0d47a7d2bc1ec937ca044e44064a1dfaf135dbf4606cea3e7d6fd638c1e335c38d22f41063155ad88fc5f7985611763e2b8c900b2786f80d0715614f0697e48da69ea96c30a81fbd910f8048de30c796a93a29171be3026aa7402e73a9fee6a015d5e46b325047398ef24d9e3e966a0414bd2d42efa7e03f5516799f3f3d79c6e69e74e37b606dca38509234c2f0952f78d08e56ccb35070f9258f1184345d6286ca9f00f19750e3e975e658b3ca140a058854952ccbc9cc5bc4de67c94fcace29304f44ee115e3fa5029cde62a6aa4061cc2c17402f387c488ea033f3374d9b5cfcd8da930aee870a784a621f70d597687f04cdc4bd209bfe9b86452a1dbd2e390601946331a2e84c453ce88fbbd1ee583bbe4d69beb745f1add5a5ccadf0035e615f4a67be7d20dedfa6928aaffe8a8c9bf3b9b2183b68482bef254bb67ca2c041c954e15f1fbdd9a550392b44a1f023c87aa6e272bdc0b38e12b81104b4d6694a404ba63f52eecd4d181345976f870018b4ef4c666fefbb4d628f06eff59e876a5a32631b246066d0926e32bd64577c37fd9b56abbf05562c54bfaabb76ffbb0088678ccd8069071f268947ca24fcc76fcba3e0f51e8fc2aea315dbcaba92c7bcd95124dd0717ac20c264ebda762b08a8754441f9f4ba51147bc6d04b3249df2369ff283055b453d730770de78c653cda204270e2f8c237f49d4ab6db5f708aaa1743a83e4229a00f28f41a23175e1321aac6a7e9820ec2a42c0e40ec8eae0b93f77bc0a426c064090869e63986e69a192cd13af48f456443b164c84e9f5fd228130941eb8353a22399119fdb46038f8a78f3698e8c66f9b66cc21e2d2885826ae45861575cba6c85ea3f31eea171a944ce203d130335e4f8af439f04293febfc99320ef80de8b6dfa477f54b17d06f6c264d6906d308a7b995c5422c92c0787f172b5cc5f5c6c62204c7c713cf852070f5fd2635a1bac8bbfbfb118d97d343e69b032c9fc79e2e51df698cb3f31ed345c4cf930679607ba39fb717dab9347f466e41f2567262fd82fdfddd534b25d8efa35420ea891e95b23033140ac50a937a12e4f1dc03cd48ef7fe04ebcf1751a54a3a203f5235f1bbf93b8e47e9ef633de34291fa384610acdf236cae8ffb7eb918a6443e0bed2d9b49641cbe4fdc3db2c8febbbb554375c6dcea9802f9e48c8f4e5c278b082a6547c297c8bf2c96ac0dd6c656e3c7c55936fb95849e4c88d107b36dd0e8c4ae9953436cdfa685c52b0b365ac1ea946bf6de2773bfaa2e30cdd4cfc9a66f753c2864d5d1ce8712476894a853305165469db4f94fd7051f90ca40cadb81c7f4b8d548f542f47b742fe493df862ed49a9ad045598b76900fcd7c7c0fabea2aedfef1593c84d16d78e0731b359bfb8861594ef5b261bb8190b7f2c2f65d0fc1158a8bd7896035f189d0ec56b5a278be1f83c7cdfc4c6ed635d093dfb6ed20db767e4a2b21caa6d65e638e38b9b5637dbde37dc0481e78054b15284b20f5ce171f0756c40038894a8fb6350974830029f955ec48cf6930512655953a59b527fc8141a09559d5a81c79e8bbdefb93137596154e5586217d2741274060a926516362260b65ca061976b0edb013e915f12c954596291a0a9b9397d8d29a77f1cd5c33ea1ddd45eef6674aeb11d7b99c22ebbde3fda338106401e12540e5bbaad2dcff943a02c411fc3126014873a12284f886054b57cd576ce119f4a3de10954cd16dda4690fad6a7a68acf36a70dfc40fa63136bc9ad84e1709685782b3bfe131f5a96d841332d4124e6090f8caecfc7fabb511e300bb6bdef34d02e762b27ddb5d2402653a778ec662b72e0452d05f9f2d1a47d978656dd24030e2cdd02580eae1f853990f1e96dcb715c39b74759cdb1d3c9b62f6cd950bdb460f1224c17ebb1bf2802ad4a6a9d3fd09c84dedde0261d7ebc6d2830328da89eceb021072d9c82132e01622a6eb1d5ce63bb72d3e3bf97480af0beb534df56fd821d1533ae473b1b776b4b160fa28c288ab77400dc7be0bb3e6f0eb456232d1e11c4e9a57a99ff42027a394f35982e4c9f5aac5c107cc5a216d3c4b663cd48968a21d9c779f5a571fbed2ece072deac79e8bb3e086b4a3eb2db4f67cc9e4b5f8e96af2aca4ad44f4ca8caa1fd2012e9110052eb98a85ee3129d05b20d1ca32717f16516d0897c2a3cede07fd4b16c2b3d68e1ac07043a3ec65d89e2cdcbd532a6a3464f835112b71bd0b3dc36e8328330d525f387dadf4973af3edd9c66f41acec904063770dd65865fe6f19285908ab8a122136906730f99d99cb754c622cceb5ac19f067066b1f52d80710a84cd917b84a2f6f057fd907ddd3b86373f0dfaa14d1c000973bd3a1e1a0c5e961272e767f3111cc487effa0f13e30b207472763983a42a0d237918805eb792b53e95d8630eb5e59aa02945612a8b747f1e5f2346fa868ed999fab398bd34415c2e16d6a8a66a4b15bb0121fa3f0959877442bb0fcb4df4b65b1dc3e4dd9c6d7a5e74d50f569e801be26b56c9b6d3886f84147aa49fedcc82e20151662f395a1474f006fff27d34b4109d32ae93cc40d19c10700111ff22b7f3d89577a02b1381b2f6873fc5ff31e6e42b0ae3f546d46e6d7c3855d2210d1c5419145f941dd4d5d7fb7a72742f576457b7d23b2e84243be7783ec90ffb64e5012942aedf2763a5535fb6c1a487849a7aa8360ec184e934f05cd798f7902d70e4113dc40a7fa7dc2863c6f4fa3400ed7c6a3acd45653fe0a79ae6b717795368d98c399319ae0d11d7cce99de2f8e1bce47412b1c5ea630d727aa66877d657622de0d320b39b9b50ff84000b598e8788f8c122d1fc05c6f395731cee910d791c967d66aeb1c6aa674477b8079c04b8de54b51eff8fafc1dc74ac5c15b58a40db5586d2c8079eef8eb1d93dc27c512c4972f459f9a2af5bc7f382aad927c1d4184857fd9b44632d9d4b1e04eaac418797aa7e11dec1e6ccc28204421acee31962fc21fb7ab2bece149b016fffbe350aa4daf0fd6df95f26b6f3d8981a474e3f5e65dbd39ad7998cb451629d456d9fc67f78c638207d42c5c8c2e96d7444ff02d6b860f89ffa8d4842234eceec592aaff69986bb65ac1f25ae42d211df260fa841b2aee6b9f3b33402e86a830a7393b1897e55284d8351cb6e699a5ba41a727f298e105e969a89c3a52f7a841e192ed78e68e1abc0a82dbb1f72884a22d07d281343af43175980ec3421e60232157dd11aeb75423bb646711e735a4f20600a65e16a8acd878dd347d9bc15c3dced5663e850a0e639a4c72e8c963e695e7eef8b773cea6194d2444acdd7b22bb73543a6184d1de2c0ba7b130f04620f14dbab1713c0f0ee93604905c44170c7077a38e5099e3b0e2e2e84dff536aef66e480fa89c9d5f3513c91be21ea19e6cd54b9fa1584550d9374683786ee3c4daa6674665b0f3497d49c4c11ca088de0d2d057080f1f953b165b372b9898a776dbf40cbff81af49e54b3cd57c5cbbae231ee4dc870b91317e36fd8957fa56f1fb7c66bdec57e74ecdc5c3433e611be44d95dd920a18217eef8e005e0d93796a6f3d85c68ab4823d5e099b2c861a4302e318d07f6e8aa24678077357c42949f1794afbc9c5747fdfd0d0850a0a7afc03e3964ce78943635337c0fdf1885af05e11b9bd1c205074bb9caac0a27cb963e235bb051b73334b45c812f9d78ce7f38d688dec38338584eef2bb05f7cbbc514dd5281bdd78f2270665fa51755249ff8d5deb6de97502ac8e8acbf41d55bb20c71b5632cc0aa53dbb4bd3ed6d8b2dc131eead3914288fa60c78f8e0bdbe97fd88070259ca20d3cb681b83371c427496d44777d66894a70fdb2e7dba24a9d897bbe0d4938ae9a6ffdeb41d9b9f3f4e2c3abcc82a3869ec532287d05b0e2845a34a9538ae1daa8e8c3815dacedcb9f939f7e9f4d9712e1a84bffb84b28d2d328453f70b66cab4b72b6ec33c8c94f6472b8e6b3374866c1f57475064c36e82ee44e09b221688dbdb13190aeaedcbae12e32b9306cc2875cfe999c9a93b4575732d0b1430649f146d4d3cf6b9f429a1a97e3d00fe93959c44cf8ca7b93fc3b5ab79248f65606f1c439eb26df6312e251fa9978991cf8b3a69f7ba2f72d371f306618fe7665b14a73b12696fc578a7a481ff672cd9c74d6b4b801aca2f879db8e852dec6d8216500021be4ed0284109099f85abce4f4093e5b317052d8c20998a7f12ca3fd80b8f27663cd5f4771ba04df1340955e6501693df0e6b9b6c6b6f6d0b89f979269230527a61e73436088563e0510ee0b71e313535acea1b5480ae45d606e37202fccaf6bf02fd83a84de1a388f3220dd70351d94253b09576c7396af4a7ac97193421246fc3b232a48942cacff636052badf9b892332ed179004d71e03c95912aea77ffc0a59f324421b3d40c7d7163ca64bd9d025159eef1344ba5f8748fea9b469921a3541f01f66c0ad39c25a2c0aa99caead4d82f352a729effbeda5fb16812e614162c840164d2d489589cd5c2bd291c46b3b00cea26317dc3f72d4fb50d6f57f417079d10885ca69e54adb56506a923b65770a272dcd41c52114203c97e7ca06c465d15fd14b20ee241da056d820d483d234b5f8cbfabf4412fea3acf18bc34ac8b50496f97fb391bc05e2d60e0deb8a40d480a321180af0d8398e330aafbd083f30cbb6d602b7c9ca184b07733920156f46c1f514a4b74aac4c5c9e02d8be3e71d4bacf91bb76f495852e62025c71f83c15ad49359ba9ee069d7b01a9f02a0577e0e9bec41cd8c58fa5b93a77d32c9f6beb12be864255dc1c2233119cb39c8ec86a3d75210016721443456cef20e226c21fb352a7fa0f27d5eae6ee3236e9f58f73bd439a8559070fa2e5e0b6d703a92f37c05429044143aecc904ad5a56edae172efb76592b36d0c9a7811c17bcd5556af01286d81339e81155d0280c691962af0b723e1b1976a93761d5a11b139aa2021929185636820922bd60ff4d53ed8976f6c722fb658ca3029e0364c850a3f107ba5af35e38f9637cbaffd03fc3636ebc6ee927f3b7275e025755c11dd0eab1475c05e4a6e4d3de13154aaa282ead6801af6fdc6f29af1612b2060ad2a613b7bb45df5745090e107e56765f040e11c8185c86b90ff02449dfe3975a65099402d75eb27354df64022b2767ae094742344b5c3bd050fd65eec0eeb84870c4fab070858737cbaaa854facc721f1847301d7854e38418ccbcb3abb4336df9745ed9b52b2f77902263c1b45f091b861439ff674a601db8c7b281ffc7edec7a7faca0fff91477242d3d0ed81b9605aa078e09992d8e0ebcd0354050ca42f0a472993981801948e86c768a82878f5a564e02312f1c87f7004c35a36a8bf385371d082dfdd03d6b1716f713e394823c3a445ea443b64379209cca969a4539bd861fee4b94aa97868d651220fd891c7a98c51b8e47ff39c80eb38b66ef5e5359b12bbe72b9d8ca847074de48d06f710ea2e1e2e40c9a9b61de15138072b904fa7ad9e8c73e1580074fa7a21daf241c4ea3c7dcca9e278a1928db39248e97f59957b9e48b22f9289f01f011dd130e0d5fb72224b175bd5465d830cede658d083a0b9bebea49eeb842d5e5bbd211b9ae8704f3ef1b04124b0bff01e1b15ec6b4ae7e59f26b0887965b82aadbb6fe606e78f56fcee2032e34ff76a82ba222a0e4aa2d8c48dfc8b06cf13559421aaf60cd372b15a209313cde54f8a347729558b01fd615e29ec9aab80fd70572c910fd35442faac9d9453035711196ad4ef9b49f8f2601af5003a1a66b28299390804306cc333a6b6b37855763d1de3ba92fdf766f16e01a7bda247a95fbf48f4fb731fefc93f0f684e4dca25770229356cbec1cc5e25d09c40963dab651e4d88dc42f0b9d05fb958f3e1953fe4951a4921ba7d06481fa27abfbcc43999781e6f46db389299ca0a424fb98f3da80db0e09fff1bcddbe578e538a53f1002ecdfd06341e17eb223de63278c5d3e0f306e6a4c8c75fa84ae8ebc9c49cb2712aef6dbfa83e30ae386f6a2c0aecca36c26475c1107b2631811f6fd39030f747eb69f735d5d03ab609e6173deb4acf8ebda4b7e25bad6872b8ef1f574115f7646ae31a41ada6663c448fa5341ffbbc5677042344512522c4d41377723230f2009b19d37916e73afc10067f2c41129c58831d16b4ff4f7d9e61953d079fa2af9f7f977d85ee56e357225fd06aa78ff9b3f05e18efbe8c47032c0a4d6c65ce55b63ea00b7b1829d0d0fb3460788dff8c58a64667925dbac54812ff1fd353d970e03b2d90556c3d8076f6eb356964195bf80cdd09774ef963d774cb10b6b7a33784ff2fa9d13eed128e31e21048e62ac4e3073a2a226654ef64b881d2a7464305dbb336f88c60c031f4765482c7023e05f95eee94588df7ee95ca424d355a446268d8880ea152c11493fc11d1d3e4a38cb3fa25b965b010f1b4fc3fb85e17d66b05939dd498c3a91e17b1aeae2ec33309133576cf84e0d53d7be83078b25aa66da52f5379c7181935206da3287112b5ae2f116284c8a1fc28d27370adbdfeacc5c642669d6400430d8e0606fe7f60a5e29796a687302800b8187da6d34ebaf823be1b2ed3757a75687a7530212b429ccfb19e0d69d2398a6a955c17e50d5ca64690b7464848043bb4d2b2733afdb757ffbee700d16c66ed938b0ae68b7a7d37efa81f91f4d60d5328acdfc9c0b90bd8262d52f517fcc487f8c67d171b2762ee9d0c13c9b08766d75a63317345a7ffba090440b544d42792343d231cfa1ec88e03afd02232e1c1378190780136b43c5bdb54f7e9617412444dc0d9d9497c95ea13c16b6df5361c079ea4dab18a8a97d5303004dda53b1f6bb1702ce1c1c4ec13cc94160bdf8191df81ae34e84e2137daa9cd6f6be0843f19ff4071c1bfea2bb83add85f8adee5124bb8461e4891df671c177e506fd0a9639c109d2a3fdaaa9497e4d9091e5d78953419e5cff91446cc7125a96456d47f2ec282496fd0054b116370846c5efc84dff1ea869c167d6ca126f67e049047eb84918908db83619ecdd54246539801af64134436c817c73a141e7858a6175219febfa47b16b561240603bb8d75b22c1ed9c16a0a01334937eba38f29b911356899dc375bcf5682312728494761af841d6bf51271601b8797e53d2b8f201f1a81d3676bedde79c785b2d44722b83d0c4df5260471891fb6882a8ec856c815936841468a62d6239e81ad0acdcf2a4d05c23cfab72651ebe95d021e8c0deada9be9193fa134df43382681337ac164b4b2e4592c2bf65e0330f6c21ef1a87ff63e6592077eebfb6f42ddc12af8ced583a0d3fdf9631a75f28f7e38b2208a66da1ed14c7b30b419c3c09c10ebb3a8b765b590bce71872c587e076826108f4f4e20012df3623f9e95c97dbbccf53406165a31ca952a4a4bc4ddf15501e6c269880c6538a18d2cb5ccb633740d3302de1b49078e6f63703b37e93d8653b687abd443efba38609c116e985690f85cb8348bc96adde7d10e1fa9ce125a73fdf8854b7b8d0ad5539d4b4c87ef12d8bbd7fce35ceb2bb678930a8599cd902524f8146516d1abe706f383d84190c17172777618907341c2b47234af01ada6301ecf8184bd8ce08b30903ab81c28968c9cb32b7571c238f0011c216d07c38318b4b1a91adfb358876a11679cc587217fa7d87adc4e6f22377838a4803bfbe2c400b82d92222d57c9fff397077a9e22313a5e3946100283430cf854f0630dcacf9afd5ce91b2c56a40799d1c642fb63688418e96a02305efa896d0ef31cc6ec9a968630084e6f90d5f0dcbb6ed9d03197a17dbdb9f9a17de5e80fa6db3ec50e604ec4a73df954c73e2af590bb58a81a29e6cf95d8e1a50ea29eb8977a422e91ea6575dee936353c8d152c8cb80f7983cbae6de88b3ad65f6d27566fa492d043fd91a340762db5bfeea6ffeb18d64acb309c5f4317b59054da49ff29bda19189d85972f6a49b7abced29940d7a36a0ff20ebd8b6fa4e9f60c45895477ddbe382212ba487461d2a705968b6dda5d8afb514cdec06fef9cde4a341a2c5edcbcb39113ca86a2348402099ad1d4e94d50fe7f2f0f1bbb3cf9dd05f3582838d0ff63de2a40c6b70ec7ec328e7d67fe09c7e986cac01e9c18c40ec7076927e3c37878bb53ae9ad29b2524f7f4734efb9c99c42c8866de21efbe5c4d1b0a6c1eab31d5da178623d6b7a8a503909b2c52967eff01ba170429da453a1ec4366778bc27ad620bb26d627519c3ca8c26c9f4707f12a5e410643a98ce2aad67a3f75318c1b4799d8ae97bfcf319e567df79ede9324ef7c86c581bcf745ce7731f78d8c06868ade8bfe3a537a29852577b03b006f4c49d6864f9cd07d68231c112929ac15ca84fb30e0fb153e5fcbd92afd40041dd6f1b769584fe54ad7fe6d1fe026d8aac2cbf41aa310c5f408c100dc9cb229d43b3149192708269ee37b24df9526afaf80bb30ec050a658cdbe58fafbe2c82e08b0d4b34cd8e3d3e98a4819dd4e501730c6b24609e3d45cbddfcc0ae75974570d75ad9ea47b2bbd1f2c61f9b339e993fb2b4f1189895c5542263a4b7f121b32499de17d7d03c477909a4e54aac87e8925f77f453f012ceb26fe219a2831386bee5761dfa4b4e000203ea2482bf645999d5ca8518ed6a83e7ffa3e0683f4368356d024705beae0343f24a036b60458b8450542b78c1671b8ecb8cfbcbfaac431fd00025e795ce3f923b5302972fc2de708ee6496f7613c284be057a9437269c088d907791acd914f4a96c43cd5c6051ac8e67c4d54c29cee3e013ff4ed5e1d33eeab0063af76c96093a87bed2505bc1c42a9bc7683131522babcb5e7f88a7a8a56310d14262dff6c54959f4cb97836b972b6cb9dccfc38eb559cd31c8de2a5ecc7c83511d3cc120227e2a80e7db2114934e84a6564916f68b90182a96a86693c4bc8914c52aa02b2aca1eefad1d3d677c8fafeeb1213fd5a458335ac0b386ebd1c9da51ace2ff068d033add08da16d46467191e0f8f29b53c4ac0c4badbbbfe277078c9d77888ffac818e5e33cfc453b63a83b5fe16965353f98fe089600cac4cfef6ff871e00581bf6bc766740e29c8a02dd1a459a1ab7c60b303287f1e18894073b2f6a51d05a5f02e1ec61e4c525552315844df1eb84ca2ac740a3fb176ee74b6cf45e5063b489f86eb43f83e2d77bda6dbdc7b1c0aa53d0c69edbd79dbd5720571a2af9f76a048080337a78354ccf57a567509fc9c6c438769e8ddca1b0e3badbdcce2f0875619b60e04d949ebf1ae1153abc5318e597f6f3bfa38870b0ce5e913e463062791c5fbb0f520eff76ae8d94d32d7cd5d3682e448f3e1f73b7832b86221a5a54a3bf626ce1452d23e79425ea4918211be0c6486c769443be30bdd3f56eda643814e7fe6acc85564bbc8b5c7589b52cad728fedca35769153856e551bc02bf5366b40e4c68615ddd3da932ab04bf348de1626e14a16baa496a152ddad6add7183fb9a3cfa46477d92d09f820415a1bb52820bdfc613aa1704d642fcce9c8dbf8806002005c685c59d3462e11d8c9c2498c292575e30595908ac35d02509919711a2050ef8095f5c72b3f6483f47d24fa6ddd2d0111bcf51ad64906a8e64edae1b3a89d14d9feaf25c3aecab0efa449dca9d714fc8f93a08ebffa5e35aa2dd71944164858f1a97058d16c0384975965a2e5c003825e6d4ba813617c2def98836496038ed7c285e9340fabb5dc9dfa44c6e20592a24a5867a4d9cf0b04dadf0969c0486cdb07723f7f1fee9f2ff84c320213ce3e6de81383139722508dbeef2c6c86271ada41117e131782f5f66c1549bae3ee594e666a5253f0bf3bca822ff259661a5c6cd691ab59c09d9c4626a1234ca1358fb9569438c7b3a1a874fe9d4625fb83347fb8f3b919db8e55c46ac41ddcbbe4d5d315f3bb07499ba6ad645d7f7d71725d325fd60a7dd72cdb6b87e45fb259f147c70fc80513f3d50e94cafc0459c7de10c7f550d6f6194955c45ab51813ee8566c4e4fc331380616f0a459992a8a1d55f097ccf606619a34af424f6ecfa8127d433666a9aa99020b8860c95cef4f18231ad1696c8c52d7451a550af1ff966fd3c0dcad686ebf67d7cc33723079de9a7da349930e9b4dc7deaba7007b3e48fda8060fbf35ed8f044f1a932d85e0ff4c59ac1b1a0f8228a05f04b18c1cf0cd3b8b98482d9ca91ff849eaf181a7d58921f6e884fb0716fe11e7d3afa6211f9c7e54b52ab3ab9686d052af928d84c52400056c94f8c357cd49995c7ee7946e961b2986c55167932b26fc7f185de24af5258077a7355caf85343d2894a256036dc2e1b5cecf07286f83e0abff5aa81cf585b2daac93ffb9511b5d86a4d8d1a05a0f0fd7958813d1e48547eff5a60b4fcc845fe7fbb20345df57468e65c2fd70c1929543860edfedc35bea86386cfc2b6cbe1f9bdeef86f4ebe93e107d35b0b8e760288810e46bf409cf3cf795d156de6d50eb148c21d426983c3c1f1df3592d3b3a42a0658ad77ca6ce3d193e984887d3e683af9f06f588636e0fc27f34ecb2a878dc2dea5dea5c1f8cd4eff770cb711c911493bc77c35436722f10b0f47d4c473c8a0db6bc43d2fdf585312a12c776829ff3bea6431a76106cfeb5b7594ecdf50bc9bcea6c796251445ee161ff42219584001e52d0f87b977292f454a118d2af0f04191ab39229aebcf80c88a7b3b16f4fd8212d70365aab62794451a1c0a0d3d42d396c827194f9a42630ed91d747dfc5e81d6d4dce08f3ab26b4493ee6cf5065b94f553d0dbd5b623df25412a5ffe8ff24c14b04ce84c618d4eaf0ae8befa854adc028c1d57793685d1b004f27f898c4ecded1500e19d9c7d63fa858f8df3394fdc2606f8a4c9d9da1a6986608977cf4f634b3983ad372854d7046b1eb50097a0fc2380a14c936039bb46fd4512f26178f542bfc3bf718261c954459eb82e16ca61d5e1d8be99bcfcbda4eedd69c30913eb081354b493e24472b7ddcc73573482d1c3f1b6405b7c2d34884b812b3b2ca27598d5686a762cb39b2e37b208635809d23388d1e47823c9f76d8fa96c423fe959b466c29e9aec2632f716e6692c984c299c27a816105e1aa084f98b93508658061a6a95c9f7c9c3d863cc6961ec27a6080ca5037110beb25e706816e825e9950ead0bd2d18f679781a50e358f395a9d2c1074c39006f26778dfb9a5d5debdafe75b17f04a40c06d58c2baf87b2ab693282b0682a39e49c987c9be34efb14c05fe0102444f4a3c26c768ceb8c72430cd9f0f8db7b6195c875df356868074d2e9df455a89e9dbf1b3b23b560683ec963f46fcae04f8e3d021c93706b7722907e3e9b4bbcc3253f4fa654c39f76df6b4764a0c120032d334ad7f3b8fa8cf5fc92cfb75cc7022afa6c94e022006fc594a024319910798d33e9fbac36d46ae6e1af081ea0b3f9f2c63257739d267cc4fbf0b6c08156d7a3f51f2073e676cf947888e1ff6068446c898d565241ad3d3000c6b3bf5d3c4ab89f4e1a01af7d11527b2dc6c3fda9ab41681f662b277972a8bb6f3eaa6ab0bcc5a224823a907dcccfd657a7faaa2df13b65b00a4f32cfad45648a0b198dd952b136313c9a7a5f74be488fcf7272c4dc330343514d8e2d600a6d6fe1e2971a8cc94bffbb4be63f5f06c6174662e373fc8304aa0e9383d862514e95732de8504e9af81c6ae79851d48b889c4f2ec43d279e5be2ff5c4e12571e54645d0ba23ffee287e030d6eabecd8cc9e399a6fa5454f1254090b7f1b0a0646463d984171bef28aedc776aa19eccf42c576969ac54ec344a32ec76f3878c7046d991e47b4a1a0de3373c311144237629426072ae7d5629f83855d6103f9afde725643667a62fbcf4b3a2f9d3347916261d6aa8d6711381186240740905467ad44b2db26a3b8636e61f01ff6ed8cfad9a84609fc22ee9f6d07c5534fe048fa082cab330fe62d6e3d16bdeee6838a61b954ac6a9cde92fb2a318ef2ad5584c380b56f9a0ce4856ba38697dae82a31f9a6c33f4e87fddafd82ac623812a7957d3d4e7aee8a1a5e4e05eeaf170d21fa4e79c02ec2cf1db2094d03ab5764c0fc4fd893b51b1d02377cbd5aa2d19f50ae65e14ae420e4eb33ab4831556d40b68f4d56257b7a8a2a260cb04107a9a26e78dc30f265cfcf1c8305c451b8db4f1f5cfd56f2bf40c4e97ad8c3a6af54f956e068ba2fa47d73a94c5b33f1206006ce87c0507857880e3dbcda48000fd5835fc6f9be89558ab0a631431d0c976b6c374918e895d931e4a6a624c0bff087c609d461e839a396be61f444556711cf0612cdfe3cde545db93b57d703ef33f55b5f3b30d1c5916eec8c51a431842d93dcbe330b3defcacd11ff96f3928bb24b3f6ca999c37b9ddfdd03538e90f7e383ddb0b213f3c2299372c61254c9511d9d2678f94ea02dc0fa00cecb5d394763b01f6212156c3037652acfd7ac045c8482a4c79ded5ec811f71833d12183d352472218abef80f09867f77912c261ff5c8276329954f2c3c8f7dbb8b66819279333f256e758e5ec3731f970e8a16e431869c8e3a8a748f2bf1aba39962dd2abe4e8fa148ec34648eebab492a5176e9d8da6a6ccbdd9545b54644ef63012d4e294ed010450484440e282eed948b3f700c5d853dafaa7880ebe965e65efe7eacc7e4f257564446239c310e67ab6f3113ef9706d542c6882292a2ebc02df7bea82ea18cb999f1672b7c2d9d3e08c1841fbdbd3ddaa045f2dc727d7354eef6580a9ee0859ffe59273fe03867faf905d3191296c6df0a3b5087862caae348e8be2e1eb22463e4ae341c4c288972673f77721f1c90f8899432908831f3d8dda9677b5bb3bcefcce375d54822427c6e3064a39d183b16923bdf42363c7df33cc0fe043cfe43eda29c440862d72daf9aa5cf47419194a012b84981168cc40ea6702089295c629ea3bdb71b3764f8737d17040246cb257f5e105c553ab06f59c3a2ae4fbb185491f404f548ebec34857446378feaafcd3306d23e074439fd6584b9432bfb60d5943e83743cf547067ecbe7e7508a55820911745eade4cc43a25ebe2bd946fb0990e23ccf3a914007cd97f661027c2c14246f9c63eedd80744f04292c1a809eb1931746aaa0cb45a7a6785b184c11adabe337fcac00df09b52c92b376404d200c1aa33d6ff7f0e285c1019de20dc9b8a8af1e0b2828f2af0708253e700ecac1c4fde1de7be90384fa6200fc5d63377e7e8c98b826570389c01c9c8acccf0845e6d31e1d0344a2bc830059427b61ebdd75c9b4cbb7af75889877f4631a7e526ce43d01fa493b2ed3b3ec0c341e9bc591ee2dbf6d774967d6ca3924f896fb22d87facf8cfa7773b3187bc7221f51b3cbd27f0f5924ea509a4cb8ebac0fe5884468550378ca8807067883ed2729052e95b9d7f8db0d873673381473eaaee632272a1c6d3b1040e66e6d4b9986bc8fd421f397c72b395635a23e928be34507718b59306287d88109cad3ba73cdd843a5d521749c947cfb9e21d6085b11952a633eef5f37f72ae762ebf2c37c7124990b81bc036e40d1b0655f2259bc73ed722781d188cbb686ebe3f1c39240cd6fe4368e8b003dbf5161b0960b7b2e79f59e8f587188e56c781b410808ba080e0def1ff560e7b5c376e8a6222c1d3ac5a425882300420a8ede9a8b0086257e2bb109560418d753498b388a94ff5ca8b89c6fa9d0385372d72350b7c3cb2d3cf33e09c0a4b63b8654f8aad87da44d414c986e6968e7eefc5914e8c51f18e1bc918dcdccdf325813b6be98020e826a6fc28c99b568a19a5e22a33a7ac0958581ca1ec863b7306627c74f371875aba17083f6080706afa603014a68224323598c0029515a1dcdd26953df9f22b36aa80f36c03e7b8f838373add4c6fac64ee8d67ada2c7be5f3c34f021c42d89430d253b4c9f03f20d542f1dd5d47f87cedc2ce6263b45dca893a4824c21013f81ca6ba4bdeda55cb0872058a98bd49773f08328a0179a5f481ffa2be04774f7d9b6073aa6b7e4373a4d8e6ac4f5a8081d9caf9953c90c7e33adc33a3ddc27d3477bb4cd064148594fb94560411c4e4510f6afa39c33670c8e84853d25f3e54616ad4e9edf9037ec1e1b9b3fc3b397e1072110386c48fbd5d16c2a7abe074dbd187324c2b3d258a6f605b2ba69abe138b8f6fe301c530da4ffb839c1d146f27fdd24dc50246abadb6228d0974cc6f0e0f7d5d2889ddfc34f8c91973adcc9896c0adcc96eda412a82aff8ca59f1b27ccd7659d7c7c5bd81af18c4867a5e7a8eb5eca188db606864c0e8feec4ef72a40225340d126b20f90a8cea8e6b1292516c5e946e4ff641d33d69c5dfb64b944261520641ae542fd383d248b7ff94ea318465951e3d0e3b47479dd9f66e846c7105f30fb5231312a23518324580e8f48d30a0c902ac82d3a34d66c02e122a0d7174cca5680fb6c409af4c4ca3446537a8e61feeed652d84bc691d6df26765a42a94a02c5636c01064af2b67a7e2f3423f7ac31b63bf000142188072b06c49bddc4a8c2eaf9cba1c5b84e9b2905d3e13bf8726eacba0eee1de05a67d11e5c469edb39553d3005bd95db772691db7d09e1ecaee1d86f20afb50a487f2c307ad04e070aaa4c192928c3c0608a72ce2b13d6111219ee5cc9563cc4a726f6abfd1fc8b4e6c1d652b6e52ea059bfca161b4c93c1ded83ec39a1d7a23aa5ab0dbd6648c266f05a00ee80b1f6c8556f744d8ec8ea43665d425f555237c9bf6b9eca94e3506fc64ee9411d22c8656f08ab08d7616d5233329ed452425ecf269dd6e259d4f56a839fd616b63a0cb2bf867e460d8850ded6797740602a4dfd58540f881818ba935030c3cd68061f17562f10095e7aae0e27e03f698f940db5cee1bf69ce59624947e21204373621178c41dbf633ff91673ddd70dbbb4bfd99da195c5c31cf2c31ec7160b8fbea2ba2f4a2a6ab79b66c0412952a8efeffcf7a11228b41e26cea8c33bd8880859a7fc63e8258e6de2bebcf8df7af87aa305285a1de2f05f312cf2c89e1dee3ef60f86158200b55c2a654e6958c005638198325aa8767846c5d25944d13e711fb5aaefca4638261a65fc1f00d515104486c148dba46a707d7ccff9c0cfc0279e8808f268a90b8a84a97467f6230debbcd6cc9665fef70e398cb63d145bd68827ea7ff37732b620f7b7d1e861f22af45da877df239932e07d8192202b1b1ffa7ce0617eb584f9e8584fe649bc0f1a95a655224cfb4d0b7e67d300041817f81b4e407f82279b0f29b0d1854498f71b834365065142a4f87291280e937a144ae60fa6198345984187ae23890f670367132e939f73b3b44ec07936ac1bde5d811e40c3e97449b7e694f6190cf16dc94e21470edd9a234cfc54c75b0b66b5b86e35cc0f5fad68e45898d7de2085e2cf5f93968c07d984eb27bcdb9f0ae29c92508d0b9172f1e6533efb304cc46d5c9395e0f1dc6e53e26b6cdde0a03870b7b21a08ce2d3304d884ba9997af447ca89d414e68301e4367e1805b34e665bdcc161e54ba5a78c6406c06e401216d1dc156acd40f9c200e4dfd9dcf433916b32ed6b986462ab0a56873e88f87287e3839160fa6be796a79ade93effc547adbc5cb50a7a1c8c66830c8aa6cd69947d756fbf6ff4dd655b7479aa29b05be5a04be40cba716a39b9ad1c36cc809195152603525a3b00016ee93b5b7f3cdf68face3dd0164c2859ccf83ee8fb14b34dcdea5cd6294d791131ed353e35dca0e011bb79c9410c1ed12d87e8905d8fb4917700ae794abe243fb597d0f727a330c73a4746709c9f5ffd862bc98499ded1b5fa277a88336d3586d9a8c9c3e962dc55a62f08801ba5355f74a2fdbbbac6f9b01b5b040b61dd743892355a02b4b6ba6d4ef5223c53241b2037b1f7abc183a52324264ef0c2d6e0d9b696d4339757edee17bb825c3df102eac93b7b32321b7757d919890d16cb8f448190ae7811a14eb8ea711c999d8e1a3fb82ec311e3c44b876792a7dbcae98f60259af72a8d2b9bb0f0316f412d65b41392d5a492d378c8f4f1f318da61b05c492c08472e214560c7ac3a8ac68d6bd77acd62e4cd8462d373f372a59db43b77b51f4853a7d33b6f342e823fb5be2329c9254060005b349a13b03c5195c4527d73d737bc64a0aa4e064e693a51fcb3cf9c7a9cbaa1a0877e4751578fc8048412c8ac40005500b78caa98c4d694d1e257fa07621df1238c35fba5a9c77368bfd1bf24ca82069fe1cba1adab764038c3bbad908f3bbdeb034d31d7bb5938577e281d77e78f8bb4f35e639da6e825ff606bcad8401657f3eddd6e2954ba5cee1a68670b61652145c2ce712aafbf599dd77d01e8c1e93","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
