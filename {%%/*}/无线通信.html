<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5052b9d364c4ae1c566f8bc700df27f136f6a8936afa5743a3147b2eb1f38b8201d4972273077844ac2d18f9df76f01fae4c62bc02b5e601895574536998be0bfcb727c9b656f560793d433bafb4eaed24fdb7cb009d3880ea2d1abde503dcc0570e83e8bdb442d1fd36ec71712a9c443296c61d5ed48c10c83c9f81c45776fc5e8e172df4048ea621e493110e36af3eee057ed429876700108736ef6e72260ea85701d275c9cf503789d8e5e89fcf391a13c5df25dfbab880612254927d678e4955e3b68bea51f083b588d3522b9b9ef267436142b00dc3fde5095bda77c347576152b70a3d2f0c9352b3bdad90c2278a01c1ea4e3af860cdcec2426f675330a9fd94f90bb5ffaadf3744eeb30e50e9977c89acd829c610cf05d86a2eb0b258afa87de97f2639de0d612d96e8baf9c76602c0260fee7c70bb8dad8bed0bffc8f902ab7b2e8b3c1a49d31539678d9ab5d36260a67ada8d48a9319ee0eaabe75a0e444737c4ec2db594a4fbb0b6e2d81d4bebb78f2293b72cac9153869a16f1fda339b17348f77c4a200632298f5432c6292a724112f1fcd507fbb773cadd0d2919385cea2c94343df49b267ff64727e9f212668c1214111a259eb87ed0582f6d4098cb305e724169fc54e0518781b1b1783a19d8b21eeeaf62ad601ae0bcd8cd7978e55a916bcf81cdd291739645e35e7677e21c8eaae324b8e382b65dc72d464a6604a76125cbaa42bc8945acae7af3dfa9dd6dac8b6bbf8900edfc298c3c5503a67adece89b0f8c608dd4219b65e9c5fc1d63969b8e2b570b32d9b2c16eafe59020d84ba67d48d32d5e4e3a1244e080639fa472cacfc6cef755e1c84da0b037021852b487ee046d7647c046d40521e987786fb487550a29a6a8049614cce7d5b2b149d6c0c8ea559df74b005a3915244e79bd3da2f293ab53527c4a544848c3f4f3392e6199f313a3b2eb94f2d4a4c91b78521409c5214cc1290da6b6faf4388a61f7fd21de3501fd78353af3a34397705a6713318d6e211037d6511cbf2b603e5569a8a223a13cc0263f8679ffb7eed315f99ff71d247b2e6f6a32b3e830d8bb0b7cbca966bbdca024fbb9cee9ba95a6b84588190ceec80ab6850d3870616ed1cfd08bc8e61f616228c53248e72393528a9a8a99ef9b8a97416ed4fd7ae266f4ccf1131112ced6e5e5a7fa96bcffb67c7d5b12c08213b2e7c430f96092cabc3efa836ea59f153d1cb3f7de6f8d93f2720def47b21f147e30841c428ee5167c21ecfcec64a522cf248bb2f1d1240b5d68652ee1147f9503537e2df3316ec935a36504ce30ea5d23b0bcb26e90ab9e3eb95e8585d3e4e01add21619d1f8818c464599944a0c8a7c854666dd99ffb6a011eb681a97036d93a39c2b0ece02d709375a19a5cc64991375e6b0518c8eb02c90f6727fa36aeaf0b3527be7a6882593351522506ccc31f688886e1dc4ed4602bc82dceb9e55665116a96334d911875129c1bd2712f06c87237995aac5a1853662b37ec9966b0ce1865d3101ef0c518de21b88d7d9c64c6aba7899321389ec0ed62f0f62a82da3c8749892359cc2e613ddca6ebdc2348105e1f25295f3c2c0f4639a5d4c314b6e30d7335765faf2e99e9489208954c2f6fb3fc835b60710e346460d2f667f500f4ad1cbb216c5665d3918d1015cd8b67c6ebb956aa5a7a702fe7fa995d006ba935bfd924e581b302d328804bef961c5c286b877cb7d5dc4dc7051ca5903d0f46fc075a86d5c016082a52a5c2945587d5c1c762a23136c533ed037ba7b2755fe033b0719255ea2c96afba7270396e60dfcbb45e866f394ac2cef9fd7622668c6ceba0c29c28ca17482a56a50e67c0521acc29e7d5fcefbf816e2d0bc003393b82f5353e3810814e4d8c26bc9af0764a0262a0d2f0b857c3cb5d50ec31de21d6c0781a9068c142273777a49df53e923efd093e55334bc0bab94b8633b937c2077f588a8d01c1c25a46e3c50344f556f14498970bcafe68c083950735377750a06734814a41b806b4917402f239c3f910d8a4d225a385eb393d01e5b51ff19cc7428e37ee635496c819b6f385f870891eb7d18601dba9ab00930b64d19a3d4ae2d82d4d633cc612c5a8c65e3965e49f1186ac4d84ad0ee41b87e5ce4406b767a86dd7991e0b27391c1cc6b354455c7d91827dfb84255984a50b376a0031c33ba1732c2440056facfd605a2622f99db7cd7ceaec3ea6fe1d53a0fdfcd38e154343d415feb523dd4caf2c3e4944836f190a41080f5907782d139db207256d5fa2eb2b3f9b385b749761a52c9c384bbc03287c8bdeea122ab9fb3a017d122b078624317dc906139b47b6116e9cdde35defe6deae286269b5de3cbcd187207f0db55e8213a1b24f03e9153693329f5068056f6d04a0e8083c294f9d6f566d1bff18f294ee7ad892b886fa2c0ee72aec04f3136433393007658546933bba52c264de39df62dfbf3cdb1a3c896434dcff3c17f7a94ac1860099b537cd8828211b66bec86ebed965704dfa505e1bdd15c6beb308c510ff3efe71792f7667a91325658665112c0a925583273ab31e8c8f1ca12ce4ccc7d72ff452fa25f2d925bcd3bdf71d7a1c39d1dcbe6aadb7654ee69b9eaeab36d47b81bed1cd67366f3cdc4c1e379733c6261bfe449c32e22f13a6078076c934e5089ece0447d359e9206a254c3bf4c645175fe60f6280fd6b4072b4ce17cf0c2191207f3d91a2800e3ca5ac752e140cc8d6571c28b7af175e3b75bf4b53ea465fed3b720c1fdac8279a9bfa7215ee248fe762b12db6551c675db4f77e938707062bf2db34a19ec8e4327a92d444cb8c5431c8e99cb2446c0712fff35e2ef91f80ca727597f1235eb99cfa4bc5d4246e29f1b351f6a77f214e261296614abcad88972a21dfd774d02dc476b29d6da51535fcf3d0ae6f828354574a6c4fbf2a30bb3cab42b8a7fa629864a789dd61475ef807c888890b808349a4c03a2ef384a75a3118eb4ad36a4baac7a4fd02b73043b15dfc3b62fac5cf1234a13a88af9cbcf8f97119af3198f39d310ca86641e4a87cdd557c6d7cfefb864539bb8101804156cff40627ffda501b5271ab2f631ed3309afb201cbcc1bdca0c49f1d2c7623b1b9a3a8ac1f7ccb984d22450801ac7b73e0397ab26b2ef5cb9dc32eb0f8dd3bb49ae6c3510e6300aff661ceb1864035af28746766769502555925ca101c4652438cdaf7d40be5cb83c9bbbd87f1efaaafd46de3a13bfbfcf86e1b8d77322ab7889af4978201aca8797b4fdd9c3e79f9e2e100ef08057bfd14593b787792861b7dd26fc9b2a409dc59d60ae4e902aa4fcdfffabb75cd480c2c4865b6e99b1f031019165667291c849cfbc8d7af4d9fdb1a2cb023c9161214cc907d4b0cbfb5c8d8268c44ae18a25882beb61c6964f4e5600d72d33ecf39d599d5e146e31d583fb0dfbc0698adbb6e236bc23a925ce9aed0e69a26672fc3d323b4e29e9ee5a0bf4abbbd1adf33ae4a48bcfcb9a267cb05dfad0806c2082bfef0fd65441c32754177a79bdd9fe872bdc0ed1e0a6832e54a38312f2d9c001ddcb3214d228f67258b6ce65868fc1d48880cffa11986c49bd4d1997fd2f84fb61544e1efd228da2b9859da747493c318c9c6dc7a4f41c6f7c9bd928c9089145c2ea96ebe14ffe374c09e39f97d1b2ee60a66a8be492840dc5bb4a660a4fff2df1ea0695116e29b43d6cb5cb53b8cd15c1f81141b917aac76584a832b3c50e7199d63e888e5a5a7c9a5ed801338d9ab2eb92549ec264caaf37a76a5974f25d4f01b4f6e23581bbce068c2f64d68d421d10fee23ed1d8b53fc5f730d689638c57b21476237c0d87be2360e9e21fe55b3325aaea715f51d2f48fe3a851122f371c77f4423d0e6ea31d4bf852e1de219849fe0d2a7ef1c3305ee09648fd82046896d2570097384571d14bec4eb289c52e408589d73112182506d8301307b8bf526bdc5e0574fd1adc7b0a964d63fbf04e21fd278a71dbf7e89c194d76056e3b8d8673d719a8b3c05a09da5b66598a8b3d4f05cf323ff4a10b1d02e1ce38977ae5f629a1afe9bf2e511c4280a636df50400e3387d13f247acef705ce5abb7d770ed6f3fe4e1bbfaa690f54cfad7e8818034b7c29fc02583e246e5f5763afe4ef4b4c9aa8d80a3f45f0d31ce3044ce573574c35ca8ae24001b5e1658a84b0e1394e487552f94ba2cbd080d2e87d84adcbed5963e106b6fcd5c0f94953497ed2c1add25f7c0196b072dab1b19554d69f557b60016c43d8309d6beaa917fe12728f65d1937ef30bd7b5df1ef736ffbc485323efed241c9c7eba381295c35aece5387cd40cc71d2db256ccc83c262a28e65612eab83acd401d62bdff69ea52aae04fca6ebbcb7e731da271ff984a30f3250fa4ae4af9b0caf9ae62f7c8ccf45b1da2cc6d3ea097f575363b8ce1d43da00b9a0b74b5d6bc21d61ab8bbf63f0360c89979c3a92e5a761f5a203655245b1a4e48a843ff6684ae36e4285e930f49149a718d71d8be0d7b437eddf06f402ace6d0306f65fa38419f7b114eabe95f17a91250cd5702700b766b7d9d0d8a14d52ed3521bf04fee38eb7cff679f1c493345bf41854eb776be64d953f706a0190cb7600178a76da4c10ec47b304d7cdafe1c15259fd21d03f11f9f11069bbf7e3f7f75fc67b850be10844e5381735e2943780a5de6399990d748f10b4a98bdd06f04600258ec86e2135d8752900f3a603bf324f98e9d4f46768dab1e8974a432640604efe04819e6029a02f04faadb8b23fd6ff0af5558884008e95e9367a4274cb4aef0d17f86fce9d47e8fc9515d7bea47f1a8711f31f5df2e585caa118de64c802c3daf9fd6d1d70e8e398ba18e3266ae64c3da6c2c0708f218b184395c850825743152e9b55bbd621d572363f1506ee1c933ab11a64ba812fe913b169b004fd5168461a7aee78a1865d9d5d87fa04c7265cbc824317ed705d587a365bfcb996fa73b8b107f97ac928bb589da340ab61391367f5c876e16472cf927c9c06c3d898a61af99380b8bb93ce67c06556024678d558c2bb909897c037fa6660c89fca8ef83634ec73d0024c57e23eb0ef992a3a72e8f6d2c9db693815ac83049fcb11c938621d82a10ffa7179fbf68487cd26ff253fe645101d99e3c331aa2890e817c1b1ed783202fecda7fdae71158a0abd76565bbb526cbe983fac5da85ebc63af58b05c608dc6018af23ce7499b7bc4fd373c171e4df2572cf57313760df53bc8d080168bef66f58158e71bf1741950933d9142df2c18f099c80a9184f4c4ec79c426bb8727418d2e191243d949a1d254e498a9bebe3849d64f01ba298abfc441d445beb4c6ab5e248c2e48a059f93feff9377b4942809836c9701848dd730f0e48db76e121922f58ca389eccd7e459cc92dea7f04fc4bf5b7ef6b408fec0eb4ef1b2db72b79e4ba8402e53cc12c4ddaf98ddf9aa5514f031a20496d2d72646fb4eb95ce5eecb5ad4b2910782eacda7c684e3a22b2b707fd3880ef0a23b581f99a1e866ac79ff83e4604531acb6967c5b33a2dad9723ee53ad192f5fb4709293f622512ca9c4002d27f887d4adcc6ae3f8925546884988f159cfd3d2386916602b724ee482f9913b2e29abaf363b5e4c8e1c2c341fcdb3a6967c114980f75f9dc220e94000687f217a7d440743b5704b022ba9c1cd6b995c37add22f35b21f0735f6741a9b72ff80f89695712d0ebdb66b50a3fe3c1bf0ea3533113113bbd56d4d43287c3141ab68194aebeca2cc1b42de59e49faa90d2842fd33a08263096cc77b28d98ae4978c20f0b932eee851f340e5424cb2550161eca8038a7f8e3212f2dc6846f584aac91750db3aedd708aef7d2ece17e5ff71091787847cf5443e5858fda4dd1c694213756e3a4cdda2c782943273a8e60d9b93875943abca48b0a585c5324013dcb2445b777081f029ce2b653aab085ab33a541823c20a5bc0f87f841b3fcf30943b1fc6e265acc793e5621ec511db3e6c7a0b29407007d2571d936cb05a21a80fda11fc4602c3838e53172eacf51f85bcd51dfee9d16795d33f5f2b30e5f01895e23f781d35440291fedf5cb0541351bec310e51a8f75822b1822f9b43cc6388386e786ef5da254a4872ed3f8e2e8d9595b21392baf16545a0fe4f69df995236efcde4babbcff42ecef53add0754478f8827df33d3e8f6475d9d3252373dee36ab336f94f660c3c5c5d1d90b06893ab45c0040e2071f6aa843dc5e4234d3960c49eeede0e859af1a90d16ab0c9866e72ca918fd6669e76c2f9eab8c157a820beb2828128e29d1582f77c144c99cc8d4004444f19bf6dbb82e996883e7a22c00905b9dbad1cd8c7ecb8ae8938a75710ef26073d46beb1da5cb6f2d9d825ed7f06a36ef1566b5c8ba2d3732177eacccb534858b05d2596762d4c17d323e6b59e48298360bc5e8e9e75727283c599094bcd410d13da3687a42f0b88254f4f4575907b0eec9ef2d8eef9061963c6071ca99d8fe33aee238bc44813663017285629a30c14c029413bd7db801cc36f5ee116ccd7237eb6fa360e5a10ae762a67c86fa736dc619e36a1796b2d76fa9aacba5505c8fd81322adeb00f0b6449c9f94fe2a5181490a17cf75bfb8e7681c0883cdc1dfe7a3b5b49b4cb3ab6d19cc998cfdd6383983c7df8fe5dccc51b7c7a57727181593c2edab76f53dd94d96486d3703de9195db420c37c04a6f19da216c60d1d6ce217b19c4374d31a559e481084bc22178a90383abe9022a559e6cce4878e94638c9287c6c37624fc59984596603ed29bfee341e58506fe7094a94d2a0c647843f104e16958c7fab9dbb6da717a589d7d1e86221b0fd53b98627f96a68fa80ca89dc5c509565561916f95c6efd7df2e87adad3d11cbbb0cc476c13c0b7dc514c3036dcfc861f33c289d9636eb32e260d95fee5b26c952ed46361989d39ad5565b2a3d10632ce77263e96c1987874ba3f72321ae976057b12664383877b5b94e0d22c531cd03abd4b7270651a3ed726bb90fd6d3890da22de311c880a4f99c19a2e980c6b320b69a4be604704f6d4fad4040e410b435568951755e8f29584f344aa71c02cd6b435e274fb788c1087b0b5705b7bf6213601bcade6cae773a72d3458d51e476cad244aedb19326f33030f75d7e4194096b7c7d227890814274c44a11a7f6311a6d70499ea9d09982681e86609c0d04dd572dceefcffae56de83322447e171fc14037421d75eba6668826e584be833be6f7af5ca6036b0bea38083a5a1668c3835788a16512359b7b2e7f3923d30bef4b41c4a17122367e0475e2c0b210aeda93d672179487afee1c780587d6bb3762a28ca0a338dd77b17aa00c69eda9c56376a0c9b7596e7373b911f6f6459ac5c3710f557496013c61e842d96eae2f075de4a833c56a3d717f332ad34022abd9f3561b76afde8d39189bc35f1917c69e5af5b9885d9d74664c8e99064993b1484bdba184a7236bf6bc1a5cecb89e2cbd71c29e12219d1437c36f7a413087d5ec33cb4f12a595cc6b9e6b6908eeb34b0f411d5d6acf8cec98d869cac32037b0536b9659bff8e30875c7f84efd0e96548926c42071f6619d232ded46dd6fc01a9ceaf32da7f0936ac63fd2291825c96ec82f506b006b853cb8d518f6c20d914b189367954bda610c97afe6a9df9c91d65d0f4b1422bae24a45e0ff5126d1fe2a4740dbab883d1aa2e5ca0c303a3b17e50d4f1560a023e9807dd3701453f1c0522000708708a97259cf1d8c9b7ea84b187d3f7e14df659b95651cef6b73308e6cacfb2855bb04f5cf7459077a04dbe6ce40aaf11dce815c30a8f1b9e9af7ade402965cc6e6a5595de025593480aae3123ec695bd062b91ed2b3e0a4bcf1ff388abe7188b2cc3d826979c866fcb6b99153fa751db3330496cfd90c5bc7a673ad00b88ec5d9c5e77d5bd2a1d0125549f89913fb0dcd6a1136774cc60f9e0bd50cdd52205bef527439e05762ea1be7efdd8c1bb1d87f6eed450988f1c929f3f1881e4ea747d8df2c4013e9392e940e234798c6a5ab66780ed19324356db1f8ecfdb14c8e49e5050f0d914b2074828a2b50cfd05c8700888852f4a0626d78dacbe665b371cdf9676400d24d4576a7a24768b93c0aedd054ee81f82da6dbef0407cb2e16c5e5cac74c8708d20e577cdd69682d903a84ace7eac9c896b132f5cf25bd68877e5cf493918172c4cc35e209ca3df0512690f42b25929c48a92aa7c56ed9eb38d62b650c2cb57b1e008a143412781c8299d1317f03a4465c87b612a7d3b6317a4d3cbbeb69bbf1d1471e5e5a7076874a5cda0ed50e998fc3011d7a303919722c87e8378a9f343b02d97e8a75452f5bef42558109a6f75380f63787ebced59f495c922626c9712155c6eabcfe43ee05c1d8557a786189078672aa4cb4fe37c87d0cbeab90532cf9717597094309a89981480e7b930b251f29c1b2641cad979040b32fb11b761c2776e14e4eeb131291bae284c67b7effc2f26da3dcdeaf8802f40d6e0b1ec54b2b57152eb50447b49f182746d25eb8ba9d55a3d847afc4a606757a169c3216c5bf4ec087afe2e8277c73cff4d51c8a0381f16b8ac073ad938900a7043a0005744b454cabb23c86f036ff64eecf7540327b5bc4d4641d1abae4a81878826cf18c0dd638740d0b456c2dff6962d05b1f20e1b56a5522f966eff47f7d79ef5ed7c518a580617252375160b0cb8185bd3bdd6604662b6187380f117d76dce421d63c2d64ddc25942208b3e4696dcaa4f18591d314e3fa392d7beca442906a4850b33cb7f2d20247661fa56357870badb07a05c9ff414771adf108cc9c5559a3c92d48560b4c1b928cc8eb5102bca71fe0df9908e40033f0cc335bc3d0e62154a17edf3ccba795b924b29d7bf5dfdc196e8dffb56c9a2d60061f06f65e810d2603d76741320d26d57a1ae1ab2048c935c5ed8a435b291a6e2e813c1f4c02b39ad93edf63f0a04ba1ca068e95b7c64e14b425b927783b35b7c131ed5616403d351e864a0869bb55ff750dac749c33be32fd23facff7956bd560b601bea016ef3c552251dedb736c3529c97aad5206ba5b00e0268cb422db2e0f261a9f177f8a512e41b28aeea36335187c0d326e8b9d82325706b1bc5010208b72ddc8e2bfdc49a2f001a97e89e84a6eb1a8750da081bdbb1778af7573359b4b41fc8cdae8120183d7610e656b5381354bc475f1a5df96fb4255935a8b565e76daf09f6c1d447d51c8aef94aa0b19a1b2f5ebcf6ed89f3f8e480c487ef478362e5e88665e523f7811b468147e887a2214c45a6d7086a2e39bb18e5e35b4356902966c501fccefb3f66c665a0ff2a0e349c69337670b4d84bac30b4ce277f1b20084e0842caeeb7dc62f29d52df5836872543cbb4d81e6572ab14ca28094895c34c86617709f5509a494a067e340c913888c36653d24f3cfec04ee264955a86897bc09dc7632703ade0807c680475348d1c06670c8d6996b1530226001096b4f4eec9279a861cdce9d3ecc3d98ddd1aad012dd48f5e1ab703936aa56b0a9d1007e7654dbf076f261017a57013118bef2217689131c71b0fee768653f5c64bf258f0dbf830f7c3405391c0326a9c3964bf536069d1bd4117dc9c95a325c9ef5f91daf3593b8674cd2d5d25518ffe7ec325fbf110f9513085da61c396d49ea8bbe2353c630292a7350259551bad2099c7acb493c4c017485552d9a647bedf10d47a385d58bea1f3a36668f1932db637e1321fc9253bc39eccc8eb541721edde9f526a0498b16a2b7de2a552db6ecc35c93162a7de46137f79178b4ee4ef2728c63a9d1a1a60c4e86679b792f2491280db27f4ebd90f94c01c9e202095d7c615dc2248f85f2ccd162d5f2784f2c9e46eb0b308e56608069d644fc1f1d5ba0b0a24b04825af4d5c3632eb33507963b826065a622f57143e1babb901d7bfe159738c3bc0b70a76c3df876a97c8e42e27b25565a31aa6dfb373c8a9cf8854a4366c36589dfd7dad0d770d81e5010073bd1cb09c581f44d614647dd338e66a2eba0935e09e7d79916e3d5b2f643101a5998c2ff56598602ca1ea9afe6b1230af15d6d7dd39480cfa5a39766689021bc9b460d84e7c651715c4f00b470b083a66f4b6844365912a5b54a50c75fc125347c57b0c58e11be9a3581f0ff5c7fe162634b3687074f0dfe1faf6fbc2d41893e05e4548e2c654c8a7381607b152ee1f0edf04a3d77c646b00c29670d49e4905c0c01489783cb521d1f45aec84cc9372c5bd22af9bd8d7a2711598ddeeba8760d5ca7e6da8997b59f9a2775a962d3bab95bbfcb4ae25109e0d3903f7c08dcc221f3918b3e32fdcdfb80b5d99d7b5ae9693f2dc5c4dafaa5708e02eb97d15526a9d63aca27e916fda12197d40f2e44c6088e002d9b7c3f789a76e302268bd201685da4287d12face735893e51faeaec75850bae9949f11b48012ea804131cadcf28d9d8a73ae470db63ac703e84e512f4c705ca5b8ebd34376ac8e175b9f6afe2b9ff2e2ce61ada6bf87a5e47c6d0e284f832e0563da7df3556dd05869d62c2e5f2fb3cef95a9613cf75934b3b06704220a9ed9c6bee3e97894177a471e5de1555196c34e9b6670a27c00dc18dcec99d2279960f5efef47c368b8d514dcc55ee4d98f3128e8a89bb2f74a64d162817aebdefa55debb581612835f1d1f9d0c42732a2934306f09db7a0371e1c23a91ccab3eae258d24c3a42702a4d75afb6d4d13ebe4ced5f9ccb276419c6dd20a84b3c869b06fde0a397c152f5b151aadd2f21daa6d78a985fa70680a3081b3918c8e55fe8723f9a27d1b53760f4555f5b512167621ca636433ce41f14a1fd81cf4a9079021d9636583e0812c7d69fcd4224e5310b5e91d493820677945f2afbdce1d7028a2308065fd5c51350e7fa8fdf3d77d2cd611f7d144426678a6a48ad09f183a62e02559501f482915984f831a64aab88e2b643492da31da5afb1676e977467795cb6afe40455aba6192c501c81fa4f9613df1a4840309faeee080fc6913cf1449cad49a2e6379b59990ad4b8b86fbb337c1634f9f25304d4e0f7660ea845f209cdc72f94271a7cfbc57313adb5a54ddeb24defad2b58502e0babe27f2b553705fd1679a6f9668e381ebbc4465fab585a5bf2d8ab14e306100600611307b61c6a394671346e4d1e89c6e3f015dddbcbaff002fc4d9c8529b530179c84418671c8db288716da417843621f5ae5943a4497fd479ebd77714293f38fb657f17639bf536ec4a1407f1a36914c0dd0a23cad8cffd48a02c6b219e457b0494a8b28fda380869f48c3fa42dc1c25818d22f4f209ea5667dbf201e009766e54c372bd2f072ce154822ad42ef868d7b8d08fab3a02cb0ff2d9213c959035181f568efa8485829c1788ec05bcb19a78c122d669bfdb22bda167d5ffc2faaeb505b90cdd57fea79f907fe9030c2989363696ef49aafa69b06857f5db8c4e515ffb61836a68e2730d61f5f6f30ab84af76bd339cd194dc8e07b2b0474e636f49888ad6666ee70187adf8667562b1d9bc1fe27648e8b3aae6d3807cda18ac90ac793c6826c06ccbb3af032e4a2308a03c30f438af49f7bbad0981b2517cca78f55c0622b5052a0429b496293472a1c998cd3d77cb04c8374babbeba3f699b6d4591da1bb77eec5f7f7d37091cee66a0e969b7cf2d888e549d83d4a2a47c9bb1222498d46d9801d735770cb887eb87f6c62a050ac359ce0e83190db8cb97bf7b8eda3f9e738b8d0eac546af957dcec4827ee55361bd532132fe07c65764f94505e502a8e7e46c7abc37978e25347a4dea9e5846fdce1c4f07d50aa95877904a6d0934fd287159aadaad8df80653eb7b1a52602b1d6d93f2b0c4b18f7b0a9dbff1143fd7da7ac823e6d3c7842e1ed43e59d98610abe1549c1a98ffa2d5a0ac56247e58ab7f7350f558e20a744d718ba3f50eb03dc44a4a5cc431996179fd4d70a32e9c1faf6d96872018a63142e4bd412abb4e828c41001dbba5b05aaa9b327425799865589311d14e047713ab90c39ab24ac20fd4823b5151c5f546f2b0817f5b8a04818e1b214ab78133f0d708b92e54a6386d982a6ec153ed6dfc862ef11d21a36d17de65df1954da4f6ccb1653ce99c155f58e19fd008b4a82c7727557917f5e525c552be7dd4130f0b46f1d855e918c2ac9eccfe32812d6f6ac5d3c8a051c25aece8a03bad6c28abb1685629ca716bfb047eb10ab35844d8e912ec146f0185d1a321c1c369a23bb04758f2d35fdb31f38e444f29631459262bbc0c46aa0e2baf4af2073c27d7743b5c7f8aa1760bce566995d4a75d59a0227611d34180ef336697a4ae27f5dd3ba60f8d3ea5190771e4d4c886cc492698867428d1e4ac15ed30b97cd395a06bfa3503b1c54cfb460263767ed72e7652df36cfa927586f0533d2e66313f59bea34296343b4f497bbe8cccc4750200596a34b7aa3a39deb1468e0c518c8b4796abee2b6f73e5941d616ab7a44275a5d6e2db5df47e620367f29a0e924b921ecedfda560ae711caba0a7d1b903ace18183e5e47ab5dcb1775bb44d60d390afa2d9b66338263276b4b71fe863811cc8ef3db00dd1470d8d11622824668f97e1a7aad49c2f30b3043dbda71244fc59793ead330deee984ca9a6290756a68d9a90ce593772d49356e7cdb7218c922b57db3bf920bdc8b44fa585dcc78b5cd4c9a5f568a076019fc03b27a45a9476fdde6df2499308a9f56302ed02740d461173215b4f5b214f79f18bfe44eaa1823f0b2c7a5c206f1cc8183671bb39275477c3f187e00027a69abf67416b5f207a80118f347cbae80efb565a25dda959fc872cc00b1761fed2efcff3a8371a9c6a80723bb0924d9a5559ac242ae5f624ee6ed1ab1da1077370f1d7af9f9e7ebaf37ba02ab4a2edf8e19624ae6e029c199ed5763b23ad7b5b955c0d0635f07365569df6b2f1f61b82e072c09d6ad00d7403c7a307331cb489db3c95864c1694e5f1f7121eef3415201783689b7fbdfbd67b5b2758927c0469f1b15ac806d6309b2c0494e4a7a0d9480ae4337b6e1691aa8eec66eb45555a3aad7d4a093b8acb2e87d52b3a78c1c20ea8af8322b22b21bf6fd4420d4c02042e3412744873acea0eb940bd0863192bde7b2acd9ac0703d6128e194274f18a1966dbb8489eb660142b657a2bbb8ac36a3bc19cc32a398aec8a5ac0237e4b9b0f9b6abf716b076ff4dea8636a2b761e22f427fbbe88f8de1b53cc772ccd66dbafc987f9eb320fb4355c44880c228061ff78a7a35a5eefaae6743aa3d29e4ae30d6c787278d864a3850ffeded33a8ef4e8da3a87c04d5716eb19639aa81de6c8400a9e464568be5edc30edd259c26b219cacf8fe8df23886e6c6cc95dc098098c722525d8c1503fbb5d8cf493fa6e57fc8ee7b74dc3d5064fa4ac1ca7a3f92aa23537dd120791010bd56f02027b4a60c509114d620ae9655e6d3ec206df83ecdea5a5596257db287d740a86456134fd2aa3d67d1bdc7e76a509636fedc53aa2e3fb5013cae7bfd8034687d9cd11bc12e314df05dd9c40d1b4f114ece07893a27d3291ecde15b9be267702e58fa4299aed02cd6c9a7df07f4f3eb69bdaf0567d8b397e2bbac97e9f3f8fe1d1641e18502292fb11138fe8ba6aca56bccd6a0288aa743797c081c67abffe722bab9f947a8d47dc2a9af6fe176687ab9cd82d5a98faa797b60ddc78354d43e9bd32310f5803246946a86d5f6d2176fb5175555090cdeb0ca89d5c90de4ffb20849fccf97d63ef4a7d453ffe7b7704eca9e22bd49c330748c2a55a16c1f9b13ad9d308ea40e3c4f11bac8e1ee633a7d6c25cb395817fc7f9c783fc28ea3b27c3b465bc00c3c710386aefaf3f6cfbf4ba29b772d43df841ae2321b74b27cb60a1f59ec9402df01fe17873848eac087d4f0321fcd17f07d01452ac003a846fb4395a3df5d912c8c986c78ea8a05575f258124947b9fed611466316b0f2c63591e9b90395c4900db47dec2e265814fd1a9666d574fc94f2dc8dbe705ffa2d9c8b6ba26cc3eb3d6068dac6a21542b078aeb7908aa25ac675f931110ce1b6e109dd85e786bc71280c4d791d6f2b12898a2fef1d070ea56bd28149623d0af15724b4e52b66a063606635ddffac8f7a4935d1aa8cdefa13456ea012823d04d24fc0a22beb881360af3895d1d0c605430c4b1392e99c3ca93a75f846bf51750c4d74fbc7e64e7a64914416fb321095b14be9200df3b0114e8ceae19356824686314198147b0604dc64389217b1d15fd4e6e50c90e7728e4a0d3cdfae960b68d990a155d6b1c0e50cb8bb95d7adfe688f2a5d7a633dafaee5be00c1eed926599858715ce725b7c736fa2ad6aa1feffe5169d388c7f62f73e3d177d61679516801c847a0c15d2fb0524d8e58ec38061af308b6e4c45a790aa788366bacfe1521087ea70ced0b74a7d5acf1f34ab922cf7546ce3afc597cdbaee16b68a077eaf33fee397f648a2559e1a65abe330e259440e901ff19b567e62e0ae9946a472a4864c75d5a544dc89ee55fa668ad132381c84c812350f1c5df8fb8aeb279f3f2236bbc4db80da958cbd0972d5127513ef378e071818b90bfd8cc148820bb3efbe227a70a6530d789d65068ccc468228a2c27623bb44b6c85960c754529811a1d85648dcedf1cb5af33eab6ce5a4382e69ec359425fd8791a1a3606b09d9cc828b50eeddd13a1e1d8ca506bd16e5063c8219fc777faa2bc7188f51962a95e90d8773e9893b8ab92f3a935d2756576b511cc16dab68b4dec7098fcaa39f89ea2b594286c990490858fbc4b33819645e4bf9c6f28abc83431f68d97d7f5accf930b3f60fedf613c98343cf0fd9220af2432f9c5c6d0088c13809b3e9c8f5d0d5c536d15f1e9e7d3cbf3899981ef0c8a7710c98fcb82997b37172e68ef5139f8af00f14e4ddb2b40bc70779fddd3fc2833be934857abce8412851ca99e7f41b31e46f355e27d4b2cd085e78e376d46df13b4dc7168c3baf3404878bf111af756df0f9bf41bcd2131963d992082708fd25870fe8bd426481ccd13eb10682931b59c7d39a1cc8ffd500a520a450aaf213d86e0c29070267893b0a903a44e504fbe82dbddf16dd611d3f900867a5efbba3ed9c8dad57e644ecc1973831102928ff67b916d32f8c00115b3d562c8ebedfd7b63561adc86ffc6b93773234240a2b687717671c7f60d04286d6282b62488c0c8132b09a31c78ed3086d639690acfc8a58035e304f6e45370b20a91c7e15723016c772060a0907af4e24fc6ac1d86b31b2e290c7e8f2f01e3ceeed52455f3340c91d191d269232c049ca865becba67aae3a5e456b49abdd2bd292f4c4e0c239882af181bb3126d5fed5805bd66bf63552afb1e88d47a7f6bef4ef88a685b29afbe2018306d1b385b57100e36b0f6a0409d562525df54006036f3187036290998dbc430e1610bf4a38419871cc9229466cded0d851b59e8de2ea25118aaeb35bf50925c3ae2d1617e8cb422ed20325e76ea3747bf56e8ed03e278bac14002af8eb1a252de190a08dcaccec39e7a1a165e51621ad13194601dddd1886f1b3bc7ce94a3f2ec7d9c0222913d1fe81d58444fdff5dcdbbef468023482cc0f31543b537b26d7913cf7f3efed51aaf10e115039ce07e7e6b4c30e3a26d914111e36c369479ef9a6d804090d7e9b1860c51b80111d6b6d5968e6b8e7acd1bfd457240e102d1550e9b13de707fc09a1e74db4785db396f4f174cbde5eaf2c6e49a6f64242dcd2b033eae14db6c4e1dccfa256f87d183fb515d7e82737d2324752114dfbe6a8617811b0db80a206e3e4d57e07bd3bb9eb78f708426a74a4026b9348fb5ab2871ec715493f2e38e35deb5b11691e37c2b7616405b83f5fce76f09a23623677d62c54377f8e1bd24ac92cf785469272a2c45a23ceb6e9b124a5de42c8aab15e37935295e3832c0570ae77d43882f290a9de63c30e310a60250cdf18a2cf8de34c0d1f680ee4ff88eb2e479c0dfd7d42f5b1f32500094d0052e6f2cf9be32474628b4c96f7e010d42b6159c3d2e40f38fcfb57e4cd4053653f0a15844aa5ae29a880bfa7abe392682cd0c6e7956f6c32c5b1816b6a688b72dcefaf62f113c7d147f39a4d5f6927f33cd359b0d8757b5f47541cddd3c26bf87765191f2d82aad94219ab969ee0011f3869728d99db56aacbb90b30646c57e87fcfba3ef16a0e6da108a49c99496603e894cc51989e2f32bedd76b37fba119c7d6dc9579311c99850ebb9daf070aa724f429731c571a18d7635c9fdbc7eb2a416f9758e2730ce57025b0b8670d35a0da1ed8062802d9277cc7bc237b09b725bd23ac60a9d4dc0264d78f8faa63efe2031fc1304fd761aec285baaf33dea4c7364d70b8593ee0e7e3ccb3b085956f897bafa7ce6c256e1bdae3b9912577e3d8301c9f951da2797067dd1ffcca58667adb5bb6dca1c8ad85df3417cb6e486e4a1a7577156d57867b8287f022b987384fa45fc4c2d10ba88c1834ead9c48d804023aac012aa2ca7f620d5898877f7c6654af332a084af49d9cb58fd0466176f1abf290ff47bf23d44a8e7d5c1ef9ac4fa0046f64068289259e92a7af8daad2b31ba034f93660c7a2081c2c8702eece9f0e45da33d1979510ec409858c73a3608cc3418c19a7db52beb9850bb1bf89d4460118b9ec06e3c40c314e7d36330d9c1458499765830f20883b15af74d40db54636c9625918f4efbfeaeec2f76ed6ffa08d27351e54d2b31744a647ae37fd2d3e6e32ff22136abd4455bf2482d8bb87f29ee605f5faf364aa1fa67861d9ad6bfaaffe4a5080b96a59443dfe8d4009f9fcb3a74bb8819dfab08195e5e01ef55474cc4597cb5671addb0d6a562bc97cdaca15dc32659ceb99e8353e8330f7c89c66f7e36663f451eb37d08c41b385f3d3cd2342a9b8ff9a48e8b965fea0a5277cb9b9678bafc93afe34954d72ce716fab4124fc0b92e711953f5241ed0d53e4bc9b36f06535be1d52aa8aae30165791a4275e3cef4e1a3fc194f307e1aed286a1fd9d6a0a19c4c0b0e139e7f97760d7999383380f183ab9345a421290ece898e64703dd9b2fb253785bf9c70a1751a3bfa9c3a403ea25e54725749198d4941063b8dad29713470b78ded640fdee54d9eb518cdad85c01606815c22b657c3c2727efa32f28e4d70413bfaa92ebae86da94e5d9cb8755db741d5add69520824ec877efcbe22b57fac6c6241a1fdc2dda1d5b75b479bd15ccc54da0fef16ffbd531820bae3f9eb64f09a35275aee12b6f654fdc77459e54e9dd5427d46f0faeae13c382b4c1fc5a4fc34734840ae4a9cad3b5cf311b33a5aefa0de9ee8e1c1e54dd295fa7c25720bf68ba811b006e8131063f7ec2384c0fcfb85593e3e9a634519b7bd03c2ef78065f641269aab06b7b3311cac8e4ce374ad11f97ecff6a85265dacdeac9f14018f55b1d84a9cffc867e7991ebb1b70cd8437039195d31490d7672b8f405c80217d05640999f41485341b703f8fb756921667308959046489d28d0bb072152d9fdc9183b9346beb7aa51de1833319c56fdac5e95c0b7e8cf3bb6f1bdb955f5d585ea2373c914250aa1d1631cea9e143f848a92c01d9cee76ff6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
