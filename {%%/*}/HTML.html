<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"617092075bf4c995851d1481496b0570f8631048e98080dc894a853dc3384e2adde8532f8cb2835a612afd3634818d2c4940636f893141a344ca130d24feccda426055a0c77c5d29a91f33a4954a5d6bded2e0e592a3bf802bec936f9970380a46050f9bc8ecb3d6a2ade10d13f123a170ddee00b072484f9475b4406799df79519547b16be59bb6942a3f3257617f3cc7aea2cea5a2050a54eacfa503c79f3436b4de9278b713429d4c0ab80824b75e79bbc511c548594a255aa3a6f39d62c6449e14ec49fdeccc33d64df0389907724d5d42b5eab061c14ad7436aa9d54bc2875bb2446add3e8d35ca643547089afd15e5160f2626614fd669b9521c9b3bea57a34a178c183218c00a5a28b8b07a52babeaec3402816914c167b114fcac9d2d58569652a42aea34a3f255bf9269cd6db657c0102806dd2cc59d9d66fe9128350135b8973c4ca1dd669aafb9d9fc18bce7b011dfc2ad5479198b0cf9417c59ff7efb742f4f378bfa36a458d4506e97cf3463200556bccc16807d2a53273d9e7fdd1459fb6715adc6d89759c9b2d554591cae8e86fbe035a0eda9dc9968966b1c2ecbb95d8bb1b077d198238256c65c05b1888edccf84c256ead4c444630a5699ce9a3bc718027f2980a467e09578298e9d07115627cdf09ebbf669413c3683093365a0bd2404b049d8387dc30bcf3d69acf1ba66fd668d0173281cb10c994e1545ddff8531f6de898cce30cf93c8f9a9ef029d0e036b3b8b32d4d244a14e294e40b9f5b05c32d610e582d612a8975bc5d8ef421168f07722bcd04a5124995ac944ac92e4778486735e440b9325788f166b9069c7c9868ce6d884e0eed052a9f5102688ce848b00d482a7edb45cbb63f902904ed81918e45e0d3413d535d02c154c9613fb0dd64a3bdcf3d33df55d145867d7a9ad3ba5a65914f3b469eb48adc6d236502d734cd41a5101364d9fd0b64fa4230c07e5864a898d7612faa2d443037f6fb927a567a8300741404f2ca67e83d0c0dd31d27e32db6e59f7e998c5ef9886dc3923ef367c2875f9ab8106e56edccc9e9ff6d14ebf0795d18dea2e3dff7e9c990f76c5ae70f1acfc08a99613629dc2a7a6c97257fdc24b71b1d6f81e7d8072ff539ac153530b248f0dd63ba2494cd30b1df0a7640da21766a852f86caea0439e067991bd01509e7a5ade39b3bb99c8cdc23a9b980516b50d89a46e7bb8000a27b6d560ccbc71973d6d495aacb30251ccf78b15254f85aded5632f62f9d865dc794d2dba60866dcacd64947efa43f7bc471574e706c747ca5a06548489be7f4de8286e1ce6dfe42cb23e79335072331b831a20722b2ac91375e1e4aec0f52399d62b866e521931fff9da86361231731a58869024c512308926b1f53e74aa9d3e710d4311ff9a3331f98d41aca50ae2dbca6b90189722eddba1c6241940b782e3d700c2dd712c7ff888539a37d6f36fc3fbda7a4d4743d8044ae00cad3a5e1cd5f49fe60e0b7be2e5354ebfd091ac5a5a0efbdb556c9fa9ad7a3dee514c8a31fd0b2be4d1573cd0480d95531b8e8b0d6b26a3c2631de05b17a2f61a0318509414707f9076b352c30510bfb3650a87ecfb6592aa165259faa611ba808c68c1e6503e012c5331d597312de2f6b8169a1b43a419e549ceeec6d5fcbf654e573e53f5ae634a258b6c6e083fcd24248e5b22624b8db1a710e3e60228bad7cd80dbdd6b29b426bb406baf6747cdb27f530b65bd60a5a697f1adc54560b97d5e0aefa82c81a69f25b4b0b79a3d1b23a9cd7e52c1767345b0d8d38988c799d4af4c413c8436152a5c270e37b8a062ce401444f7ec4ddaa9c3da39b925f959c9ca1dfd172085ebc8af652b4d47ad1c82fb9488458e17debab536863a205dd5c88451349eec22cf0a9f9997a2e16f5927b045bcffb7141d23afab16f6cb5df5a8d1d1892852840741c9e9051a18ed956b680c4dba4c3650f390d791fd5d52c6d79fb717dbf7fa9b67366f72cbc650e701d42b3098dba57b10593e95608a4c08b9dbbcf20a0609695f54badfdbc0a4fea034efee2277fb370e83824b3c107b7aa452d52b65e87d40f769050b6daabfed8300afa0aea2933560b6c805fb1f606d7ff60ad2ac60f95b66d9ce164379046a68be356782c1a30f905d0e48413fb8aea5164f221d0159a26199bea12dbbd6ee154f59b2a2b1ff92455849b11e6b9933043fe5e680f9a35443aebb83c89975eeebb241ab1c635d1d6f49b874db03afc762501e2d9e82bd65a65231ac2f8c1eeedc4299f96827cdc77d469e6f296b7385b28805af205103b4e522ee9e78a431d620628f7f9de852f905f2db2fb613f16854ed557cf4c06f9b71c248e1199a1ef672e522aa4a715e575c3c50de03a427a1ca5b3e369038ada75824bfa3204d542d936f3f55ffc51b68e03367c621d705c9197b62fbac565484b6f4bba53894eda91fd168c01d2a2c61c2fd53f0592156ea08e92b47d2e72577328503d718c21913eb426c846df8198eec859dbe96830a40e27ae921bf069159c29c98a6dbacc04f2529a10a516bf640046ab8ad3f4213ffde2d3a806f828ebc2d7798acd872dd98a41a944f45351fc3390d653a012fc27d3ef9db123967f8b791640f7befaf63238e51378659c52272e6ceb2ad0d3367cbf8c0d24f41f70731937cfa91887dc13fda47160f27d0e31c0f24fc63c6543c80b0b2389fc7d57b3eaae5f544fb92536f113ef3dd89f7bb786552d36dc3bc2d00e180ff6f19088c8039fc969e46e0c066c88bd8356c8cea7ef13011de52d88d860599ce01886473de87b9d95626a7dc835730a9509082ebc74db0167ce33c60b7c1f548b61b9e12a6566908e8e693c4d1d266b66d76035ab6254137706afdb8e6c6345dba6c113c4b29448679d800284cead1cbfd5a6240ba2b482db49426ac37320cc631de42d3b6271dd16a4c6b3d76090163b14d405d79d0dc671a42153667b33af4e84a73c6a6c24b6d969c60feb5e4edc7dd545bb8e8956634df1f744d067147daad4f31635fde620bc3ab7566b9970bc17e2c22490847b109d1d75297c12de97ceeb96742ad889149717c25119547d2e0798c0458fde233d77d9511a9a1af418490a8e584e055e7339dd3206acb9cc3a3bf7ac43abc0cf9519873157f701f5bbea24083997f0bce4e3b2d4902059a7ffe99a8cc4cf4ca526488ee99a0547fca853cc8a4c1ca09877df3dd0a1d812e239145cc7e1e794823013211a3e2476f8b792a8b187b9f3e8146883cb13c7a01066628759a86febd105bfaed1010e79c169e969e659b73b207857046dcf6f9c3bc04b28325e6b1c96d846aecd72828856cb06c824b1c2223cbfccb5e48eb12006b4da38eb32ee8f06406b1c8677209e886182068e71be4310556536a8e8aecf5c52f0f69742b499629787cae542113971b4ccd7085366ad1e97b49e2d8e12c6b0abd9f17dda0da31523cc42d6c2f0630ecc905465dbcaf95620069334f13f84a39b95ec8051d2c03da5720e5b18724210451da473309e6901d91e3083fab9cc92c3bab496589eb844ca7e8e967e9c16b5d7e60fd035164e8a26c6be015a69db9588dabe6852a1b61812ca6b4d317120e9e5acd486bdf0ae74b4ab569769c1d405c43ada2c1ba09af23995076c9e397dd09eb6628a1c98f1eb08697fb848c42767186376f40dba11afd96c72cdf7b573ccd33d65121ca4f94ce048da19d0077929d6f4653f4a27c465b8d6ef5dd2b009c0555de13db8353b5edbd90e2632e2656d4f74d2ae6718e12f4026ab79a343fd462a974a3946ca806d484285f221a09bfd6bdb146f119c2d172cf0299b650ee30aa0eec055a37956d339dc7231095c961fd36f376bf84ca22e4c1c8bb4b5e9fa334733b1e7153db0442f0c80e6f1ff4870e40cc8e4ad50da9d9c77b30a0a17ae1624264aee27cf7a770c14be8fb47a4c7ab4d7087a7721b51df990c56778fc18e56faa3a38f028f1cc93deb1d5311afbae3fd95b50d96248d65bbe6b5877cc44b993c79295c9a72757d155a30b197a07317f17cdc84d803c19f12816c5c1fff2fb15d16cd6ab625bd236221e3610f7a60451ea4c043221167149d0b69fc04e2bba858aaf33282a415bf54a5bf0573770883a2d1863e5f9522e8bef04359fa47ada1620c92b1f1f696d8cec560a94e2c76c8d44337ae41b1390c461c351e6921cedb80aa1ee0402fe3ab0361c685609b5a3ab3ccdf4b8a3fdfaf0fad57475f24f7d04ad5698ca3072799a410a9d152995563785779c523faed12d4a8c1ff7a169a2ef4ab2057f82730370f169dfbda61575005c0b755721c160e461a0c73347a011efc2a5c8bdafcb9b0736f4d63a2d48ade89539c0f617b9d2b324c7845ecda8afa4c55bc2d8eadd93a499111dac0c42172b9465c6f852ba36c518e7441f37e9fdacf5d080c4d216e0bc7b5742182d9f293fc30b1ec87c19ac696b576b2e3fd91af7bccf488bf7962d051da8c6750ba4821fae646a03ba53a3285536cf156af86d0bd1290c85f5f1977a393288a69592efc642383f6a1c0f3a1cffeff1a8386851d24c751d65beb699009e242e2dc3c808d0606cf4e24dcbb628d4e38141ea671fc38365bd3709547593eae02a2b171b8e1f57b5046e15e801147556173e78f3f7a5b6773d4cf8fd5f3438d92b860585ea63c02a242238e67f013b57b6f4a9b29dff48b26a5a5c726971fad77e277e076e4755e9df7df859d8fa0fe058255b3bf3044086a3569735af57ab63e21a6ced84edefe46908c3e322ed0955ed25cef5bbcf392d0240cfe7ce814fd7126cf82a619f82ae714060f80ab128662acf6df904e49434a43b30d4a992921b6d9db392dd12ce6b596cdebad63940ca58c4fd2ec26c1bc25efbc1f18a2a2aa22f8f9ecde349ad6ecfe436585b8cc90627b96672774784536f5a136a3870656274a893a0729865b1f0a5475406a51fe362c19cab91aaf5989a9d3ea3818e029840fe5ecae0b6e3c7f1e94f963fccf27dcc9246fd5c3f7ee3ca439fcb1a46a01e10a2663e796174e4156ed325f0438e3633fcbdc9a19c6bbc508a9a5c45636ea78a890d3473d5b39a09620baf0bd2f645b9bea4ed56bc43583bb3726d6731822dee656a9fcf75d8ce8ada30b5e2c58d64d75d4e3d03f5a68a553666abbbbb84627e1365b47d4bca9d655788685b6b30fe79f5946ba16e7bafd7d4ec07f2d284646b716b944a4d3739607018db2827fa6d6a30425bb7951e07328708de3da93dac44968f298cba16db07d28530aa7ff105bf74ae36cbd26df6751225267c286a41bdd99e7b7f9bfaa65606cb1c43ce66e1cbef241e8fd5dd8518acf00a0abda184d3c99aae9e58e3b11341f1a7a5a12934cf0644926de2d48b13dadd71967b2600b6a1c0a621feef79fbcddf22ce65ed457d688c89810db82a0f0c0fc4fe1227da372142b65eb6985f185931f071e302e24843270bd23e7691427a3371986aa9cb98c5971982cf79e10710523806ca797ade08804777b0e7414a26cbc68db3afa217166bcbb33399598cc6441548f0bc2c5e45b99b9920380eb9a58e12c0cb47671f945fd2bd46fd728fac78284459d1515a2e25e1295d1c4561ad5355864688e1731f8657006301fa940f5f7288af9c7ca628a005c023fdf96008eb988640ded1411a1610b7703bd6f2c7b010793c1d410c1c3c07ca9fdb411807e37eea368ab6bc5d88985ca1efd3cea1b6bf831ff8f0683f1eb8b1cd99b2845f03f8af96a7e2e1623015db7f9942e35628e9401dea96c9a7fe09347b2233ad9bcea73fdd6f3fd2f5773085c28339056ffc0de8dfe32d11633b307fbf3c007b68bf37db34b9b8c4a52524b24c7a717890f511b5f86d0915efa63db4eafb3dee51a61dd8ccf1e3d85c0ae25d09dda1f1c502455c643bf47f3430d27c7f9dee4ddc35fb525f97d13fc3c3379eb4061aee3a0461cc5ebac166219c9d82b60f63baa6ee32c5033506461ca397e315c994042335cc1fd155ccd81dd0e8be33962e17291bdb4327ff36946bc7a8926277b99c579a05f249cbaf24b78104ab4d2d98770bff08b5dfd5ea76499deee04909913e44e6e105e2f698e13490814867578d268d9554fe00308c0e2fecf70c83eed9b571e78cb4902e42b327583552752bc949dc8191664e3a702cf638117315c9e52848624ac11a66a262f43753d41ba3080a66476ee8d566b84f3223c1dca46c8f4224d267d3cc04ababeb56d1e6837a27948477a0455a329b3c06cae747c424061e45fc6b514eae4dae5a0ebfab13d090674564ec23c3d60b5ab88a8cdecede50d76daae49629d8768329f63a65cccedb125223b3e08057ae0e4c80827e2f928844987db70660f352b9da708e008ce6cd5700e85cb520fef408de1a6d2380a5b10b37f78cb3fd8db08c501fbbc605339a1ab868baaead162a746333187b434ef1ce97106b92e5ed617153c2c4f79ed4b25a1db52e554e91771932e4f0b37a8aa90929b782309b3f39a056feccc65760d0dad632d242755a421529dc87d54c20ba426472134958468ec6445cbb646109e34f93cc7e59d401c243d81b852b52f13e2a6c8fa376d0d0ad61d8daaaf7b6a1f8c1d8ea88ae8bf8424847ba1f0f18862f28d50544fe2d89461c677b91ef530bd1552f4d05979cbdeaf87f776d25a5b56dbe675eb4576bf823df7632e76097a3771358729db09b2c15b9b93953411bc18de9fa50c1bd36b5f899dc68df73918e6b34261c46d03739b746bdaa9e3de1d4c5e52466bcd3d0949b15436ea64f6a0d7caf965f6de76cf3ecff2a03afbda8fae4ecdf99e08ce8b756faa78f22279598e128c587cac21e696ee70985c921031e8fd37f0c9a20d2dbce52ac58fa26fa48450383a81af3ab3a6646eb8a8d06f4bea8acaf4321cb89b47351c755783511c241ac08e3bfd81c9744940062f6b891c7fd2f711db4d0ca888195c3f25a9154c6a959438f85fe79075f46f269114d55a8abc4edea11dd93e3dbf2a793e17df57e8da1eb94148b39aa696413f5f4d86cbeff70a2179be12805e923b3d4b926104c9009a5a9c7e32efd571d9fcb557fe7aebc226539ae59d15bcfe6e968f8487b3ac791fd3fcd649a45028f7c733864f6f781558fda4024c46ec4e0741c34dc66e830b390b10f0b32836ed1ff70b8a5b249e8dfab21c2e3694aa9b928a05cfce498fa77eab2e433daa8128cda461e33b77584331869445a76615836163f596eb254b24335f2e64bd249c937b2bc8f258ce10f646f9aa3bc04006c17fff2f53904790a673566631ffc51141ef55acf9f7fef831847e53450c665400b7564e743e79216e4afb73e47e8e8403660686ce66a11a35c89d036f4dbf9423123c3aa7e0f396e808fabd43dd7f991eef9c853bc2dba5e441b9d15df3c2ae492c19debbb761554866be585d692fc5f1714eb37b64884bd6bdadcbdca791ae9003419bec88b95caffc322f0bb0e739c86e8ca86d7956cd120d3683f52051b7b51da680c12acf48dcd8fafacf2b38be89c96d1e7cf4dbd318c0d63bfd7511d5cdb08f962c30c0725906a24ef5d0df425cd39b6caee396e879fefa3edda60afac7a833994e6a0b4337fc9616e500b1c8c6a9eae1eab7ee9ed6bf2e20512d079e8f837055a7655663eaf78263fec60a46e07801f36a44ff13fcc5a7c3cc2e3df0d5c7038116aace15503765cbc1a89bb19c508fec669e13d485943a2315744f0d2a1b226f1b17e3395d80d8e6daa1af37d4ff0eb68f294210ca5f7e28e250ba689046d62adfda68907d0ba53f527d507d5da4d6f24587fb6a9451a8744a4bd096da8def76a454d9fa7f18f9e668a308045d594873c41c2ab9df4c8e8d000c64d9b61535089813e0b671454316df535fdcbd1170ed2857abdee457650644f5243627735a49a2cb2e66c369bac77351ef7336e790648541378af4ca7d5d9f39fcf5ecb3f397b2fe3c1b9e80dad887c8fa8296c36f716134859f80f38d23cfa8577e4da632d4829f3dc8e042486896d542bd7f342c29c8df60e4f7c00c25b7fa23c6de62904929df17e42656ef2e3facdc479ced04668483d2fff8263a6ec4330f9985eeb302b02e5e33b98ef424ea36d7cbd05f6ba6ffccf4595d4b35b34d619489fd33702e1daee45bad4df8bb3061104793280a2d548460491f14dbf7df4be97e140bccc6227e9e1134887a7a74d4265843a428a717d16f003af5a4566032d1bf1b5acc0b640c441f928ff560eb920aa6a76e3b759db04007000f1fd9178518f3407504c8e21048846fd64c22af89d8e8938ef32dad201042eb656e138726cffa9f96e1cb23af765ed6af6fa7b626b2a62486b68780ac0adc0b6d2cb0c1c43b7a5392dbb937c015e01c71cde7e7a982f0a5160c834066ed62794b5f918f5cdc3ec88d0380ffbd2b89ecf577e3b5e2a9d03fe886d67f38eff8f8d7bca5d1fc8806a428ea0df33d134363fbee0ec93e43f36e35e8222ce69e48501c0278f9a6152f93045b5d69f5be7684eb0fedfc5c75910519931150e4026f9472179c7ce94e3e453325cd1aa0df874d8a4e4e4a47cedfe050663aaf45b6f65f7585121583ead40b08c1f4c68e7746aa478e110f5e230982b05541eb87b651f2dc1a4e1a11198c12c4d4acd04d9dc3c67f06b6d24b59da9e1eca7ee0a53ebec81866d13473d48bc8677c326e8bb97ae39dbcd956b554f4c06b71ec4e32650662cbdafe6d5f04fa4fb3a75c3a7bb30290ccd33530271a1a7ddcc494e008326ffc5645476581c2104a2c5f9010510b1501823dafd34b3799d1f8cafa2416681fdc4eaff2cc7e98fcba86fae918c9d9a8c51dad23574a4d4d0d1b2c4593e019da712f86d5634ea21245653224debbb096a6bb3fd46d77d29421ba31fca870753143fc570edae1bffbde5611867f07ee0597f1de7c3bc40f6fff9489bb9272f4b099f73688c6a73b1c4ba37ae068c2ae3647b74f1be3d269bc6138eb074ba58e35e757b60c9e98ca08596f7c102380572c62e4b660391094f797ff939a34a76391b17a9db474076354baa5aa32b78c957298b43d25ca99597221b4df2e2169ab148af5c46d4e786731134b6a2d4635c305c2aee3e8961065bd485241f9269bb6a991b90425311f32321bc24013a5e0392de02945013bf1e43c4735e9b19a46ef5cdad1971c34c360abd69c230537dc343ce9eaf4d2c9a0083bf896a6c25eba7793c12547f4dc93b3146992872f1ad574c043e1461260ab5fd7abd062f4067443f3201b2b05dee24ab025dd19e605b225ef0dfb5ad7dc4fc882b5a8ba2d17dc3afd0f256518291cc2600e9ece25bc269d2ce000b3013669a0c4e4a5276778e6e06d06fd926e818bc1c2ee21f4aef0e29aa0ef97c84e72bf57ab49206df64a41c3314b2637ffd838f3a31827b3f7ae23cb23fa5fccf23162436d3a232d1114a2aa4af8272cac69aa2ec132ca7e330a8c1e615f972ecfd014db988d205899b02292244769eb005eb1f9c98f45f8ce9cd5c6a4ccc86bb3b23a9953f68e1ba4669ce67f4811bc969e0fd8f0df489e49905cfaa9b034af5652cb7ae0ca660c19e3464dcd590667c430d9cbc2b11aa1df28f6bfaf9e29b9a0c8d58f95a2d927011838b6a8544b76e2d863d7d9bcace5959d51e7542040062ed67e6ad22b5efce50bc389bd57c460cccfef68aacf0d0d2f26ad1e5c2015ef2478ec9776890b835f2d143edcbd481f51394e44b9070ce59ef685c032825cb3bb8b4eba82981a6472e4bfc861b4bb541f4ad4b10d1c47a8d26efcb4ac3d2c1fd11ee88b87718ead02f88108e28df69cf585f20b04e4e2195082f052e0714a8128d79d471905046ae8a2f4fb5f5c9fbb0af7af8978b496cb6c5b7b92d820af7ddb77d44e9bd36e42197ce8d58514ac6d210be25f2f409e66f48c66cbbee6aebc3595c89ae48989c58b9e704ba997f9ca2ac719e0d932619e7aa5bb895c1e251c0069ee78537be9bc52d4aed49b3fe7d213e72a378ae7a1c0336b5b969d9bcda7b29d7fc75c0358de09bc569a3cfd35deb17a1c17dac12fe4950b0c3215223f5fb74a93cb4fe7feb607639c152f8ec25956f688220dc1f8b2ecf484f01cf117c936fba9f29a8f6092eb72cb43682e319b3f812ae8b1aa33916a8ac5ac1c990533c657ca920e4b5bf5ba878f77bb1428e625293606ff6ff49b8602629d752e3ca07a14551a05d494e1f4db95e883ac421706d09027cb505c04156cb5219a1c8b0a32b9ad5146d30cd4108ee44e050eab981ab5938aafc87124514f7d5d65e96cd81917073b204f88758366f4470ba356ada8434a7e8025a87db1f691aee9e7fc3e04af28855420744acf996442f6257473a3670fc9d9ee3cc8eedf7bfd6ec85d7a408557cf1dfd4f4a20cdcb743d0509bae531949abdeb0c30f5e80335611de8c0ef6129ef71568decd04e9c520130ca83e3fe12c7307fa58ac4a7c694e1493ca14686625bda68557d9073397518b23ed000c1dde51df6c4e8acdf8690890b8d111039f65cc47bf460686307de2b058cfc22fa46127ac0781cb08323fa4d1e3c72f728e27bb4f597ac7bf6adcaadebb2daa8e3f00e85bc0645132c571dd3506c2865550b7d621da74126abd50fc58185ec678bdcc694d81ef7782fc47e0ea64628cbc6b18940600fca65adea6729cbb882ff11dbc6989469571b67b7da1cba75256be14c354f725e94de579e035e779370cd3e5d3eb28a83797c947fae95b6e8fe4cd99bb7f7c4fd4c17dbdea0fe0a2a31122152846eedfc015ac45ac1b7285f870dd4c1f64a38db2e543823a67eb04588b86714dcb5a4e57b6f9a5eedcaef6e07130266e663a154a2631074895bf6c2a4c43df87d7bb3150f90c0dfc6f918b2a244a3e3c01f0e3619c4c6434f4b57489f997cb342ce3fa319cafcbd91accbbf90a83b4e96833bacecb3d04a5468bb9ee705eccf613b0f7c17ea8d200e14e5c1a8c724ab273f3562c483c5e46540ba172323adf1c3ab48162dd96a3cf0ef1b1b673b67cc0f4a3256019e07ab314b6a0164275cb5f521282232f0ad314b36d75282cb05a3a4ce8f8bd26ca945e70c0bf4587c08478828ab3eff2133c6f5b16830b28421154f7ab7c53183b23e65cb09599453f2746129a31cecae252490a76cb49021cd5a5436a2dbed9e463e981a1fd3930a120cdbf27ef7e58da8ef38655f853867298758e47c30d8723d1f98bc062eef2f27fdff35a940d76bd7cdc3ca960ed73650c20de1e8a77119215134a00bdd1df6a8913049701af507e52fc5856769318cf9b0d2ecb0a0242856bddefbdce0a61144b152637d4992b649e42772b333bfe8df8e21facae0ef7ffb1b2a23e54231c928c59be3b0bd9b9c52fdb0b3ac19d4028358fb79417f51c720113ec1736214690b568c1280cd444b0b14d11bf164697108a9b7d30c71cdca6b4f679836704b11e91994cf2a7b11436d047007b03e8921747d67efd4e54c94c491176ede5446f8bd67484528f367916b550277ceeda691991f3ab2cbfa21fcb8b685d52318c02812ef314259ff8be39745e7d7f8200586730a16a948fa8f9c498c0428cf18df5ac7e08dd3f8a579b038f32bd1d7225c6454a305ea8336d870db19da2a8ca1eaeede9316c20dfd612f8fd5143a8f1fe125a390f0d27f9438d122a363cc74f72c471dc3c89294b261ba6ca3718da625584a4781308e6ad667480cc582bb2593e82319d601450fa41444daf10a7438d76904687a2cf5c1eb288230263e7cc7f130f351dae50a68ca2d476fae27d51cfef20e80931cf48e49dfbb0e855b8c493fc39b82a05ddd5dba6de1ebe1325b3ecd4b07cc41ee532b33b52e377275199ee733a345033e25df2b61ffcea6d6f7f679fa4f1e0ca707ef8a2b081be9dfc94b37ed96abbc3f19c934fd4ad436bfb207a429fa3c43dab3c3bb53d1375ffdae0f870ca6d166d1243be88e667c28e052e3e8aa4c064cdc220255c4d1951c49e891f0659b9dd8d16a2eb54dadad0863b2f91e4bedf584e88ab6c9092eb17f1afc2dd5e332ce476ddb7d4b5d6d93cf995545d4c555797a870295533e3b11ef9c5bde7aa9ea8c177b57e92170ae96022f1eef52346d3172cd02f74759af96a900bff774e2d1a2051ad3860c29ab09dff53b5dff4c22232ebc49e8ff9a8aa0574402770719f0e9a81c48afb30015dc490db9e1b5efe9cf27b8ae4a835697e0dd6adb462aafcd1b8865c18f8ed45d11ed4b0da3dfd345cfc56d90d9521d6920d3040f0c4bcd41537fe96b7bf237e8cf909b8b435750c4b9a02c7c7e917e646eec49c2f37fc201991894f496324bf1e65bb85dec9c3f6c3d100cdd0f4e3d414eefce0a3a2a76fb3f427aa75e56e89d3aff44447d09b4d366e96cf975c85f01605f8e3d14b1b065706cd6d61f921f4b3b6367694eccc5872d537b15c2ef4215569cf800fdbe539efa5b6fc3d8689931d21d80f2859cadb04772b97181cb0f4b919aa7788dfa5c50a919dbd1fbad314a04f23511317fb8f1f0977bcb174b43cea3b2ed0e7ada4956b5681097bec2c6b5239c7966e8754a792338befe573f61f2a43d73a27c8661f6aac9da431db7cc64555b4e7d4e3444fefb70ddf99acecde7d98ca8cd20f14fa506c9ec190644245fdff420d942370e2a966042829aae41dbf33ca26cce68f0979df084688d538725a94502a052f1595bcf0632e37b94ee3e12880d7bacf6e459296bc373390ab6f4e5df591d357161c7c9ca9594d78e4e6cc56963b228de7cf4508bb2a0738aaab2de1d240c63ecebf5a34b77a2944e10c071efcbc5f58a17b6162dc53854805a7184eb6fc232d76cd855b9c24e1a7251e4583d85820e5292e4bd5ec31d0db7e488f1132fa7e17209c852838cdca3849a1e4a907b2c47b5a0bfef4d46699684282185a0bb7bc509fe565c1423129e8057fbe78bb6fc6673d47f762079e5fef981d7ea372f14bacb5c120a5587abcf0ae3428dc56a3021cdae4ffcd5dae51d1943551b19a9be66d4440c572960b8543548f08dff6065735991ba3d16ed0fd4bf6463bfb11d7be233ee9d36db2bc9725bf6b0a4e98bb95cbc6008c29af806b73f475b88dff3d009a72ad2c5fe75b307620d1712e896f686d8303f6050ca19084b56958e942a31dcab7dffd24b7e9ba634de9c13be924b3d9a4730e1380b3c95276f253fdebc4c8897ae8c17ea9b4fbc72cc7f0d4fec762055f6eb716626e69c82a4ee41181a18a08e969e0ecc63c5932d6e599d190ccde44ea2b589d2940b7112941aa92a7370a73a13fe882992f436b9f3d990d6e9e449e7f69233314361c9cb6515d9fd3cb7577c4d8f757b9afdb87ed4c047e201db1aaaee12af3523e453cdb9bf48692afc4e8427759aebb48a40a70404f2cd9a9050a94331a068cf4e78131b99aeb6c8e1e00636e952d4307604e4528c2c7b86f52c581caa0a1e193abd30fec57d8720750bcd6484c7a3d1f3609815bbc8f0543e47c7a03950808e7945fa19c412ecd0c93fde7a10df1454d5f59a02be0c557d236b183d2122135f167d5bff1b0fe4fc67866c2e3b9120308b1ba4be42233b7655053cce9e6938adb48a459e4b7ed28bec950534e8eddaeca13da9b1bce900d0e1eab24f9c286e87dc32dad824366dd331077cbf6c5d97b7f85db2dacb50715d3361fcb8483062b1a396643cdf0abe1a9fd41c9cb401dc000ba209e513d24f2e7354972d63144c821d081b3b43b9a2502cf0a653128ba62fc0d4388c6305365d2accbafb4370b73bfe09a327c43269dc54f90d97c2763307a51143d8713fae9cee779851bd8fb225f1a54c2dc96b68406274a215c08e1181e4c7d8fb4cc5c46eb248736a48bdb204f0beb0ec2184d775e64c82046e1404976773ffa0f890de5904693baa66b9bddb1814bc9b247b4eda37575b9afcb480671c151eb42f8fae8c31489b1cded456dc5e3d14e8605bdae2b9d3ef08fad1223fe1c45ab0c591269624d8491bfdddf241263d9bcb536fa31b69537c1bc12b2f611011ff4f85cccc650a4ba0b056449bd7d44a3b963f370630396ef0735523e7792248a7d6d04b4211325e10807410f51b0b5dd65c1502ca9023bf331c422def8a556e78dbfd52c3b70bb0645f11c020d4ecb9261adb978f82eeff3b8e9590af5ec254d5ad4956ac1f874e2e0cf67779b6fae7a689f586fd5e6b8522af74e168dba28da1917ab2ce29ee405ae0d791ce2110b2c6e05f0915ef028d5b893a02a6d5f697ea3b138fb6fe1f5bcebe638467b90725d72819667e16c98dd905e22a38bfcc232edcb9da1c43738c20426ac2e3afd7286b7c8b0e2799c4e525d6c1c46dbf4761b70b60efed328c0e60c38e4dc2fdc603b449a24ec1c68dc935579d90b2ba6c35ccf6a72c943dcf855f181b66151ebb736cb8f76cb804fe8e72a5b5143c2bda7b76649f70f8c7b96e1700002f540db6a3cf8784e4736cde2507feb5b93814dc9ca0809508157bc20673187cdd6e814d98508a89c86e4e067faca31006c60c8913fb85c87be6b876e4a5f40812014592f9798bc51d08b900462ddcba3795057f2efcbb012f5123b6a187320098aa906adb8b4c33a422c02c492f3b99367178333de016de2ff46dfac90f87cbf8d2bfbbdb4989cd392d1c4835850ab1b45bc8ec833c73ee432d421a0f5e78421d8c0aa243b35a1a4630cee78d0044ac8ae03e1efab80b73796a7be4add18b0603143e4e74939bc387be24db92314aef1432639238f1af044623e6d61ac56bea561afd1ef67488271f23468f4e1755685ee936ffd609f74ee5e919c90796866e32a7d1757619725dc0c42bf27808fd1ef40db486c077d62cb851807fe3747827d02e243684914a070d43276cd50d8d47abff459c746f7f730bb1754a1a5ba43958d410e2db9dacab87f278d2946d42ba5ff554cee8d006a8d66e011eb042d9ad4ec80693b31723499859a2992e07dc7357748e0cc473ed1d10200a4aa38da4608c24c11748a8ee88576b8b79f72e3a2ddab9b976d9b8257e6443b5a042ca0eb2f4a6145a39e639dd85f39eba3b1fcc47903b15759a6903e2e99b9fe331cc94be92b28739e07ca99018e9d8609578592b403001713ad27c63af3722a9e7ac45b349478038cfff3bd214b83919788101efb499e5fb7b68cf0d4ba6768e661ab470f767541decbb9a822421bcf4b6e64c84c704689a5da16acc58e628c3bd4d35549d655e1f49f97dbd6ef6209350fb0a3f68c7622df37ee9d9fdafce15c7fad9e70a012d3067b59d2f10ed3817a50e86e21858bebcb80ed6112302adc4df779175c2f7de06af885fadaad60f9511fb7f281657ee6d4c8137629b22b0baa67be0700c3af811a5b39c3bde9fc787b97d1754cacdcdd4f0f03c4637b3c37a2d286643f807c485fc2b07f01b419735faca78a2525588206143ff77653d78cb251a673815e41720f39babbddd200fdf69a2e451ebad7bd9982e8ad81f96005a63e64f1f081fa0902ae43c5d0a9693135fbf95605fef5e1ee3a683c609b78480dc750d6bab3f6b9d02f2c6f86bd0b04b6efa58859b545a697ddc4d9dd7257ec3df3f5f8d837efcd7cfee01ca5ab7335f8c0cdbc399207fb561ed387107360fc7dfa46e21315b80070e63720188c87366902f854797bd9039b8d4c8c5041669e5872c3fe480a0a579767486cab0751492e7812a1b7ffa1ae0b01bec5bd22df2d962cbf8407f8e7bad5c2723a16df529f08179bfca6e8cba7e5a6575e4be9ee728826bfb322da8d54274f94db59faeecbd4cb4d017395b6748190d3736085763a58ae1912a4417d77ed0160bf934231ac7ab8fcb736a3b6225fbe183d590e0cdb8c52065dd06712b4711217844651368d97e7d41a7b600af7f197a8e991cb69fea5c28f6127d7aed0e90e5978af94272020a0c8a15531e7b7b0e5dbdb8fd0ecd00d10dbbea83a620f5c8332c7bbdd6e120241869b5601a08ebf588db1f2ea88f63302e185960e8aa28c1ff7eab10e421a363b74832b387986e0f38bd3a0e9100d35b2e7cdadf0cddc0492925dbee30c95e7fea520987df2ea162f8686b9242b0951aa8f3dd94bd549a00f3882df4e707a9c3fab11ec9beae1508a3d14ad3adfefb7cec4181aaf8a258fcf9a493edeee6abd6115bf102e7fbc48961880870b1f5b7b32d7592e4d6acfac87fcf62e7f39c4f189910bb376d42195f8849a62cb6acbd66c6aefd68150e40d10a92aa768abef4598b4a4d9065775dd7b5522a5a61c099186c309d14f11839e8380909160428d803851a92d8fab1e50327b8c3398a8970f984d035067e651bba46d0f4d4fb3926be9f67bf9ec3cef6c7b6fbcd877e2105a3e2de1a9ee403efcfe9fa4560d38691f2d525e491461e5e56527b0a497d9f6a54b950679df7b1ee4a57a59c13de72fc8f8e5a155a1c95149df017ec7295f26a0c727d33144a1692d15bfab1a1205222be208bea2a47b009443b2e0148b44e54c9acf429595b813cfa5a5ab53613eef8169ffa2cb7cd3149f83d31f11506bba25f32c99e945920f4d7684f1bd2e708db49551d643545809d9d36fc82cfe651270ff6dc0c64e65a196d0215440b82cb1ebb601d8ac8c421750ee1fe3153061331255d4bf60cb561824ad878f6ae6dbe7db885d068224dc96ed54f612d7fe510c5bf0d96d60993a49ed6e7435335a8369f3d9975f01a2e742dbbaf8526066f05e30736023cfe5d66a5211d739f63edd521df51bdbf011dfd67c3df9d9861e13fe782455c6636011ebbf084a50e56ca27870f56cc3cf054358381b6e1f5bd3623610cb92ec1be0ece27f66a1eea4b57938204402c60796324fb8fe2a4449d7b495dc5382e9503faf958c8ea7bf4277fae8c308fe984fc0f6bd11d904c95e6d7b4a7448e525a67765c716d0889f524c457759d271b74d3e2fbdba3261df2dab2b717af5cd8b8095247f708e586ba0707bcd367f17add84ca674582e1c41b9752f296b1b5d821b8fa417172185e1e7e8093804b09cfe90ee5d71195d6c17c4bd86549d91b31637a699f9c7c751a02ea141228884e0c5352363126243cea2b3b6a74c0c5e627de587a6d4eeb7f8d3e71a4080ee46e2cdb1313b468541455d2e91b6b03e5403fdc2620041bae0b04472962853a674f269886ce393371c5787cffcd119a6ec49e95b5a2b60e175fdb61f7f19d819658c129dd7bec1068e62a9f4df02783d4b45db7de43a7bc177b57bd401a482e3329677a1f665d50c670b4766e04353067709e905beb1f91d2406d93008c0a2a0f67e32318dca578a08dc25cf2fa53a96e633fe51a742dd19886a09847689d068f740d70ba42a42501e1c0a3ef39124cd01cd38beaf35608e288e3c5754bfdaee7e4a087058f43f157a9637f604dd9621d723b64d44db6ef4bf9f7a78e7e298a04c530ee90969b7fb1f6eeefe9a80f1f1bbe7e970991949d4d97c3e3a644a374e1af800ebcf5b7e861c3799d046c3a5450798043a5c13cad5fe4beaa11c7785237cc67308d209db934a0c7297d9db9d3d91334e1f4f4ce8eee23b0ac2e4664127d2184dc6a2cb58bb072bff189469c3de3f0a50edaac3ef3711c172fc4adf0fbc2297904ca4bf5b1a02243923a3774a63e91051f0d41e4edc3cec5ec1cde2e91f4df1bb923e9d329e9b6cc28ab9ea1edac6a856f021f4f5831a828b7afc7590f1be90f27d16099b3894f0b553b91b2c74ecf4b2ae9cf5cf3bd17a61c0d5900527fe2e215ed08fa361bd13fb90580affd708463692cf5bb29f4d65771c6536c645e73bc152c4e3b7f7c3afc8eb18537dad5d11cb6cb539fa1b7c60353b6c7ea869e9295f7f59cb8821d709f3b634ce39d80105a05e2db27a2b477b57addd9d42b0c06e285c37f04ed8010b6705194bd6411a7da12e7e4a0d3760e12118d690833cc5c0779272c9c2244b49c362f40d4aed617c517a2b07536d77136357820d3548db840850dd5ec3b69c3b78f1e6ece56ed54c2d2d22bab03efd5e55f1e1866472a1681e914cb6ff7c1463004cf5f8c8360074e4be7fb6f1d82c76ab564e6c0c89e1590b48523330377a9a9d6ddb016a009cf79bf5aed235db3db197c46b88d4c99e0c37a952b2dd1f8928f2e7561400d4edb26b15a6063e74c3b2361e217341c85a220a9700c31f5dbe1fe5a6b80377d4dabf57165e64309953602f627e271938b35d415acdbbdfd0f95b6d243ac6ec5f52754838c1a628e5ec7cd4918aee16701794e235db1328b5154cd730df003cffc5a95c0e7e4d37c75ad9ecadf909922d68252a9107cbb4ae0bd3041889efd80b152ab74abed45c729eb30c701ba380cfa971e01df36bc4e0b126ed3cbff4e2f29c7ece12b4659c7c5e4e21905cf246fde37fa37e1d56ee3422ac1d7ef19c3699a562fc080c3924dd25c1f923ae283548bb3cd256f6f6c5a76f9367c43cb6efcfd36797053e2844629d293ea1261ebf8c2533b864c83308b8501b36e89db1f293ea9fee363cf254da88fb30eeae480bd3943c760680c5e2589fdad52a13d85359875de48e754580661759fa0141ff0c7e0f6a6f208df33593c6f357566bf9f0e0ac515f09e33b881722ca71d812674eb50a75705fd7e75e0c29ec9966bf51d5c27cafa0adb12150dd638b2f6407f2e1412936d91e0188a0b9d97284be6d39494d75b8da4e0ac83ca1ee79266f8ade415b781e9a852608af50e9d766fd99d4f386388f20108878a5b07e30af09b52979819a0442f72fa1caf01f95e49301c3592ef68183e77c6d6984c290e81aef4ea187df6e61129cc6e1d54ed8fc2e79ac5fa166178d972af7138e26507289b9e94d2887e8e1426b0db45af9c3bf0f1e3169c7c85a7f28355dba12673c30a12bfdd7c02cb696b708823630377d43c9c856a6c43ad451c90f6803e27b029bf791517e734ff0a30c802fc5ca40ab29fdef459a75e19a72e5f105e14a12277f7d88754e2ba4eaedb78222aa740ad20827a29ec0ce4ed79a0ce887d579e5b076917e2831309fd27143f35263fce6016e503387d5f10c4a3c32ea10bbb18426226d733bb9087b78cfa0daddaec4d98270df6997023634de5d572827c2f311f203a2c87ae2ddf4ce13a8f5b105b614adbcf2a0f6aea302fa2b027e70d31d0e4d99429e2857212e9bb3317445a0fc05a42dca77c54b3a05bfc7dd911555aa2e71f9c0fcce68fad46357cdc3a0983949cb0e597ccff532ad300a8e302a39a959490c4883082b820ccf29b904e19fd24dd8a3bf150f1e6bd94bbca03ac84916c3228c6d42185859ec9d487a9a9caa7cba9287ead00ea35d9c89e3f2cf4434852b0255f49bff46475c1806c1ed00ccdd823199c9dad3922f834a3c83c076d7937202fbbcebb644e71d09466cc1e9466a2f192a42b9db9ae0c12443b63c148281c95417da02c5ebcbc07c6e633435bda40fe0789910ec94e86c3d29d593742b90d69d34fe6fcc98b922a62283d4000484ab351df84305f99ba39bb42525982f8954e88d9608cd37d936270fa43b4d3d7e373f7c842dc9200f4fbbc90ed575dfba513e007a7fd0807d06b7b7345f3a3c5f9ecd58940473d4af17fb096dab58c5ca2b7c7391cbdda5a8724ea1e6a4430d18d1841519f98300052d06311df5969bcb7dce9ad323f2555fcb56535d5734787327b97a71ae0109d66e14b5c1015ef54af7d31f9e0435be9a82d9910a7ed00bef2b0272e218596a3da63eeac4e08d20be52c00f16d2d0d0ad906a1eeb0ff9df13075d8c1d7a7e6c299c5c9eecb2e9ffaff4373768789913567596a7ed2e6c08303bbf765895e2bbbb0130264d4924c16b73adba2c16adbdd0e0c4767fd281d3901db50a4f00d1219b3676c07c6bc6f2d7bba3d876a56cfa1dc7d6f73ecd273577e9ce768423b3d9e01f95e7c318d6838a89a44379817a8ca8f15326881d2d53ed601454d84b2ba4bbe9a96d4b91c19eab9924947d4b7d0965e81549a6b987f5fff1dd8656b84df4336c9ae4e9c7f99f1d362ca6f984119288a65d68a956a40b66626c07e1b46be2be60645cbc1a5e1f45d9e5f8ebb55509895700b432a433cf329f1301aa18f0f5d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
