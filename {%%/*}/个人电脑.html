<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b3093604bfcd622f29333f167a188f378fcc281c7079c6028de63ade588738c8a0d078dc7541d1e76ad7f99e6a77f305ce84ed0cab59d30bec141b3b21d8f2f793018e740c7c5b6adf29f920126b691cdf7f22c517b4c882639d47e854fdc27eab97ba57cb26dbf2ea35e532ddb5d229e4e382550ae47d28d18c29d4c8796d315433ea6009b6e96fce9fd84daf9c163d250ba2c3da572b9be18f58e99383922f57b7abb37ea27457cce6250b3f8e429caf9d1a8044a00adcbd539510b97b7427420f714972dd049dbc914ce82bf1c74603d536129bcad15f76e71ec7efc726e1ed0f9dab77fb64d4e19a409e940d8b9c467e83a99904a6f2fec74616c2fccaf2f25310d25041456efde2867c96cb7e5cab2271ab8e29a055bb5440d23b33751088ec4b595a52f080250ff70852f804d0e35c8322b9192351a32630953a5009038da38a006b82bbf957498ab80a63cde711ae7323a99c6c40b3a62f7abdbf255f0b7a407fb0716e43d5671de8e0259f0c11ed7fb970de11a8a662dac2a30bcf4b1528c06cf8616e8abab3f01e97ab17dedc4250d13fe26f8c833dec9e1bfaee5d5672582852174d70db2de11cd92470bde53f41637364e375d9591d50b6d7faa4d7e78c620050552cdf5a31d391abbfa3be99a92c56337232d28d828753b5d869c5330f9600b41fd31f189fbddf572c23df11a8144e59fd0208873c075be3e6dedd4e0d2d3f58f9271e588be8cc1e942b1f040826dae8c8701972b62a379cec088b0e9223df1bce59d44eb0c38157311653de6099c7caf8e1ca88ba5240bee9500035c5466c80c71c510177b2cf493f1fc7fb3ecdd42949b6a709137e470aad2d1aa696534b6d2a4316f5a7cbea6955ccf5d360c2f7ed0ee6f3f7c42290afffb87cedefb5e89e5061bd5211229b175561792aad6ed1057b47fcc924c56114d1ef601bf5c3a67e7353add9064625444b8c86e9a3335aa82f039db8c03f0aa5e7726051783c5901656baca29b51334a6c0facc429d3f6d2844b48cd5f00899b5444745f1c304452b52f86295170981ce240100b165e56aebfa19495ce199e48ebb8d51ea68a4c2360f0b3a1efd03099751533ed4b3386ded8dec882fe4e2cbeed98ad2c542b97369c7c63966dd794751d9814927d74d264b8fa9600df0a24977de30cc834a6ac1b1ee59ddc5506305b20f5292e45a135cc2eea1ee17c8e2d877382d699538b6110b6652f98cf0185d33bf633d4e0f27f4b88189bf5de42dd15e81e4a94f42b9a82dfb4f9bb8d0e48523e0af90c4abcf2630d8a6feec69283efb105fd67d4528ad9431953a30bf398d10a632322e489de372ff05b54f51623536af33d9bd22aa9a8e20a12e4528e508cbca7aa6a70baa1dc98510056abaf9d5a78098c54dace62bfafa919afe45dbc24894a50afde45854812d5a1935e1cce8682b6b2a3045a6e167ab6c25df7613d305f6df30fbb02f9949d646f358d7ff473dafbe4691eb56f7ce11cd5a85c63d30a1a415ca51b53faf89ddbbe429979518b40f7709da6afc224458912b4a65059777425886a44d4f5dc8b6b2fa42ded885b59fd471f841619a4c9edc752a26559d366fe6228d2398c43f465e28e9265a7dbf2ae14f428ef7428d7ddb50134a582a5dee16f98e3035353bc3d8e21ec19fb42708cb6f58771a900d79d585e937855e3ac53ec91c735a10a219ada7ae70df1be83521692aa7f992f58ff9731b73ff784bb5fcb60dc747e1a7f2bb3619110314fc3bef5fab4bb29348deaca839d2e69ae3d3eba5db958df7538f0cf12a5b67aa588b82685fc269a0f28fb6f3c45b4a2a771ee2c17dccc376e2af8a13d0ba9e016d1ce087ce7053ee9f2178b86f734ada878866564a779210936e2d719589f46e5fcdbe775355d749ce98be31231e86c44c481e61704afa7bde3cebb6e98355c3d6e2f5d81d173e76dd9c39dfcd94867a4bfd1d56160398a408a64808159bfe5b4ebc090f71015c3a6ed0a4a79815b5bf2f61dddf51e6b246eb8a93f03e9f02371b5aded38af75ef7ab26ad702488cebd61c6a65c303118a909e16260768c212ba1f3c4fbc12b3e8a2080e058754728a6bab497a4dc31bf6f16f999fd72ad93187c8e4d40c3f24a44b87ca39d919cf9139d4a7127fa69ba7802babd27c2c53aaf55b31559ed133c70ade9704623d74b04b0ff640db0abc554a3c9bcd5db283a199441940436f77bf1fc73b7da44bf60cb58d5193f374d8aa0fb5281d8a090dd9896c5d940635ca34dd19bd0d957e70e53379f1779a7c7f67e18dfc961da301748e4090f4a762610935896783f37ec1fa8d51395b517e7eb9f3ff7c0640670b5f44216a5f80f14e5144f09d9e32ec2db958eaf90728c27db2bde30cca144a28eb13c5aa086dc5d9519fa04b7da540cd470eb17a43ee6f4304ff9f66cb4c87d8313adedc508df8c9edc9beea3390f4d4c84b5334b6104ba6438a947e3b85990b4b414af7fc741de8f376c2a8148f0e9b2cdaa3c2f94ce9d48c8fb0c8f50bbf216ae783479bcc64b29d74ecd8f00fd6c3eed6af49a62a700dd56c1dde5b98a30b61a2d26322490845cc94e63f05c68a553af9d34d9ea5e35adef4a74190c336ff1e3c5b6af4fd51d1d9f86cf58d8ce0e3d088d04883aca24c6e61b49a7ddafc18361671c6d2318ad9bb6f54bab347369f5b19302cbe4477cc34df356f0aab3bd3b46121a3d5200065da53864027ea37133fcc8ee8e6d2662058fd8a3d0bdd789ea0d088b6041c3ee115cbd6f457bff867429eb6b5447fe3a0d68b1a8b51513bf93dbed7a703ed36a319b3a6cba6c725d79a14ddcb24ba7c8cb91a0959f9ddcb6a6ddccafb877270d0faecd44fd448f4db2e374b41f5d4eaa34d8e696a52e1c0a3bd24564fe2b81ca81c54e17c7254c87435f8f8d335f5187976ae7c09f44dffb83e96138916253dd7f086d373024ff2355a94f40d456beb4f52a199a3ffdd0b1a52b7b1ec0f22b85039483e1b2e3f35e8cfa105c1fd6f3204305909e44e59d3ff65e0c38fc9244badfa21502bc31c32ebbb09ebbe550afe327f49848e3ed277f7c8ac40eb05386a7085732f2a2c36580021c0246b1954d17d607b30a1482c1153c75e88d54a3360686c9341485dfc15bf80c3de8942e0565b199476828e2c1d84bc4205c4699c7087dc08e74160ae2a12a86037095a217b33812196588136b34b183a9bc3f3837b91aba5f7d3dc6e968ce57d05f41fd468f346709838ef34754ed05e495b2c2ba61f5d6d61340c9036d8cdcabfa9e95311599296c5a2aefaa672b4f73099616d1a3dc59fc362cdd16164559fa74484fab96ffd42b861f787eecbc2bd6e272bfb8dc8ca5ff83cf7f9aa4425b9411be5677c697c72e5ddb45a7fcb5c52dae808ff6fd0174af4a4b87dc51b82d67a4050bebfa7e6045a839dcf5ca3eddf3e5a8b0f6672e9b94c4aaafaf4d5826b597ad520f8f4cee534899e1cb5d96e6ed1f262b16c0186d82216af1d851abba5465597cfd4ca43753000fc964ff317d5f45e891e8c1f672cc5611251d90d07c53d2bc0fbaa0f677aeb9103efc20492cffde1fd3323360d37bbebb2a7b7534cd1fac06bc7a5950562b7c21003a43a53941809bb65dae0ff936feda5b1be7dba87e486c41e4cd064b202f0a8530dbef5957913755a04516658afcd3e3f75da9fd1cbd633c7d13b570cb8817565d3b1f676b65ab530c833f1120c294c254dd2ed4970539d6c4270dacc812b0510f412e0a8db41d844a696296a3b6dbca85c46f091e9beb31e2757beeb1f7bbb36c73208a8a6ddb65b826a031db612d5cc2848343ac3e96587c7f6f6e7cb3ce2ba3dab56ee94f0b5d61786d5abd5b0d19ddc83721d1500702867a58581dd3013c544b2281ada8be6e82ee2d2f6a8f138bb314b26bce0a8c3d46d0dad824127aa2848207e3552890b89fca4cc5c0a73016421716ec996838c5c1ef664611912c07091eff71bf8946a5d59b0e27df67c966024dd5631eb52bde36cde41d329ad0daf4207da7a9ea9b2b0ff5bbd216ad413e4a1119f43a609af65d29ededde5d0613077a830bb77d829ec5278fb08025ddd419b5724cb7e6343083de8e8c181965d89430952fe896b1b42e0853d596cf6be230b0b992a991f21ab9152ff421ba23c76f98fbb19ee0f15b67bf338bad162dba29ca783a51cbdc14b2dd80662ab884a0d9f4203376a8fe2347ebb7173f506d9a987aa37eb2ace35c71de78784e588d76cde3df5a9fb01bffa78cd38c5d3121ce6ab42bcd34110d0f0741121e97206a4dea8571ce1fb9c8389db828390c236c7472ca8b86035e0c0f21421d0a210b65e39598796aeff34bbb77c1ae90fe778c8e5a7bc36b6855a48816fa0b523cf2bfc521ecda1d28b6f4719f10a59982a83c42945871b955f84d365e61931a42dfb2683e694c020463d75c47a3752e00fe77aebdd1553e1ba82a7ca0ab083c4a5ded77427f0a35d10347d5236ef6dcddbd31809a0e67a128b4d08d721ef6e3a658167969aed84d8024bb0a623ba050d44b72fa5dcb27528e87c5b5605efbb85e9521b9d2af69cb1cbd5bc8457e40fb966b25ba9f3f3f1e9938bff5bbaa2ed18a09d17bbc202bed2033be6677729e0b56c9a62be77c3e60896007790ff106d38ca741a527bdf36bffd739b000a81f5e3ecd70f445792f1e785273c524567f99d02d876fbb294dccfc8c19b8f42b4c9db12125da07f32e2172e14fa5a858b200c4a3c337331d26929d3c4f9dfaa33fad219e91743101e65a0b861584f8f3ffa80ec02ee1709a611dc26c07d84b2037ad9021a208c994a6dd0fcec4efe1d8a2e8c24243edf896a85bbe96ee51b1a95a12ffba999ec08031fc3e5afa77d4181d9205f157a5667efbc0ca36b6a83c3b14efaba8aae02415c97c0db2b5e1e8c2603841ce620fac58a5017351b4f618229bd8c2e3a3cbf4bd06df8eb6d7605c41a47589c32b3596d701ac9acb609fbee54aca207bfac8417619a05a34fc4b2cce36b94d39b42dd1cf971ebf59c283cff78b2d81236d3fd3a0d914b26f425b4c339621ad8baf95ca444c29cf309ab957354aed51896497cc23dd5aa1ef6049d9a677f9519511041a4eb8912802d7104cccfa2da5fb3212157b309bdc058c410a18715be970728091c1f2a1acc9d70b4ba28f695caa3743949bdd5dd49bf7e9dae1a1d86f4966a93538a01d94a5e598b0a8079b4991de1508e92fb3360fa246d53f73923347161c7c7d566512420e116ad6fdc33be17a0b49656084249df6dee10ee7eb727bebcc16bd4cb9a5788806e971dcf0ba0bf9608f16b5f43c1aecdd445b7196d784abb1177b0a1ac875ec026eb9251367270fe4420fea4c689e229b31b614223a185dd61b9d7e06141cdd77e95973cc06da3b7bd781582cfb6a567cec41fe60bb37b3219ff639cce4f37aa7465a159624a308576e31436bb0d6ee651be5295d234970f3defe4e3202bc969cb5c0d0896184f2669e04328cd45418766e44f834125f12e2fee766f0e35c9ef12b5c7505be8be7f268819bc91dfcd16fc83f89c31200fb147de8ec65da8253b72452bfd0fb564d303d3431f669363e2b6b00afa998a3d14562e72102769521e0b557ae3748da65c4f2497e7f5d8661686585a98ec5be278e2fb30b6c7d2bbfbb03bd9a178c32cf33add7c2a66278ccedca2878508eababf63abaefa2bb48ddd907da54ac0c5b51ad85f9195354e2fae2f42572f3f083aa8189f7bbd3dd12ef3cb2a2adcf98e424e23c8bf3e6c174f9fb176a1205ed23a074ad3d434801667b729853433b6f604b0ac4c074b8e1261e67fae015df344468bc366dc2dc0e00d341c5c5fe671b11832a1aad7d40a8f83bed1c0f941def2667943d49dea3d5620a01ca09c4165186dd2e87107781e00107b1718e1b878e00eea0bc0b9d7cde82e0697d6ba124017a4ffa952316e332f46ae26017a1faab4afe02d3f6eb3ad90e1dd4c2c6b2f1b0acf4ed8fbf5eb79fae11a4a46fd6f27d1d574db583563ccf2bb4d1d345a34c1838b880f42f1a4578700f6fd6a7d9d7fdfff2b7cfebae29ac4ac13414b494de77f37d7b6a1bc4e5f31462c07ee4f8f749399428f583140719e5074ffb9ddcc02c1e311dc20a46ce9425333c6e83d4b779c654a8083a1ae5763b852dfa5ea9efc4903fbab99e66527a7b25e66248fccc77d97c81b101baa2e6ff0bfba994e7a977e8abc5dd6c8b8c12d656fff8bb0be094e4c954a696452e7991c105906982a76ed94477c53d71c8735819ecdd484526c602d7fd4449982453ced6cc3877079eaebc26962ec0b54f83b1e9cbf07d3bcc6e9ce23a798f6d50797aabc7f40b6d110fea6a9a614230869b19bbdbc471794f41bfbb71131ac98fee4caef0071491a7e14a0f77b84735422ca89b9a79f9c8c1c6e3abfa215585e5a2661ac25e6885443b9a6bfeb4cb27d4f62a2ba72545aae3ae64459970a0d78626decdd7746fe29f00580497ea3e888051e9ee180971370406d58bd360207240b563c9e15421f4ca840dd2c0a2b93f66b1ce116c191e50de8645427730c77246cd01402de2de0aab7144094fd34af832ffe441f7c6893eb0b8c9e8705a99aebdc36b9d88b66b652003751feb2f48d798fa18454c112f5480dc94880be411c872dd9f872a11efe3c566d01879b20feddeaa5dd1fdefa3ba7e4270db8bc40a82bb4e35c4cdcb9adc36d6d10752a1f6f41b68cc2390049db7cf19f906c93a9ae22ecdfd846ade03ed749fa03742c0a1a32eef29bb4351f5f29503845eef8f64bdceb720e6c773f7e9147cbaf8e6e23930c9a022c89e2dcd789f9cc22a2f62ab53297eddc3db7812e39d42f1a5a8a7a46bc12973914041b0709ef766d7245df5f14b8ce1f86f332e7ede1089398334032d9ecdca76cdb773a43f46b0ed319c386fb8d222c96c7a6937adac96d3fe7dc0262289d964d6e9b2d9dc3b018cd4b39f4bc571b198ea4bc102e145caac0d7a2235094443f1749a161d265a1a88ad9ae973eea7eea043bb8c74ae99b9cd8021bd0d178e809908a0e24b3d57048e90418ebfedd755e8480513388f2f408f726fc58415f505ee2391b8bc61701b1da5ea92cc23253972da37f236a8892b793339284dd11ccea80486aa70adf3cf6985bc91020712226ca2e79f7e3e3e4f4043d12c0d7933f72c382c2baeaa4eed9ccff1bf07af0b690dea484cff825816bfccb3a3449351d8e301a7f9028da8cf5cfa836fc5740be0f361be1efc82d5f6adfba4887dde9393fa5638f6a124b223d9f7f5800019ec9b78863e904dfddda248f6f2bfa327b39afe98f8ed163bfeeb7a4bffcb0a71eeceeccba3335e7e4703252536371741368a9cc6d2031ecff07ed982a76f939ed3a9ed5376b1c03b48c987c0d7ba6c2ad9698d4328930129a112907a1f45d77e32f9818f8c7161985fa5b327adf90d3ad076a84b058b1d8aff6235706031222887f5691b8145f5ae33a5093f7f29faf33b50d9aa07b7910042efab759fb37553da00fe3b1c21e345622c2f4632b181ef0082b04742820cda7242170fb638251654991525c913975c331fe5781a829b2653c499c1df0a26b4baf3ff892b8c7984f2ea5f38fa5c6271722f1ac1a597830377ae0ffee7721b085cf0c03a2e837b7ba4b743b2dac9302f81605d0d26323ca76396406d59d76f5298ac186400c97c83d5a951dfeefc2d2115416d896c8b9a4c6af9fd8e10c8b1733b06caa457f0671ad92f230b3234afe8c06e76b4ac3b367126f865bd17aabf944eea900f5f1ce7e784291de3a639fabfc92ed64c876be31f5022f53172cb991f87913a000c193058d6d42a2316fd2623ededd5f2150bdbb6400055b9a8ea6e54e0f9cf43e5cdc4acaf8425aafd74cd99ccaf860748c260521e80a5da4897a819319cf4a839e3726532925ade85f81c679349d6c6b9a19c1c903c614d03f2e7463974e97e2cba338cd6a0ab4fd4477225dcc82892572fde7879368564167cb70ca3322963b394015449f4406242811334bf76d0a97bd4a10593e130d7b0916f0d35c1be9893db28c39349590fbe88acc9fc93892e09c3f3debbfdcfabd2214bb7d1d21e8dc9286c1c436a3946c90da59ab60a3ec6519858c956c58e22d53da0cc1ccd1fafc32ceb0951e3e9b90c44f0fdd90c2c76740238526bf309edbdcf02fa660c82612c25b0d1360cc73acf208adb49472f82b2725ea0527df6b8690f04f5e40a364aad95a6f6f8fa94ce0f3e04be13451ce3ea916974effda17bb4c8a79483a969fe7ed3a7da308de8cbadea982cd07688db9af6627eedf687e4005133d048d1fb52727e4873345950cf0c3687b3132cdebadea9d373baba043f9a0d95a0cd8d8b39b07f073ff3c899c775361ea03122c4da080961e4da26ce20a4a0a8f76723056c42a20912e45514448d105d213bbbaf718013e76846539b60f9e3b8e3435aa2cf2be9530bf0ac7c28bfa559cb535e2d3f54a286252468c1c6387ac39454f29f28b96f4f5a0a0f8e972cad3ebb57dc9d8b50832ccc787047468f24f5d7fe671b148eefeec8efedf68267dfc28c2baab22c3f6a9c44c4166f97b365faaa3303dddbc3d154d048c23df5691fc331f358ee69a6d89ee5ab2afd2010da8a9a8470bfa4177c0cc340689b0fce8cb247bf47c79808c245fc60a562261968e0277829a26e5c26d44a6379660fa0da9e44f612ab99a8765d7eae073486ebc47a83e25a62667e62b3bff2a9293028113c5ee7199a06d9af20d89639c845ca542d9a424b1463c79b975d557ee21336040fb39d6ffb8b46ef8a30c491f3436e40e7d76945d2497272fd20a7746a2c15ef3acb6b6de7128fd056c106b898176b3a37d786097516502443c958da46270cf491d05b7b54fbcb89cad32c6ad5a7b835172cbb795567e36a8071b008720c08e9b1614ba98c2ef0ceefadd63afa79aa4991b2fc22b88d6c7d16bb8d5217933824bf6e22dfa6a1508688ba66604737c67a85bd45c149f43769af1a5c7016629e8016ea1451c6d4702def578cbf9d102c839bd9d53a0cd99687ff81e23b87651320122583a17e35d88928c6a089993e84aca34499779e7c6fe742a755fe758f7a4f89247e333cc79d2f59119d73275b3f99d64193cb83b8d7d905fb2abe725ea4d401c2380ffa826bda19bf61dc0cd97dd1a94eed1fb7df2bad8e8b951281a7c8ebaced416755c6875bce9290cba02771a0421232f60c996bf0e665ee4485fd5f943ccc26e9b7ddebd4931bbbe99d3d53b2e9df93b9395a714580776dbc42d1638bc41faf8c536ad0a276055ce74a456e84ba15a2d2717704d66ea1afe8aeded6eb297f6c4f872f8751ead08300730f176695429d2fa97eb3a61abec51bcced747a5f4a1459b572ed469f34c315ed7bf063da780cd1e0873a729b13f7dfd8788a45a1b5d7512594f8adb7e0c4a997814cede75e89fb92dbc40bd6591efe2f3dfb46026b276b4de40e7f35bd226a2c2fb614cfaed37ece4bee17cb959e4e4b77a27d8f91188f333609ececa80dcf499a2f0c3834812f098d42854c0e5c373574d8b11e8d6eef547332b499b71097075c07cbc08a4bcb655559303aedec1b40664f12e630cbecfc152a3a208eae84555e5b355ccb012c6ed274382e6c7f01ea17fb6467d23a1c0a4663bc08e3196098efc69f58f3c2da1774179f9e69ade191f882d378d293111614c5cdfad95f02f50c8ef58cd84848c6fead98cb163827c9240b0514f17dae3b4c0ca583467fb09fe43995b53893be1bb1823f6b4f7df724948beaf13006302ca251f815a7529f3c7ec02c05f53afc2b2aef155d6f0a06dcc754d5fcdc96bbee65fa5ea1e35608b459bc23438a1b3efe1ada3709a01e0b7497f180f2c73953cd9c282b5eeb24cc8db2b7121e57879a886ca13d2cc3634eb64753198ea1e61a45f9afe6cb2cdaac2037da37247e6d5927300765ba2b274bce8d9347d609d64ec907a0e0fc0e18bcf8e4503569fc31d7fe3fdee1c5c9c42d303a219598dc4ec37f6d4e85b5d989f1b15aa8a4669e6cc6c36f3195cc014a7303f26b64caaf0b82490d5eef866c65a69ec555778d855a85507a5afc4a70545cd950cef1d922ade3f2cbc396f59efa068cd61ab141cd14ce726f04ec9a9b2fa04b5c7602f4e67d968001356fe6a116678253e28f39089a119a1e136cc51d03969ea58310af723b7a61d2181a1796bda79e049a7ee7b5b29f167dcbd64d0ed466edc443246f093b61ed9db395e302bd2b6947b4ae67471944876b35bd95f4e03e8baff42483b73e84e3c92105f5403f5d89d1ef7ce5ce8a78de9363b71236fe65bb3913865cbb4102bb2e11a3d782db0f410af35ae791e229c7286f3e645d1b8eca338ef0d465fae85deca8bdc0b37820fa4e2a4b1569eaa29d33983aebf7eee230f22b32f44e2e6b5300d50c05eef353844286179a3482969cec39734394eac088f98e24f0aad7d786c6b820d557c9cbf83742ab745543efa8f44a1db8019bacb1a967b553b26d28222b8fc1f0a80d6af7f101f5c8776ee82874b39b3b6c841a243ad3dda348c7fac7ecaacd17d0d727c37d156b795def0dbf7b0caf91c91f0d4eb89206de8f3c949effc625ca2c18cf5498052ce78e92a6688aebe0a6e11d6f44b001ec35c2056642ce8b1d9972c4f6de5acef1353f75b28e66615d00519e3f19ec2039c94a54f5ff0df00b19e8e8bbea90560a077bbc10db5933eb9373229bca9a8630148910931add49a23765e7a568e27daac2b71ab0b8651d585c7138827a40d00d61fac024abbcc0286d502198f75451ea43102778ff33d9790c20f0049711df228a3bd177b176e272e5879c654eea76975216781bf7a5c54b4a9909201b4c034efb673a4787cd49dc568f9c4ed5e92f0daffe42107c47b5ccc8607d8d0594b92b2e39377f48294f072a4007e556674538b8f04e144a49983c3dda12e51cc488be00abdc757ed7ee5df16cd925722e2c447a6dab12c060fe0d9001f606768c2732607608d88c42461a9f61857e8c4e19ffd63fdb09ae49ca08cce4454717134bf2ae8cf974e28ac436f00f5cd42dc7b57dc83e51e879ed2a23490b00c5d450c2a5e91219834f4ead194863b504725e01d9a7031722e6408e2bfbe81db87ae0209ac1c07f34713afdd208e61b23ffcdcbaba43c41323bdeeb48dfdc59d9f354f816d80bc631d4da09532c71ed9a2e787e9a9dc2c0e6ff3bccd85a6a202c08bbad33737402d1072eceac0b2c5249c4546202060a42d152abdfc78d295ac8cb3034b3581d0b47fa1c880cb4301116c2681e1f1f9e87bf34faa64ee7bc2029c0ea44006ea715ce9f78817390f265b1693ba3127ba1d09e1ac625939b8e928a116b9a08cfbb4e89de100cf8512b62e48ba7837eae3a40a3aab0fb909c2d0d5d0177875d7b1f7c0e11aba8c52286364dcc8870ff2a6ce84623f4a0eadc32da5ad14a6ae40e3e23255eaae7d28ba5bafebcc61ec01f710655115b16bbd23bd16776f44966c6f5764d7a630d84bc7e9c919685d40d21067909434888c49c0cbeb1dc81465c70a9838d04bdd4fe8f66676c55212101d3eb817425efa2b44914b90fb06f3c355cc6dd1c5bce5ecc8b52dcec68cbe79ea69c642345aa55af801a04843a9ad1a195be411406948c84a1c152227ad2a30227bfcd00b2cf898eb4a766b7aa86df3f91e326a2fa6d63682b69269d52b31c469e34a526f7e5477077eab241db7d4d18e3d10ecc61f356ce4232e8e19be3a217bcf5dacd3b6350b21a59acb0ca6807305b9a06001cdeaf5fd468779ecb8b3b5805db2ca90650867b131da975efe58e52b1f90c586f29ba76342de2dde0e0fb965aff3f606ae99107273fe1287e02df37883d5f361176446b12e8162dbcb941967fcd14da2fad454fc9a3077d0c9807f7870d7ca1702ee3e343c0caeaac1a2cddee191fd3caccabaaf5f2fba5fc0794b5b8b3d708bd19fc42d4bfded1efaca30d4850144ae502dcc7bd732d174dcd73125b0858ee3b3beb90d07a18a150c00465d1651b6b4554cdea5c643e673e250cde394f6797c3c255116e762be5bb3e91387ed8509ba1c852a57fcac7a8b496191c8b9aa2736e19afb1af3931ffc667a1f62d69e26cbf4c0090a32d27c7a240f66062cd309bbc9ef856602d6888dba887789f6451e34b68e4f9d7f3ff9e6a289e2e0d669ad7271aaeef0851a5e1d06165891749246a16b3689328c6542d83aebbd56c0a45f31a1a12697a294e4b7fed45d55a4c9b9508ddbe1adce7c4dd89b7f94325f4f853f45919f13722704eeb8be1650b493b0f142ada99f60661b614021ddd08fb3c08003ae88740be51143f9cfbab15b9c141af9af2be92aaa01bd39e6ed1ae56640cf441cbde2946a4fe1bf9b9077c217b680c0e68111e5a6b70f67d07ff4a24ac503210594d035a61411caf1545d00baef91a34a94aa1709685266408594db21deffd62bec4269ac284229cdc2af3122b35cb3aea485c1df2b7672c808f71ac905587604ffe27be03551a7afbd2c43f4af4c930ed85eca6165c274c6fd384f49ae22e8cc271a91ad9254efa1e0cb7c83f44f81c1155a951cbf3144c23b1a9dedd17993b5d15f90dcb8ae4dc000a6d45094e95057e48f0b885f6a138100c8f11d2ea41aa11deaa09c7ef4b4ef3dc36eab01afdd5df80a64877f3bd629b178786c6135a571877e6742db10c00abb9f68cd07f95bb5ae02ff79f54faebcbbdcb5de058553207ce398f64192458be77fc220d12c1df4b803d35a00d1dac7846e2f988181355ebb82775a9a71c0ce7f13288d2edcc2a946bfb31bb6f4d674652199abd18cc0ea858add9771b7de9615c114ef9f4bd672a0e3ab97b974332712ac98685c86dc80d29010570c82df80b1d5eb8936f6c8b19315c8e810576366aac357f9886daac2c07cd784677484da86ee029e75bec7382ab1e4346f5e92ac67229c11a1e5808028278009c733e696e2a5e22b6fffdc0abb580fb2b588637a1e16893d714ae6e3e26e901ea16f741e301490aeee8ea1a6056eef04c8c1ac594dd59d0c71b962ae308d285b97bbce632199236def56c0afa192c6f439fdea7cedc93f77be924fd28c62874064abfea7da34590b08bb0e8f376574500590b5da15c471d3f8790b4f23cfc9f127c8ead0fd919f68cecf3c601dbaa812fd4036139de015d77a3c400959c849d08973e80ad7c74154500e67f4f8492a2f58ed060d3fc5172c00095531aa4c05f644852df35717f0d2997068fa9a92c335bf5273c0e36b26b05274045f14cba2f292586b3b74bf66d865d6a8142e3534e397f7b71f785f07cb1d300aba026c342b1887fe814d2a6b1e85140f0ca651c162dcfc6e1e741d5c3866c0e7583c95734d885e542567def5636d5c03231486d80ab6022410f7f9dc505d8d872ea4408597fc356deb2a42a9057671c242c5ae8b0842f3b1d0cdafbb75d196c533e559b3c6eeb0ca53ed46cc2e5f7e6f64eb625c01875a87959e4782b0bbf6b6074693fd9e1a237ef0cbe1a26aa7dc98396264d4ce47887281ba3bf6502b4e1d2390bac904d81f902eacbe375c33f8bf0e42a139faf251e8d89240a904f667d08a1fb8246961a36477ab6ae25f39905378ed856c65cef7d84d1075c2de9436e6a3fe7d35456ac9a55fa803cbe31c150611972b2db07c02e7d7e20697fe3d65ba37c23f39836e32fd1ae84a17abfd7201eaa04a148aa8992e16a7d16539382fa41717bc795e8cc5e2df1dd9fb14466eafc2bf7916263ce3f46617f30c08e468c60d6933c6ff1246b5445cb3da69d4462455c6aabac8f0e5e8a93008ae3d9aa2ea9757f6c5bc1f8364aafc194611e88866903872e7c94d579975c99924d1da1be960fd9fde81683c530718424b453c224140815d5a264117f66ee5f80caa8191a5191ff0f6c0fd853279bfda661408cf0dbee36a4771ebb7652cd4056db9021379d90ab722597b58bcc2c8129ff2fa9a61e07eec041db6f1a767b66645a49be7db7dfc0b5687e511f7fb46d12a57699fa4ac2e5dbbda5a6a73bcfc6317dcb8d4d2c330420ca6e40a024148c0ed4fef1b538d0a338613629c09655304003b698df7df98637a14b7b2b5ebfeb20627a7e803ca9c986801c96dd142f3055b67f44da2241ff1ec327bdafbc8dfb20d41108e8a1d5789270078d1b8d06cb5c2d4a3664eb9da4f2bb4527974702e702e587d4346d04a263248ebd63eb760b243bd5264dbfa1d780d3700f8ecfbb4c518a7bf2f158736e74893ef7b0245e2835e2915e1fab5f1a2a2e8a1151f2818e494a44ae457d08de97a175d3a148ea6ac0924f3ddcd86a02d28200933008d71ec4b0e901685ea3e04a3ba47327571c02bdcaf95e5df0a9b4e86e9a98975327f575870a952f13356695018eb31fd66284da05269eb31e4144ddc726e69bffc1ba00666f8a7c6947127f9b64fb117132ad4498af47928e0e6acbaad10e81ff4a7cfc2475492725c8dcab796265bea8c4b2ab219f7e077065a80d8c87753a7938fc9fb53711e709580c2a2fa44e46835e68eb31b0cce86ff41ed4ee4395faece66979e34658800384e72b9f520ab1c3cb0270e6625eeef5bd10f8f96ea9715db62b29220bbd1cb058319285efb8f4ee50fcf647f48ed04582d998a01ccc6ddd6e7cf8cfa3f3df7f37e056a3f9f18bc9926ded54b53a10acc1c6e98803353f45ccc864cd9392ed496aa428f89d4aa333e33ad000e6ed302506e1601771273ecc09c015e5f9022fa3eaf986a007eb5b85a689a10252e283e79e413a021d90b40851c8bae1038ba9e69784bdedb75d835d4e587972aae7eaa0f570380c0a9432fe4dab81dec5e42429a2da49f52849022f98e0ad65abe4b3d66938e0b8ee6aeadd1d3555bad7d0ecf03082961ff9e6b4b78a788467b197670f1c0b54aab16d561709bf3b42f9acc8baa49e80e67f54b94fab93d5c3c57efd55a60ac541a5ade8c17569ee740630054f04eb118038fbf6e5b8885a3c616bc52e216c96cdedcc85a46d2aad162c0615a9cbe4706449b5d941c6790be640b84c2fc379f1070f8614f92cefaff75b3f8a6f3c9995112bf408c630fce901e024ef19e7e61f905785d4618d7bf8d06f403c90a4a555d734c98e21777cfdfb95bf19ceb7a9a31a850d458b2097af32115bdf7b596b77e439f91d2118219f92c9ade7e2e703ae03e89bfc826f9655ff0426d53a4746a33dd19f20d624ecfb9b1159edecf9301fb67fff618d12888bc7ec8eb692d053a231c585f2584f610e250f56888bec48a94cd0e48c103e31b060350d3f6be96b333bda405682f6f21240ef6443b7fa320894b6e4db9a035a38f7a808e953ce74e763c9ba31a8d1fb451aa99f20672a73f41928d1007ccffda32f494f04bd626854f800634f8e4ce677326c3a22de5cee238dc486172deb5051490d8d6f9f0ad4ac6706573cfba014e770888593ed38ee96845b22a50dd2f9395b22fcbb559ac5b86fdf13388b9702c58780a978996306f42a09be92d5ae26b2da70694b1ec5e330eb7a2d79c1d783799ca2fd669ee5237befb77b5f53a27f205fb3b53a9590fb553e1a3a327b7864226cf5039cf88e09b4e2d59b352d37814ad4283050d21e782c07f31a77f7775d68ca282d5833b230e937c5151c17a83d28991dea3d3a1c23e19f78955f61784f4344d0c82a907178e15afeb9edae3e65eb80372bf886770ebcd25bf839f09ffa3af1ec7edec2a2cc313bd8970889a420c1b71e252e94bbdcb4a1f7e3038761c466bdc227ee63568559ea025e863c7bd69bd23925e0a800fda85968897210a60e9b948472144d4312911d0e21bc3ef255e0a1b0b5716235e29cc449596a3e431de3958168932b7525bedb7fe8b39185ed6ff6009a990d6b6c37b2c5422c866bcfe46570c302eb60b8ce6e74fdd6c9b89a23589c850b91e652ec55663162b414efec88880ddbfd8ab78f3496bb2f7297672aae9200bcfb2237df54c338a4d68cb171d2a2366ed2d0ca63c3392bb50b9b20a4c915abd002d87aec5dfadcc05a5bebc254c4a2ffd30a65e7120e2e4c5eb841a96ffa14b92249930fd1a3e0e22942a082fb3c0e37946d8f36a42e049f2be9b353d6b45bee5ab89eb76f81362f60e1114667d457d18af1f3af6e19f6c7f093ad20368b9bb2859a3fa443ee73d15c5f6438a7d7d8e4013be4f9b0ec39bcd7c8e2de9643c7390cdf613b0e4b2b726a0cbf992d0b536b83962949770bb5630b63bb35b71a8f69c7d970d6ffeda33cf5a7c9180d8f423a73835a17f93697a6b7094c71f99a3db6c8e8eb9f3c3a210e61aaae2b08617c7d9de3facf330f16489fc7013bcaa2172ed48445aa79e045ca8563880c89f1e0efa76b487205b1cc1c9395d38c7051e3ce0e66ba8e92855a36172d1c937300e2be147234d77555f287bffa6f5e8f678a8f542e68ea25f24842add7a72bcc41208c05047b0a2a500a9302177271b3628cdb64b671e977b04864ae705efc6891bd9c58db605f2cf50a97c47892634c8e5057022e8975d16bd518ac429d318a91c827d5f73073906e9cbdf4c5a6d08176e60e4247da94ea4d942d3d789d6fb4997ef3e6228d0bee4298aa2682962b0b847ff0a7d0e80239e98119f635b6b6810bcba0a686003aeaf3bf7683450625b04cf75ba1ecb0f44d351a86566553f4779f60d20d5ef55507ea6402955208585462ab6fb1235de161856e3fcbf09f3bb0542225f7f53ccb1114c6730ee91e2d6db079e4c27733a795ba5f3396ef8f4804d0c6189305362bfcc41702bf6007eff1eec60415b26390ebe5102a5c2b8b1343541755d65b234ac8e8edfe84e58df0d90aae4db5071bea58b6943fe928bd149f71f9da6a7ddac32bbd0c173c3f77d9f54f3f9ab3eb9d8d8402757b029d378fd0b3cc2bd7fe551389024f715e967c265b3f9fa46b175dfc72eb3cd2f0b91ef5bc13daffa164cc83e86633e556ec49afad5154d5d977adeeda39f3b4f10453e081d380bc34381c3e83c65e0b0c19acc81c6a82ea3167c1eeafd0ec5845d652104645c42ecaaa927022779eb66584cc2e3586539ac0742c09bc366033c2f3ee312ddbdff009154fb1614c6c69e87f4c90047637e1e921e69bcc5e78f88ad354505e49535d774e9bd55789cdb85b4284c9a6a8d8cc6fb351e57df61490d19759a6571f2f447b0b9cb459443c985e5c837db3a4549555a26367bd5cf6aae182cc42357b5370fa50774101c5bf20abbd5e63f410bb2b91f6e458b173bc1aadb3276841fdd89e1df00fa06bb73827a91d4194ee5659fbd37842ccf8212b596ca48313d98d99de1721670b27b3d0ded49c25722ee387e9bf56c6bce7097c93838868d4178d03b0c6e3d0863993861b72e4763d33130a327b55dd82117f6d3299aaad3dffb1066ea4f4f1040657fe5f3f1a31fea8556fe1673306530885dda7d1a4abfe3527412d258cc60fbf80cf1a25364636200dad7d48ce450827d5d6087f9f4aca57933702f16e564e3f3df34cf2e3150047f65194f83b010a5be894fdb7417f18b5ef97a1c8c947134e5ab403232cf82ebd096f5418b6c7f052d31ee1b11d0230cc223e8d38c09771d81a026a38b38fa2a40e30993d743f525337e470c4f8af4806d71ce0e9da49d861acf6fa9afbaac107bf9b9b8de57d4a5b493bd9caa400abc6e3bbc74408717e4aee1b0d5c8556f9393f219dcd1bdaea8c2d0b9f5599f1963691218e8d4217d24912d40a05882fe3dce2d39ae8b754a5b1701fe9ff43624c53566893c5b6907565e3b9392f44921015523b0db733a612378dc36953f4be72e0fdbd3b4bfb2d6bd80e28c4345472192bb3637a89c43296fdda6f81556b42e832eb5d634ec80d6020d57001f88adc8c6863b820c41e3efd8ffd2e3f0e9457b10c60b4f070aeb36efe9fa6c2610927a66d87f43de15ace7df160b892dc410826f666156c8d05e4298f5b5cad51f80fa356208c8192e7e02b82a570566024dd2ca50f2bdf802803d9c927dad5f9f59616b1ac4d51bef2f7d2d4cb24e7e5bba2997703d0ecf2b6732d6f95c8ab047e587135b96eecce15a279149a748e41bfe73adc9450463c7cadbe1bc5be60172a538c7ce52bddf68b2240d3571ce230bc1042ed2f8a762b6cc474ea1c17c21b84e140a600b1880faa76359b223fb83b3f8555f45585f7ea999f58050ae675bb3a90699ca28b6b71de6feb2b18a08a6539145080c0d6fa3b6d523c7b5450c93495ea3231bb4e230f4d42172cc606e4ea099b63b9921ed249c07628c76d5f9507f4538ba5b3c57ea13029e2e9db7e11a96da15bbca395b94fba2880a6e602720ede1b5eafa84d008365ff8e56261d16acd47443318767ee63cd932a582d6ab26100f417b8be52b49f9eadb20938fb1c66dfa8e77011fadd45ccfa165d2ea73d9565c203192640fc629e97dfeb104d01cf8f7ed2a2962686e933828d360f0e3b8ac2d81b185f0c74c63e65f04e9ebd2118751c9ecd1826ad066ab83d1680a0bc28649461908ad30395928a330a7d581aac555b80010df725afb1e42e6b996f6228ce42d0daa7daa9ba8c38e8dc83cde75b5f87c166d250969950d8ce1dd9f4b1d0d4fa77fc2a88aaa8e5901e43b6ffc9bdebbdc4de7ee2d60d6ab650734d288f7b3d3e560077e23a6c7e6d3456a230cdd2d781e339679a2ac05feb922512c8b1edceaaa4d33b1deb36b5a2c4dfbdf56c33a9042295e43b79ab2ee51e24a067b5e8223778c6dbbfef7b58a6089a125bfb59e39e50f8caa222ed9142a6e494e3ebfc19cc42cfeddf6981bb6b0e14060efb52c051acd8cb8d2dfac7a7ae7f33fd64ba20dc32bbc508fd9e5aef1c105403d7ff6c70a24b1041a3832dabee11d8fd31655ebb4106b8f2e96bbae7c94787218714acdcd4cc5e28c7491a50423e154d3854dce8d286466ce45f4522e28d58ce4ccf5118e151a34d9fe9e8d4d95caf292ed719c00970f6be0bee5dde9bcd195dd11f851cb929f6b4b015c610e6c91265842ccd04105c8a0d20ddc8e6e9e0bce76e59614af18465dad1e23f1bd32830fb0f1cce39af07433b6c1a4b53fe47ec5ece2c56e1eb78acd7e8b9928f395da91e7376ec06b3ab412e51b34cf22fa14fb0eaceb53c7045cf08ae4324f0593ec3cd1834856ae3c9c713ef3f8c5dcca4ab45891744ede922288d7f87b85f59e9e94d87ae9ad2c460075989bf55a2f64681aa1753652791fa356f2c7d501888aba2acf761c805d1d51dd0c68cc8716e7bcd483610c76c0585724a9beaa18570084c266f27b066c0845a7a76101b835275def7eead085892e92f7e3ce5c0f6cbc7fe9aa57596451a402b6262337d0f0829f5c7177d8d24d3d2f5e5c7b8a05b926599761a494557e472bb45649645a77ffc2f2b385896d98523f20a79f92cd388e08bc9029986f153df59413ab0dafcc0860b177959fa12f047ad57cd132a542c97942830fa5d5a4709b60c3d8c0b56ffcf7e984164aa3f011c4162bd10ad3b7254f8b0ad39e5b79cd2db043eb400049a962788110b2abbde50051b9e7d14ae1c174a574b45e3ee020d24fc6ba904e1861bd84f8cb8af0bfde94912589efcf929f32f8d465ed451b7c02100f042879423296de6c52f071f760e6688bf713cf040388ec729901199b6e7d9e9c2ab17d9cb8dd4ea55d150177b392d6e10e4ad926de20abb8313fcc94914776adafc8a2a1ae9fe33738871176f5bb544b3d066dcb85f29b1ca38375c355491c3846de75f10ce5717e637d3fe7ea0b29ca9d0493d18dd7ded88575eaa0ca86e27532371c42f1c9996f30a2baff06527aba3596704b9a508409b881e5d06126c470773261af0c82ccd5c485187557492c43e9fa4f18de559c0c79c4d673a3fb56b827ff2ca807b916253a47794fd59b993455973a7fbe1af1770d0e35d4b26f0324608f893b38f86836c8251c32def9dcf7a5972a628f62b2558717d47aa861b30d4440324a94796bc91e1a74a9946001b541dbcc9b31caf1560bf1bb2bebf1339a1a1716fca6e945cb86609386dfc3913153e205fd01b9e6e1e3ec9d4fb43e97b890e7988b0980ef0da50f4d1251e9b86c2378c4aea567fa85b50bde9b4075155b75e9bf389d28f87d96518311807df8ffbb760fe61efbd6d6f5279e345eb5c2bb06626f2b950b8a1b133b0d3c3c0ecfc70e45d1850c7279cf9beb420ae42311735b10487f3737e6272eb560d2e531461b6105866a8e96c31e09491ea88ea809d59d5638f801e3c891d1a486d8960a7c393131ddce445ffb7f59ad54b072b8d38f956072e20d37b95843ca487e5299b1fe0dae58127e18322f7cca71f183db489ca01fd51a1ec52489e3b0191cbf596d63a5509fddc9ffad2e623e078808d6ebf6425d5ad82fc849c3bc5acff6138cf060acf65009e0abf6c38c38ae13f760119ca6756b301e83be0370db3fcce711d72e66c24290dcd8ebdfc1825f61e675a40ffe563e29751f0273c394527f3b2002045704929cd6b3fc6fa728672bb3171e9f5962f673d3bcd3496985f39deda2804a41c0d637cc3110ad545ca4e2a1b036bf94cec336f077215ea50b935ad7f09d59687549749345466c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
