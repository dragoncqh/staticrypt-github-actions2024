<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e5976ce9eb4e8672ae95d0acac9d4809ef9d0fe72e9a91f61a98076d60abeceacf37364eefef715c7036bbf2e0e16482d1e6a591c93b5124e8e8030dabe2f251f612c91c71cdcc23726a84e09b22dbdad9ca463a7729fdbd5d325ff7a86158ce53eeabdaedbb6ac12981027ddea4493f6a9c0a27530b16c7d4f1183b44749ece681c384ad3120320fea648060df08bf7ce57e924b01753c9f6b71263a9b83bd228f17285f041194105b27908c094c7e76238127c082630a3433fc37b2c474097f493a264ee706f3f3d69208fadafaed67faab3e867324310126a05cea0d3c622fedfbdd49a36b1f6600e225515c2f99be3645724adc954ba863b4041a7a46dbd317ffb598f66b15d1dadee4adbe9a77ee135c9bea6e12ecd01f363b5ac5dd1cf26ba28feacff5564d4740ca9722f1d00eb0fd92582caf2ad39f04fce92a44022f62fe151f23f4d512eca6a707b300f5cfb2f495c0403c5ae056590d8dad3fef81fc60c9a0b74751f0e87f0269cb299262c2a21e743b08d768f3ef99baf8596162abd27f298d0f87ff7ffbc5838ecd984fd938f3f7ac91b6bcdbb49664fb7dc54c4d20d6dfc5ee877c23011824a57f06092da3ae706cd83940e54a696b7f175f4f14e9cddf206fae674b48cd38bc06bdeaac6f60ebff3e78d3e92b0a468dcaa25dc775c55f3392193b19203eb4849a98124dd6be7d99f78f1b6b5380bbf98e4d7a01c19cd3fe1dad5fb558cfaf86eecb58b5e7c8b3d6f371c22b7ff68b3bd964ea2bffbbb2c4e69f578804ab3b83a29231ce847fb017f94bbe16bfd2cfaeba63868482fb07aa213a2108ddaba436dd8c75d771a6e140d58b320cd83e21fcedb5bb8fca178effe4c10cb1d60263f1c9af82b8c167a2ed5f0ad6fbf1701f142be291f86b04887fa56975a4099bce18d2149d6e7427850a5c8ca41f839584d883451d6d6bd10ebbed25aa2277c94d6c7a975755f132bc70735504df82ef5474137c28709d342b93e72884fb9da7f64df6c482227df5dc62aa7cbb2a107ea26685beef2a62c07a942929ead4ee1a013302b62ac97cb6c10c614f709cf1c143410a022127b0d4eb2f09a01585d83f34662f8cbe288b5719d15ee1c2f4bf44ff3288d8fb8598bc75f16d475f904df6cd69b430ddc9183b1c6ebfd8a6aaad22c16b15ca090fe8119bc4ebe0c7883d6f7de5d0aca526a56a64f619c0a2312686e30441155b150693071846d6396f4d197f1030a6a59889c8b84960d03a1b05a9663c86cdf58afc8c0a86123cdfc98773d8adda9180c42d76a5b733532127e3fb23f1960d0e8f886c1c3c8985a876698a70d45bed2fafcd29053a9192eec439b6f854367ffe6be219b6b34dadbc06fd4dfb0c5a798273018f824c8bfaa07c9a63b73372debb22d655a738a8923285540772b27b3feb89929d3bebed66b57220a175d877c14c10765401b7130c7162a87e6300219cf0083ee1d773b52cc3fa5e93ecee9ac173f371251894088a2fa1a03829250bb78db1006ce57e76ad806cce060f0206aec661fc1d1f8ea139f85b17aa78f79083b86154b612a4a37b50a8ab81440f7ac0c4a9d919c4c0faa3d883654999be7f06f34dac6109c2c86935d26e7bbc4e802f92e00c97304e4654490c5613507b7a773819fd72cecfeedd80e61623a54c2efcad9136e71c8a1c5561fadc76ccb054d944ed4c56fbe32bce2ceed467bff21854caf2273921798878d826be5930361d363bd2ea23adc957181696c9d61f1fbc3c533bdceff47002da9c329c7ba20be4995f08644d6982751215e42ea6e01dd7fa64352520a8612a9f984fa8c9cd2f39ec14053704a90216bb0661a1ccb2928d60ea31a083cc5bbdc4ea0502f424a3cc46a1a10aacbf848c2936e650561cd2ed4c066f0a11f9669a3a3bf8c821e8f77e8ac90fb97575f43618b4b1b520a2727a29467151fcede5f78bd9d6ff339a22c020ed63234cb55baa2b5fb14a377017a1da92bd2811f39768c7327e349c09eff49e00bbae4d06b148c7113b40b72fd7703e589c31beb37daf8230f293a796ff7e607bb0e00dcece93293c60f62e763956792951d4be59fe605a150195d738c322616d9effaad32f4d1669675d1022e2069922242510ae980cd2343d1347620010b82bfd4e5dd4e8581a61aedc0ca9e39aa9042f634565382be9ae92f33111b87268f6a40effaa10ab661307684cd175f8d9d4b4923b06806313adbb7d649cbaf01762bccdc43341eb1b92abd750e9b1872fc5d6fe579d9199f1195b92fb234c2d1f1adaacf3d487aa59ca97e8f2f3d3f43113f11403061591d704c5337c16120ad01963603d0acefe06ccd89f6e780996934a9ae73422c5af66d78a6330ab3765a948931069f5cfdf0770b65efb62db654028d173a97559ea26ed829d5d6d7bcd8fe9899173ce361a90208ddfbce65ee4e3a0366a41ab48b0466d0fc3d98edda47b982a68a760fb6d62905b3201495ba6ca73d760e8efc85e190b23ba6b6441bcb5fe66834415e1598d7b5222337a0437c1cacd2308b147a49da93f5a23b6a6d12841e38081d12d3225bd79dd5212207a96316099ee5a450d1162ae260342a6f9351353d4875820dc793dbee9b7392c31470c45fc6f8497603005d64afca8341cc8c4f224caf4362dcebd4106c5249b3d3a1d3569542036f6803c6ccd926ea244de41baca84af778236267c0fbd9e9e95c904fbc3a7afb29b2e9b0f305b437fb0d8e002a314a8646da3a03b83147b9e5637316120be8f5fa76b4abdbefc789c40fcb3e77cc2dad6a258627974f2fc12a38a231af16ac0b43d47dde91890afae85ec58029703ae304622ddfebc3f4966a9946f45a42e879ae3f061f933c4b8ba5c51a31d2881cd9eda0bdc3abd5c285786761a9e3afa05e04197d1f282968c09fde60982e61539d66f8c3a093909754a78e0b2e283862e40949436f8662291cee0e702cc2c281fc193238ff1d856bd3f67e0d3edda62bd53997b498c4ec53b640918c9a9cd5c171e39dfccacc2d59c0ec8974aedc168e4889f2cabeae9b22ce058ac9c604aa9dd7a5fa2bf15d07b64c49a6e9df9872d8620989f9f2b28949c7bd5a61ddc16fb9ae1ff9071547a230c0a6b9116841d619b6772a7895622e6d7f8497e34343304534062e3c585a069b6a200869ee9028d1ce34eb6cfd1e108fcff1e8c6b613308c602050dea36e24530a2d1540c991ce0e49f49aed0f900865e9503b0172c2951f79d552f58e83fbc7bd939a71e7a7bde79baed20412c1cf8f9e29f4c3f552a138913191769fd00e17bbda3b90d492b2eefd97523184ae2cc58b96fd7118c872e51581b00da785d623ef1b2220f20a927ec832d55689e787223b8e38b6e47e9a8fe4a4f921d77b3166f4a3941984735b85fde7f255c9522e0889c7d636cea82e9bd0b6ba04b9d3acd91e98938d06f7ca4e135ededcf22cdb7c8da783d7e99ed49c09058e3db292a86bcc3b09d0836ce316807c4b85242db9258405a15bdc859db20ec66bde339621341469d2c840d12fb848bb1b4e3519753090c70aea85f9d0d50ffaea45a0fca8b48ed2e19074704feb4d9c98ee7614d5ed0a7f17924201b6a763d1e6fd564242ec881fa6ae109b1a747561bb991e790231fa47d95f53f5145f7901d0ed980ff2e74847056037acdae3d7c1565c3d366bc893407a8ea3ece8d923fa2c7df96e290d5d39b389cfc6c0eea8f6935636b805235eeb09c5ccc3fb53926302bbc0c4db33149f41edbb6912ede2be7349d3f0903603eb1feb79c641401d3a107c28ae424be53ecfbd910620137140dfa6772b780e0f0be8305624132489d4cbb94bf444b5b8c22a04315478c6533d11cd0836e1211833b147b357476717d6d6d2ce602174c31c66ab212592222921e06626fbcf13d8efbe74b41d6c58cd7b5713ed1ce5e0350a1fa93b30e112ae5c3787d18d491d7fa6bf24f4c651560dfc0534fcdca6346233fced8a5974b6fcbffefbc71bf5afd9179df7a27ef7e08b65107450b5bb448911db8c340ca66f1ec06dc05f411f37d46a252708e603be5a5a02a812d7e3c2f4daf53311ed1d7ede9363dec949b13e540ed038b0611602e1a52b5f9b8556b4e1693995bbe669e7a6342f790be2dd904d7fb4919ecbbb0a7fc818a42a518cca72778fdbc9643074f75f5689b310515a0f77a5fdf579e50888614b7884f1248095cf8e1935348bc9f93f4e5ba5f172af62f990bd973f13ee138c59e4a822d19c5a310927bbf81fc4482ceebfc4c2ead1bcb87d3260af244475a2c18a53ed21ad71605545f8766c9dbd9ce97d82b40c185278cc96ac68dcd652c2ebedd99493c089ad295ed1c355bb494e66fa2f936d2a7ebbba2be8ce5a1c90611cd9c97360fec3f4914f31583eb7fc616b815e33dff5383f19998e522d2656713f6c3427109145c95668a2d0dc1fba61353c61b5494aa6f1ad5616b113a51c925169dd80e54cdaaccf4c3a56486c3709516573d1950693aed48bf3c11967201d6677582e4a42405c555f2b822a3d5386aa691992da29f58bf2dcedf549e1f013cbf45bbfe18db08a58283ad169a24a2f885f2b11eb1df00148f3743beaf1d3111d7942c0dc2a934e999ac440ff55816ea40f9d1d16bba3a08c2c54738c4fb85c4f398dc5bed24b156f1636410dcaa0c1019618526b5460a5f49901b432b2839391b6f1575dee7078a512832dba428b4586c2962e7d48953238fb1b5f08869a5b64a0d107d2d3cbb886fbfc5471b243177e620ee8506f06fc5bebc6bb3fbaa1facdb8dde66dcbfc30a4422c75d79b0528b149e5943b1e978a52ed34b09a324600789d1a4db4dc1d15f4610a49b6101541995bcbdff898d0753b419d18216b066b893c08f2684d62805a427c44d31ab372345a4dae4e227e8e63ccff023debdc3f88a3acd77d415436768eaa59187ddcd79e9bd17e9f49a8bcbf34cd400cabda27c2eff7db3955f51385f2c056bd6c21f5a80d1b38c546609f4a6a48cc9f2b62ac608ea7157130ae68cef619239f3a607ada1c82d935cb59b02a8a76b919b38e1197788bb0e44736516c76b5e341715808a418850b48e67d00bd48186d414f952c4ff251a8f0cf79fcb9ad7e1e6bdc5617764d4999941ab45288e35f3a65c3cb9118d83c33deb87fbcda61c9df084f10523e54340e8b72132015ef91d2ee3200dba674d05edd93dc256f13b673eda0ef43a6d22abfa67327a55ee8e78825e3ad4c580f4cffd765a3500c89c9b6aee0b2504db822c65ca99fa5253faf7b5145c015a280f4f592a8965ac0636d4cbf827f0997f887f9a82e1c6b08c28df1d4e68abfba5a4a20e57c61c9e858c7d7b3d63f103cb29f18759dbd16d389f0049ebda754865e02f44f42c2dad662cfa10b5b9de5f898d08c21a4ea26d820c08467fb3ec078bfbd2689837407bc241dc6f8c980d6023c94ea0655bc62de87dd50fb49aa5318336eebba4df01394e962606f5195acf4f90f5eaf050289c7c2c272daad6ff47b685ff3d648e947f5c2346d4789f81d5a96c2a7bab786c3bf9fe0324c5bc4c9396954e62955fe185199f8cb4f4ea5b6d56a75529e1cb4e5381306624c7998cd9f2e50e4a8867f6a88ef81c2807ff99f2ef4043732e6e2cbd25b3ad00f8e4e27c9d87be3f1771c39bb58ff175b0982f3df95351f258c90f90bc68c6cd9686107738e1c78105b909535f1372f2cb7a970a245106f44e91000e03bb8e0ca230fbf85aa556acfc05ccf1fd5d8283be51ce7467564a071568906e3814db79057909aaea5edb5b389b272f09abe93e5e28b3aaa621f7cab5734db133ac77efb5362aa80c2c0b9308fe6aeb3a8871c4a7113f61851511b11f890c27c9c6beafdb91bfd11520de2b3336a20b7db0e05f06fe135d04ea33d9f01fc91c4f26aa5534627af6dd5499d06ce8886956276ee62014072bac1ec77f2e1c4cad653a3c65b48317e64388014a2798098223dc3b4bbc5770ab70c65991c7ccca9eba048a3d5482b28031ddc9e6e8b7c122112e40b36a06132345139f7f6a3be482b6c6b8f59cd6bad44f6714ca8708de41eb0242ac3e773b817101eb79a3fe887ef99be0e011439bc5064b3a76cb10b6b6db3a50e0b6303a37c61a768be974c418cb49bc9559ef0bf777ebee2c9fdf957f00e36f6ea11697c71817875d370d650ef9f52945f09efa0282e88c9cfbe9999277d02d8e6717417b4a59920e640b10d67bc76767501c518116bbcb6d3896fed3422f2b4144887f6c62794dc2980dd1320e2f7a1ba8cf858f20cf22628b63ad6413aeb1bc2bf8a182160a7c5b7b8393c84773bd1cd449f37f36292521e567fa0f49bf581f1be79d6171365b785894763769ff69fc64d09dfdde04a173a4dc5c129da83efc646d86d3bf461c454dcc84303d6138557923c9db1dd2071cb47c854a2ead4f380e5094b5e3456528e0ae478b7689a17ed6e9349b8d319e2e6d072d56dc610c09bbc525a2b3a1cc29b7c3be8b1faf1f69a93b655bb92fe4306e3d0b986e2cb9093102f80df3463c147924a382b52d7e5b818108821112194e2be4d6a457453a98d8ee60148fbb09732876d3cb7c48e2ec0c7bddf9adb362d3651af16f174f856db391b88e768dd0650da9697a7d5a49bd7ab2b52d061e15d7a33045f17f49fc4065cd1d99984cb01da3cf78dcf9e995ecb008f3b59b4c2056d425891419cdf4c6f26bf140c8f32c7c2a59c74b8fe82c454cf21ccc9df3634e06702bb45b33cca24231d1956008a5131c648f6dab1566ab3392a8c50826a9436a9c32a1fbf7c48309c4a4a48997ff9271c7839c83cda96f071a2c5f66a5dd20fe1d837a41e5360ef29d6b819a68ddcefd457023b6942f3792e40565030bdb3d9f63c7dea3ebc2000ac94c35480ea4398a790cf4452655e4b59b382c83e8f08325ac1db5becae982a1214f78c2a7d7d1ac007f2a7342986883bfa8c27a21a9eeb5046ac5a1e5c98d3e0dc24d529481831c24820a81edea79e4a9aca87d62346f5e588238511ec99858bd6a87c2ba58f48b111bc0d9f53bc3a2ace0c677337cc29847b8725455efd1a308b7d0f5901596093b30b6a03d019a98b7c6bae2710d85d4683119182104714d953348f974bef6514f303313b0faefbd6891c3c5c1a92e244a11fa0fd89efaa113eaed3705906003b490a418fdda6ce0fd83aef8e17a10f543acf5efe391ea736000003e2f11b73d1f9fad94b689ea274958be938bd7da21ec1a51e810656bde70eca33ad83aea1bef9e30b69fe5be620c8816fa58a35f2fda1848ec3c725e47924bd3b38f080c523667fb58630aed21a4af557cabaf21a0fff755ec102c24ec960d5d0de13b3c532f6586f0546ef0b795f7b58f65379520e2ebd015a124184c618e3ca98abe9787f5609384865159f60fabb186279bddb11e95f49766b0bfa376c84c2e50537d860e0859452eb1289149fb7d14eaafdc8270f590107dcf92f980cc26ef1830da1d699f8a6fc938464b68ee0add3baf03b02bc9e4a53c92b48e6c0014a2b744178e40abb3876d1968dc6c172b3e59b73df947b58fc619d29363787db2718c4e60b8fa93ca9bbaca853009b365c31ab044e68d88bff0dbfca441bf8ffabd3f7233906f50ca03ee20ceca4c0a70ec83c34ca7ebaf799d0a6c8037786d53e87b7febc3cba0f0cb352380933e0ef6a3589a8e51253e30aed975fd493f74c4da9497112997d2097fa9ea730bd100f71a5825cc69a3e688aabe47fe63b05880efc0e041829089ef7d13f4d7e2a08733b61af249c9a98727d8632d67b3a010886b700592ea162b42e37622fd829e3f17443381a1d3df999fc130d18bf3bb30edc0610214d3503f78aaa160702a25339233af9f06d5ac691cc8e4b917b16c06f02444640e1fc18d88694ccc8188203c94efed97fbc84d0e16aa418ca386e65068fda06f1c09b3d7533af6248354eba5868ad9cf28de133284303b923ed8e9c070494c7be026b062862d50550dff3b38675cdbe5db9865d9aebe86d1267359eb81d68bb60b2b495a067d956aec37c01c33f69428ba9b58e7f5bbe84c95798c40935a60c73c1ad4c72de671e9bafc177ae1120166f50e29116442479f01220fd06a52af1cd82f19f3142ef0aab088b66ab1b2414978786e8d8da4a5bab2e2f42b963c161af073bd8f06b3a20fb3be6c1c2654bf46980a2234edb50","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
