<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"098c901c61f161c8c568f28329459c91e91a33a2d9b5f5bbf72a0b047a8c69aee1b8eb59d536b46954ceda5d05efa18a1fe90f0755c13c037ec297ba034c873670c4032ddd4e3be5ea4defa31bf9c25cba23b00747cc07a2481f2fd9e0c1f1091c1e619b7f8c374e0520f71b8c86b4b4a2706f60b26ddd4a9bcaad8ffcb8cedaf71f283394e5034c373d4cee70f1474b034578814253dddbd8b7273e6c17b81d103217666c65dcf3d0faf3366adc98ecb54ac9ec186ffd7902d979e1cc44c55e3663ebbeaf79e290e80644df23a146911f4691720c424c557dcc1f0c5bda9577f7fbfbc2e4d29bece874feefd7a6d26bea88b7af3d5d1fbe0fc114a29b6afb237a72b4ec8065af41bafe25bf4944bbdd367f5ec8dde99e41d5ef8255ff3e84aaafb6d2b6f90a6993a878dfe5e3783026a94dcc14b95e13cd1165c8f4c3606f89e267677959ee418b1e4820c2209269ead774c4567d32628ac208da6fdc4bf40bd7950f9910dd9669f8a0d62f7ecc6835d96fa4464017df7c1c19b02e1d57435074d129b97e1c28948a081e8c6a18c0add7567cc649eabd309f9cd29252c79bef6a5cd06f58bf77a13d0bd3f42dc16830e0ef161dd5e52a427a5814131b78e73be370676c8b044fffd77aead90017490fbd803ef9e34177645deeced505a4d4c72add670792e272a07c2a02c61358f5de32b8909caf9dcbad467fcfe15eec916f256ca6751de65a71e8e59c0338bc621d9dc24c075b944ab3c086afb3ef2789de2ed74b0888b70b861d95136e84a749557eca5fa628429b37dcd388dad0a8ba9a1047b87c9372f173474c128298ab917f1bdb3d459598b1d31ac6eac8feb2553bdd19a48f3cb2cefc8042b54b60e77d38e686053fb9081ca7c02afcc904de3d0e4c3db48b5b51a17029868d1166109979de276cbcaeda0933184f684bd1a0647fa44aa8ffe1b9afc9e3cf9593202437fe677b64fd2373c540d8e0cf271d5d091b592e394ec99e52fa571921719ed1e9f69418a23c054bbe9403a92c63b52555f786d294eb26fb2a23e216fe67594360fab295e8a0255bf98816c8d249640cbf5340fea1e4076b2749f110db8ae147891176469b941f5e2d56a5c68f41603be9d35f892d9e7b44406e6d41938bcace60badb21f8830befdef03c6790af92198239606c559d47e6972b4c0a80e627c330ca3ba24e0c4705526c4ee67dd6888445bcffa86e8e528b2c381b24f01a54d36708ebbc7e7ba4a33c88647af8595395a5d18d6e45b24721db77329252e92a927396f7d716a06953953b6381f728cf35dc7ec272567d3b8d1937ac126936f816f563dc0ed174070ed072325024528a6a0185782e29fd799763a47abf69b867166b26ba9e36f88ff3b1f14c0e68619af761f768ca00b791cfd914cc2bda912e0b408de3c4c7bc60ff121c281be55226eee3cd48a5da82f1eafc9a2e45469b2c0851555709501863c149d29ecee7cda95039818e7eb6ac2b0c85affd5cee6a061e7325c5ec684f7196b9b7f88abbb1957804708322628d51f7fba8e283d19bc41ea972dd868aa6a431505ef350c825eb0ea770195bb50674f0e6dfb52a55d87e7bbed0d56166a1b6332d9b6cf1ccf62fdfa949d6390cad4e9aa58d216a584b9084db3ac9c7d41b3482649c617c27ab7f778eb495f036b2ef5df26b40a7b775581f7a968244bba9ee5276f3d3b8c881ea8fe040c54babd538684504e730a748e8e6659fa00192ebc7d7b50c61d5e8252ed0d12cb0e9a4ed29ce6334a2ec68806a538269381503aad06ed2750f1c868445fcb21ecd69e21d4bba5d6a6d9544e6ea6cb74e4baa0a097bc87fffd346d0f1458a29cb253d9576d339e36ec698cb4bbbe72fcda72771e86cd1ec0f9b8ace72f15c548b85f27466380f86e541a20d8933fd3a6df553aaa2f0a3ba3c71e8d77959e71e6443430118e173217e9617eb7e86c297c168cf2222504f0ae17c8416f34c0265884379daa52d14289a9395bde9563cecac7f33715a2478b12bb21b572492b23131979dc39a43af8ebf18b10b4c2e07cd225057812db77b20c0b7da99fdd3d39ba2ab57fe2262a9d9b4c62a9781d697d762cf8904e5bed78558e4bb6ff9951ecfe926f77b10736c9d30a099bf7a8044b78f041a843cfe91dd454f7b71b11f78cce56d496d52cb2428f4f5aeeddf4d44f294dcc7ecae000dcf1b23226781661adc6c983dc650ed734a6ebf95532797ab464fa1be4c5134f3c9e94e65eb66d83ee128c16fdce8f95ed33467d692a969915ceb50613cb2e565945752d2587e8a9aa192b17d8627a47f472864f5c7fd7a051a7dfba6aee47c437f8fc26453b695cf06f78465cb25268463945af08486217e8266cfb124be27f0bfec08ae4a581aa501c66d9c387f7aa9510e4b5ab1fb8218a15d42e35c0471a73ffbe217e2988e926aaefc112a2c58935ce192009e51a0442cbb738882e7fc11f6b83f51a6ca2d84f10ac3a295ae5e5ff06e0859824874cda7cb989a31324004f567efa0958b9aa95035a6920892162b9ccd21cdf8552da94fcabb0bb81e2bc1b501730641e563afd87c4251cc65fb5c24b1af993bd699464ad1cfc8884c5807c3fefdf8507d154bd9bbd72d68b9b090f31fce2b2012cbd9d9a551c345a2502213bbd6c3148db4cc2adf1ef0ba54ca4600e2459949fb183feae2c3325b4701c73e8d7960b773fe1789590bbb471fb758de744731bb2dcf1b2ff21b731d7f6051dbb90cec574474bf3edc6895a78a0cbaad790737338daea906f1be8c0468b3648341d45bc52915044d7bae05a0ac5b321b9e36dc2834cc66a17ebc36254742c7480ea6eda74faa81dad10ad79a48f621b86f7ab502250e7cd246bb6ce960c92ae525f475ce4f7ad96c52bb9aab90bf08aff4b4d75ce344bf919dc62ff0af7a456d4d5fd2d0cae911b8043277cff5cb412207894af7dea33083a4fc2f9f13769f2d3c7d22901140ee740e408493e534c4516bb25d4e9338e4ba08ff5d8af4f5d91dd6095ef6059ee60230be4b90688e924f3310d8262ea76e2fcb9352ea1845145189cc852842cc36d20fa71d0160f8f07bf60699015c4969064703b14cbab3706e614e69451de41079ab517fe325696ad9dd827e0025c9555705279db4234db665c5652464834c22e0c3a2fee90476dcb160dea8fb0758fc7efb2eed2f1fcfae37aeeecf67ee755de663c2b557b711f2e22e2dc14df38f4e2e6d62950bd0ae5f1de0ee290012a0025cea1dd888df36b04f95cd49f8bef07fdadaee206f2ded93ae6d789fb79b51c2941fe5fe31aba6dc9d2c2c7a7dd35272da22e4565d369cb115b4de265e3f064e53f238125d04188f585a3b2ac9cd9897e1cd108231f51722cc257da7c44b8b05be370d12990435309270bcf6e5c0876c202bd204a0ae18f13314171ca0934f4112331a7ccb220eee4d7440f000103a2208d3b5f245d54aca695ddfb9a3f49769317933c54ab9371eaf86228623ac3f98ef385d7a156695c32616390a1cde677e042c41f0d404fad9a5a83b44fad31cb8a6ef21372904d3afe54f132702ae8a37c537eac6d902fb9120ef88db35f088279059051f5ddfe1bc2f2663f5d5ff5cb9e7aff287da3ea08b761ae5110e17d1bca0f10a0d54afd4331720cb52ecca8eca76bf6b058f4048cfe2d0a96fe1fb116073415d73fae1e78779a77b60a2204156ed64151264cd2c4e342d663b8fb92c5c454639add3722f70b954a1006091f15cb2c8a8690f1f67b62965efc408d7dff4ac0bc4493b918b82128f6df7d425f5c1165da045617bb8ff50139535b846e8c4529df6c08b95acdc58fcde2f138a511c4267d9a10ba4f2cdb753ae620de040c9ac980335d5fc2c6f672e3cf3342120f58ebced244ef46708b5fd2ab7d0d2fab1396a44a6ab4d16b2b4184278539e85e19653c8b553c2fca962a12486d73343cda4d4e328cf98b8944c970e17ec6e9f02259cac27d51a9542aa7bac03576416d98c6720c86f39ac0f8a5319d50d23a56e98bce99a7bf32319dd888ec6661b2b1457be7d6582de7cf31c7d8a68a3257e2fa31480305ed72034753b820e74ee098815e68b27a9fb148163e1668e54e541067038de613340b4380bba51dd5526e23b7e7537f1e893619b080c13a9ec99c7a7b800c7c89ecd6e3d78192a17fbdbbf011a92072ef41370cfb8a794abd97ce24824554e59a36c7e8a4052712492c150956cf1c3e270d1c18f295495ba127a2a2cf314e3af3bed8689abcd3101cb6162da3dfcbab83e79f8519bf0f0357a42eebfd7e2096ce929ead532f9e70baa3636d2ce4109c52bf1b46439de0d33dbe2b3016af6beb4c8ea2b491eb0691ff8c807e97bfda5672ad1579557813751692e9f9976708f7d0bea7a66df6b3231a36c9be8d0e20065828c421f6b6831cbd8ecb8ffc271a49a3f345d78ef0ff980a6f401861935f57a2078009f5e411fe68f85eb56fe5dd7aa878369e70654716f6fe802c77dd1b64d61e5bfc2127d5acd6a563b976f66a47fbb5decdcb0ebedea937cc9f3548580afe73373cd6e86dcc23e9156054fc7d9586511b312585080efb14510694c4f2bbf0204ab6ad2495ee1b704f0a0d5109fb2693ba87452ceb0dab3c36dc55c31d7220f150cb121e3e92802f675f6a5fca20090b5be721c6f5fd76d9c98faa1244423ec9e7e5b1a98807db22e81a27dcdd3342429102595bb4efa0cb7ae8d7533d72ac49efeba61024413915e726aa135956e8e0656470fea364dbb366eadb39c73fa3b1a22fdedeb2e9f605bae874f821d9688f52ccea3647e927e2bbb2d92125ac8f8fa9e2862746e25039a49fec0ecac8398f718fb7cb79c77d46138bc2665539a74f54b7cddf4f21c16b7e2b48d1d4e6c5f8e1f67e89c5153dfba4813b3f76062e77a2c96896cbbf7aa108719c75b3d1a3e57b5795a314d58575a54aea66efe83663902499a4157a7f9e744b18cfbc6b9cbc359a5f9206bb9a86338d9e3538394c012c9370ce8c2ee3d77e32c804ee01e13b37b008857e117288cfe9f4c792483565ef2e187a2f9973dad7467995a6e366903d5acf2120b2b2d7e6d8791e65bb1f5ce4335493c4dc4999ba2c78f479e11f0adca084c4b730fd4615ed5137bbb9b940c46d9c7374d370b4fccf56a8ee95422406c2413aa133c38a18cb302b1be03207f2a773f5cec9f45560ae6562fca39a29209fd9c56d86ff812feef9a95a8f6c246e78331a90c529be8512d93a636e356cf76618cacd191e6e7bdd93f4275eac6ed2f3e99c7f18bb3cbb3d144eaa57e7ded0429a213a3afae7b58878fea2f9a09a355aa565d1b91ecf42f8e9653c2220cb83455773dc39266b9b0bfb343ebcc24334228ec70ad78eb98cd70b7c234131e410b36622ddd8ed4c2d6a863817cf0013289cd76e565316ace1919c874cb0be347793ad8870f102de86dea7d69191df16776431aac27e5173aa7bb662cf5770fb128321ecabc48b0a517b14c8bd991796ee370b7320d348f252464f8bfee30f9ae31a180af736d76c7ca2bcde0200388d541171c2a668e4f9d01b566e53b41f79af0f2b34c9e2db36b41780d378b430b564ca25fa63dbf1ac59f7a2596ca645aca8f590cfddd10c63c774f103872344cfb3e535fc88935bc0c383a7c896f4ab54de761d5a63a8b67a1cb27d15c67c9be3d73a632a8ea3f6211c26c59aad3fbdd8cf552e60ded067e2f930c6c319b4d691b5b6f49e44cb274f249aab28bc439327d8f0fc341547a0f957fb5c317fff32878f73068e28647dc7b0ef82aeff2d0cd632d95c458b840453bf789a7b7444fcd7e539eafb3360eed089633c51ab1cb5aaa1dad195acf596147b993108d0a7fad93a44e4b174cf61902d4a0e3319b7625c7bd3c962113cdf04c7bab0499db75e740cfe41ec67e3498730f785268d40fedfe79f1609af547df13459e7bcc8964742626079dadf194b74c6c607b18152399cbfc5f54b1ddfb6ede7a3806b753d29a983fc938541015259d7a003f886ca832aa36e7e8532d92604aa18a814a2961a2f21de48cd9fd6aebf737fb070e34a26b3cda5ffb964ad95fedb27f87591ca471cb579f4802e9cca3b30efc8eab2e8383960e4361d1330506536f2116ad4b0edea20a6c26190a9cc0c7c38ed57b87ae49a6bef9acd4e753bd7d030a78366bd7e563760362adcff8d569dace33a1b0b2a718582a64a766af1c4943430b665b5e6d308f9809439b208fb84e23e6ca00c32ed67571100078d90236a7c200956ace853cb5144fe43b569de79049f635fe82aa4d6d2483fe73853a6e88c91d51bff2c6e9c89d8a6d34bd8bb56c8d595f11b87ef811f283829bbfd88d69f9e65f4a0c97f5a42402f322add0f15aaae2239148f80c4e916ff3cd2c2d6c84198f8f6c3067ec718821ac38c3472e5c7d30236d3db0990d33e10fb8dd5b0ad62c2b93ea73f703aa41ed193065b1a4acf4e5a90c60b11601ef6f9f459e97a4cd4c47a4ddfef6634e0a476b63f5e85d2ce3c74bd1cfecb960efbb872a766d13f1be85d1d8f792a3b6b25589ce9ad70c3b8ce23a76a3f02fa128702d6d9dd580e5b45997e169efddfa8f4abb16dff67d1850910eea72de53349ec1421f5a9de8a1b6bf92d7915724f0e1973321547ace4ab046a6b199f2cd879e8e7abe1a7cdb8b2f4c219fb99abbb4c3fb61632b403f3c92692a22b69e552415b209213a945fccbe9671538a084360a215dbfc09df3eb456d20ae8e676049222273a6ff81a57e6c9d7f14b482a02da0b5de770eeacc7dd6cc17b9bff373b38254a0076d66957a0c3895eddf87d196982f0eec423304fc9a23793b37e118aceb3237eb7e9eb5982f5bd406616f56ec01a1a46b9ce17ada6e414bcedf8ae5cc24e1c67567a923206fc47a0e4c8cdf46ccd29f64a199640cc8894b6cc559983ba9388ab357b0ac31c6082d775ffb77eee9e437da01731ace6e151b398463184000979f4acb98e00407411e99a2e7a4f2215706c7bd80b2964ff5d2c000cb276b531f34a54ad553e936890c56ce07ef4eb17ca2227213a340360db3bf78312bb8762e2bc4d419c20cf0aed0f95b5d44adbf0128b1b8405ba803b56ff41a385b5f32674a993fc00119fb6f1a059c7f716f0d4cccac0358e12ff8ff406b8413ec22e0959a4b9f01347b665dbec394ab76a9dea66943b60497cbcb4827805088940b43d6ee0992883a56ca47befdbe903f3d59f4a7d5e747d346f9a9faa7cb904c3fbd51b1746cc1245c24388fe5092c9ffcb95dcbb861b7379f54b65a73ced69f992d29055c5888816b85e0424cc3d3d6deb75b305b425ea178df76aedd665206cf1490f092b02acfff1599889b5f0135120a8bcc87ed93e7043241b0b6511654745f905837e7743ec8899419f125b0365aa8378a58d1fb5807bc4960b654849905448c268a931304beecfe5b27bbda501f85e24253ed50156c8b8233899147785ea9a1beb752418916af86da817c1ef3f2bbbc66631e0a4aa0cd6730969745bd5187ac8a6b4b912dd29f2082772070c2a52560abfb5da877c783721d7f61920e30618cf3b6b4b7e295de0549dd8810217d6320798dd9410f5720162ce8ad8def16fb82ea0fa1acc69f20e613b39273d1685953fbe5df2fe5ba70196f87c8ade104b7a807d59be3e22dde364c93f6d8e276e5fa15a8ba02b0e089178c6451bc8392d439b50188a812163d1719cf7cfac1ca94c4ab74769293ddf2b3d3805976da4146e85d4265c266202887e0fefe1b006f97dd40ffd64fa24fa9aaf53526563eed305456704e7348e36d07f8e5a6d71b4b1069c0c9b4f7de51a7eec658c9962547884881e1317f3b6ad91385f078f6e218442255d489ba53d2ab6330d05a2f201739b12de3c7af19e4337ac50bd429b94f5890816b07867dcc30b27fe12f85dcea15edceb7f0f4b16381e429531cec575e1829baef945e944c98c951ebb4e334f4863585090a8e92e3d86929ba2e472c586cbb8ca66bbd000c3b8bd05b04dcc7658994b072f7f43116b41a0f56a357956b9143a562a4ea3f0d899387cbe754f4a2f74537181130d4dd82c404050d0579c3c0ea12431a9bc72386e045f024a2fd6d2c718abb110fb470501377895659c97ee8978610e32825b899d38281bc815f2636a12528de515f6e4c0f57f459e33ff0b9041aa38a275427722dc029b87232821bc0608d93e803998014174c60ffcb8b0bd2803200429af64d7307fea9cac1011bcfd1e87bfe6bdbfd2e6b7d2588ed5b4df295afce9120645b25e797d1db832c6f159ed700cac999c369cc727e3d78b8bd278654ca3f037be81d1993fc76d50489e39fba76d92cb0656b8781540b46fbcbf4b1795f2101a21151aaa9d6a7bd9dec291bd14b02d97ea4ce418804f72be9a17dd1c068628ba5178a296339243ffcfd7c248fe044bbe759247087ee05e00f98bd02eac65c571f4f12e81df89b8f06a1313104efa662423c31321d4e0bf37314e32468f9b83f4336d5b634ed8f1406115e89141a0c2beeaad8eedef872d78e9ffda80057d0d36f50863357881450af325a93b328fe18f210b76e06f172238c3d1d339de48237796f6102294cd1457ec3f85fff79e2d7c9948e7fb7591ae3f7aaae43cf375952b46bf722b9fdf737d147c52732e41f767a1ed7150f4f0a8562dcf81bd2785f7d7048f318b920054d188d252a9abb236eaa1cc36aca7b6510114878e64a362e079e52a002568c6099baa83de36935c1f7f34bd7d6eec90348cf2c0bd3a2f62afa18bad9ea7146b6cc8c9bb2081306b2e162db2458a9c22f27ad77296dc09f6d9eba5d1ffc5bf5fe751fa24c2efd2258743ea6317f4595721c9c432bd044fdeca688792f9d2d6000a3d5f5e9bfc9ef9bca70cd27d6f13b77ca08a21690235b72a14401c38a3cd4c9530fc0e09b4a4a6640fa80ac0ac961836dda469b9cb930087c98772232f4bbcf603721a67a2c4a374b31e6121dd3849d336d42b3756befd9ef575d46f846ca7c44455a3c5c18969740d194782d0f22749bc76c363b697da0477987ae07174a8750f6602e6b3e42c07f352aa2f7f06bf05619df8f15007dc2ccf93ccadc049bea06b6ff25604b9d4134bf213379bce077d643453f76bb7cab391d134f467290fd65353d1de1d05a3a97a3fa01dadfd2b572cc25ccb184eaaad6254ece54ced3152776b740985f31bbd2389e90d376133119d5013678a1411518dc81ea57d499108ed424771c46b6856c09a5729cb8e4292f71ea73fb3bb0e5490a21be96364e8e10f6f002aa2ea491a82d8f6077f14aa7a4ca97828504727849badcb8529b45baaf5bde5a66b30c94dac4031c1528a80bada9d9f113f49391d7534eab73e29096b70e400b8904d4814372e806f41c78827d629d5d4ca43d68deb47c1d864e97b2426f7554b8eda4de794ca6c89714b3b1bb8b9765adbda641a6e36dbb5a0d89ff7d93d79baec6664baa284d00a055a7dcdcdc032c5e1791fe03dc794d732eb6f937e73ec6b4d3d93de3b6ae6765417f847d0e07ee7c55a913bea77a8eeb2400ab43695c9632931e801a786980b426c297b78f6503fa73df91120f6b53994a92f72fb83de9f52c15a100aa8939c6453ed436fe601ffceba2e832c30beba54eec74a545dd477dc4df0643bc2e5b224fec3a0b0f74464bc2e19cac00751767b81fdd111b9372ef261cae410383274a5771fe8f997daf0a469cf0a62e88dde54e04518367e0f8640d8a37cd05a6c40c1dc425d41b0f07bc65dbb2623646f83e7697569b100b2a4d025fdafb1b0168da1171b23941b8687772e360ee879a621495df8b3f55648da16b20dd1122189a2b46c860da5a793612cd9c99ed10410d9adaff8261f3696bb3fbeb804583564c94462ee35b20908644f27aabc0bb792bdbaffcd34f7c601f84823ebf9bc0f99d2fbe7a724c88258670a4137f225d1e69cdbc58784fdfbf0245da76968bf591fc90a171f0077fac3bbdac050d4f54a5a38a96200c31d6e9a1061d9e8d5e0f047e2d6bd9c65c96c0735bdf25ff1ac55883601942fbc160c0e8c60c18559b2e090a2d2b73c38d14f3e0d1ab22e5d1abaf471ce2c8695445389e98ba17cf7494800f602cb2bd24776c93de76a14c11004bf7e4afe02d5c6c4e92b1b72a2c3bbfb111afe12fcfa6101dff939fcdaf64316f79934e20e07217a24835515da5e12565d36f9e5ae26b3ca52fbbd8d1615de25ff27e0346e5f3c63bc6188c7fb68b0730a1bf87601149e1eb03b72bee51f401db27b3194a459c6c6d8b9ebbcfb323c5f2334af2261a76f6d5e1e22a0de55d038b415098b2064aa3ddb80c284978f272afc28fd208de7261dd613859315aa586c5ce13750a1c6890e5c485e1f3f225d9b0808038efb5871e7740731be289a371e27fd929761752dae630c4c9ba2440eed265c4e74d5a37dc4a3b1c73b9f788bab8c1d9d6d897b287ccb6f4094ec5a8b3810d4047df59290409d0d016e8fde5c7158152a6244c177dce73d4c658fb507496c398c52ba3df344b858882bd3b73fcbe56a421c3a613aba1da50f228eee67ecf12dc14fb7a46345eea4db3b380dc98fb0724fb0206cf1684809c81dc15878d2dc1555ff45ab81fe6128822b1fe80460927658d808ba51b56d856a3283c7cd7c7f205712de6b47c5721f43331027320cd7a9663ea9ce04b70f87d304db2915329a9da9978e56d89a0d4c8cd6e185e8df5abf6be6638302bd8be0d58a9ed62f48bb598d81b63e4fcf074e862d103e98df38d1627f06e11016fb8e703110afb4ecd7f9464cbe043cc3dde71a230c50325b09836f9e572a7d531f5b25ff782e997e85bddbeb9581a6b02fd01a54b681653ff3afe08e23ec2eedc4eec823f7ce28017fc7bc2f37650714f575a1b3ab5460d65d3d0b160978a2a21f93c3e50afbe8209d0fd4d373885a7b881d194bcb3afbdd3e0193a641e65270c18bce76c727dfabab340f2bdd11dc350f856eda9017093d2a80d8253f901137067bf18a82f7770e7563f923f201d031219234168d64895e4da68893a138be166adee477fe1f463b3245cbe4d2dca58da8ed2d993c22a985469295a73410301850b1130d31ef0864b2ea01e685f743a9ef15b00b7720b2cd877612ebbe4c5d430a9efa55ee94bcd6ba8e64096e89531afb2e58a8344c75727965b36fb1332c4de4c4a28444eb1ff9b88ec08ea5f8c0e5ba00beb18e51c333c760642ea344acad0cac082694c6cc02104a6d085a27531982aa5c378dfddf8ef8e75e20563245e20a082e649bca82282d4b6985657a08332a75d20eeaea89e8c42016adff216f42c15fc9ff8d7c084b835b06677d8e8779428abb459d5e854835c52059cb7afa9855aea0c2ed5e2e68c74549abc961c969cdf69b72fafc27351c39162577ed3706f4fc1932a4fdf48d39fad6437b5ce853139d874265a78659e8a697b10dd0d286d64a4fa617b1a78b460ab2fb3cddd64ddcf85f0fd431e6977fef741f28158d20052c24317389ebc22395e177d83d913579d6e5edc8aecedbb009abb24ea9f4c4af1c93508c6585cfdb37d09d9483ef915b0c643db0236d2c679cbcb9804f67885237a609f8cb05d1aee2832758e57feaa22735a98de704393a2de576efb5075f15998be8e2eafb5b593e52b86a7826b85da924b13b360f404cb7363bb199f480f7d666639595b822772d2e9ec131aef06a7ef365b78de4feeb8269193d0f5c45011dcaacf1cfaa2c3e044ff6674feb9d71f559916f90299c5c4f9d183190b3811d87289ce370a3b102d12e2a58bb15ae4d96ee8350bc9a46835a7b0f8fea38698fff29cdaabc3d1913bdf5e24dc1bcc4f1e91b5ff6a18e28216ac315f075176fe7ca61fda74719d8fe1b05994e3b18a981aae1569aff06f93cce8b81e724f3e6c9c580eab2d524c53a9f4d24876b63f35a9a4bfe245278cf625b072b1f00233d9b40442e34d75ad3b69c30762453675497035d0d03bcd064f0caf11fb23b7c4f1419da6eee30ee074b0f8d9bf5e68e97565c7bdc4fe35385eacbe5eb60bff0d1c0dddf593f1be5976d231d43c1beaf525f517e63cddda26d01888f76f873799a9f67a150ca970913a7dbbb3f5b513b71d57901e5f339e8b1781174d4ca4cb98def77736603f38b1f3ccd211a39f4f074cd44f59ea050f2d8038e3019b70ae15e2d71ec40bae0e213afb55a6c1c65145e536c76ce28f8c15cb2b97f8cbf12118f6cea2265c3f2d9f7b94a7c7fc0e419486b993113bc15b626e783b46380c7df4b625fd29576ddb325366e03125920dac2714472326ca8ecb9c84bdba3e38f777340efea0d85b7001f8be5e0af6e3298fc38732d40b52dff20d4f5fe6f2fab636dbcfac8667123beb2e65b6d5162e89ff159755d625d14fb707252cef7d6121a841532e6115728c86404f3ec3708544c5a5bec00993dc92d2e51b5b32880a17baf6d8e895f1e8fbc6ed97617c23e9bd67b4ca25ef5ceb31c560598ef87575a329726148a3178451273272b752f3b6fad8188770825f29e2af307186a05b43b79963ef3155dfa554dcc20d43a35a820e205687576db73a0aff6948ec20dec995672e327f5c25dd57c25c67b13423b740d08e0d6263de1f638d342c3ce379f774288140088b90e383fd3397e614ad5afd6e78f1fb9bb08ee35ae81f13129fc6c20a29c033c8a8b39d5cb97468c8ff619d8eab050d526c1e7424cc48f3d6d9bf2040e527e4299e7f7859d001dec612e5bd07d637e2a2c31dc3974cbb39fe170cf7eaabb37da8bede1fcbc5cf8df929132906b9f6d0d1ac1638777c81313117cf55b6aaac473dcc67919a7aeb3de5ee09af26afbaea619b1777377b89797253caabdf595a2a8bff91de38026c15064504e702673c574504bd45b80a01eefb22a62140e9cfc0691a3e959d923e165ba84cac8dfa411123865f9cb6b0e4d6d5769b3a5b3880efe6f6a00780c0d03413f9e2a6e1088bf991080848573d070adb6a0ec0a5287ed367aa4458966df95c8a27539f88bbeaa7331b01aff32c6639a458d136ca7ce3aff6369ef4226fa463facedac4e6a007cf68d6ceb7e968cd16f667e602d3d8791d77cd3f5fde392f2a6683ed57716ca60ce93c06a54c319d75d6862a869049d4f2ff0ead8d051d46db90817d1aa07eb3b97136acb9326c4fd8299617277ec6c3167a89cfcefd427a81a9729743eee2c90a070fef7dd88ec7557acc6ee075ae692c788fa939e53590e95df7eb89478b8f6f31fd6eeb7829bcbf97b17078649a1a87f5c362639a8fa66947a78b42a1a2f56ca9e700b83d72726aecab570bcec76d8a80e77a03fbd78422360d7dca46a05d5baa55197ec672baf4d3ce2e1ab159ba6907ef4d24e8c81a40ae3372cfabaeadcc39a78a03252ebc3dd67856c888f9563562ee71ff6efeca6a6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
