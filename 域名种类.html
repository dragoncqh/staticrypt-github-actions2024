<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"de56d9d04464d171522cdf4b78ea7b2e9c0b4b821f54ab056240bed77d8982e892faf77aaaa01e97571eb22ff51b13d7f6412e31ced84b925cf3d5b93d9c0f97e242a0754cc5a67b93ca9f27042de0c298d1c7eba077aba2fd71570f6b123f38fdf0e374132cb89963bd886c681a5922046b4de3510680b13cb70b54a35dbe697a9f1667d7f117b8b0c4b89acb023558325680d2e75688b3541f620fa415e43e4993f73ac4981175e31cec9c5bd5c832aee190a256b43b684a322e682f2706661ec04990a155200bf193ec4e149fe52857ad61883ce5da1af8c64c6e4458e2b2d66b1feed8c35198b110247af0ac524323d0ed383c241305b18dbdc006ae36467329c1c9ef135312078c1e617ccbfe891b5971ac78375957fe2b1fa4e1dd0d36861017981694d2ea733fa56b0d7b0fc7e87768b0c675f9397d6b0671f14ce328a692b4fd0c57392e06751d43722346fd830a4f44e9452798bef0db4e40199ccb936252b59483014b72a7b0a160486ac047c6d89741a36c7d2a15530f33515c5fa1c665ec560cfcc7a3c811adb1447bda863e7a07eee77f5132b795a600aa01f9ad41f1ed8d6b136278a4260514e81a4d9b5594e965a287f31cfc97c32f4743be8b7c355a925811dbba9c37bd84cc6f6e1bcd8cb4301ca973e6722bfe4b2828fdddd390c08e9d9e075cb12902a2943a87a060c512c232973cdd2f0c26f5796cf221edb3c8254c3f2379920c580cb1523f7b2f07f86e6169ddb822cf994012a06bdd5619c340eb1adcbfabdb087dc8e9afe3acefa0f8f3504db91fb82f861b530c8f5c0df5e86b2bec2b50620cc7ad4c0615499c2cfbec316092a40535f4b7054c203cf8b8dcb4462629f8d8731536c8ad0b637717be8b235b52c8f9ccb76e982292beea04d8347249b2d82aa90f6982d82f7bc4ab419081d921460a03dcedadb806eb871a8870e5ff1ce2646390eaad20effeee6e596d85dcccb395f414010917435390e135916ffd4b047970f245f05673ee3c01d520479cf5ccde3da2059eb006872d4d08576de6185d65ac664885a6353e6e72d726102ec28624c922e4627bc2abb3077629ec588b678e88f265f69844bd7592556a6922bcd68484e827426cafb746c66259d71148a559df03b4d590f674d9b4c580ad65b3c4fe6673a883bab739ae8016e492156735af07810333bc3e4aabbf9082a44d0ee19452dc2610b8b443bcdff8037ad5605f29383c99a6b3fe185258cf0e9abedb97dd46c8b99372e2e820ba75bb256bc1776e5470fda8e030fe622a3e47caaeb9de72decc8863fbbe2a88e937544ce8643a8668f936eb5757670135b025e7b930dfc4d69b49b7ea88027097f541aff151f1c90288752dad9a8bb47fc74f0567758d513a5202be32bcbf343fccd91daceb53ac41bd1bda6c0549c3808b8251eba444b2f46325266980786db75c32e463ab4371b044a768e815f43c814ae677304ec4337c88be3ef7a7bbf1184e44a7e7957a010b021660dd67d15c0058fc95b8a0a8bd53eecca2881346a0837586c829285c623cff1266f4a4418a35c300c2e7769724895687587a264e157a22a1cce52e5244f943fe53af478f06da7b4ef1ec1be00cd93a7aa8ceed87a424fed829b40136dfd7ee3e6bb1278e9fac80b3afddfb65034cf488a2180e224947bd28848cc341a96b9d4b74ab43bbb49ba68f607453b6fe457a4eec5b4050784e85334dd2c411f3df0275d16d65dc378f92ff296e1cd9c21e506e112ddd113c46f4baebe002f29e84d8500269e84c44c4c637a20de58079b3de8b375f1e3167a8be9ba485bb7511eb4fc3a3a2ad29263203331e13d6f7df33672834442ebb4b4d6424c0cadf0451a9f3f0e15efc1670a7abf91c16c5eadd8dc5db2238fb4dadb5ab9fb6ea9cafedf975dba60f6cd94a73a23138244f80f80d3e2a3abf9f711957aa43b987eec76a6c76fa8995299fd39752f5bedc4910ba8ad304ef16456ad46cee7d374046700886a5a3364ee7c7d441ea8bf8185040bc3d5bbc0c3b9c4b649bc152652758ea10581f3dc241e143a53448015b001686748c8c314b27a0d551262cf217df7f74f702cadc842d79e50f3ceaea8e952489310975ffe48d26f6ecd45cf1791d4027a42020799fa8ddae4ba21bf620eaffea94dc1f370d2b49dffb9c8c4c146714a5bf7fafdba0a78f8ab4bf30c9a4c653f18a2337e8080988786ec6d30d8e9b3219b9eb8284146599d709f20540721bab52837fa351823c516057b0d56983fd161fb37cea0487532c973093423f4733e39db200907ff6afb5237ae5cf8db4b24fe6c5c36d9785a3973a5107f303eee8a091d9708b8ac2e33dd37291c7f3f219cf3562d78ef6a0e8d3ab1d67fb30cf1ab063f08fc71c7d6e108143cc87aa2401a42fa24e5a33139cffbdf31eea12c3a0b6b52c2d39a0794b9ddc72f074cad9558c0e0fdfcbf63a513b2b9e8838b1b26cd900226689343f445533740c883a51074ae31aaba3be76496724d84fa9c5b3f0ccfae5ae638a37edce69b8d3bb123c2fa1b21f35092352c78d4bd0f39b10c71c77e39d2656580473f0f4b654936b4db11955f9c56e75bdc44b2b8a4656e5ccec7aca7b70c2ecbd43f81e320b1501a92fa3a63891da3f5a52a5c409b78afb6ede8fd6580862b94c89a779e6849448841232943cfac027f647bce65101517c7598c76b32dbd4c470d541853bccfc4c9b15b1daecfac997a6415ba0697f5a47a877a9e454c3c5069ecca112db08cc0d273987c89886229dd11b06727598182eff4027d5af24e0328b7ba551689fce01e2103671134c38dd05ca9d4d0e87c5fda3c11948b09dafecd9d4242f9779c59672e922e885cef77f1cbe2d01356ad676d53ac6df021e5a90d556142ed92a11b90ac7a80c35e6c8e66cc0de60d393cc454f601198477425cfbcda9b1be2528f76fb710b51174ac632a0ef3979aedca902f8b11e465f17a023722742ac4c2c9e891a63e85cb04513680158926a5b7a336cb703aae9e18f3530916d40c04ce9fc5aadc2327f6f184b51022d40a0a835b45dd52458e86c24fde631f916719c11e30f649c98f47a554785acfad6fb542e92db2fc9e4f91e7b7c8e10f828a836960b60f708e9e964aae0257916b314189385fbcd3b43c37804b3662a0ddca6f1eb0e2b6f2b9ba80495ab243ae75b11bfbf15bb98d62b49e822f0cf914e52683ca08fb8c9efb0ab348515f6dbd9bba0cd54da5c511b9e0fb1aa9a4e9ff3fb98b6fb798cbad6f1b2be55ae2209a57d6b7410d38dea797aaf773b1679784f837c8ac13545adbef4eb5d6d691f90db7338d0df661a9c8f330963ec90bfdcaaba0dce485930df5ec2457aaed1dfc5dc7f4738c96225fdd879772245b810c3baeabc61b493c818b9fe2f8168d3f03777508705c86773ab93b676217298eb46337511a797e4db62dabe288d2fe2052e41df661a333aa8080c86ee2b1552967e81f74794c697f36d369bb66e50590727ed7695b9a3e8cf46d846a245fc6c4dcf478d5db5e294cca3862fc8a9b2abe209f8a18db46ed4617d1b6cfaabb13324aabc5a26a4bb543412f3a6186457c76cdf99111c12d09e5ecf7db27acb467ffd9a203f59839c1fa984e54a44c2b53019dc4b78cfdba13017643db4920c6c4dc305befff4627586b698e2dd54820563fbf2e2d155e48d216f80f6b0a08a3f821845e1c1b15a8cf381146d74cf9649abca2913269bce87ee215a0bf2cce60afb97646db6e425dbd73dec9688354ac371f944748d4693d9c718eaf1ce12388d7af7618c6d97a3d5103cb9b080aaebdf672cbce7b5365c4b74ca9a70489a0270b408880a39af5c98fe07edb640de0e9980b5a5ccf8cbb5dec56106186e8f18dd7a876f4314bcf402f4862dfa7df122de9510b7ad5d8cbba56a8a7677ba670c8ab9e966202d01f9de57b9bf70ae3e60b3db56e021c2549faf8718e9cbcd2f55fc361ee5ae7178c5296a425b2758b2530d3f5cb0b502dcee73757f9be0a79fc86a674ecef0b120c64876a0615e650c02bd82287981bd09cab2a605a27f3f03c118010dc8491ff6b131a2250ec2636e7fa9fd46dde86fe969d9bfc7bc4b7b53cd4684401efb80a56b9265aab5482c759e92097630be684e66119e8039ea0655a4bef8484d13f046afd29036c1952ad08325fd649881941e1dd13d955ec354925107a5456d43d40365bc04f4e512fcc5ac6848d3445d429839b056db4e7624407e1286d2af6b04c8eb6d74b055271ab295f92efd9af1a44ae1050e4b3638dde5c34ec3fa497bbbb9cb6ce495098f8f8e937382e8e76222704064c15651b09576c132d5a4f1996a1e6c66fe27e0cc949c6d6190ae9c2d9225d0ffd988cbaae9024cc3888a19e9a76ec949badb5d230953e3680bb695d0ef2dbc1a6d8c6a182068f257e4b6d9ba927bbdd9d1847d63bb1920f1662e1cb75b489e68716c4576f9ea1c096d823f1660423f2dc5dc27daa2bf5f79e942e372f5b60a8ca8e267b4a0449745d0f69d8accb4f642c24f02687a14142f3e24e1f0ebe8acd341116b52317915c2cbf647a656af0304c697181ba8e3ffe94002eafa5e935447f2d5fe29df6100443c9e3ac58403068b39d01c2cecb894584623f90267d0873320ef9ac7b685ae28fd99f563d166832a4b11fbe84effbdf3df6571e5ad13dc14e28ce7587cb8248ac0e6775304f679db0c2f2cfd26c07dd879e6d2ab6dd086964b45c6ef9c3e52691ff6e2da76953522339cd13191c78e4fbb4da0a7b54a19d27f809d48dbdb79c29e666cc8e8568aa9e6f98ba88730bf89cf3ea2b496b68a10441743df90f51446945eb5074953efbb40a62ba473a32a14e85ca66d240e26cbd05cfcf4d600054de500bbfc29f973ef913f6429669999008c3ed1eb08d0a1a4108bd79309ec176221004c3b5e3e76dd028caccb5b8287e613603ed161513810353cf61e9c0a32e4a0c2b80ab6681974787276e5f278262e6821a457f964b3dc779cfa17a02e5ab276775635399e64663e0377554dd559a25d8ed02800e76ac1353ca279c53492280c5448a7c72dccfe00f3c0afe64135253eec69ca0adffe9f8668a22b6ac7b88a943ede0134495e140026154903d58529d41cae46802df809fa7499232925010c94f6859489daa05f1069c2bfed70c4ce5faf2edef79c6b3a81512a216c02515fa2438726482429afcacd806fcffcceead5829743fa42e63db575c69c31612145654c47c7a29c55cb950d0985719c6e51efa96b6befa81dfd092acf0e963ed1c12ff8e78c8beb61ed59dea5b1e8e56211b64868c220823ec7931b166f47436d79911ad47cad953033bf09b49b88ac93b1e6be081c5534b55c9c349edb3ad203090d29ab630609de677e90c4c882f5e88487507a942e5bd68ef820e0007c74a1cf90d9140b8240f08edda6c94eb66ca7012f62084fbb30d3e89dba7040e2d1c7e894149147380b0ac4ecea4b69044f002377e1a4a49f076d52862efe7c14e72299df9c99026c07a8697029592b04be530104c008866d2cf100003647f04fef0ee524b10af90a0e83a428faec5d654e486db41cfd59ce20e5f16ca805c5c87b6b3c09e423fd2dce093b2e38480418a317e7acafe304205798c4bbc07f3ce44ce7accbc3854736f76d280058d2e54b67b54def780984423c6611491012ea27d246185440b7e8aa1528c63f97fee95edd3ca8cc6ecd8c185278d44707fa9519ffab0045cf071d9fd10ff511a2b77f06082670406e0e4edb4cbaa95636f3e67c2b503bab2bc434deddb33314d81c380c90dd6d7556f91d0efe40bdfaed7a219e93615c3d490b6fca92223e62ce0eba7f0840fed87033a85815b0e1210d019c37d753b1d1960de8b2ac8c20b5d2973013bccb34ec80f569cd51c61d3b2343ff28e32b4e334372062d789d92cdd8a83229c548bd5a8ef612c4536cb71dd84ac6607ac162f987918b630a702080bd1cec1db88d760b4c5e12c2f782f0c0cf6c5ac1446b55e4be7f60fe57a4437284fd12e58381555ccaf64b95812e3d65a2407159646cb42fb4c9f618d270173cf3266790709a303615414365893b5e387cd49b1df058eeacdceda26b6b46f643f02eee66759290a073b4a91230dc31a5cfa8fb9179d0f36feb1bd19f8e4ce4873c8275ea9eea1692fdeead41f1a52e3ead46893073fdd8232f31013358477226b446f6a42b09bef9b79d2ff80cc77622aeaa646005e2809b86a4237bca337ee15095cc45a4161bd2e2e02f56a19f0e9d04c10f7e29028b997b01ebb07eca9752c93f7e6a72c6071571e502d8ad1612e95a286e3c727952ef03d0c18b562e2bd95cff7ba885ec63b829f467d0ed9509948e0c9c9b9200665fb6d7162427240001e587504adb072906482e37a6123c70c0be5120c40c762930a19a308a6db44de3bc1b33cce8287a2eea667defac2e7ce51006481c074b734c1a6723634ba46ac326d39ddec890fb490a4cc008e596bd9505ffa5c3fcabf692cd3f9bf86cf2e6c73c24d499449467e299f22ee419d9f67c9955f4565aa2ae741f06bc8a2146c4de4a90f499b890b78d1703e9cde8526fc96e70f8eb99e8693f3d3ee3330212c080da79fdd6737ef7b26fe81d29b6223f7f1b0d31ac5bcf48d6a130438d7b85ff852f8f6e7fbeb89c14f4a0c2c5da7dc7f35f48b2ff00d740e7fb1061188a8fbe2c15d9f6d96c945639178ebafb2a6df66473656acef37c00db0f79ebdb22d136c74c92b904ace813d56dfa87da408693ddbfdf82eb632d07997f909011bd17369c1a5a9fc15e0e06e503c8dfcc6a1cd06cca899ecaa20d9deb25806064ac040a133f839cb1d32b2259d5c5181f74df7dd4811ce71d4dc96d5122a8c64378cfe8fbede626d6dc5455c59ddeffa64ec76f86ef9977b40841ce5b4db943033735d35081208a39608e73c50056b61c3ab3b108afaad5d83e5bfc4a95b92ab2d9b21ff97ec4338c54430f6923f06e4283b2ffc8b5d23d2a57f635e34fd2733d2b602f4312a6e8b76d4e8983f6a26d05fbc95ba9add2f9e0fa99611cc91c20041842a221b3e47e80831ccebf57aa5d82062f420aa104fdb756af6a922001c8bb742626bb900dd6f287077b484a338e778fbffcb6ff06c09fa86d2aa52c445c78b5dcd01579f78d687343aebbf8f570c147e9b322025bd9ea4486de68925cc5c288eb62b960110ed5a537e95c27fe633160ecf4fca280ac0e33827797b7f8398b16b8141fee1060df15377f5bc2c125b58d9365b6478a42ed44c6a46c2817805bb5202002acb6abca0e2972a901990ebebc6ead8143751ba4b3fc3a2a140678077977d328c5a8e0cef6e4ef2e023f8a02363d3802a9aa3f8db70475ebbeaa13b4f4f63cacb3f994b900b586bee9593485617e96929f115d0d3835ffdf9ac09ea9ae18b5e46c338ed2caf0f31d6a4d4e277961384a7966743d1eae4d4e3ff862d8238f428fde1a28c20427b1b2b85a3fc33ccae7b3f690acae624c7461387c69cf6a66d21564dcee3b2f0aebf7a8a315ca4e1383cf74bc63916edbd830f3725ce399e8f67ae3d0572073b5d7aa6ba29229e05a98069df58d672c9d6a6d55abf4f270c11418d2de24a151f55ccf0e864cfc09a42ec325bb2ea46da52e53c4888a7609a8a6c063df9f0ee19f2fffb79622e0ba9f16c5afff8e298c6b5013736ca6621925bbee1ba4cb65d8c023e636a661e71fa0c23c13ff54fb2e6655f1f5479710fdb9770c2734501b901fd65e18a1055c10a9c0516217153456282a16c6af6903412f0ddde8122eddda8e77dd39e81b6d4338652f2c482023f2511572fcecc7fac27a9075d9bb701d279e8b8340c593dc38aeef630221e1f4044d0e962d247f1fb0bee86bfa0ec177243ca682b43a6ead1b136a84964993b886fe54c04df95f98076a4eb563536695ddfc7c172a03d23c3da11bf768942c821cd95259c21b448e9bdd2d2dbb276a09f954f4e941e4ea57b9914992cf0fbdfa31e8bb6830e7c7d33b4f38ae057dfb9bf41441df3a3df59dba98526b1491e95fe487c155b3cf07405781712ece78e578ae1d2a5d078975417705ce6198b989641d820f0c744b35d819a6d6ee748c7bf5483f9f88bff33eb391625d14a5dad69af8f85379c6b3adc973931a5341b31391678ba026817867b0a5bf22f2033818200ba4c4d94e147a099b14ae5a3131cfc8912418df01e1c395d30aca890261054ad22eddf7a40c09539b256c84159aeaf95129d72a39bb56a4179e8e88e3d76449962e62a5b52dbed489d2c09391742c16aa83841d554a51aea8c18230e52029e7eaebbf24df9f0b33465fc00eaf17a002a6cbc3aa4ad374ce9b9f7d91ca55f1bfbfbae5c236cf53fba5bf18a4bc570f5a0a6fcef5a54c1c3f22e26f04c0becb81ba514a87e1ed9962bd762f27e7094ce484227b0208d851b1e4c1a64f9d46a4edd16f8c01d18f90395aeb05581ba92d0a9a4098f090824a3ba75eddb78e2786fa98a9e49936dcb4c99f3e7bf90dfd17fdfb2a003b0d01a8debd66459abbe68ec957fa571bf4c5700abef8f34aa5d283a458b7a542805fa825d7994b33acf428ebaa28787f0548c6a13bb2037dd6332385b344be2ae5f8aeee31c68daf5d9d866cce0b72420bfd0a307c9a219b5a7f72f5c8155866a78cd9740541d736f7e7825bb2f041579fecbb5a99c579983d10fe1905a79321916184d572b84077bdf642d1d498a5c645296bc63f4003892acac4771faab1d28d2258c0c9df151674d313b7e943a75ad0942b9586ae7cfa3aae01b8cf4f088416cff08b8f880709e15af4f930528f53907356d13f0966e064ac3c674d22c96e55e9ee80e52636fe965493c88fd2628e4c976e37d0877b76d5a49030121f4e415790b0a67d4cdbf8b464c76a80065c0c6e877af4f04c6bbeac09b128be2e97b99dc238dfcbbdf7d71023635ea5e2c05d0b10c529f4c7b984c80b926f97ec85e639b012f5c68bde924cf3c87ad58ea844abc080cc4fe7e8e0584578cf180149129cce79279e3d27c025edafaf89aae06d94ede96cdef4ebdebf54474ea733b407f559354819e0fbb135ec7f0e9508bd99bd42f532ed250b37d0ed01b1f1556550378bcbc102000c2621f12a7a99b81028413f226ec03c4afb4066487f4e982ec1dbbe11ee64fcd2b71922e73f9587754fa0a6276fd7974f319a2c982a1bf6f1fa1c70747edc98bb5df355ea6f7a4f6307b008265709e9b349dd98b2ed73ecc63d3906f8746b1c88d7492b5cd4b098c8a769cfe3682e71c54bd4ad43b860fa444d3f24090a948ba458bf3c5a015f693abf51af463d72562573188c3431421fcc8c16562e0bcfe53d014dc94130923634441417061e0a3c9abb77a3b1a03ac9ba7ac87c27612af96fdeecc15a39e56ea70b060e6907401cc608a42e200257b27db98e9f416309526d3769dfdaff071e75af84210f7b82df5a617158c854bd25b49808b11b22f3ac3687519bab9f6625e3a6e4a884c240b59390441a5529816a17cceb22b01075fcb81d6679420c37d6c7dc3bf39f253ebb45eb36df6ca97680669257676442c1e5ac1134d6b64940995292ef3371e4e9e32b36accac86e0fb85d66fdf36f35e5f24cf51a2122fc86a89913127e3787777bb17ba44ae811862054fb30a016d45b3d1829b902c0d60ce156daa81456f50fd9a3b1eb1859bb397d3cebb91a877e3a2a73868a88fc346f73288f9113127ff66fd3e298b577fe2e02b1ef0a278d4cdf15149b3a3c8200e9a18ef8833f98198e0e4fc333e3828ef2e2c4d4df2c571a3e26c23828906acca696e9925d60c01ccabd233e28cbcff46de9b821a9ee18f378785f74528e71839abb10f4bbcf41a7137aa1ac64db0bac42e277baad33c4c3f911d68bade1380f6470d22462aa02d91387a1bd7e912451c0d906f84123191922d1fd605aff7804dbaeef6c8d456d1a17a464e1d97aae17d19af1290e6a273ab7b223d5acd6c2bea9162c8aacd36c9de666035f1d2a91d95b2ac2590a67f1ca8881089217cb93de6382eb3ed7cb8e95e69eaa9402d06cd8ef9584499bb78cf0b26489749d4be5ddd7908ac49ea3a7e2ebd32265a1804651c75d913a9a0eb85334af64906b67afb40c0c365aa4c98d9bea233c4351a9928ce0e5b11acf9cdcfe8eb90181f9ddb3dbe750bc3e74d221ee0ad7a75dc036734d75a779158776c8b5ff32e0aedd0ab1683a5f02c071822a9a59f1fc0f77b4c65371ffbdafa6fc7b9709b83cf022723982fd5d1eeaa1511c06a87b692923327a81673d7f28b6ab2e07a1c38b88e11b07587720aede053f409e80fe8533410ceb6465abca7183d4a131c7c1426c4ab440809d1ba117b715003d17a4fe5de7bc1b1f92257f3340c19253500b2b6a86320f6505d1671bee78fe12c9de78d219446f84d7218531a67b80f599208f20f8366d64e5e0db9b747ec06a2255928147ceea14224ea2eb58ccf3f7f933beafc16de2b49eb99106ceb6b48866eb29924db1ee9b0a98d9fa60c41e649684d7e20b01092c29c23bf259dab70728e4bb0ecc1833a754a68578d02f209b149cba2a85fc27eaad5f79be4d472d541a31ebb5889c772c637013e8ac168b2870279774a3438458c4b068424838feec69044c731b1744074774b77da7d6097d78552905c05b04f9a1b44509a004cab8e4c3b6e0cffd647419795dee44c30a923044d407115cdc6307a8c8abdea753f0599361500db72b842df5c37a582c1ab901c6ad3f07c9354d7a4637554ff2be9a85ddad6a898b4d7c86d2bf01bcff37a2e971834f9fba92fe86616f57616048cb89610fd62952a08335a807b2f9af67109d14a69facaef2961f07a78a0a674755534011c1f8e02de0cb5d28990c12bdd5acfcdd87aba4e356b9e59a11b194266ff3e03e0457d8654287a0b952411f79741ded889f248ab42f55cbe090874b9d6e4802d4c109ec5c2a0170bc2055052e914eb6877e621900beebd9a9874dd182788bc6fa2c987cc13c49c1303766a504e7dfc0ec95285e952797d77cb04b7162a28828109e1e364f5cd8f464564e0a09655b9cad52ce6a5bde3083e7bc3f800a216233689c08b679c14da4e474e5fd419194072247ca6b3d31d1970e531a69d4428e105daaf516c6a71ed9adb4323f07205eab0a1291b861abe3a545c7827aa22392adf942541ae3c1a4682cc4c1f4dd51eaebd2ee11a19c6ca9e334db617370e3e027ebacb5e97570f5d220c648a9ab134be1b2901ccdca8f3e1b67c116a9736124d9ab4a32b7a6346802a28c2f6100bfa310b16cb27c5abfa78946a5ff2668cc0eaab44415058f7440c259eb5a780fd6ee598253148d6a3276e024fa9bde5c6ae2833c600c3ff098abb2b2f3942bb50b63203ff5a9f260b7023dafe2d4c26177764fd47a00e2024a7ca56074ac4d92232dbefba659b86fca2a9d3bc17201761170ec0128d6e25b380ebda60f4bf98b102c32cec76612e9dc9b6435c3e66dec1c9a69f9eef6a2aab79c9dea91d5c1668f28533bf0b12f78c758f3217c6486e9a85e86718f6b5ef0e3f1182d265770161cd81ad23080e836ff09ac00bfe632c64c1638cb2674b1809c375e3faf76d20f5e9114e50ebcdd5b281609bb99ee8a218cb51832991c9cc0f5b230763a40bdfce113c8f6e60c5f0c518da95a2333fec6f7981a4b1ff6c0b08b800cfbe4fcc603701ae6480ab4207b4e4e141397d92e2f81d28b039a53c1f539e43e3cf87e2d7a3a13c2053d9643b8e90c9835922c7b3485fd5e289a2ec8fe35aad70d370beb63e446cf9dee220762b868c73a2d35fdeb5e06765d4a95135c7ff551d2ede378803d3d13b1db3cdb959990741a90f2121c8480052636ad20ad42f3bde67a6ba362ba241cef524c64ad6c30a3b626f16eeea39f3a592bcc442d4e582d6cb50114cb15c83ede5a84907914fbf333b9bb0105dec7e512d97c5a8f7d28cc8778057df4d2e833b2577f0af16949a43bfdb548c0c0c2e0efc416b9d252da9587b6917ca479b25a2e83a69b30e21c472811f1c916ca417acd57e84a4b8833188dd4d532d403373b12a873f663f37322af46821d66a2f329e5c9d3b652e5cf15a54d8e9f2da69ef363666f8b55d5385b92b8267073ec81b274126f1156723d815bf61fdc039de3d8979edfb62f27d22e32ae68743e134f502fc1d09d75d03ed7e0832b058e748098c0d71660a7e405a23c6b98c019571390dd3dc084129be5fbb622e70ab9a6ff3064001c320f0fdf6f309ac0f77568673470bfca232f3cc59eec28f3128941666456815e378cbc59acc8295fd7683bb99aeb5c114bc3982784810772a87daf749ba6c6be5c4605117fd59eb23af11c5938132e41f4f4b1df56ac4ec0daab41a1ba7f72fc553d3746c4b984a61679ce875e81432431f5aa022477213ae9ea5f5622e73f936773eb8fc67a5925e1fd7aa4fe6e514ef7af07bea805add1fdcf37228ae75d38ea0a76de774984324e9edf80b038c5589e442299e60f97c003570c97da868285134e64cf2a0b416a63dc49a6e4da8f6b5ff69875a8e137c1fd6a9316237df733d92263d1b9c7cd13414399661bdb7cfa16ad7e904dc014b0dc0d865a1cc6bbf5795590fb03a1f79eddc1d5bae5fcbe266731c0ca13f68d5e9703932de0cbd20bd695368b5c2d0d4841da0c4ea568d64c0565528558ee4d694dbededce6dfdd1cc482a26f1a348e35c9d0f74b72ac4562e19a645fd159218e9a1334ad72a4a26fa0eaba89d101c7b1a795ef863ba7991ec730d512d5a4d8edeef90d44ff1ff61587e157808001067f2df86b165def30812c35d3e8ba42b914f3959a649dafca61d3990776a49663bbce18cee6ea28781fb1446d1a5639cefd5127aa2817df4fbc3767762e3365a79bfeca3c8982decdac49ae72555396c5183b19cb5e3cb0ef3fb05208b37da0897839eeaca8fa116da015fb27de44d39953816dde686fcf25b227783df06dba6030c2a5ca13c8706432ac60616962cfd2eeb8acb1fdd170d26a558da486e4055bd42a163ea337589013c095b7581c80f6c63dc7ee38cc3c0105d8da36a9ae8b558b969f4bebdf24c6ae218fcd38fe039b83985fd0223e2802ff6ae01839e10bc030bc22e68cf18425b3e86e433c05ebcca7cea483c52bcc7d0528623bc165a1f72411a18732cbd58291195f1bca2813c1cd3d7fe7a432d29348a1bd4f50dfac144818bfe8b662ca692a1eb863dcddaf5b09dcdcb46af86227d220e51b73008597952114ac9b2f8e53b407dc2c5d175f61ab247860e22a2f5b7b52eccb67449179289f85fbe066971d61783dd9120d969fa9557f3634d24eb25481ef5e3482bcc15bea38cc51d0b6d4091cdde55a1a1233855bb75437b0890e04fde475fdd566a2ca10008699cdf1769b3cd6bc851135f55e6cae076abdc129b0f3ac5c9c23e3bf2c3231857c53e13446ff4a4ea3bdd0a5dcbaaeb0366d4a20bfcae7cc12cec431d2fa547c36dd10a4c3ea5c8bf2cbdab8b344edb3e6162c5e0e47923bdf2331edfe1495d6e0a8d17e43f642b957750792e13afed923bfeb77551412c9dbcea704857be740bb9f7346bc1b17a4c3d14786a98ceac8581e3fb28724d237f41f684c06c8d68343daf4550bb5361e887f72c145e579a022f4215d82fb24dcf9486ad88a459a25c786341cea5a4b670fdb98ed8f6340d36365a1e5b078b89bc83688c9d501c1695d0fe008fe42546ff66f1917e0ebc7013ed2d53f00409cfd1e261a2f01e9b2600922684b4557a1677d3c2a2d4fc8aabc187b89e6b2e51e3f09b5851dac56a6b87961bec6ab0d11335f14a299b2a0270a94f9c24e0249ef35107e85f3e5497d6881e6777ad3f8d2090aa9544ea8e7a1e7e839c6637d407695e568607ecb5470a54e3756e1373be852a76fd1a0d3b4ee2dc4b14c4bbf67b32f532161d48e0dae569252e0eeb4f1b0c2fc3434b5d333fe933a1b9b63c30348d864b013996cbd0a569109c19e9a23cacc40720f70c362cf6562fa02c73a940e9938bc16f2c156ea0904c779cb472e254a904f6ca37ace1c6b1b64b914256d5bdd7e7b985e2d13f25d08a0ed35bae87cbe8477e69eee4590768a92a83947062b8e040b8d915856f6d7e7e4c2a04db2fbf599b7c8989d2bfec1a9747d2f3411d373e21134ef7b7d15729f97841b53953b81ad635a7aa2dae1d9a7463a142306e83b41929ed58fe4e4cfd726a31d8a8357be6cd1ef8a7688b0334a7f45b1ec6e9d7d5705ab66fc7d71dded4fc4749ccec164e924642ef161a46a45a931d9f2c4f247ccabc78d627784b7fad0afad8312a298b10ff54e7ad1fb8f871c5b8a44593151de8343f0dcd51508c801796bba0e5385ccef8593eafe3515ac50adaef4baadf352b8458c3da78637aa238d7f4661b89d10dabdc990bd103c26779d0b9f5f8ffef23c18bb56bac2244f14ac01072f02e37c2d0d573553c9896520c9cf970ddd34eba2ecc2bd4c312dfdd4e58fc124458ab449a23b89a796b6e5b89a211d16b1e935beabcc00fa8e4853357c9ec712c06ea8824104968cc43423520b9110f06a9c5a82052ee465546091ed3a63af47faac45124575f9b651df1ecfc47e5e43470cbf7ec21c3bdc47e5d75ec4e1428073bb2335714d2d7f98b7c7210fa6e2df48f0dd940f4f7351ac2554b60a566cc4faf617856cd57364689c901261fa1ae2cbacb205105c133d8b64a3088eccd6f147943097536214279140ee66cef1297555410e5bede06cb72c0b568c22ff36d59c88a2d73d6ac46665cee653c0c9aacf345cb5bbb0f87416154d83416290e7fb43463e3d9b0e00017f1619dbaa33f3bf7a06b7622cd8f814aab1ea36bc49d0c44f186e703d9f4aac6d6962aa56f9454dd5a77b3e657fe276be3e63f9dd83c264f3be084508aa3656155bca99c9fd518a65f39dda299a542c3b1f440b8f6bf21e711a94c471c73988ec732b95a268fd19928540df01ac5870c51795abb2d9166c80e58e304c2beb2c53d8792d8af9353cef88f953ed6bf709f8eacc3602cfdf47770325bdffb138d82c19cc12cb9ca152329b027633be6bc435a7c384509a107db4460cc7b4d79b610887d4f3bc80c878e548695675780de3f6676a33c61f1ebc72787a95ecdb1963c884fde7b030005663b45165f66740875ef11678ba6c42d058c80818b17fd9e8d21c45bc26eef7496007b568629c715e88941d8a9a518e66655364fcde0ce31d136df27f13286a3dab5f7168d70ae838f0d5b956096839cbb14f7070c956dc6a5f453121c072d8e73d87114e1c5e8940804a8f46d22c97aa979562157997a5e912a724f9957e47cc24627840823512939f0a6b66cda40016637c3c51903c0f75022dc035de89c773888d4dfeb473c925a32c1b73c596d33fd3bcb06544086c9a0e6cd7c2c51e94f2ffd822fbc6229e1e39961afc89ee550b711fd14f30eaedb8b875d03567fcfdb968110f77f435e91574103a2fd93210c135d24ea6ea92426b0bf4f334cf493a81b925b8e200804c4a3baee625528beadf8a30bf3d24b1e7ecc470d2ecb7f11269e1f80ae60e167f12481333542c105f2e539ab2c247c4e2fdb2e7cdf450d987954a5be1906849ade04b978bf11bc546e847e2261d57b4206b2951c5a4cffec34a62b20fe0719606b3483463f97e8cc706a91732c3aa8836690de841233e09f349e071f9977fa2b5c0d741a8502dd1805e463a8a1f4e948a43cd0daa824bf37a51a21bad2c63f14850e5e8578b95e0c0b98687d8cc4bcba9cf16e5767407e1c96ef36e1703d26839b70079ad3b6c2d96eb4d3a07d8fc2f51ed6fac5960282f88fdf68c5c209b1659eec04ce0d5e89b1c60b30ea0113894c38e6df088433b7333e01cc520fc71c8203118f672613fc13f74979dd44c1885512fe2231361663524a63aafdafbe35225ccf90779038581fc973cfa64bf01259061f70d3b47fe2fff4a105011588a201468ea86e08f8475a7e806b87e71272b25a1194293dfc459a1946b7fdc2119f645b65bb32c7fb8353f897456b8db2fbf91366d3321d19a74db484dd8ef93bb0397337a35d11cc0b57774b4a1b6a86b6ea0c48c342daad8135d6d137a3136a7b336f25e91d708219ca6cd107b678ef79a2315d09ed7544210dba0bf3ebda28137ff43ec2d81c3410f1eebf577357826908be5a805d81172fb6851f941abab42fd5c8792f3319b15dcb3adc5b81721b08a92d9d686e6aef08a631b0dc6b2b67ef087168f8c03fccd728ffa4745386ce1f5d1e77d9f39fc4b7cf3cb8e9220120af427b48dc024fbcf40822f80128ea2de369b1ad467f3fe62894f70ad2eac927b6c92dc3f83ad75c70441bae59b0db6232c8b06a348f4c0c2658da5c8ede8b96f9bc4877d82e0c22b70074774330d30f86863248b484c2e276bb26abcc0d01fb799cf1d79e6968b5ea11a755188e1535b8fec0d7d556f05cd43cced3424ebf67f47cf763670d88359fcc2eeaca0d4e46c4a43a3382233471f3fc1b5c9ef07574cc9dd8f6e275a9ae44fe9b2c2e8c933d1a89cd2eb64f544f5e8db9a7c0119bacc44b1daa90a5414ca2ea4f236381b2aa7ac5f23cd99057f48dd8431b429bd031f5ce7796906105340897b94b51f0ca4158b33cffd4bb1c2ca2a028b5a289a30deb6c613de11361af76bd0707970f7654ecb8c40374889331c07137924fa417d5a6e61eed3d847f1d0d37009b6518ac1b476155526a6e8ccbcc84ab217f1bed9013a3d652d594e1684b3bca466b57821e4122739fae0e379ea4e5857873a7331d575bc4f7b19200ed589b016ce6b353d1d19f9179f333b335f0a7f5f4b6fd0d8952d57937ea9763512e424e161327a5202f4002971995a205d01a077e746939805d4c104f2b93bdbbbf6551919deac08beffde1f02a882ceb58f345fb9aa1b9cd3241646834bdfddec3ab99f3c5c44fc6fa6bcd840645f0133c6cb066ce4bf3071142173f8ec670aa3c22f3eed0a9636ce7b6d183b8531ca83c1cfe418270c4e782980c0334575f380669edcd037ffd5499bdeb86a7ecc561883c752d8a11a30f2477538ced8827242929eb4ce7f04fc0fc74753eac5e269b2b44463708bede04bd331b444e765d1372eb1ada719431aa8690aa4136a310703143414c8c20335ae01b44fff9021813a4e3e41f5cecc5eb942b8174fee3aa19837967f6d31bd71e7fefee8e9bd6b1bdf961bbe204b445325a02dd47955d06c601377141c970510275c17f882a6acd98ba6cc2d462738b517151eaf40f31f8d69dbf5468e5b82e7da54196c9c192f63d107de9e035ce694039feb6672d987f5eea73af77ae72fae954d46c670fb8c1035234579c2e0b41c998b17fe5de45fa23807632a2ac77543bf260bfc9b546dfbd7c1712ab382ff770bd7f05ab7b9299e677211152d9fd6ff949e49b078f7518f7d687f5f1296e52645abfa9becd300571f00f3d1f9c02abc6b5ce2db17ffc723d68baf7eb5b765586ae8d548a24db9142deb70bac7a15fe3623baa53b20d41359c737d40842d0ccfcd77fa2c29844ce24cbed32e525936a14e58835ba5e4c2dccb0d073fd29e489cc09fe25bbddec699b8a05438fadb81a2ec098494d85d4572a1b4a3e275bcb9e60f18a6b9d107c1cd96022aeb7f36e3a518d08fe1c0b6e845e5df5f8f772d1f4038b21d4b942a55e6d01b9054278cae97006e395fff4d0a40ae789b0e120c0c21efa8edc7a29582608244f1d76a48b79eb78a9309b1c8557b268741475def6f60b10c8f2e8f55762b52b741c1c19746507a105a269e8930779b87e8584140207bf2595a64267ab5b1200ee74ab3cc2a3c128a578a2e79c38bb51740ca6c4033b94cf24d089d9068955edc8198b2660339350ddaf4d23d3678381ffa025ed41ef0cf5af43bdee97546a09ff3b20c123e1ffa79c6b86106c7c8ac2d74221c4c55039e2eaa05402add3f5c8b7c3cf3fb16f0346e9096ae22825eb67f9153e812ae71cd48158979a4bdf8452c03d379adeaaa7b26b471ec83c4bf636cb1e98e9f9bd4c58a8dccc805465484d03343606ffc8766cc081067dcebc6f32b34b6712a2afc2c4ea527dc45b9561a9877877a13ed287bf8222913a5ab923d60d2473ac0bd3ea20dc30ec19b1ab26e3d06cdaad61a8262198bbefa724dafc2e58b6dd73a1d6e511dde967965c475676a86d015b3de6624c780976062e8892224829b5837c1da37092d5b65f25bca10bf5910372119607b1a85e535f7db06cc4b1498cea52a1f5383a87802b4e5741c65f9a1c85002d59bb6493fd10652ab3faebd466e8f9ae6336f21442ae7f4d48a53549cee321ec19388d76a409a7e703aa5fabd4b14149accefc8d489624b19faa7a8f623913d1ed139084ffc64c3655ec620a78c5cd1aab9aea0503c19d30a739596945e82192046274104a3d2f3598d62f5d0ae8e585e5d1e881ece0b0e3d905663f15fae48a51bed839838981f791d44735f62014fe47072f5858bcaafbec428368b827ca811a23780e89dd1d5823290df3fed2886efadcb18d846f073678e7659f6c000514fc9e76a0a4d4c81f9af975b4ed786c6ad6ae69b6795bb27b78f55579300efa452d5ff16a845e5a6cb0503d6ba87e3ca08da9aa713582e7e79e9a9a4c9c2c401848a4d532374bb69eb667ed1fc06f2c034e40639b37735a78daf675a00cce02af727cd1937486c2e520716edc9ba18373938d93e60bc3fa8d4112aa819590c094b5a454a1d65b55589bc436a152273195e4863a5f6c8d87cf99f67cce354081bdec3abf813a57bc58add729484ea578cc59a12b87ac054d798e18a7a9d2a9415f0172e1dac03dc066c8a60491c5c949fa958fe99965f0857ca59cd1c792d1c5cb29fea4a8c9acf54e1e33894d2daeb1b34864c756b17e2aa5935dbdc7665ceef529933c9b87041825130d23729854aefc2716263555e321ef2e597e7f2501f842fb8a8250a644b8db09c72bb3dc2f1aea5072d10d372876072ac6fc2bef6f7318429fc961798171610e5a1cd6ced6036adc38dc0d6bee8d5c7c688a57d2b43599e9429cf6d4937303532c7686945d1df168cc35353a736f837f38a9c7b7df288c656a1337d9e889943d64f65129b4a71e997a03f413ca0ffca08db4bc713df13315d0dca8e928a509ed85d5109dd0e0fd2b25b8e0a85e6aeb00a69231738a3a344f99954aa98722d91884548a26566347d6d512daf3cbffc691244d992e5947c63fa38212fdf372877d9340bc59454a504ed15d3eda598744e3859eb74da8941bf67ba0542f0db91c363922a8bf120b5227ce7ee45b84a43fa7f70884c9797da889f7863cef5de8716bc3c7c4cb13bb36ebaf079fb3e40e6aa925ed509050ca6194931b5ea67ddc79d34d1e47f4a28ca52a1deaf0483b9477dfacba8620c1e2b8ffcc1b624bb031ef7976ac31be44230d996ae65937c7ae4011c72499de5b6b67dc4936dc1f00b73a3941a4b3e8c0ed681bfbc4ffc0c92305d4db16b6524c8d7984c1b693c86bee53f0cd0a24f5ea610d10c3e1e5b95db3087b0e69114bbc8140e37577b0cbf5f28ca6e864e79f5e5bdb82f702857db35a2881b6916fca2bfd64eefa2e753ea76ce95d6b7128ae494f6d2ec0ff4df3409ce23f9a9782af220573c373fb3459793b7b390292622f8d54215e298e06d9672855091a299ea381e02b439326146eb3d76121eb15a091e5c02498b1d1a912a7969352e6ce9a8e650796b3044382aaf24859ffd1b7c6d23fca99e92f5c4c621087db3d8cadae02304cb0e00fa24e32a172c1ba72254255c1b56f61ab565d90cf6877e9a65bd07b1d3d81dec0c694e1055e892f8a6a643b4dd1b2d6e378e892c88a5fc4acc14563548cd58a9ee6594f45c20d7013a0be25f6cc4c6075b14598bc301e093746555f8e6bd8b2e8a6b7d03a806db118401c3eefb4e35df40be6f11e63630f384b26de277aa82527fc6c246867d1ebbeefd96e42cfa951be5f9824b78e70e1f3ff22cb023432eb2a19bccc206e26fd7ccf3bf94d634ee4017f9108b33a84e02455f427e94894f6f0ab8a873a465324f4a38dcf91629bf7619e5e1eafd98f3f1e0e0d4c76aac61d3c92d50905b4f3f2e88ea3aa7b8b29d6aba05cdbeb65a5807ece66f120907e78225cc7301ce271871db7d923189b893e1213508194838d2e78a6c8fb9cab9c4cd2516a157a58420aeb22745f248231c628f315845d09eb80271513b0ab7b0acba5091a2302ad2aa1d33ed89d5abe5de4a5bc848768e788ff886769ec67217038914def04c41100126465847c1e81fb41ba61636b918d2624eef1253c96356db72378fd013d81f8122d5627923df77d8d9a34646e149bc8fce32491cd1aa3f5560753dae677ec9fbf7225d6d1baf66e2ef4c33425dddd9035834ace404c22df00172c24f2fb69e773e10adcab8161f5e4217d4adc03e3a1ca9c0637921d6312062ba5588e3a153156c099ff1d8b4af86b70b9b3780ad6317ba7ace6dc7b8678599f4425611c76c6232f349a22a6ec27dec8af3a6dc0ceb8eb68efaa481521df478a2ae449a954b67ae474229266eb092680541a50e7f1066fa8b5aae389cb0f1368aeb0f6f25f8f069fbdca34c5b55f39f0cd1dec4102ff59eca8b52ca469f16df3d33dc081c79951f7a7e0ce37ca6e1dc7d39a343ce77f619a3f1b9c8b92829b4bda1a17ae5af1103d4a8c791ffbd28a99fbb9303d886ffda7d2e5f000797fda5daf1075a326507acb98346012b6578fd0000ea7062c092eb4644102fe669ef76f11279c9903ce41c968a217307340bcf9d1547fe6789f0d76a563c7bb35e8580bcdb11b05965b461f84e06f51d4af6a933b97ff3b149927e8795558f2ad42388f68712850b8add15351b6f330ed0e59518df041e9d38adc6ebd0233a347e19c70ede37d55ec9cb0a7f08dbce1c875002831634510a6a35d2064389134cb8ea3b4bd840fbd3450bd8063c0ad9309e774f6c8300161585288e0eca87597e15f5f21f8c209122c162e7a8c873f47adf8c5ff5c5047538a2213aa1c55f59617af369e75f5a3e68edf74a44fc4cca5fc15262ffcc26aa74b7a68a4f28bce5f4603b5770e124f25c917a6d1c0ac64690c729f0a772dc1ca8892196fa4a3b2461960b29d221d93dc0745a84428d7490a64467553c061b88b3bd13640f397c01a9cd27b059b9f775867cf68dabae9a55afd906a9c04e04c41f7d48357601d69cf82b59264313f06f59d4a6aadfe7f6eacf967e40533cacbd621a2a787e2fa89ce93ee5272abb912715cdc1d18dca109ba0a2a5cb802b3e0c8460fb491b4baabd7801d33d3d78b212f4f20eda8ed6e88d89f3ba191c58cdcf845dcdb5399cdf1534e3a1a965ba91da5430c3910792be39867396cd76c59073e5993a70610f27e6e258c380820bf7501593553987c7d43b4b7b736d87bf87d821eeabd5c6aff4ff9378ae600ec1383af2cabfbb8cfc2128a72e6af4bfb8e2a7b95f533367ca887d6e4be4dfe66d614909d87b825477bacf985799358d75f3d31e2ab476ec0777096d3d07850399bcb1e6736b624125b769d9f9ecdb5e83904172e2e92823794b9d76a7345e47f5bd3432c432decb3c67054910aeb83cf5ade86e6c40784e404268f544bc67ab6b815fbeb6d0ccb12f0a058e3ed8112fec39eceafd2427b9de892905efb8487b9b27ed99cdbf9c1af62ccd1630b83124c05d8a91e43a0a49ab678c74a60801e831d8b9d706e283484c099579f81a4f248c7af190da79a1935f3a91a860edac9b3527d22b8e94a0cb84bf826052efa6cb1292b9e03b6067f3d39aa32c3c8e1039a7990b6f83da706fa038abde734a2346d6a29e7496d5ed50ba6537b0ef1689bbe0d1eea61aac8997cc7bb8d8070751cb5f9a6212321fd2799f631c3724b27b70b5ec475ac96dc391dae5c23ab656c3c5ec65fef6ac8cad66b88ec4a8e777fe8b6ea7c1f9adf1352beeeaf42484b48161c539abe8b6e8d681d63c527d40b038720b3882788712febcbbd5fcd56291531d802ac1b037c7e2d7d943511e4abc24343a4541694c9c564e9bdf13f76fd704d3fd749e30f73ad4f53478c51bc047cd68ac5e9a2176dc3c396d0f323e73e36455a9426ae336a55ca4561a32ac7f35e49f0088dbaf0a7fc5bedb062e362e67fc3f802d0278db2895ca742ff40d2d6a382649d8d38a861dbab71f3b3887171f32fbc5e2723af7809aeadd007fd720025b4744dddd6ff3c254bb37185db79c37a0361f31d4c2f0e59ef8e87030fbc2e3b7d82daabc0844e36c003c1088a1e8ab8ca11506e5285b63d0c2a7ced7cbfc359effcced60003f15afe4022e9db5fe4a9504786265edc0bdfa3849ee2ded42caae77bd3e79e28530fbaefe1be5e344c1cde89063308ac088d3d5ffaad03926c4d6446907ef4eedd4cc9797285b615234d40c102a1467a131042897551913c14ed548dc3e5f16f4d55e49680eee0ca3bae2f0c7919b7c62081c65440fbae6088e4ca7d45dd9f2248055d5a9b26098b4eb398452a66c20fda0b1c7d510c571ab6692ccb918a393d7386326eb6e0272d9daad3a6918ba852eb872f01508094348cce1a842af15e8ed94cc0ebfee66aeedbb0cd381593d314c915d6c0fc35168e95ef311abed78336e1385ef138e5943c147aeb4593215e9d415eb38fe443d754a6f12635048d5df5f9389edc327f8dad4250233d620a7f685cf556e754c86bdb7ab7df26648d619dfe5f926d39e079bffec4842c63cc8a62c67958de67a84fa44e6485766f0053bf9ca2f6eb41767e1377a61c9f16fe357f7bb3863abd2e65ef17e27d54f0c2ad98745b5694ddb950c8d986bb340ffd0b845d94f60fceb339205c14b4e9703652638a96d20f7b6648fdb2fa0c61327924d153710cf3c1274de11fa2e3e14470dbba943b748a546bfc49041ea025c738d399732f62afeb632b9821ccaec2c02b5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
