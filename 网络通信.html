<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9f70473d705737be6285b0cf61dbe04b36169913ccab0dac13c6ce482178dfc64e57670e776004ea66a20fecdc69c2f5ad0ea706ea8bf64eb3a81e5e7a0915b63958aca84425ffa018e94dcafcd386c9f3cb2e5c226656267dd8798033f4e28dcfd32208e3671491afe2d4bf28f837524f0401ca99db1b4dd28e77c8569c537e8eea80ca9d7699e812b1441f1a53ffb87f1d92bd63858d827287402bcb18e5035b69c03c06e23d77b2402270d1236b13dfe96c3ee5d320b05f736201c644a5f1a314c265ab25cc0feb003782ace90eafeeb7aa96498c2d41e2339f1579eb4bc2b3b07a334223f5be828c926270339404747e80d30071e60dcbc293389f28f27220d2e6f7804eb54131b44778c16380e71fe6866e5404deeac630448814855332f5734d4a8308ddf322c43ce8855f946ef7434fc2d35342847d569da118df62da6fc4cf45324d882ff3603793943bac0b9ab7af8fa43a5682dfcf2aa0ee1b082355da1cd575c37736c2c8eeeba1b94fefa2d54baf437d3034655ac6ac92996b887de3aabb0b1060d5dfd8f6a6533b99537dafc681b4581553290323f49dea6ad0db7d9047200e450be01e65f365d23c31603681e91bd282fa439649f4c91e3e9dd3d4dda1757851a04bddc745941de9262572ca4c7c5b4de7c8686f4317449208c04b924ce76ff13483cfe33010d47ec8aba5989acdf905e4d9466ed4ef57766e8709c11e0ad1f9d2368dd8eb237cd1b7de42d112ce8d6068dbf414329cb2878fecfe9ad2ff94be15ad591e5c2e92fe80b3fcf5ead6b3a458c51c7f0e17a14bd4fa00eb8ac5b819dbd663f70977611088878ef4edcb24b2295016915ce20e45aa2f472d00c5c312c1d1bba377ecac48e7973637895c555bb78e12cf491c56fe5a46d57d24a13fff84c5c5b574f9aa40b481c2c9ef6ed5a4ee5a289e15b0ffeb0dbd8b63eb5503523fa542bab174a101c3994b89621f7ae45870d79462d364939b3b017ae818e506431641705afafaa264f779bbeb774beb002f081e5379968117d5f628335c7f84cdc8d795bc6fcfeaf6087537eb4bc78308f022fa23a6c4b835654a07b36f467dea8ed6d9d946275fe5deb10e577b8cc46c3d0762ff4748b2342dd9f94b29698ec86893a239172f38ed50ce1b3e807550b3e90978f88dcbb41abb697f81dfa00748044d715a75a1f17f24003bb0659e23f175a05ada9fd7b212a861ed3833e8bdc93bb025dc43799dad545362d89d57fa479e1984ea57d77b8a3f1bdab2f1051de8a9e67e6d28f03814911671b678adccd3e83cd36d66897c967d3e8294337fc4b1ab1896997905f195b06f4a5ea8d8e870eb452173c16526f1d41d3269463d536a5ec4c3e111a6d38882474bfee9e857561a9e7c9640224e5b84152adc86d955c2c8034935c944fc802c557a9385f53e243a335baff05e6dcff62be12f1e0b94cb70e00f277ed903f134738dc6a970dba8a3d09dede21a1ad1675bbc15a733fff8f678275ab5fb5e9520ae895475875df3bab6ace15309589635a343470f855186ad959796d39b61a883c6ba9e7c2758565595596e07400ef3371953e4ec88aa6e7c9a4da985fa85765e1e183cd862050c6d2a9691d9355c1d1a389518ec32e1c1cc73faceae2879c50ee7f319bcb327b8d0f382592ee81a0f7790e7c601664e53f3b8cb96390fbdd680b017d379cc41e652317ee39dcdbc21ef24914f2fc219313a3a21c615bdf02b17a0fa2c3409e151df228152e1638bb3103f2fbf98a22ffb884fae481136743f28a6e0dd3f66337861567b58ac5b0bd5519b5af821629fa2a011aa8c4d1f7eb42f3679267a5115403c7b7dc35898121a1adb165667c08be250fcc473925d7c511bd9cd064bfa0353c632661afabe633e5470f2f3455662597152407f9341f943755490dbcc076f367cef8fdb60263e5936eda16f0acd690549236d38ce744ec8f54f128e525da20fde1bab03de874c88bef08a35b064fd1f4aee4ff694e22da13b67616a7e02f77a026482352c0a3ba07db466d6846fa42d552381c142f6e9276754474f05d6ef577d005295f853c2996c95edf238f7baffd1c8215bd0180352a6be1adf129a2dbaf57405363a41044264803ce5a79ddca93b08b78a760ea7026ba21b0b358ef793b34b703526d3391c3e8b07bdecd5923f2ecc739ad5ecdeb7a3ea68b0ba833b72820770c5953e3be64cdd844fa03b1c4c269a9180366b3f18dc38601c795a1a04170e503e430a6345616aa3300e8807f9e58d02e3d22d02203cb66ff887b614a2907de5aa241d04c37151014b118d99a5159c7552ded03da289531d0ca6464640caf54f309d99efb995e6a0ef8bd825ad43a2f2a65a5226c5761adb9fde43c7c9571618c06a33e4dd38d84aadbfc3b557a534de38b83f6bd2f20793e387019f45306b554d7341a9a722ffc3a8125a7dc1ae871d5918728c56b6e2c23ddd417a9ae3c2fc974160135340a3aef612eb86fd60a657e0094c4e531a8768530a3cbc47d0c0e340e8a2c3b611ba26d5298804da64938d996a5bc4decf4dbb72fc92219dca45b2019a44c421548e9f85197c2e5e727b035533011010c54ec996789d8f8f4b9945d3af61b4734365e79dd0f4c4c16f9de6eec8656bc1e29b78a5109476a608ebc5483dbbd81026893b9960f79eb15c3249b8dc27030629af34914ca0ad025db3a4a5bc745c1202fa9605ef5bb542d8a7a5ac75ca7acc1a8a2349de363155a66a71c9ff5d9c0e79bcbb1187c1bc19c5dfbac32748fa5d0bea2050b6e774e8304f9dc83ff7af3f78b1688a7ff71b1ab1f74a0c9e11940b3559fda84c7794036d83292e120fc6d04a1080cb89fb2b59aec4445fc4e1678ae849b1b8d90e2e2e01a3886009c3facf504b4ade76d6d6f61dd0fa542828ce45174a04cf9244e2572d0b1d9a886960bcb06f8bb5db9fdaef3da829ebb106ea213320bff1ff6b18d3d8907252e140312022d65f84ca55bada3cd293bc5579966741dda662c8282834370ac4ad7e53e07e8bd537bd2cd91974a3c97282a76c0c8f02291d44d2317216920d9ac519e692e80c2e4a8bb79691f055d4d499d608ba75890fa0ade03b4c4a2b1074050f724de854dff9d237991427781d0b02c969bcd538069582d6d1f93525dd1d4b05dd8d9e7b29913c7c081da0d991f43d1a6b93334b2084435f5e29e6d3a0312a23bea454f8eec22d002ee084b5f3a401b7aa8b99961f94a9a4026f184a042a91777ad3db0c4e3ef071d684203dd76f2792e910d2246232f80002c855ec0c966639a42f05337c6de4572013094d987d2902cacdd2def21c7740fde1efc164d0d5004581ec20f0e488695cf26ab4246c7e12c2c7393eb82abb721d4ce052cc8b8bf6e01d6ae50e534ddae8b930be3443ea915d306a9ff149c42b612e79cd3813ee751bcdceade245c55603eeb7487df6c895086b9b5129cf69120d5308f2041f1776692488c52b8f50c08e68caa9aa807db7e72b7980942583f75466ad9ad43179fcfaa5345fcd412adfe04d833f7d767a1dbadf54efb7f91515f8de89439fb408e893ee593a11fdd75f17e39f7ca46b4130a49b630c41d1f261148a2edc9fd3a8c8c0a5260430861f258804adde71fc801f8e4d9c570cb9664337952c88311b87ae1c66e4141edd6a109135a270a211d43d1d8b6af5ae4e2c439a8199e5f6dd4e57e4d00c1506d13dcf0e542d2894d4029ef74ee9adf64d4ec353e6b90c7b9021b03dae54c651def06be53a6b7efbf2419c934954ce3f2684cdd58a3086d5095c4ddbe46678513ae52784a83711dc761b9a587203b0e5fe856282a25d5bcd89c70aca2b6c51c52d9c6c044d53a6b4aad958f66b1de234d188cd77bba8d696a9cbe4b9c9b5b8d81a2399ca9b6d90b166d4f4fb48f518c1070dca03a3890f5ffe75bab3d3ebc66e8b42c7da8bc843b9481321c9202511cca71973eeb60962c448c97784eaf15377726e6a8b16235a84661d20dbeb6098972692fc5075a9399de7c1f2e98646c1c96341b0591a10c6b229e09d8bdd7cffdda2a9563cf3b6f98505dfba0515c331040292606bc19d44ddbaa2e25036188424c4ee566a05cca0f47270a605da1909d1b249207370790b2a1501dfbd9f1bd122c30076dfea8cf66be8f4ca114803bcd67000e9acc174ec4d5eecb6cbb475871d5588b20af9c320149ab1d5e16e86ab0a17136ee9cedcd5b763bbe6805aba9d5c9fe11d61cc353eb423e7f40c54d6825470ab48ed1ebe1380ac04ac064db5883ac611b1c351684e12b130d4f92e4d56845cd12915f839e06fccefbb1da59d868a9187cae28cb46924e6e8d5a0179fb069497dfe4f34fbcc134d6b225c0821126378645beaa33d3dbdf15f4a3c3d48e3060e2455542d8eed5f2f28e8a4cd419f22a915c75b5730ec4253157147cf4730750a5f6806b6ec09e520092dd2b720ca58ba787f4115ef1ad216b694725df2942b1e32c760428ebfadf75e918d74ea723fc32e1d0c9f2f7ef51163acaff61545dec378ced104bf0f6c850c13574175f41f7ff5fca9c6675475527fe5d54ea9e8723d9e8c6ddd350c97df47e102294354e569331adf542ead0d4ee5db2ccc4b178b154cfd11517829e9a63e05e0d91b013da1845d46cd2c6f3f8626001efdbb4b682c9716dba9770e13aad14e16b85fa8b3932b815a72a8cba6f5f0cd1ed1db1660f8660dd3034623d57df647349b92b2c63bc102b564f6028e91fc9edf8778742533c075605bc5d56e1ab0e368f8f83b0da8774c4e636d2989bd30805c56b94ebd037ca9987aa95b483f964dae270655b6ef74ad94ea48ea8e9a72a16e817790002cb6fcaa0eca5cd9bfd95405fdf1aca5f423346984351ea8f88f01e9f19acacf495af0e719ee7cd70a78b771431a33eaf49dcca615a763f01c9b175ac48fe6e28dc98e89d02b1386d7309157c7cbed6b72a92fb9b2894123a3163890ae277a3b65d8d6d7b6d0c3e7efeee53e08ea0d52d69aebc201ba7a20c20b9d8ed1950b8776db3fc1473091dc0ecefe3da0a15e1925f7b0bce6e3f5da551c08d40a3c7096c97e89b9019801564f28711d70caefc498238a615b5bc2f1bfef77e585a694c91d54e9e3da6a08e6fc67436376775f404d2e081fef651bcd2610d6dce3a4982819e2c2ac6a9f7c324d2ffaa000d8e980fd798f4dd7c319a479677d7f54c4bef36550ae4caea37deda736a20f945fb3b826e780c4207175c69f36cd81c6d57fbe3f132bed67527e461e2e0e22fb3c3bf68d7cfc5b2e2062786865aea002d0167d7e68d7e59f3a2a322fc700709bb269c084418f8ebbc330fce963e0ff878c2478a86fc72faf475e6fafd7eefd42b1e9cd913dda543dc38b0e903fc080260143f72880f9b8c0e1b47e7a013fa1fa6d35ec42b5536d5da600ea4062f96fb5f9f35dd779d776438460416488ec58344411950754d9b157a108c9e41ae13391968a3398895c9f3da38f01c75fbe94b3dcf5d35f55fd8afba6c293eb66ba4b507d444c81127542188abaaeb6564261e23a67633f8557a44f9c0870407d94599bfec20c7a09c4889483eb11df3b0e8231e96252fc2b28b8800372aaa8c4ae1ad77fc948db757a6639c3323afe0a81224df59287a86ca15ff584986531fd413595f7c3522c4af262e73ea355ec623dd7e870a687ec901e9b41d28a3554d4208c1ef28913956faca6fdd2a69725b29fb3d01b8c287aafea3e95099cb2e19e0bd9852b453eff88eec91c2cd9105534823ffbee933eeb64e17273df04421cc3c04a6e673911af320f86d92da3ed1e63dfd7b7c0bfa0aef86e60b8b27d0650b06223626e4f90e87b49d7a99499921e930693721a10c50f7df52d65b578e51b411c9c38bcdb1cbdc1dedc795af3fcc13e51ea0613adf5f952ba14e2adeaf10462d1cf09a6fad50bd1211c6afdefb079ba4fee1eb91a34a6e1e227a495c21750a34836c62758dbd73cffb811e107b63ee3bb9a0a43f4b90ea56d3ca18a4b1f0ec2a3f5650efd66f7acad0e145ae32ebce2bc6f59935feab01a8f9c94314d1c05fbad34b142514f65d10aa2664e749bc0adb767cb177a4d69f355ab29c7aee66f4db46b193776a63c4740e1d91512aa7a4cd783b336220033296e1faf7d7b41993133cd30c519f2762330716a85f87e39e916ad55dc279c132e882b0a5e22a9a49ff515670355dea6e9a3886432e19968139780eb756efd417910ab76a21f4ec8a8ea3ad8c85b3db2e94bba1b06a571cb25baf51a2fefb9a063e0873adb22bcdcbb1b7a24432ffe05eab8fb1ec490c43bde5c41e5ebeccfc5ea145854340f327f8054636d2afd2edfad5e4bb7a86c6a322c7160552a669e6324bf042958456be2538f8d9cfeecf5d04029d19f12740a4e78a8e19b8f260ce12baa5d1d6d2e070c38bc214b82eced420010b8d1fc4c399c73b7d3f36603d0ad373b94dafa67024b5861baf0880f5e3c7728f634bcfbdf957bcc1069e1f1a1fb9b1f02f517d54c4f7663d8da7f3d4c87b3058acd56195763bcb61c0b79d0afad48f1b47ac05e7a4ac2b8fe7101ab72bd3e757f450728e4469d8fe518ca009cb4980828445b857d36d9421dc17e9e0bb955a106448f274aa8e1a0d540040860018ad4b78a27f51dbafcec52b20b3071f46624d437e99aed963a10068763600191f32308149f6014584873ca9f9fa69170fbe079e709bb1bcc15e49af49a5a16ff156f5591059c8a7259b661357cd86956f1f6be73a6e890dbde21bacaba5b4c2844f9732f283446cc1da700eb82864e7ba849086cbe9203bb1be9f2efa16d2aa650718b5e251eb82b86caea05cfc0536216e9f222b27bf56d810daa5fe3134fa6cf511ee342c4d27fd06769266d3fa3c24d1e172eb20ba9423b6fcda8f0a3b36cb5b40505d4a8f4f460db567fab3d755cf610eec095ae2f646f0f5375e4a0e3e05c0f906ee7bae555d14e5cd986df15707bbb2bad5074c6391383f82ca55c9bb096c9c567b99eaddaad9a3af4b8794c549dcb7e1c378359ee1e2e3dce4995ee500824d5cbb08dae4565eee9b931dc23fba0072d6b87f8fcd7063a117659e1863479e80305f09cabf0a2a0e9e41fff6f924aade27e27adeb6e2a7c5b57fa01b4d04a71b1c34bc99976f01c139c2905dacec17609c15f82be3978146dfa69f17c0e82e351662891455620c4e9be1feb69f7556998a947d99de1cd12710d6daf8ac3d78e4968c9f5bc8cda343a9cb0ff35203cb237b1e914ed3bc7e8a4064e1952202f8e49b87aa868447fa6ca58b8bc3132f752732280b85e0c69221c86c01d48b45ae161ba6c60848fa36d06fcf23862334c25525c8e95fbacd37f92653730eccffbddf6e041f6190d7f4e69fbf48f3aa9331042957fdde0b1e9118f2355669ce04b6b448762d42bf41593685736876e6169506ee3d6cfc8453f68e7cd2ddacf0d6babfa5deb3a74580a2a14859c5f6ee14f60d0b40ce504bb748154f381542082f2b50241035d1d06beb9e1e4c866d9c2fdc263667fca28be0737e7d5c4e8a142c3a4818686ec795737f60cba87f21360cb525aa1c5d7ed99247517051f962a51af6d08b6b3e777d635ccb82742df6fc4616b5cb93e8dd6f6f169a04cb469b3c34b4688f4040de304cb40dac77ed63fbbe3298582bef41724d7347b7d9b392407f55a5de439c1c8cf0fbd8d7caa2541e17f3b6ba164ade543cc9837c2f721999ea54c8093af52746b165599d96a80da5a9fdcdf3329264ac7bf5562b85810dbfe203fd54a06b3e2cb9b4acb5b5f40ed0f79845f1088b972604af89aa5ac54e53be51a05e5800dd7347883448d4336b86eb621b6c6e80e94a5a2106f926e787dad03eabb1f19dd1efe2db81819e2b703aa328993e31be48f3b125fd443f5cdae67bb9dedbc1b4840528fcaf6bcf50ecc72714662fb5cc6cc9fd3a4db5a1f55910c83f039bd80eea23a480e694705e138e711dd2c9f508f9bf317aa1f2b2cd900de0a872359a741d04b4b3dff6816f278e21bd28ca612a98be94ee982190407ee66ac5f7e81032d5cdf8a8415c75e9366fe3ff83d3faf143068c83953b4673ee5e6e9184b82effb3fd202e4dabef19de32ec4f6d5d59a68b80a7dc971d3bb3e8fa6027756ef7acdaf0f895bc2104bb7fad0b185f5a437a5438db59232ee287dcfa359c3de40f8006370b6a5ac45e66cd531225a3a87eb2d4a5edec84b39b05bdd15bca358f164865579db8fc31f8db8fd5575287fcb5a610730622e9e704cd73cf0fec9fab90e2e381e104ee8ecc86ade9cc03a8ef4eea71f260d6610dca943ecf656be8e2fd915d8b330acacf5c922b83ada6c0eb2fddc204218c115df3a7b32486a09ac0ec6449d692e53bc60c469e470f26b3ab85badf72fc30a2ca204005d9f5d99ccfaee3ab1609669cef277c461d443a0c171f6e3627983d543c23900338f10fdbcf96d4de3d58ec7cbdc71044747f562fe0b978ddc62241e337fa85c42fa73cea9d68137b7c15b2993d05a2aca71e732ba2b5cf153719f78ed20b924a1dd0602b7040450aeffc518aca9b8e3a45137cc9e105fa2b48c9674a0d5704b47211063f1669ead8422203a73dce9d595dbdfea57e4aa4cee65cfb2ba6f8910c1c47e83415c346ad7d2751e05339c74af542750ac31916213ca909cbf9fbdc50715622485b809b038174917803532e63e38f65688efaf2e92cc9237853eaae13ab0f8df4d77906cc7ffc9d0ec3b6aee9737158b1dc42bef20a3b05b4e2065a195aedd8523f1c8e4862b2cd7d9933852dd7717aa601243e99efea10ea6548f5398c8fe2398e3133c10b9942112808dfe62f500aefcb124f88fba0f8ae875a3939c45f112c0237715be4f4ee05406347e4aa2b377f1279f08d3b0b066d49d35dd066b20d868f8eef7d5527b81979182e0a4122553f806dd60915f64867bc331e85f41719073d92d896e51ab0cf5708c0931d05bc32b65702d5ba1bcd124f08b8b6602a85bd6a27b0e86986ff1dd336c1b665a9ae1e4d09f4baddd73170775e545ece4e1347a7976ec67949ebfe67ca2905a998fbe0f9d658e806ba92b2b3b72502a5fdfb6a578d2aa8f840a5dcbc93208466e40036963006b0d8ebff0cc5e3a1c16301c00348edbe75ee9cc541884b211c74f02f0351d5967d9e389e0162ca2458ac1ba47da931a212241da8b0f302564a0952c9e068ef41403317e6d481c6bc0442dc0f44dbe316e22322bfb6683880bc84efda99a5bad079a6922d66b35dc9a6a05377818f0e133dde1ae7a000215b76f1db3e62f3def715e763708549a7db1a380e32279af4330e5377e944c961e5750a396276ba682cec98e2faf6b76f827542b024ff9d958c28acb0162e3bb8f2811eaaab0949d27aa70a9d7fd7c6a2d72ffee5055105a1793cdb8a25ed5043efc528de89937e11e0d7ef66535a77da304d1d462fa11ad29c21009ae3e8ad57218d8d5334fe83905b26a7ba3cbf5e93e661f76f16063ae7cf863640964e2c21d715efcc433c2d55d8d0fbfff73474cca67c689c553192832c9892a473563b61402f9006d53cf80cbe8aec61209bcb867326e7278ddfb67ad53a395cf6c0b82084b0e18c3d704fd21400349f08f27f368b46ec04567a854d1cdce2014fc63a24a8f822b4fc850781681491cec8027426a1ee699c7f6466a3886b3896b0419ff7037e15fc009daa5f8a917f0ea69228647382cd173b21d131634626fe5ef1a88eb6f7cb1bb700b26f8dc14a95f9b574ba75833114de79599abe798e3ba0a1017ca643d95d8594b66ada895081984a2805693c88b62d8e744dfcd66eacf33f6879e1d50b6d2f37c2925994d292815f2b6d6ae313cce37a10f4784b7553d525ac8739942fe032bfa725a992ce2ac46d92a191f85910a59f8f88c5b759c3570a53d044e200672d63071df7512ec4d9e86be1080dee0d460e87cfd0529008490d1e9861fa9ec7219a01ee9ceda0b3a2547ef434ab1bafcb3cb9cb3666334dc476613b7cd3de2cb7c3f6d078736d2517db889b53b7152bbbdfa68ac23fef0c3176412056409fc33c694a87d5f06b9d10df5988902ff429be8a66d82c8d1171e5b38763ed5c4a18ca648bd87c644aba159fb5191c79d6877fa6e364d78bc7d1398f6e93c3bf294bf185cbe318dd2d9e955c79cbcc0f18d0711d6c7de6882f4a81ca36974101d3d32794428493345752d842ac96c155f9ef4804b56339ac0a61de6e328579dd083da9a03cd5bf78c5652b89bc44aeb8802b248becc74507465230ea5ab41c7ab2ee9b292553579e5ce2a1d1aa3b5e43c796ce8a695a2b20bab48890b6f533cb64f58f2f5c7975f79b703fb174bff26ae0db76c436f52f019f5cd48c6cdd28839fafdce1534e74fa675dd993592fa39d1958343f3384bec9819fb9e6a5f4d61ec9f8aec5ea48219cc2c53ec84ce4c311417fc030d41898abe253b33e660152624958af73537a0b76dca6897b77ce90f023dfac8f26191fc2f968e8bf77a7f8fc2c8e720d9e9301caeb237b65265452dc603d06eba93220836713c37a2dfe84010447de243596d139ef1787a28f317819b88648dce0272854e550b0937d13d9b395acc4a256a141ba123b37c3f0cba37f68c95ceb011c63933d4728c2db4487fc7786dbdbf4ee46d4eb181a89d2df3434d37c38a24126fb5b03470452ac2dcc8ab08cfc2249ebb1e622c1dd93fdc50b224ffc704cb86dc0409408630c1584f244de609ea888c101510335e5a99905743d08455d042aa3d256307b19678f0de722d9713b601987177ac0df38067bfecb4643c0cd3564d95547bed69017a90bc0a263b0bf376e7f3ba73993d710f69645cfb38ed7959205ef7af86d0aad4595e259a88e359196f2fde793d4d5cf214d829d6c2adcefa505325c53d1b6ae4b60426304c1361dbcb8ad9d5fc85705d6e3c2b6df141b0bd66324d9770786eeff4baf58b8a417c21840995bb470759876923fae5c8fbfa01946caba02945b5b95e6176a1d2eb617cd3f9f5302b83adfd3c1c2e5d6e68bbc6a8bde9d1aa65e14dfa5acb2ac71564675d2e20cc633a35c1a118bbbb9414bd1e02e73fced557a0292149d3e130f5b31f3189fe75d353841cf6368f2f6bf91ec34ab1e0b8ab68b12d4c7acd7f9f9bb0e8f42a77136b9d544df66120d6083ddd6dca970d9a951b99386e009afb3c27824a35e2c33db21b6b202bcb4dd87327f6e732c2c7dff3b32f9ba509b9145a5e9b77b186bd12de6e0b13e3057fa47bb2c79bfe2769e5eadba060b70e5f9d884435ac594feb8b617320e2c66c48da7d5b1d36c92f20de619383593e97f1b5a0ee1c6a4cf060dcf7c14f14ec6d60ebd462035c15ecf9be191770500f3bf4b5bd7247c17ee040509df2a6459df258d931faf86bb66bd4dc0feb02df73d24c3890f5ca04164dcc2fb34442589189cd87f9f14fdfd5a5736316b9c54a2f077835b04c154942409d9f157a42ff46c4b7346050208cf1c4b810e09cad2375064b16725c0557d53e430f371e13f3cf47f5becb2314471b2d18c5514152e33d442bde218ebe7570dd69dde3915c12e14e62cbaef4759b5a497f1d08f320a46b3b4332419cdc30efbbf9b52ada630780461c84dcf196ead3aa10fecbc2a2b9fbe7fe1e99aac0310c18bcae38b25493757c471e15f2e4d33d9182306332539df50fdb78a2eba2fc0a1fa5d2301b0418831704aaa7ba8f50c55e305f16f276da74bccba887a936d02bf74e8a4349637410eb43941884b5e62fcff0a7ae36ecd9f94b7b5538441cddb699fee03229440921eb37939b5cb5c15a7747c1005ae2aad5fc6abb76abd3df83b6ab4d17b5dafe886eb898d1fc36ff9e1ae52ec8034b15f189c93eb1fbd80b115f4112865ad4e0241e401eebef6708128223edee62ea5d2e6397f42d526245c795498618a6b57c73869eb163241bc9e99af22516804c4c3e595636cdcfd53d8d14de4ca195b042724f4aba9c3698db1e10ae095c7dfaa167acfc91cf9f0cb1fdf885c1a86f88699e7df983c741536760bb1d9e85984e763dc05ddf61bda62a2d5b93a5fe02d16ccf8d15ac1a408290016a8bd43375f07093f3a67ca42e95d87fa295e183f5bc19204f8f4d985dd921ce1a9cd4e05d473746bd2afbd579c4eee54ce6addd89b52151482de5b7952567057fb9313c6a85617da77a52c4fd6fa393d5db76bf138541ec289c2fdcea68e499d0684c3b97d718da5e6fe3d43a7a5244da0f8801635637627af2369951df98d2b39863bb3f4c9d763b086360a0036412450cdfa567ea9d0537fed12405cec3642bfe5752bc4db1c9a65d38d2f35678137404bac6bdc54373f432f961fcf8a4e01d3b91b879ede1773c2ec4106b8c027fee28919d2367c676d3b5b2650b6f3765fa827f7d0bd3793417d5d153f55fc412365ecad3f492f0733e073ce2f8705e92a2d9009a5b1ace6671b640cfd0c97d7a9b6751c5ac276fd746986e4f57711c01e35f1447805b8b3dd906cb121c00437a0926c1320cefaffd3d148084d9e8878c57762efa34c5801c8b120a66467b7d776dc2b9ff788ecb1397768b61c0a6c020acf49b07d8f0fbcf68fde4603ba76af93fe8c4cf38550fd3655786049a85c818601e6248447478871c3a136410cf0e1baf30c540214bd1a2e5150d3f02123d49f7d99b3366579b7704b8a84b49bd14a535308938919ef2b4802d3f48b3c63667dd5ba6ad8d1953a0f92a79e6f994cb1e95fc15096ae53d7c340d8ea617f8e00017afd78bed5c490ffa9008487a98808fafb5f3d03c87cdf6d42f62634310bfbf59fedcaed76e8fe36c9bf94c8b7788edbf2deed6e319bee2529e6275fe93bf6822e8762bf609081a8c820bd762c1f58679d65c49bfd5fc81ae39ff1d92d06a31b8d54e8b93e9a0d1c922d2157c840023c56bf69f7032dd322a28c093f415040ca69f9688ca78b7369d2c1e137132cd3a30328d08fc3854232e2a0cc13bd2e09af2fad10bbd113cd83b4746e423475f56c18ab5971ee586cd61c4e87d52e29804895f19c04a88183547bc7ea553aea5c308541db9d21b4f65dfff0346b0f9ea43ffa3766c09bb9b91df1352696bcf4a5e0e90acaee2d2898656aa79f5d0014292a50297209abbbaf6cc6878e20b1e7e0c2bc992b26d35a99c2cf80e0ab4aef44129da57f06308e8429f93d643d03dda28477c40a19b549a8ef614641ccf7c995231358fb510ba8b1483f3b49c6ad07903bf7372ea7a1ba5915d047d84ff1bc3674af6b4be024398d3080885ca3df119032874d9b91fe73403baeb20fdd1b4a3ec518a8916348943f4865655363ad6fcd752fda4d7e34f60080a313e0bca6caa6b5cdf131306027096bbed8057db45e25e33c35f032ef42de460a4b659b61f675594a61c23424c50c82e3f0eb0e41a6fb74b4b1b7b87408f89d2e42ef61b1e2f17014068af968e25d7cdba045f138415657747ce643b579bae47e6b6a2b3dfee404a2a7222b9a4946eb9a8d4f146a65784b132c475c3ba2dde399864fb8464cc77d2d549728b23dbc1791fc456eccdc6cad4f7dbfdc0fa55ffb06356cf4ddd4ba9586f90cc8d3ec056a0e3b038a87a3f462c9feb70ea8aaa5f867a2cdec8e7038210dd63d998c752b51980755eafe7cedb752ae6e23fb6a9996075eff028e401b9ae829d8a50cf4f833588a484ff19be728a043db4d5cb2cc94ae84134cac9d90be6d85ddf780fb0944a88c685c4f87120365b455777348c93fa6ad567cbd01fe92094260ab4ff383ba1a887892f126e8e3736a79f1a01e26de5795516e62cdde8ef325d9798ba79dd473ec43bb03cbe0b5fe31c7beb90f6be40d0947ca032a035061ee511bba33480db46f9db533c37f89fb3b45a89a81e99083f9544fa1834c0ef8cba0267e2fe12196708cff82bae7e7fdbe6b51b6a4fedf25ca9f7888a079616c335e0728ec466e29f5525b5e4c0f4c3e6ccfb64e6e7d63725ee512b84d9f2139f4440c0f913cd75a9d2a6d8e3dfd27d77f9420cd58df49b7b0df33c86d1e178dcfd774fb818da06b84e93066a7fd939d5dce2a84d4568911158978fa12bdc0e7a64260c9757b43b286737d0b2e96b6d3f6f9f572b063e2e2faa074bf459669cb2d841b0d49241951dbbdd206552f69d3ad3e11b76474ee97d73cc620e2beda0f9b02a9686cdd84916d41b87037dca6de8ecc38be43be542f972d0926f56acdfc8b9bc21dad9b65bf082eca4cd945e5171c92535ceca8c1f9134f128601f77002290160e5e3045f67f1325c63de856bd4477110e8b7c416c69ffa1e666ab334cb047bdb7ee92c8854c5178b239f6a4e409299b065361152dc7e06cde2c0602c89455acdf55c4e702cf8e93efb0ac04ed652486dc041e1bb5d45b3527caccc90545733b3c8fb95df5bfa530acbc0af055c039e856ebbeaa09c62a8cdab56cfd4eb400f0197fb85a30df447019560e25c044f776297bc52b18e61a4ea04e0b90534eb76570817f3057c1edb017b6a9168e0817044608cfeb625294f571f09475a850e7a0d12ded60160a177d791399c48e574ecc900370599b4e520518712c1c6fa142724baecf5f0812e0914c516361e2d5ab657b1396ee87c2ad780626b379cfdc5bf546c3967b61c416938383e6e3bf54832852f6f5aac2633784d4dc036d0e8ca3b9e1ae36a242edf5b5806a75e53e4b5d89e85c7fc97c8ce0afb3af1cb835fd7bda357df26cbde626f536ccdb200750bdc938f9bb56d70c04de62dd1eaae9ab794d85d60d9da764b3be3028b181d8ff2dc58b06b22808784c0d53f36c2efa471b8177a2f8fc5af1875dc2bb3fc66f03097d36a2a7ec75dbc6448a6b7504437f5aff5d317920ebc8d358f97a042ca41f7359d75dfaa552525ccf61f2ea0851e9e75514689c8b707ba1e1ecc3f3269c163e4a7f23f2d4537ea1ac5a671ec048ac1cd90db54713ebb62e7abf4152e2a32c6cb03f8b5781e701d2baa048236f527580473a013833c50defbd06eb14f237c3b8ade2a7e388aedf6e2c15be1e12cd6fd822a3fe741e5ce3693c99ef471aa14c8e49795b8cd97101a8cf8c88c47028556bb1f659ba9e5f850284d3fb9415cca511c6bc8f92d2c76b00eba1b61ee1fd48c711be7ead2e38b437eb53df33d705a06340dc5ca0e5e5dc221113b5c7b5725ed78b95b959be7a490c5e8d556c6361dc372308bf204d35cc6a4be14f6e3ce8c75e34b276682beb582238139d9c9e45e76561db281921d7d40b0355566b69506e6ce4e3680472cc72231f0695890b5765b30ffed6bad922a9442e342b84b348d6c0bb88ea2cfa6e7fc62e578c2fecd97820aa9fe5db278308c1a842445a183cc5372d765ab531a8ec672d2a9e90e8bd6473c4e946d139a8c6de23a93befda1829ee1e4f82bc9fb2886248d302f271719705d8dcab78dc448ad062a1ca66f55006c4b65d9adc39cf3d491990dd72d5819380363e35b405406be57cc7cc1c56fb94f164cf79e2d02fe7dc4b7782e4ec93d0eaa95a832f63ed487ad5d6dab4a27d780ab6a95ea6e6181580525afd0509a6adf1ac4ed6cd064da088b820d921fecfb06f26d925d9d9f3a6bf6e78dfc1ed2945cbff4107a9ad77644a52de3bb2555959f8c84b02a76592e5d99a512fe1daceac58fa3b2a821c815ffc0e9304f9f0ecf10b1655bcee4270c0fb55638d3ebb1f330914aeacf1c1c366a4d0f76377f1fac9543193150f9403de0aaaaacec2d0b6f5d9abae94e50b6823e41efa635822014814a7008002bc2adefb335b68c06dfe79ec5a1a4546ead9076668281fd94dcd94e9aefafe237789a39cfe2fdc286d50ece90e07fe49ce82c84ff0cc20beb0db17350fb189ac2d1bb909d955798686b6e1ef5581a5fe5d650d1a84aa7c0f6eaa2fa7f61ce4135686f99af23149103912bab940a600683005ee840c494e842530e91b147366ce8209d0a072f248b0b42b780f39fbb425c429b51e3892de340402dbcba35debbda95b2cdfa1816728da51b4d3bbe80b5d4ae4b54fde66180654c093c79a75e2866dd496fe8b4afba32878f5fcdda25c3d4a64c2eed480caa8c5d5e4a0c0489076e5423a8a60d0bfc329fd6b9f7594be161ec11324b3fa3a3be340eae3065daa98801f5f29181bd90aabcb07dded942c7a20fa41cb3a47ce53496719731b228bb23d7f98596ba0f0d14614d63e94055de2d840fb4dc83ce8fa7710861c08f965bd1c1657d2fa408b9fae80753b04619ffafb67e92fb45aa3264f6cdf8447ca5cced2c7ea20f53082e8247b9a903a035e727660f38bbfcb4b7996b68d09c5c007328f31af255f8f328e73f59b78b97922919110b186e6bc2495b33dd42a5da715ad5b006bf8e53dde0f11d07643f735fca182922ed78a3a11e24eee860a58e2ea6ef9a460d08f72bf533e0a0ad5965bac13993a4279f814c3b6c16f58f9b2c5a88cd7f6a36aebe176fb46604dbaeccad9d3cbb7a356d73b2838689059ef78963959c4c58431959a7d004847aa901e309b2dd545bef514516e62e10d0e6e56e508ac741c5989753c125c12427af47169691b7f35506366f738a1d1e31ce59ff8880d3df610907be3556999c1fde7a989bd3d784dd297110e6fd55fd5835144ded7d31f732690c8fc87e418471165e42ce297dedda3d5699817cda6233c2ecd07eb948a0d7f5aab920bef2a0c9132fe00b50801a10e83d9af5d953ec40c25ffa389461c625658ef53a69b41a58787201e00f6d5120833426523d446f2263d6e494b1c06589b9cbe254dfad2dc44df258a8c7547850086dc8b91704233662d5af63003de9d22e8f845347c8687fa6bc95b2d79381d46313ce91960ddef19ea7837f6f860111595ab6cd47217847aac60798ff461a7b973744ef9349e6bc56f49c656ee056b1121a48255a16c2a3385ef0a181b59b7725784b64b787a973836c03b8cae0b8dbaa56125dc1a053a6addf2775d9ab3425a349abe7a3da6cc7e288c711cfd1f164e90b50262d51dd738724a159643961e2b3b4e3d0e11295354be38608b5a7f3f3468abfee2f1ac0dba9a43d43b7b1389f618e595763568fb095540ab7f2028c66af5cb37ebf5d3789e4caba8cdb43d9923d18b4c73e9bfb61375c560211ebf9194d132b0ef572803becde578e4481b65e9cc3d85641ac584d361c463a23b792b862167b85306263c34a775ba51d5e941f80abb0dcb65a49ab12c521ed0a547d8b1add1aa96cbe87b0d51a880f442ee42095177a3410ff91e9e1916da38b41c6dc2a756ac4d763f854dc4044ee400384fd450e0e39a07558d19f1f01d6434c537ecf6828b1611854c4c4dd3d8bb946300bed244b287a19a9162c3094333ade1fd02dca97e1c5332156385852edad3cf2b1144d6675bf604e651fd7f3ffb34dd07f6a53ff20e57c38788534eb920cb2bf11af3f8c7b2a703f2262e6b9f626b00c1777dc67c5ee39be2c3427e924856b01863b523459f6b6bbd604023852892d97614e26021a90c653a5ad195faab50802db77f76adf0973ef3a4334550cdf27b72722b29f59f6488e6bc05533b94ab4949c952843468527aa8cd496f2471de33023e69f5c4237e7b79b79dea386d0e3395714724068d858f4059f416324aca2ae6176f2242ea4f66c560033d6da5d823f82c13b4230fb64477cd75404aacee78f466272e8d884d0482ee663c0284988262dc3091077c93c73f8c5a965183379b732cd1a4a7910c1f03ea1ac3ab65e1b2eff78d9bbbd2c2a9dcea37015a4b9687bee9f5c9507ad174b785a42c6665ef7597b10d342c70d0c2d2b12f51574bc15340eac8294c3a42590c2a2dff50721ead40e300209cbfbf89f7539e612089e73696bf274fe412226289958068eacd3d2bf6a422df53e1b17465e10d288ee7d0acf382a4a95108e39ecd7faac180b3f553e0265b637e50abf7e05a306e40316c118a64ce206ff6e189a43cd5be6eea6eca7717e6249f76338fcbe2724244b87b8c275df7cb6586d597565405fcfd6548349b6a26c5b0ce471fe3249357f1ba77da35fe2fef0f56c9003b520785cdbbd8094658dd1edbe7d6e408b0da67a57b139b765490b59d28039c5a447c08d0bd7b72ef2ae899319e847993a6a0d6c7d0ec9b1bbe452fadcd66b52378269a9b716344fecb056ad8964d830888ffe738af99781909280f2c2ea7d9f4f21ad029c1dc624bca98ff5c32973c20c0a3787cbbf3001c65f1139da78046cdc64ac918df7bf20d673de118c51b010d5c197fc09e51f0b5c535631734c3c5f38ea7b1fdf621c61e4cbd98b986a9a2299175cd6831e9942138e2a1a99c2993dc6941877427cb17687a8542c72111d24c8d4a922d39bc1070d9859e3d5b293707e7a292816f39ecd71a6c71c92c573ed5149f0ef9affb797e326bd3b3afd82b04de8727259c1f1a46ec28ec4e45ed4ac98fe9c9ea5ffedf898e51759f64acbcfc9d2f2e77de10782c1e7f34c1511be5db424b6bf63c18e3602804e1d87d4083d099707bc7b078ca4774126792b725622f8e09fcd3a79dc0ec644f976b0132d4ba9ca715372028bc49b9d1e7009b55619f2786bb60f997b95cab09502c9f481c0b698350504074be9e8a02302e4379f5bf3b528139651b1e7562c5354fcc02d293e86778fb3e711a73510ecf61c62534a90fb1089c333f8d770e996a899be905aee09bcc51522e12a2e0e1ff00a8c328ad987cbac56ba74a845e951c772dff1df9e3ebe3f6cedad9f6237bf2de5cdc11a0891226d7a105b0cebb3d8e06e2a3bb841f4f481cfdde4fe321427ee0a09e6585e490bea0a368b4b731ca09aa0270b3f818df56262dec8447","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
