<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"17c0961b7250070042e38c3773d788e44d012790412d12c01f786ade7f3135ce8760988818dc7af50d2a03c24b5ca0f8bcdd522c6382c3ebf7ebb0742d6dc0cb0d010897ba1b0ba50c98f96407c123b8d15445448bee6e01426d23fb9b477405b4d6a9f0b35a38432713c583317a5d6582b517662f2dd1dfb2287539434fd9712df7f8e75bda5f3d87ff9258aca82410987e6ecf8b9746db9f0a2870c41d4d728a5f37aa0f8deab1fc6130740537291c5248829c4c370e1bfee51d8fee84e4d1e38af428a03bbc06a76a5008f08e6a290a73d0bb0db33c8fd099d8af13a96cad49bc6d4f84df3249af2b51eab9b41d524a04a56554ed0894a0e86889b019066eb266bc576fe4b20458b358763385fcd0e3d9566b62a024b7739da414fdd24d0c6e6ebfc6524188680add2030f5bf4e3d564d313ad537481a9687a8dd5c19861bb70d094b95edb92870ed2da77e5b13c9e941f225bf766d0ea0d7541c18bdaa0f9a6ede5b023eb7bad52e84a1ccf342e8f67fdd610ffcec10d855ff914b00f97e4a3f3f718d4747fa9f359e05a7d0de5fe3fde54d0a08124f2fd6b0c6ab6b8a292e8c427d4f9f1365a2e18ba2c94f3dd8c8716b30fcd4c4cede577c510e0431773236c3b67fd1d23e0a96ad8fdd4162266fec803535b3fc17a16f448528d7ea856953185acae2af8a6e391a57b8cc7686b2545481d7d8d9ac78b7794d8b199f974caecba6bd29f471be1fc9e344e0815c1d70e788a9326de5bbee051bcd2b29fb1840b1acdeda8e0f00c6a3f0a37d501d82e06075e26eccac882999c69770723e17c5beef98005cdaebb8fc57f83799cbf2b951de17dfff4584c3a7aa13c822863bcac26cee86c07b36b321b035e5c920bf05c0b182e68a01b83574da939c1ddb0b45972bace5fca90aaafea0af1f0960e694cf794f82156af1a57fb1155fd64628379aef462142651ca1b7edcb541f13187e3f4ff3a130ac2440c483658953803ae206033007b12314d919ff541149610401b8a02f126cf6844b2481bc9ed84a9f5de0da1f1808cc5a228885f8cdb4e8ba5bc1ab3e7aef990a363d899359f84e6f574efa167b16fa9c5b3922ac9d163129682b337763035eae662774c2ae819ec947f08d7eee06212913df329afe0f25c88a58d966ba32a024c32b7846cac79e6e7879d3331c4c1d5c0a7ff40f415724c6b1b204df86876d393ae925350728a1afa7afeb21e3d91865e25d4474b4d32214baa0f2d1a79fce548c580e24b4e39821d600c8e88914ef2a099d60f6678333110b3adfc92d9872bdaecc982e308278a9041d925be2a1b8e8e49f07c3eb864cbe135a2d18764085269e458ea57d032f9fa28c913d8dbf3057e6375bde04ce82acdd483dda6344c293c58b1279e607916d2e96b965271741fab4fc02e0625dc4b7cf1c42473d5b4003e7b091aa9289deec86cf115cfd52a1c7c8b58c06c885e47a7e2bf506a49fd1c96fd0386b4f269041f7fadfc60381462960e9182c02ba1b134960b8e93dca9dc418527a2e72d63aeb3cf000b6d0df45653152724ff51967786896a2e2d192f4a8c7badf4e774ed12be3b76f5933fb209787995b69d1493607ce15de1a00ca6483aee498c290dc03de53020b5a8d27696b08f9f5b9da83d687b8f4bd463c480132fa5e3761d58083f1bfca2b9f66d09a2e58d7c777fd0033e1463f047ce5fbbfa93379ada48d944c3d5cf09080cf9f357d5bbc4151fc03119552bb8b631fc6135027a0a6c6307aad32252e692bf1393bbc7acb940507a32865d88eca32bcd8b4e7bfb9c7fd15acf4f4e9b5df0d118c00f3b3b474b2d0e6aa71e6ac0b655bacff7a9d67a8ab9fd48b99dc9fa53148e54ab50279d9cdc924aa61155dd9cd0b0ecfee95edea12dff2859476396ed388ac084858aa9bd4e271e644f062bd38639353bdcf8ee86fa9ffb9a6b3467d6a5a3f5d35e1a36ff808af4cd2c9b63cc1faa250f3a91321ea5bca12f51179672b8c30b930b02723a648ddd389c61bbd848ae4c8b7cb6529c8856a346b71a81da7a493c6c9bc344119bd46e553ed9fc908826642a3882d1e30b6bf9c4653a9c7831e7781f069dab7eb0b8905bd810db1ea9e2e2d8ad0f37f1c793867f6ac4e095ccaf43101fb9724c0f34f40722b0a68ae39377ae284f408df5ae14c61b3bc34ac38d1c110ade7a2ef2a00fbb19cb3a3f493e1d8b9966ac5535984e1598dde8acefb05942c4c2c4ab713d6a3c9860114bf2c7480298b136052c0587ef55fc88ef9ff09d77c1813075f149a54d86de24d59ee6d475422264b6d2f85990cdd2d4a4a87e493bc7f71c1623cfe029ca2b16f50576a6dfb76ea922c95285aa6e4a7f79d88f46d8a9f4c7a0bf7b9f7015f0d2c15a5aa780578169f9e1848caa7de4c105b84a2a9dde3ab8e43323546da6975693c8f5191dcd3aab327b84fc48c696d6a46311d30c2ea991192dc645443c962f84ccdf26e9d50f6b80ba81e6f8363744708735e84b5b6c15efeed12f6c3bd3b15942fcfc99d85a46f2662a2d4b5b24a8fe21d7ddd5c338e9be67ca038c3b61be4fa572c226d6a14ed6d5389b67593eb429cce17c1f87b01ef7c9b04f881e39302bc01c3d47c4bc7a1ae4b118d45675bbe1d7b1783af3be2867e3ec2b48ae7f754e78bb07a4d0bc1dcd9df238acdd798efcaf1e890bf5761027c8be4395c99bf7316ddf7b5cd6b3891de71a6d2b59bb9b24e307921819d938ce61284a11ee5718709772f61859d4c3a5cf8bb42b43d101a25022e97b5840270f561eed73591bf0748d3b42f04894c7797a9922cce9de827a0125c2ce4d8794e13642c5f6851c33db6f4f510245e42814ba2d69a1a8ec5975310dbe956ff584aa16d213e197869a67902a780f23ef1134a21265a115e257312faa1d4fcc445c72f0ba1b0cd60d389bd112f838d702b90aa14a17f4473388e34d22b51df2ad89714b4f876d43943fce8835b9d183fcd67695238fdacd4712f11f168aeb3c1ecd63bb4fd6f4422e3f75bcdaf75d1c9525e03ba63786d2cdc516dfb08986464d0454229fa2014603be9f20c08565951d7ad357634e0922e059afaa898a46f21712788f1dd2dd96eb93b8a37f6fa90dfdd2435a2a71b1c776745d6dabfd08ff5e609f6d60bb99b6b5df523eed47d1611fea16f6fe1c595dca0ea501c50bce3c1f24c626d3d669e6ae8f74b0bde33ec17972b8a59270a34830053b3de1c20b41ff4b0329518b2f99ef8d8fe804edcabfa51320056c8382d8b7c9d7fc75aebf16219c7bffb69db809e0c40dbf9812df095b93070c29b5007359a81a14836c50a6938918f38cf53451cfc7b699039282f05bbddbcf1739a918abdd5747245fbfbe7547c1ee0ee87b412156ecf385a88f92d7ef1cf859957b6c0d5f41ea81b24927c65f26b90a8df394ece994e9d422768dcb7fb6139f5ed039170f1e98efacd94b96ddf1be2541991f4da321957a38749a4ba3ca38e6ea25d869df1c00d79fefaaa8110790b94c53d2afa5f6a1abdbdad02542b6c0cb15eb7f4a37b84b311fe69dbb5e68594ead6fcc52cc5c61a995bdafb8919304e3be1eaf259e47d2113e9a65827863177df5407b47aeb43c80fd2a0f9ef30b0625d2bb7adefbca1f19b1506dc134cc734ef06c1e515e12b586b37ce60e7ee3d1085dc409412cf0c8f2ed1af972103f2c6ac63ec3ece324816ca17466c3795fc42545df272f8f179d1dcba69c84b7fcbd77df756bdb254bbd0c835b99f1ef5a6ea432da5de957501b4bd035e169bf502a68fd6772e592c07fb84b28e0a481d1f61cc4904b164f9ceef687b59f815283dbc164e955b4fc5099a1eca829c7b9593422aeabe42713bbb99cf6ded662b9ddbb99c00269dcbd57c0a4729d2851b2ad50ad485534b61a85d21dc665b79b5b8b73ecbd36208a8967d6ef2b6a639928c12ad181c1fb54739f440d568f32f347ea433a16d81abb4a90f258d663723015e8a26b8235e800ef068314eb05467661a7c5da69c4c81ff89c972094052dcb1212fdcc0534c5aa171de684e3fbef3962e20d6a0e4228db16dad958d411e12119d9893c22ee3a6c7a5b84c1b36d8d579ce30487ce2c0aaf4f895685bce19cb847b561344340686ff7b7145d8285db4eac7fa2d8b67d0cb92a8b0cbdc4dd3d50a21674c5c69263975a6151dc681c6745bed32892d53731b341f8fb307c7683d0926fc44507ecf8e32ee77f00836d6571208403789d2d3732bd9227a2a0b7d302903063289ede9e29b90ba5b453883a3c18360b9c1f6d03e11505ecc7dafb77f5382baab09da7a6e598da99db67ad7ca897b862550f1eeab3fe541d4ea03bbdf89fb33ef07146c974f77d621b8f36808a552d64eec2e3438d45aa379840830013f2b336ab546ec188066a4133aa30beda8c87a8952caa369de0a681ed8a9b1cb24c91fbe90051ff250e490629c9089ecf6794b1e1bb493a55325fe5746323439053427ba802915b3777ae86fa0d519ada822efec0dc01c0464c0060cac83b16b81a999eac6c08a4cc875a428f425f7400ce8505eb4ab27a0d31e6e04c9b3bc4e2ba8fd013c96b76411d63819a74591d2818e6ef473eaccbef0380f63d175c0a1815bc5f6b951a681e29751471ac07b7cf227e628d3b795eeb20595e9ae75d3b9857eb3aac9f453911edc47740137c516c12423d466329e4ff82bd3bb116be6988ac0ea6f99b0df34279b8529238939a92cfb4cd91eda60afdb97b01bb645eca69b32f889dc32b542f0201716f494f3a011242ec88b0307e64aefe5230772c105ff728fc61024200a528b46eadb0f3b047e79a97307f62771fa95c9d803fc1c19f3192dc70d70dde550b7a6b33572c6b55dda2ce3f6d77ce8e653649134e939f5527660f205de4091aadd8a593859166529ba37f5224ab1892a9c8b190aff92d368e3f09925be067aaa845cff98da57fe39be91dc49e27bf95f4c198d3207bad47f5e6859803b8a5b19b72c8655880e3be12278c54e5b4d218defca2a62d9c9589a6a9eab5744c2e0b376a5aa19af38d7d569f2aa1ca30f2d6123334b755b9c93bbf9dca727ff9057cffa0b15a2535b3824fd878cf32abcc84b6a3dce4255aa579c0bf02c18adcd6fea88014a7f0b5c2800ed002831c321a6978b2498e08a6cd39504be85e9ad3fbef26400253df5a53d3d7ffc292d9abf6930b203c31c0899dd9409872c2c62bd1df7f28626e982cdbd9dc27594e1cb9276e17f0ac9a29c757cdafe0b689d789a61ef214aa08df761661c84c8aa8fab1194fa4216575fb56b853bf1ff8eb1c90bda76440272c738ce486641c1627387959a0a556fecc4f95d3ace2ee55363ec25e0565906a8e9971cfc63b9430a64ef665e03da05a9fad91fd63ba3c4c6c993e40849ad49de70d45eae425e72be92af7f1aec5e34346753532837a2d752f7a68e19e500600bc868c972abbb1e985553343e0ef2f10b2a6ce7835fbfcb297da24ba1e46c406b1f1203e69834f4de2c471ac1a95318652e86ffbe96d1da35c33336db700e371938429fd319058c3d0c1398d254dec4bbb64642408bffe6c0315ae25bba5c625edafca3985a9f48e4855db8137b416cde87e229e7d1bf43ba5f0029a0aba00eb131a32fc5a6fd361b80a3c3d97e339595c2ef7178261e7a18ef8661f0f1c8383c953de34fe745c3e01a830234ad2f9f0c0f69004e824b82fc5217569fba52af930a8079fbd740488cfd8204629f921c37b9c2d5e55debfd00a216d1146671e8e8bfd68d420ec16c3392ae45a57dd38816d9087944e95114061d08998a2117552bfdbfff6d7215162f94f46c20afc711cb6840acbf281cfb79d663caabdf19e807294e9692c1ab7b66915e32d06a02e1939223f8fc3a2dab6be43483d065e1c9e9e8bc69456451bf8c9331c126ffff883fb0ba78c537e734c3c847255aaba37bd53f7c151cc71f96d405e62dfc8fe27aa5d3255c4d33bff444a6a5027b2acfab2b1aae870bb7795ea76c999e91af2b3bc289c079103199b0199712a1e112c6a2751924a9ddc7457cfcc487ab105ed281d0f30aa7f9608420f7b0d8b34c94318c5bb648a67975ca874caa1e2859388566b47a295d2bb5b38e885a3baad5ee601b9e8cb60f7ebf6ada2e6555e3ff278b06f0b96cf5750c02569b917e615eaf00fee2b7d4520b8a1a445313f63e9203b2291102db5e4082dadf7470d358764b0a98ab05e73b9479f37732cf4b1d33dccc5fa6c7e8928f3e798f449e3831e8b7aaa7e1f6c8af1746e95b0acc6bcdc4cdbb2850aacebd50112b191e08ec8020da5da1ecd7d55181c366199c5a4877d5650c69520d23755794af52271b0a3b2ebea6153e2de5f29aa0ff168990b419d1064b850535ab0345e58cda51e23f2c173447c0841e0d66e234a9356e81d56e8a1c67744881d292375eb9cfa10dfd9835c0738c5bc1cfa4fac044466f0c5acf3435d3f75d328755c19fd22a7e0dfe7bc75a66d9e43a43b119b407702b406f4f0dc914a49be71546ee3dacb8037dfadcd6d3102031e9c6ad1c2f1caaa754f532b43e0f7c211107717a6d22a7cb28740f881d6b4d89800356e7d6d43861f3fbf7cc830c2cf346fe4f0a984136c3f844266bb401a4040db4b4674710494b142c9c7ea775e3972b8b8c39dbd507703662fffc275d4731fc333d370909725c7a9276fce951983492396db626aca8ebcec3021bcc87da773e10322b740b706cad46328d6efe57857d2cf263865226316bd8733a2f4b87f9cf252aeb8b2c3409585e8133cd08ffc2066c81caab3c9be4ff4c9d1ef1d0944b406b107e7416cd0a1ecd880a4d7122aa7366bd1d36e090034495f95a99ba04b6544053103c205a6d54f2f7eaa42976aa6c2c0550cb32be41aae1da9a119665fa577897d212709b682450d367be2da18a3de238084c484914fe2706011dd2d9e41fac5c9b4ab7f16c37882acd8808849cc443c86ff9c1fb73ad47fd7f6e0ae78382be7d332b0d269e7cc8f0eba33c40c1814c3fcb8e6137047298c979c1904320d356104228bcbf831a35e9d38b270782d1b0b76a335e6b50059f344048528771eb461a849b0f869cce4b7567c174937c9f8c8f3e4b5fb2a5b4cda9943d96fc2ace6007dd1ce8e2c7716139b634ce7d4c24cb1d2033ac5b9967c6564890330925023aee01e57b560314c7a1c3b12dda5658d5882df316909f41c6122618717f74a79288cb7ab6d1681929ce8bbf849522cc4ba909b4185043bf44f9924e9ee830039c33170630c176fb4bd9a509ad367fe5f1c3d2913139d484f10ac548f4aaaf8dc43c7f88dcf5cdac9310755665f9620945bca471603304fc01863d3bd106be6679d4f2593df5878d3349abbb0349c4f5c55dd58b930baf8d8c40e3fd03c02050c4c13c406c025724442ee5c54ebd15d09106f8e5f2740c31e9c1ea9217275a1a1e9e018099b4cd749ca279ba4bb79c4d51b912d1b8d4965f878fbb91c1a9b1cbcc292a3cb0ff15676bcac0721969901dad8aec1dc79f270ae7b197731f1bc794476bbb6c011752aa8a0fa68feb356bc715681c0f53e01c4877bb54e6a15dbfd1d64dd5ed77ed4c31d9b789c0a884644bc4c4a0e9a98768095456b07a0c5f0da51d28f828c946d055ffc853121a7afbddb5ffbaa65ce5575b54ae8ccb598a38b23cdbe558387d12a3a048bb689c173d02b321af937d1bf7d6977d749bd103669322e0f73a8ddebc8430e339e61133c4c15d1c30351e8bd9699c82d8df0329b3bf675981200109a2dd160d5929a26534625dcc67ad149dad8c4a32bae0e329079e36afa69c738bd4150cce353fd2863f32731f9761f6f61b6bc44f190b05688ff062b010ad2bc35524fee55f5bf6eca1b6e0c29b5974650a57026fb5dfaa90deee95bc5b31b111f54f7ca3c575a03c70e38070074be45280b3d977ae8094a97b29aa30c71fa92efec1f94e15f182812f625de6d7b35fb56e67de26760663f91f829612c6480b2557ff0b3e8566c9a59372319343fdee6896f980411e5c9f29bdf82cda81a410e5b768bd1b6eb37e70c78eaf53bb6ca2fb911dd0148be90b024fa5f6ca499a3844ca2ad90a3419a0595daa0a9dd71ac4c16e99218c6274a59633dced62e8c283b5b233909a1820532c84f29a476336988c4e7c7589aa5b5c1b42334a69fba7285ddbb60effdf8267a1305d124b6593d0f1264665660c9cd326fc2223cb2f5505acfc4352d291efeebae9500e33c1a5a593ad355ba8e9aefa526990bc746b4412141338677f0715110a01e822fbd2270b1a8598f81f537ac32f3bfbce7d46f6c0ffa270a4dcbe2e719e4d035d27775c328076c4fecf2320cee9a4395a49011ee1f620eed160734c0aa2be9f21bc940c7b43fceb4fd024ba5c54d5e8cbea80d6f7cf9ec37233b16e065457bc82ff414f9f061dc46abba3cf621c83a25a196ea3a09f6574eb2a34ee659b4cd2838d195574e78e20e101620ea82545fd05b20924fa6a2abc69b9f7dd7cb6f229ca346be9e43f2ccae7dbb14efc70ecdb168413e6c6a4232994ff4718bec7842a2c006f5cc081bbfb501297dec7c279a79b57bcfe3ae079399403ecd37269f148f5f94dcf9475385f6ce1479966527905a8245c953d400bc490acccffe2634e52e0cbe6af20e817e23fd6fa9529bd6c411157a0a5473cffcbd1ec0d7eb88dc4104bfaa670e84827fee6ad45d5ebca4c42ecfb4b2eb4a980d7699434d00c01413e737b3bce6957875774ff101c574e63b7d81c534e4e97fc4fd0fded33760c68faabb965d7cde38e3bd70f43acee89a821aa07f10f08cc9ea47d68c2fd577afb881f03502d5b8a9a7f746fa9bcf9abdce73b78a0bf047c59757f2264c918ed39b2383abc141f9b22ec62dde214b0ef4464e04a66c4a4602eb451ff9813d54f8d1633780cbd92fddff560aa82ead7747136d07b6f17cdab0c8d3c7a9bcfa9939d1f121ab3493399bc02e461bfdcca26e022e529aa74f676a9986f5455359874f8631219b423b43eb0769afe7f86dad6beb501618c6c4e4f0bd54b1786c2fadc46316d1b919dd53c86ba8b48752d3289cc1811f28a1459dd1f57481b2e9047c07f984cf99e5791a332c85b72d038b7190ca608018cf0f2b338f6df5cad64a8140d79d49cc00c30ce9adc833c2d7a7580806a81391cdde86c325ff52d52a4b9931072eb869e4ed8471ce1056853bbd229ddcc9c304e4bcd9679d2ff38380643e6300b9daed47b5e15f6eb8aacc7a57531b3206b52646ea5c617736493a95a97cf1d9ab9974cf971f28411fa2e2e5f3b2cd0da70cf59adaf5fcc16608f49c0432bf408a714a50b023fa0c7ce695334017217f79efe0cc9c171eb3b4438d2eda20afc9aaa7d81a283c85f8af53070ea9e5b926554126209b2723f51b1b6b62b1e9e55f6d9d506f7edaac43b2cffac025a31025395aa2378932818a2053a9861ced639c036b4cfb07dfe1325081c569edef5a804ce3495496e9e8e099adb3de4b79226ee1b0065350390e82ebbfc3dbefa7178f7d69087598370f50c53aae2c7e7a6ffed39a6cdf25cd8dd6e7cacda0ead761facd166011aebc4dd798f95ff8363e6e2d9c135d1b335262a18b3904188e7d7e09d390911c099b0011ae8d6d5df5d1902510c5c0a9f5c5d73f5159edeafffa30e2e7ddd454c6c3d8399078b2ba4a8992688e0dfb511497a30e9719270b346bdf859a2c099e9b073789fc5edaedb97e43352f6af1c375b32e9ceafa86aa79af61f1eca351028b08df4ef553786a06043a42756bdccf1f1185d74e95ae157f578160d01bdf1532eddbc31361c8b62263868ce8d452ff70acaf86bd345a76c83ce93a9a56db71e2c3224510ca6a1436e747b414d1f8b63ce083b4dd6de7466db6f9d7e9ac1c40e5047ea17dc7b70a18c668f772d58cecf9ce2b046a21eab8d86767d8928ab6b4e6f34a582f3834d1dc07bf019aec95885547d3627acfe1def414d3da94eeaaffcb8263354e2b741ecb634235fcc281547b6fb2e46750a3a8bf72ecb650501b63663236c7425ceb7db61c79883dd6b8255e43110cb28840c377721892827ee7d27fb5e8dfb8448846cf71e2a57dbbe5abef267aa09cdd41eb79a71ffec21797c02369262cb17ceb21602412019ad1b8d7e270780fd52cf18318829ad09cfc36b9e63aa124a1017d19a303dc196262dc2d15b1f4edfed471970a55a8b6fb4a6f2d0eb223326e8732fa748c23a69f85283ae7e7f1088ccdbe4251d5132a462965e1f2724fcb60c9b01f7d34cfb9a752f442eebc05e3fc46b09035b375f5ebd171518fd53cab14e60b67938321614a1ec0099a901ead6caf12866982e33e2a9d8268201c9a30f9646135ffb23cf5eb28eeb0d422ad4640cdab66eb8471a5bb6e34232fb7b86e0bd1168470f69bf1dbf5c6949e8813a4fb8b90d2a4c00f814dbee5f6d2e32754c4de52bdc4f2ca95a5d1e45e15d11e171fd768e38c61ea9c4e5d62992503c6f7327f759b4e04d277c569b2a77a16ffbe592ea1dc215df78c783158b23bad10bc50ca20d04c21b3777329a36e6c68aa2385ce377bc144635e7d070ec5c8c2881bce03709941ac2e73fe8c4dfa6f381c91881a154a3a3c2a25f42d2a3112b9af47260dd5503dec6e7590d7d5bdfb167deabe5739c47fecc4700110ac7c8e8c8e202cbaef7202dfe57ab2869676f7d3257ee74837cf3b31971c2c41ac61a2ab88e4245754e31c33524baa3c009d3eb7f0433086030bbc77a41cbef8f1ccf537df8221618d97d8dba82815888e3873f983688047cbb7ed64b2fbb6792f7db86792fad7e02246ec0d4a7fdb5bc5b94c9fe74e571658bfdd9f4d070ae92cb03c22797742d6e94fea7ad79754550ad825b2c51f394e6c8a438a1420a2c3b1c2ac4f284505a522e673f3e0685193a9defc8f39d29c2c1df3d16dabfe95e76237895f97a69a42196aac4bb2ae33d209977740cfeeb6147c2e12a5237c87ada73e6bc8dc1cd8c57392577afa1857f8724426b3cd29556cd8f6ae7936f500d8801553a54db4f7c74be9fa99c02be0fa7f712dfd2bd103c62b1f7baa6af257a89bdd6013667a71c915e4819c1751a938cf2faa2f799a4fcd3d6288d743024e151ab4aa2d377e2438856a883bd26006b6ad3800d0aa1c8609390288613cf0b0760608c3706bf3f35c0074cfadff11a4e26abfc82ab34d12b3a486a73bb557ced9aa46a53097e2486db3d8a531ef3a36712c3a497dce9b8763072e1cf935a3350d491e0978a9a9277d9c98150f0a22407ed96cfbcdf1776ff60f23ae2a9a3c93242e3101eeb902244a3bebb0d75157a2d844407e7d7ab117c08e779ed6700ff63244ed4d4e2bd03bbb1179194c311e86e5af1f0afc885b0dd4288207372f48017356937a0a3f89098fc653e6328f500d9f6d09a614dffb33b4edc9fb69eacc94e7831fb5f89fcbda8df6d4b0cdf81906d397d24b17cb18691939bdedd7a49e30e616a7d07a006ee5c1a19e3b823862cfe20011a270fc8fbdc44dd1913458a29f119bd402f84eb0e96c4f4fa4fbec2d2ba031448f3b63fd569f26dc71eca572f403d15b8cef678feaf6a67804095b5ac9524001728434f55887f74dd408f5d292ddf2a9a01b21c281d8ff7ef1c8868bfbac4511e21511bbfdde028a27a2966b3e64b822f87094a057f44cae08f19bf7b1a7b5404c390e8c4e8776f5b568513af020c1bb6883afac47e57e3daa30a1bbab26b8d80a59b5b649eb562840d33a3e2db970b715ce84ccca4b59f4ee7fc80cdf0b002639ac34cdff21d88ed5bfc9c473065c6d8c9e0c8d42f621e2ee83a05baeb26215c11efe02d4bca035f3f1e851a78c233138d890120d18d468503ad4bd49b5d1d3771c47164bd0b97aafd9ff8c47ec890fbc60be7fce92d1025085213bcc413e04c30b3c19c53c03b3f52035f3f16f652512e15644a86719a736d75569c7f475cf392f176e2a1025258e1e8bdd2372eb5cebdfd80e6ff7fc456287633721bd6c239dd06c3ba2da45bb75a91b455f94ef0087b22d4b944371ba275210e25a67394ba42962d2d0a47a3eca0a6b0ed2e9de3af0be54facf45c289e250474113114dac65ffd3c58397cb5fb6457deff334780ba920ad03f7940603cdb81231eb32f09b2bc941441379675b2549c507d1e0bb35bafd718f0aa89033fc8faa5bc678f7ed4a98ae7f2b49d35b35f5b6894837cccc912cb0dfe68c56455b7dc8054d6ead27beebee2e7cdc69b5372f9a81489ff11a0514326fb7dd9f7d6797bd68e9bf7d0acc33eb649d5afb47843904b25ea68806d38efa71da914d2d2c8970dbfa8e1b2a4c2f11ea50227754fdb0260d961e6e9c0e3d42af07468ef3e6e841aa076c8688274f059eb833a50374e7bbac69959127d6dab5f01e51f3b0c391e0cda275b8bb8debe3910e74ae8cc1b97ad3c3e50420e4a9899559384ec653688bbed4711c25f973125204812848bd4325da0e88a0cce16cb9d4690faf7c616da0a9570c9ffd15664d3b5b729060b184505b88f4e1ee1baaca060787f6843e69f62712be88a641a5c4c3d0fc2d25c139630a1675ccb3a50688e56c541edae4034b66c4ff33e4913cc7f03517b576999e9ba505fe51d913c3a2f6a917883dff17d8a217620b8a6709c7aa42bb69f73abf93145740e3e2bf8c4ffe7f9115d5f785a44763bff05af47474efaacee0235d363f4a4c89f7ac8cb91b301a61a60055787e44f916fdd197c6957a129e102b0ca0afc89bc475cc0c066bd0541dab972b1b60ddd58dcf36aff0fb43c4d8b0884389f0e2f3097a4e5ef325baceb36793a82e4f5be112772b57d450b46f39434d0ff0a9fd9c6bb5b41ac331b5bc94bac7306e3980452eee6bb81d282e348e458531e933eaa1bfddb3152dc24c0494a90aeb0c17f6ca3d0c825c02445a228df52bf6b4cc501939e59fa4135d6579b1cea0baf35c8986daee2306a3f12de7143c83864b7878d5613a4b945ddcb4a85c83be8af2a40a418c72b7ff6abbf9e38416ab2dc4f8e36b2c4e805711552e51d06f0763c866e5ad259781a6ec47a14138a06f2cdc712b0e0292d38a519d4ca28be01a1631364b8759369dd91473d13eb5d9c49fc3b28813b76fff1a2498c575a2460da454121745a24da1c9325e81887d9a9c0c9a298914ad5ec20acd40f926e77354edbf575aaa38ef10a2b217f0dabdf13492c6a9fda760f3e657a4bf521d12f10f24ab8afbb2834bf5c2c7481676e187289d6b6a18ff2e0f563eef61db9e5590b3187fed9f0e1e5054c512e77bcbd112a607170dff5e1ebaa583b7c3a583b63df13a0df92c36bb5cc43ccc1a7bf14e8ad9b9853c33a4554f93d039d074fb6d51dfeda52f38714ee7332d6d0338a1dc56ef07b717a6cd8e91e0924824c703c5dfa46d112d795c72df3ec2699dc70f9027d2962e698b5f862c195c75c7dcff27d19ac2eb3024419f520b0079923d06e22d70f538dfed0ccde594cffa58f685fb8356d8876e5324eaad0cea6009bb52e5a9cb6f2204deb429af6005b2073ae0b6b05ca1c9c9ec5f5e4a938a357ab7b682ca97ea7f805b27abec205d06701ebd8e04af9f3f3412293a8660a0a29f551119a415a4e17ada5f53ab956f360bf16cb65f676b8f8e4222dc204cb28cfd6e4b78ce3f90e3aaab9424fb36ad73dc834d2e0f71b1611d77cb5aaf3238e9b1313884a5153085df19e9396830ed05ce91ead1d875ec725f95d1e52c99f771c7d9af449f4584e3feb109a08c5ff704ce52a31c40c9f8b3a7d818884e997a42cca5f769be0721b3bda7fbaaa2471365af6bd4334d02710226ba5bb457e001a595a897dbc127b07e8e09adebbaa8f5958b941981501ab2f1cf7caadf6e44831f5393d3748f45fc9b8e214207a301f692b5f57fe5eed5c876a70195d91df747a9288382c3ab3efd342364c081c22a5a1e608cc990ac938abdd5714f299aa88a93ad1c3ca64f8a43b4d39637e3654f43c55ae4d6709a445e97d43a5fa35a0fb3f02f25c72b03a728ff6885f8e77b1186245d4ff3065294bca54063858feac768b6a720507ac9f1871cc323bfb3264897c62eb6a06bbdaa49e0f2ebad0c2e5099d1455c168c9fd7ee8fe2bd74816dad59f38d8487fb961f4cb0b7d674f5fdedec543af55d2464f8a60acf1291b269ddf44ccbf901782f737c14a6795492a7aa1271b5ce282b53032ccbbe7141e421c96a0b32b2cbd3d4d0d5e55e1797b82eaa8068a4ff02c6d6377a827dfddb1d939fc3f0b3a0570ae04820b73a9b12a82c310d63ae16ecc3c099cd453c7d525e02855a1f5b03af73eecb657dfe94b970f3baeb1998ab9ab87c78db9ac36357bd81aa6940ff451fd5603548f6177cae748347fa4494b0f529e42ea18fb344c43515e0b05983d4c33549b32f45338e19cf7abc439f747ded1d4af58f0f3108362a64611a6502f1fa8661910e8e5174ba1398800a7035b01fcfbfeaf3cf92634ef5b0c7b2ac6b3a0bf9630025f2c04bc20ef0dd5b849a2e09020924d2e6407c4f3c7e0eb87f2d0f58e1bd8c618e02775a8a78b9e80cd5e0eda495a316381362949d1659ce6d88f8dccffc26a0aa27987acaefc180b0ded25e20f4f37df046d39232f2ddb864ff91de952fa4ca0fbc92acb9cd3cf9017843d7e77d9dc938cc4ff088321e0c1e4c28645ce4e26e546c2effd0892053db963b570930466dcb671e93ad13a5a4f1793bb9ad44b52a5cd57601f4d33eea36ccbb71663a3f76b00256d2013581068d63db2c640ab3de878ec9facbd364694b5e4a1505700c9d281ebf71ed71d8e25194ee00ecae5afb2bc1c320242068a81e5072ffa0c3c33f515324665ad7bb4974df416f9bd3bb934620808b27fb0a85e9cc9a4af3de3ed751757e0fe17a6c5b76fdb93e5b57ed3ed1a8c52c4b51a3926e92af22253411b1ab9b92d7460de5a03fa53f3005c592daee6a1bf427bdb7d09b0cb6e361b67363153a27271eb9b7e805c0ba00f4637e3cc5cd2cd1373d97b2847690d311f3b3fddeb1b877c0338200d72ce329f8f3eb7b7139995af9f147f76d6365bf14eddc3bcf5d1083cc59d1c0945604ab19db5e6c0ca1cbd371fd9d4236834e1e60b976b57f5df50d82701114234193f78c0ee35a3f185fba934f0264bfe79db111d7b8fcc795ef04429b835e7d77f05213e468a5a7163e30843b074d3c57fc55eafce1cbd427d09dfbdce2532b662bb6a4c414c34c09793edd7d28414190e5267c97ec577b11bf04bd5bdb8d58bb55b658017faefdf4535b632d2851ccbba030c54b07ab881f3a1ad0780c0c1726bf780fc6685edab50e230cd1c2a5e0a1c735a084ff63710a17c15de7826d8ffdefab2e0ffd1f9a21430c25eb390343fcc69a227681d75a4352a1c309e1962d4ff943c74d04b194fca051cc6b26a2f6762714e54acf16bbe472a5c038dab9dfce3b4f21162732c51433cc6e2578578006c3aecffad3d8cf7cae3e007d94d4337f1133a28f5a843178175b4a998857503454906189821d613375f89ae822f8f13429b6190262093d082b678529f6192a54801f4b8e91ae1cf7b6360e7e762985d3f701b0d4edb4da1264b42c9e131a7f4ce75926c44d7174419e2e883ac3ced2b5984fc53e4676be94e5b59261e7e467e937d4074e3194b3c8263dbf0fdc9720db8adddca3a0ccf008e905f749a2a71d0b119bbbad8c44076cf5a74c1fc8935365171899ec57f9898e41dcbdfefdb6c5682efb81de8d3390667168eba69929d5ac572fbcc6f452567869d9a2d194ad4ede00d66e534dff62a95995839943bb22d9c499bb4a874febd901fdbee58463de7e3faa4d85009921830f32d77c178c1051a2ea316d720b91801d39250ae9b85e70ccc8dc00201873dd229e79eeafce54f1f2e60152bf05e0d49f02618e1ee8e39c11a506eb1f3baee31fe7912d95b5e09ea291254e06e5c07fa5ec0317ca0803ddded76772737a6d814e5c48a13cd717a37b37bd8f67c5130302aeac47512dd8fa21c16d459acf2c16ff085cb2a3c59718911181641b50fd6cf24b1225b54889a119773dd4492547554a4a66b81f623a07d93bff1a98ccc2420dec43aa130203bb332112864703b7b6af8207a6ca2c45deaaed94d1e0bdcf55655b9f6ca3798d3ab37d21d895ea5f348cc1f8478aa7967aa85743dbc9ec4eb1f6355d3c3dfe1071d6ed0fee83f052718b5a34f2e3e94eb249924f3efbddc09075b462240c6ea1523361aa32dd1a587cd2ad255b0938cc7e24e8000aa2da9fbdc48c5ac1c816f882387c9b13d6e4958badbb2143a6696e788bd762820e44d51bbe58def677de8ea00b17b8ea5c200d8b6b2149a4df1ff32066e70e1f309dba622f80e0a451841f9703b232b41bf1b81b95aecdc092af50b792b27964764dbfa7a27bc8b6daf654b7da30bc7682e85b88d6a5cfea130013800daffe430a3f361b645a14d9946a263f87ccd45c45446c87886917a435e5e9441b199e4ef391cbb96917a6b8cbbb3d6722f89f7cee136900fbc2d3bbdbb062769b45d7873cb822a9902b9a19ea9635b91a06a51d6483bebb95941917a890b3c8ad2ac5d46f4c2945fdf6cd5bf284e7728a238489f22793824ad894546daff55e92f0024e08d59ab371f9e992cd4031dc753fadf3869a059051261b4c16ee680885d34c7b25ef8bfdf1b605a9b5234645a34feb3b7d74f19c32609e2b5e8bacd03ed2b2f9cf3f3cbc20156ad5908b4561f62c77a63c3a6d031b88465fd2a08ea6e94f6fbf702ea554c094a56c9022dc857a07103693d2e9c7002bafac8e483faaa17cda85b48f6f627478b06260670c6f781d12105d21d18bdf79cac84538f6cf54b53841be2e1bbef26f0b54ff6ab3549473284908a6189ce2b560d1640ea985b5213cc0549c90408114defb9688272fc08cc72f79ed3856b0b110da2751c3c06f1bec518d633c825c40c22d193fe1e52798e875e491f93e5b4caa91c15a25ab2133a4a167daca493f6086096658ed4dbe5c447c74388e1a2859114f9ebf19378d3bd4d71f269557f7fb8894f77a147ea5da5c83d38bda856d3b81989e6da837b6869a54ce46eea68daf3528ebfe2f496d3f2875261c94212771fb2bec036ea19a90429624c94fc82d8de9244f01c669342616aa47f9ca83a87af0181079f4e31a694716ee32a702efcabb122463405228db6c81f13d2391400eb5e6ac0c6d6d21f7f9a2509be7576a9dfb9a262e5834334871a4acc4ce59971ad8a67fae94971f3d1ea4cf0c3e8143d25179920e4abef5343f871fe3a8a4046aa5569f5f1dfec8ea8b48d82f645e087a5db5e714343ed025df103cff79e2613a2a36f690d049f8b88e8ef8479004dddadafc3b8d97d1e1c531767ad7d89f613464b696db24904353d7502486cd49df0e833a684742f9e5fade02ca0a51154cfb80598197b204259b0225fa041c98e9c7b30807dfe34f25b80e8110b1049e8608b89facaa380d3da028fb37490d07821249780db4f224069db91af65c489219b1249775250329feb3ae5f933be313f2e3fc3ea8f40b7e6f320c9b47e0cc01dcad62921a1a1c81de97d1b4819ccd7fbf3a6fe807105e0aaf33fb707a4ec7d150d5980045ae449d60926cc27b33f0d014a60d53ea14baf34bae56d0046e10a2bc820a6c5efc6d3b2e62b707d3242897741b5012d0cdb27afa851f6dc280aad85abbb21c797442708f1b2801e6aba432a14004a4be3a07b4524b51d64e1a6586deb67f2b04f90972ed6431e5f0dc1fd67ca81a5b738e141a6c1f0aa86208c793b80d3befc4183cfc1e292599b882072d771287f6473cdf9fe2ebd76418cf1d9369a147c4d163bdf37edc5a91afbd405241afd504ce1d365dd449e13f18a10f1e3f6b414196555c11ad7b12d4fecf74111c9ad6bee18e337009e9ed8809f57a97663273dacb5bf87647bf1285f5b95dfd23a16bb8d418f6fc1faa0c20fbb20f2d3babb9a9497d10dc76e624059e04e128236dc7dbe23732f0ea2bb4f35114784bdafeda6e03af77fbb53ba371ae780d2d45aa6db7ce98ecdc2a48d74d61d5577e7980a16c17cacfb3f675e553a6b5b8f7e47716635217ee059388ab5cc8d78ae68d56ceaac1efb2a7e2e1b7a8625f853377f08585dc054089c90df3c0c7e7d0a7486636ff157bd5f398492774453db64865fe1dad45ce315b032eec41067c0727e390b210a0510a9d1fe5f78882eddc1790a5504ca519688cd5ead85ac1527b93f7832988339a1d92c7be616d5010f96e5313f59dac87790f33597ee224b9a28462ee0ec06c232ddacc517914dc333562ac73cac4c6b46addda51487739c19564c590f6a92814c0469cfd42bd3c66daa647d40b89163c6c31d803f16a1d160174b1d4f831b5d4d61b6739956d2ac8edac91cc2e491fcd8f273fa389da3e7b527606c4873aea79256f570ec95514941c2a5cffa8fb6def92fdfcc12b49f2614b44971a8818e912f2fe26e2fa9114ea865800d05b2439c559b21fd351e795b62e72555c0bd8ce87bf598b903f19b2073465d42bc6afaf276750ba9cd7eda38d2391ebd693db5bce2f07d668768e6084276bb87c57d2e864c2b891a6f7c8649edd57378f27666f0e005f0f57fb7755a28089ba8411ad7a0ea62607e6c17139c0f6ecd0f570b68ec6c2501dc3167b3c60b760cc88bcf0763ffd1305a18e59e00e4852eda8300d860c0aabc946013b83874ecd6d532e5faf634b1716511688f6b32c879d7bd20e825eaf68ff3316485d7ccf69000cc807a64808916f3f1c2288a816b3c6037d85de725b0b3438d8daa2a24231d4798ac8708337ad31273d869fa91df67ad83859a6591eb099518","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
