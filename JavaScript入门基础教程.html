<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3ef615f357b58513201237ab2d0f2ac23f74af67a8ab386a17d854140967d201a638cd9512bb2167bb466aee7ffc900def89d42b67e57ec69700b3d14d0683cfac281a9ae48e0a25d1fd951e9ad818589dbfa3f4a944515acbcfa2bcbd107bc0384f219a17e01198d6f0572cfc772316070b4b9306004ae5622363147a9a6e4c89d9eead5eff32b41d7262e772649ad2a52f89a7aaff50e320e23b170f55dfd46e6978491b2b831a48b25a682c848e73778aa5aa7f4090dbca4cdeaf73470dd520862130fd3c0056991cf6553686c36ef3af286f756459d87f856c57a38f2f1a26da0c40ee622c92b209da79c98c9ffb8dc4d3e7ff6df5face58ac013e0584c73567d8a949c7bf1466aeebf36b7ec6fea19563757953742b0785ce338eef0ad85d05cf28153d42013910740623b09fc08c4decad7a1f2194a40f3675fae193cce25dbdaa310f18abf9a891404708b43862a5e147bf4f2a554ed651cae7fbed4672bd7d39de9276fc3ab3e517f408656a56e1e557cd2aa58c67b159751a01aaa4a98a9bd35a957cdc26a18f789f7dcad18610b830065e1331c933ae498175be05bcf9cf6d8a63bff6c74421308d3c69a9433006c79286db00b398a54b38d5b1fd0bb23dfecd50ce8cf271ab1240990eef95af268707bcf8c5bbc7fa38b700c19f2f424b875c3e900266163e00e110b2012f2fd9703f99258c5fe55743a0f6ca753b787c0e750683518d032b13d5d74f0d36edf22ed7b227ea13b653ef9e70aae82d20f184743d976e72813ed05705650fc25dcbfb38e362a36da3a3d8f8550166c1d974f7caf2c8c6558aae21c70b34d559eeb1251664d1ee815c8565b0afe3c79e0e4b6337c9a3f147925ab5245f85758e81828ad367dc91106d3d589c24e70ff85c40fdbf5dc3c5d4b9dbc875fd5b82f38872e27e4b1a6ee0d818aae7bcae01dfa948f197842f030a057aeb34ae10346d8e5890b91309776a80e053f4f725fb02d9698b57af32139799d714fe3ec6fbd2c1d2f56ea811e36a9a0ae58ff0bd0cf350cfeda9d3a499868752eae5e921a6d754e58071d9d2fe7e4e2bd30b07f06d61510764e2072e0f2d712fb87ef1ffd62a33489a36e88dd3f0fbb37e26fdf4ceccddcc702fa4c0687a3f332842a8b5493d039672fff56cc4ab846548b1b2255b7203eaf80291ac8d8f9e48cbdd09cb632efbd756f3b76aeac404966486735467bcbc1b1647a940cf1e341d4e9314730fabe759fe96456ac658013981f922fc122ceb1100513d552c0b35148c864e2909da5f49f5b6949be4d9f083f73aa0869a62ec6a379a3da039b6cd6e37523e418157223b70dad72ca804eba3ebfae0ae4ff4bf2c256673e315ff98ef828c3dda47ca6d3c8447a0190e33e400dd764b7a89d4f502f59ac83468f5dd956f19ad2a4f9a441f2049b819c03be3f642fe34a29f87299cb83feddbf75a5c52959d80940846cf43610764cb01f371718ed6f9cb05de50f92d8e64e7838fbdbe7561e080a6af6ea61c52d29c1e4128de37c5826a3efd619df3bcfd9d2f7fad83e8ebcd7f113cf507269ce9e71b12cabeb522ea7b9ee7e85599ca465cd75ce55417459275a05504df0597e5054f8d0b6cf8bfa011d6b74a28a8fb25700e5cd515a8ab768d321566e5e3abd3902d0a99cfb9d73692b5cfd5aa468c69ec9379480768899819d7186dede27c96de79b8ba3362b9c8c0d6967bf3a601e05ae75c0845c2f39a60c68bdaf143242c83af676279b1f2f547babf2eee975ec1bbcc59f6ad6db22e2caed5c039243a0899bdfbaead9d3310a38ee7a097125ecb9495d1863ab49e09a7fccb338f88c42adc76e2735ecb4d2772d7af1f8dfc0041a750e5fa8fb90fb7b14c06ac99bce6eec1d61e551877b285aca275b1dd9d9fec56c8f393291c0be14e8b9ae3415278c0f541ba676ebd43bf2643f3847c1737ea96c2731f0d1f7982e47ae324bad397d6bac3f3386f7592d26fedd909e0e3c9597e88cff836190d546354470e77b6cbe5ad9d2361c79de664e803d9ef13f75a06b879cff4f140249717943220c163a482abe63a5b62b84946ed88da388aeb08d667831a7eca04ddf80de96890ba5ef31d8ed1f34cdd91e58e2b8667467b66b93370678f40d08f15cbbdd64cc9100742af505207235fb29b2712cacc771b8aaec5daf09c54862f6d743859b5473ba5723ec01f1369569cf780eb356fc83b5b4a3ffd7ac72184958fde95d5f55e9c2a935c87f55262cb1eff85c4d68c7beb34a199081c29d8c6bdf2e2d3b91abc172c51d7b5c07e6165ae174e54444bd298a59e1beb1770299c52e224d5e0923e0d040b2c19ebf53ad4247955c7a26f7e6950659a9997c2a44f4e1e037d5d6a4a0a7d160d632039ac575a4c4dcf77a0c1a8ed33ad109c0c5a650216eb03370cf6dc6b21695fa814ccdb47baafb43836763f932ee88a008214e89ac3111f2b0b8ad03e253577c9689ef60ace748bc77eb23741c921a5d6d49220b95e8318c1cbbb19bc08174577ab7d03a0687fff407f9af19b5bf0970caafa87843315f15f583c6ccc5d920bf5d9026f3bc87ac358721b6a69ae15e3016c81326e94f487480c5371aa2e8c55da0f8230d2fd3341c423495734d321339598e7ce0490da0fbb235be92c9f6c63850f331a66477047f177f5242a9f2a1809bb08bbd80b9d2cad085e79d357ec2e599d4ebe7b2faeef4b38a59a01daabab72d70bb59ad2f77288d38406220c2820d4f0f2cadc1e41ff3c0b5862c2f86c58c27c47f9ca79948eee9bb529e1034cd733b286ddf8ad7702e1f88b9ac805ef7a19d03a797710096ae720b84d14a0d21c6eef3d50a038084d01c6ecc839f4a588f98857382e52c76faa0f1b3d6a25518aff1a31cf40975926266ccf03de09d3df38a5b6b0854aeda65e56a21e98c6394f65c147a66b10b94fd8f19e3e6f376b72b193f286f138d137e84a76784b47e4ce8aa5940ca6d6ad3fd58e4e89081687e3101c8e50159028c6318475fdb1558f31c1cac828b4d37f6e82c9d58bdab44f90de753505bb967e5ab2d05e42f56f4cac483480bfda15502a12a1f3b97937be2f5d6afdbfc08f2f20798e99f5979b7ccf9e3155876f7ae272dc3a1160584f411e41ada01dcdb740df6b8c8c057c409e87f3bce6639ea0130739a39b92444fbca8fb11ade42d109426bf7c336141cfea0f6fbaab16f8bf67b7a043cc1a847335912f51499324bb74d959994d88c054aa4147f363787c3a263a27e5e02f7ea53b7c2372c723e20d93d5b5d2d4ace420de37a5ce180a59919c16e0e8a88769ecf86fe57c043a994bcfae5f7e1fa20e38d8d21ef7c055ec52278e48bd433edbcc5fdf1d2b8e59a225b0c446f9e75f6f1cf3933ca470f14f0cfabb0e80bd421ae29c947d4eb6fada234ff5a82e2ee180acbbeff0f2152aff009d86fd524a77963fb36a4dd4f129eb902d69532c7932f654ace171a8146bebabdb5714f36e68794dcb7b662f36207be9c9695c351e0113f304421cb4e2ceaf97f71438a6eabb281d478320b21d92c8ec45805920ef682c6a9d4e8c58d9eec68828271a6b17c51cd932ed037c411abb2bf7253e58fe40ac25a8183c934e3c9cfd7ffbda5c3db3dba64c54bb25521eaf03d10a233940392838d3f57a4afdbc4701ad7f5a081459675cccd59a6be2a5fb56a00c38255867231764a42ef9081c50dc189c749a8dac33f64cb519f2b5c9db7d368c91263c5a7321f8c4426223771cf4a2f56fa24425857e3d77a011c3eae0b74c7c3c9c3c8cd9d0a8b9326262529e2e195c4630c292659024b64eec66ac2e414fb5bfbf14b6720df009c3c42de1ad469d5960b28c4f5d02d539906e4550183218a8a78feba1c39365394df34efdaa058ecff6598b395514077b27bff3b342f3dfbd4ec0d20c10b113c48c09be18b8218a495b28517909361cd46e4d389f86ff987c31d8053fe6922691ae4f30f64bb4c015c575e9fbe6b3764b1c99fbc2a376acfe0665a4e3f9338a44bae10d10c2161cf6290b56da9bed447b9122a423339b513034f19ea9387f29d1179ce3864db01189ddca4b59e91c32aee77b8388624c2756518760e9693edff53759dcf266d5b551f7708da8f25518e4dd764c6ca7272251ceadae883fba152a984f779fdf8fcddbd34c9dd43ff72fda1916e8ad848426cc32fbf42e1c287b351d1a4b791df2531ce43b8ac59ee746a90e1ae77bdc2c19b9cf520bbd2db5c8745d366a281bcbfe0edee163318ff9888b1e7dcd0e6bedeb83138e99c51a5877cc9b6f954a8d241b73126d51d579c775cec4555aa85b4e663a5511047314b4e3026667198d470af57eaee59d979b9165760b42e30b4d6a438261c46bd74484ea335c15f6b861ce53f08754bc95cb76dabce2b35b71d482455b5c629bd4cc3216c16e38523e4218989c8ae30d345dc10ac0234b1885339127bc2746a750e27faacd98192aa61c1912aa3c6dd6239ffdb874f14f384934919a607be8325ad3a425b436f019a264641c9b1be469ff1965c2088d15c74bb3e05eb51a51c801ee68e536f06b0dbdccb37d2547dcd804229095ca61c873810a3e9b404b3b86c2e69c3802804fc9fb4bc12fe5acb512bcf6cb73d5529c4dec200983d8f87ee2029224d839bec1bdc9cc40cc42dd8031392577d1a4c320e8db8114c686237913c9a26afe2469c61ce6809fd4bb2e9c31b25ee39c117f70eae42e5f73346c9de196fb354f5e4b38952f517a2d82d3807a027e72940ec334644740e4f1e5e9a099d1a9a7aa06964d13010d4e0c74251966766452897eee04d0f30ec9ada87dd6844d50b398bcc186641802c462edcfe758b81b35ff7ed287ef86d0c61978a0ad61043f1c94fde62f8a5656904ee327dd89e85229b307b8713966a42bb6bc4456e0a37f062d09a892ec429b7ee72e3b08989d433bb8581095406b0252a8da9ac20f6f377c3d82e0889e8364d9e6b62c4e7f56bd45b50ea5497396fecb9df0d467c8ef72b1c0b6e2f424b7c6f7f96d74d7b04f67914c93ae1b04e993d85a88c51bbbe7addc2819c5ee22285211c1adeb3b6c0fe445ad6a2968420f3537f796f1caad9980bf80c0ea89a08b9e39fefcb111b40baa54952b8f3b822671fbac8032b3ca4f7112ffc9200cbb31b70aee13b4af2f53e79c869f195f4a28f5aaa33b96c5367bd2c4643617fd9b8d5a6c9dc81e655d5c42a0e5805faaa95dfb0d8d6c68a23a993031e2feca653074042429b1aee296ebfa6bf220299f81a1f4bbadf4cf18f03c28f2073bcb9d81bb2ebc3accf781c1e073ce64d980e6e5bf4effd584a57d7a14a6a5d47e7130088a2a2fbbd9bfd7b0169cdcbf97a1d489707a220d9f4a0d430d5ffe95709b4a024c523b61ba4b44a6938edfc04a03fe1447baf602c8a9c7860ef50d556f31a613cc7eaf818692435fbb7414efafcf128e7a7bf0f5722d4cf61a6b1ab83f28a2d32f4523d9128363a36b5718ca8e0f637370538854fff1c75508dcc4ca57ece5c6183617cd0ea5b5637ea32699772166b3e358c96818b04aff91433f8a252a9b576af13b726da428c090b29d8d8b5d0b21f7672c3c62da96ba93367dcd42ef0c413d55ce6a15164d74632594c3166ec3e878808889911116c72aa0c33e5ea03e0fe68828b909c4bf391934411bc65d7d679c48c0beaa7b740b250049da8fccfec505546ddfa5075132072575c3cc5e35cc6af814b314dccf11bbf2a9cffa13d0a28fc95300a17339f3b146b90566a69183317c249523e1b29e324c9f9634135968ff3ae6a3fb819bb581f8099737d783f6368c252a4764201cada68701c0f0c7b9c36ffcb55fb6fd4c773f65c492139685e53c9d573c516d38fad817a7cafe70e2e6ac1c1aace86257c781afbf2bae9821b7b5e9f7164730e439a4ba2027bace30b25fc5e0afa45948caa1ec9b2667f976d516ef1b0a9a2cf27681a341f7d3eede7dc10dfbc962430e3b5dd095e1f31a34618eec36670f1527565e1946df1b05afb2b7e9dc14cbad6f9035402bdce62734c78b58efbab1649092a633a604ddd26ba061885656928aa85db56eb6b69cca035f720d9ea8c7bdf1a47a7aa8fb63c8e935ca95cd3c4429a782b3128d16a08639c0d00319219d1dbc216c07f33943db16eb3f87fd63d7964ec68f00b32414638478e65090d4c337f3f10be43b1f0aef0b3d5a7f94b9f516dc25a06c032bf13b9943370e456e5f2ae6d990353b2f459c26a3cd31e4a7ef5a89df33ce9a165c99bdb059952db6b97aa37da0f5835aebc6dbfd01ab9a8cff11250172a3e3a3ae4a5e0a39228d695f3cd6db9a285c994a997bad8119193b6ccceb4c71504c818a3bbd94ec1d6c10b164fc61a0fa88f3847e61a33d6c143ce3ca40c01c9ec2162a6f432ede219d4b08d0614e6ea83089a884ddaf042fcf4ab6c069e07bf6d19a5aa9ee6e4f3f7d7d5cd0dabc59d56e9161548a972604b05b236252b4b4f887ac05ad83f2b8cd96edee38c28074a46b1089e707b48b056da3bb20209ebd6f4708933a69c54af6cf4325fb27d4bb1148c76c1448ee23fdfa511b398d6c87a5ac2033770b37c163e88e49908c6c09b4e3bbcbd66545d2067762294dfbe5c79329d90f4c6705d3eb3be2ec75209c6161cf261f46461d73ec26be72e1cfb9b2573ff8c73af634a93148c936ab699556978da1a920e95a1a199ab8f22b1b43f3a2caaa99141bf2bb342640324e72fc2005f016101042e4672d15ac1a720b4cfb01e0c78d88beca05a13033c250b0511cea7ed62737503a0737bfda752c3af5117f2ef94f09b2cd8d648a50a06bdef49b8b24a44cfccf35248d2cf5995e45e4b0dd32c6bd15b14f67e7a038a4b0418c2473bc2de972f9e5cf1749241ec9bc3592c8f88309e5a155f132301f1bbd049882583d4b234747d3089eedeec69082c4d9dc85842a22068564920c6527362428a84217057d4bdc711ab05079088e00b365dcc87783e710d818f8b3e2276d2b783a6f60b59694312e6a0e402004c2974d755226a370a68e5ce15efff8d888654980f67aeff252254bb805a66a4f6c608c3acac4d01994181a909012f99fecfc6dfbe30151058b1dac9e719308fa9e9ea993d089d16c9b32e5833a5d24544a4b2f390c460b73cad9c60e0255b812b1fe98617a3b6a34da265d70057c0c996aa8f7a92772fcc41c665d766446c78caf1ea80cf7d6843f7d5da7f021b6e337f907ab66744a004dd5096c871f3410a675125167330c718506f614a0051f8e3851291e68ef85932343748d8862ae753eeca19b4bbcad1a149952ec1d437caaebbfe58db67fdb1a679694f31a0f6c8f683f72eb915f73324f2006486db1f1f41954fa46a8e988c83a56b84478264269deb0c69104c0fc17153b2d5a870e3db3b51891e2cf4b0ad8f837ef41ef06e1251a6f62dcde0b4dffc37daf1f6d37ae79ed00c46c4a7beb7e95becf82f78375dd085d158cdf4c237621eb5c6590da35478197aa9a6e96a474feb0152f3a32786cdbd4fbe00a9619d7cd6537520c36c43da4c1b09923d86d00d5d3150af1aa82f731a1180642f60c67853d30eeca2b8fe2df90d37eb745704aeb046a512fc6ff2b44a1c48480aa6fb23bdcd824f728868ee5413ea431ac2de670970c5734eb8511422ff6cc528df3439d74ef77b2f3a45ea52086b785ec5df93cf18b1d8761985a02e13b8b0cbedd5b3ec635a73f8447652fd2bb3789ae2ce4d8f556bf1ff8190e96547194d9feab0101cfc020f5a9a2765ee01381975baf21184e9845379b0a9855e8b5b336b038459654e61c719451a02f14b6eb50dbe29613c708ed083867c711d3c800cdd712578cc450075eae774d48c5c8410416078ee22190d21d98febb55b9bf24f124344aee7690c70999d210c3e914d8bbbee89043d98138d413ea00ccca636f885c5379bb5db809d7af7b941371a99353e726e1fcb37c2e7c10b2efe8c1f57b819a7e5bd064ec1238b9628e13306889e232ce36fb3b3886a9a90b47864d45017eefadb1e0736f7064d9f169c3db5104aaed573b1c9fad1082222be387c00b1c2ccb4e6d84da2e752d3db4e716ed1ba6e05f9a46dad1445c185b4a7b7f59a29dbdb5c448cc848e09e078380501c8900ec2b36d064a1212c4f9c579f36b57d8a068ac9830c64e6ebf8cfc975b0545c564ce199d3a39d1c84dcb2806bf4f867cbd5015713d92295f595c60160156ac5e0170ed9ad30891ee1d91e2c6eab56cfe6c8ec7282a71e4d9726953118ceeaa5c79377e13999447b8c67baa2e926d77bf915682bf8688eb5aba01edbe01e975f2b323d2a47c2365a51074c481dbb48fee8fea8db4bf8b5088529e38dda73b5aa77dcee7a372792c60f9c476f55f4721b31af03952670d467e04af03961b5821a3e3a1d83ad04c65f0d6333e6652b77294149c017cf9478cf6c277a242c531072cd1f3f640546358deca5b08e426ece0e323a23574a69e9b48c0ad961dec415a09876be853080e3941e0bdda16eecdd7e11849a6133c7230a52d6916b6fdcf84276fc693e68674f5c0d4f7c3802809eeb7f86564d62bae57b9619249375ac9839fcba8bd30e8cdf743e1aa7a4d2888f01b52bfe46ad58e506a7503991a8082195da76520091a93330fdf706f142c89ab1aac2fc9be30203f6b2c96aa8351ea30f19f2d1e5da7c55a7a161cae779e62cf3c9c39e9965257acd7f90b2eb079641950671d056feb4f40dd74dc7a617ec4c2b2de92a7ba00a8eb83c250a5a5573f5619ca16e25de71cee5a9b8ac5a324ea473d9bfb555cc58d186d485021aed4ee801e5ab298dcb54643d8e86cbdc1b5d62e23f72a2f3a457faf0850a2dc249c1e6148443f55f0284a8711641caf1d2a67c6916aa692e3071b7354bfabbc278f8036ff62aaadd67859f9718049ae38a6c4c442cfe567c62e8363aea80c8cc2b33d27d19b989848a87ab26cb80881a3b9262c1ac0b40a2e8901868f3ca7406da49a7d71b3e36c6ff50b2f4e4c419bfa4e91a0ea2345e6ddc238a3d00aa69fa5eee94dd8d3e27602e5091324a0742bb3325eaee9c7ecce0f43bfb7b08b7cc4e5299c3a4062f68cc27a4ec66e3665ed055254b4a4d172e21f0453f405c6e4269fd4c05d56096748367238891333be34f53a06ea5b903ff33a3f5943a090081412babd3c2a9f2ab3498977958302e8d52e23cd4d703b4f40aa0b16824b7bd28de286a6e19893e23d298abc3881d3d5fa17e1bbd347fb4d42305b8184f0f4933370c6f81c1a8b1b554de1662cdf33e1e081931e00191e143c07f2649c0fddb8189095702d9799c2e39b0bfbb95a3e41f04d9cfcc462a6e85013c6050886d070c9c8d2e3fc8cbeb4fc177faed3e8f33041ed68c38bcbf1687cc3b1b8c45a24633366995386dfcc5f0e5fd1cdccc0d059e3c0eece15fedccb764a0b03a1ec146ef2df61c3bf0da82f073c4e39828dee35b09d5538e76ab2b169cc108385b9c14aa68e6940492bb4f3832def523e4036d3328a34a8716670e3c1c1d7116c7a82ae1effc3c5b2f10fdb3fbe974ea1dbd29fd4f0e8ca835c6418575d7d3d66f8965ce0c4a0500135a02fcda1eaa44e2baa19d1be3ad4f4a9cb969293a13abcb87a3ba70383f1e1052c0ec3d68111841e028f56a212f4a1eae7819737a6652155e39696cfd9b1e270c891d098b46b2bef6f4f5d5368cb89125096c552818d65d94b7fa89101a45af599ff7f1c1b2adbf853a28bb295dfe5c8087f139dbf47ab8f44e6968d797c0088ab20d61651426e4d121369ea446d8350432f331532d8666dcb9c675f0b30146f397b439f3104660436a9c20f280949884842cc96e1524530c8540e520de6c376f8e309b7301b4d86d26c9555d4232fab5628f790adebbc5f8961d040657039f164f6f99efeed6a4b0544320a3d536a43ed743dd026f25ca2e13846441423fbdcec40510b4b4f5a66d2664b1e1d000172e92522b344b3c219423b8e06d65ba144358d55a151e424f965a88fc85e108061ed65678650a7bfa295ff0d6b64b1549c6bd556e732f41f7f062cfc76b4aae32ff805cbe44aae4e4241a2bbb68ac8042536144df9522114352629266cc2253049767dbd433a5c6c212bb4787001cd7e83a6fb36322f6e72e25bb7219f6ba8ca2ccc9f2125ee3824613311a1145a893043a8c0e15d6c583f353aa15364fbd5d52769b0a6187163015f5f6125c2f01122c92f3adf60587b23ac04651ca7e70d7711c4d95eee2ef4f06d113fb029db6f7db0013f471f9ee1ec6b7c39ca6d69bca690f66db4afa60504091cf1cc7f58ac67d859f65267d9ffc656c020bfc7a68e709dc4cbfebbde412f76f116cdd2383addde8aae18de203bf118c59360e0283b583c25bc873ad2bd793f8757ef09c6ca878bdae453a629b9105171cf3924ded90c9638025539ee9c42bba91808af3905b0bf417e5f5c4f9b1c2d0d76e1a82698b497a5e900eeb63caad88c822b1ff4464a4929bd6be5477e75574e776834dfc3950d1317f0c4dfb25efb4f14abc78873b7a89dd6e86eefebd7a717bf87616dcf2231409526915b6d7c66f7c9f12c7860bd5d9d7f288cf69604a9bea1fafeea5b34b776349ffa398f6f8ac0373d10560f67c01d344c706f547e67e2519bb8c41001789fd74bbb78ea872f6af9b3a2bd8a12d517a9ea304abe8129b0fd521fc01fcd186eb2091740d23b767b1f8cd7fff82dfb1a52e8240625679d8901ef3929bfd154b00721e76caecfe4216de833276717eea53caff2dfb4cbdd40cf98ec094561d24627cf12125a37692dc8523bc1e43bf0ca5e759c54b5d2e84964624ebacbd7465cde76583ab1b742801ea644c9c66f5e7f96d7d2785502d31080d04d8e373b1547bf990e59b45d5cd7d2bfebb50e1eab82af241d479cca2bffa0ac89c0e6d68d403cb3f206171a9f5b770adaa90f975f236d2327cc9b10983a25ccdd81f69ce746b983464d9f83e18fb4969392f2742d94d8a0c0100572d2582f2c3a1959b88121e4f344d344f942deed3c61a8f3c2dec120f36ac1a96ce7461c3becbfe200ce7ef7f68675b817c98a144ddad0d1f4ad107e6d5539a75c4f6144797917d0713a5b6716e3c9f4fbb54ab76947052765d76eaffbcadfc424acf8129dbfeea7738771e6d7a711db6d7345ebc9a6e1402e4fafd4cd997cfc64878a9eac03455654c6b205d420682824001eba456123616d6abb566bd4a71389467c804b70359a40a9f370d133b1a444757ec7549bf685f8feee8f962571b1393f05b9d0d7382aafc19b4611d38091fbca65c47da373adef828998320bd6b035f28bddccf3a044d0fff509216fec8572206416ddb6c9b89cbdf2f4a0e8e60012c1abc49343c259d326feda8e9ec240fce8551c49e7655ccfb14263ac56f4f012fae4667acb230c5db2ecb67efe7db928d6b92aec0ae82631219c2d2ac907bf4423b95a5b81ea6d7a91faf95616972d200fec1cee5672bf0223c885b6f62e4daad498022044a4ce3873cf9413d69160ab9bd927f8d9419bc579ece71c246a35da2d293446381385c9770566b1c38266f078d702fa65db1c18c824639729cedbcbe6101257df74ed92ed191873acd21c63293a297974a82312726b4dac730054bedd055e76d7964b808578a2f5fedf6b79c3f42654006caf6f3e4ee2a64fa8a5e4ec94b09ae2d4d3c2ad630851ada9e976a93ad8a1a155dab18d5dc0d6fc9b983a68caac7c017195ee8d0944f1932e2cb3496837e8c69b2950e7aa563702e03966d3f7a976364e388f54f42c5f37a724a2964ff0d092942b0a976e61df293f444d2b2cb30c64e39ec261117adcc2508985abc793dfbb7f858501cb1ea3876cf6444a02579b88b204f23e13bf47d9960a68166bbd276af22c4a394a3f8b35a1f6419ab5d68ad562309469a60d65c8fcbb1cae00100af3cb3ac445b8762e8320bd683d89fd3b3a6e4f5a14b5454df498d8548f985097a5b9708606cf38b76655a3263023b52309cbd7a46f55e75f05990ac96d6f2477e226afa32e9cefb395236be4de9df58a12eecb246d9c0186238db2a2130374d76ffe8799316dd04a485fa37d520d95784041bad4cd5552e0873aa899675954269ff4b0f62fa16b4f13ab92a524c1940b5628bd5a33da8c7e724b844bd182b30992cabb12a6067e6102714ec12a5643974fc25144510862b2398a61c7600d5adb4691444deb2bf9324890b1f37ca7192f1e14215a8c1a9029ca5c2b1e863324feab4dc00a59b92257af6133be246ee7921b8c80a87678b8f2f9dfc23b1f987f277241db9b088655c706a1ec3d2721abbda296735916798ced8d3d85fc5666ad59cb7175190e0b7b21081cf697397868b83479588e362b8ecbffbf4811012882e2f723e723e12af7d4dd95eefb5882e5cc31d431492e4d72b9dc898ccaf3653f0ea9ae185ca0b4e52bd44ffa1f23b170494881a22420d66b02a7cfd67ed80ddd3c28e223e1ff2554e198769cbdf9affc60b99e971e2f1327a79a21e5dd012e67fca0700090d77ef832def13c749d7a0f01e1ff38d13600fd1bf535390337f8c3d50fcb0fd68cc3bb8bd05656ea71092e5151f66e7a356d8a910323588120f982b99da6ca27b9930e1405bfd60155d1fbedce7cd1ae9a6757dc84fc8c01f57cc41831634d5aebd9609688a885ed164deb4c2711e4ae69a425af047e164820134ae24549836cd42bb60cca182cb7398e287208b2f409be78db175b181643b04d516ab92eb40b66395009e9d366fb9fc6a11a4f00dec1a97d46c5b22e3adbf18a04e60f5476bf40e33d3935d059864336d44a338aee938fed5017c6c9e71ebb8f7a6b06cfb6762f227540e8049d2c0046702e2b414b3ba3d9217df7a3c08f7dc36c8a82ef26082ad68c43a2206b4ffbd975a8947272d660749deb5e783ba2df93a282d3c8890b5424e4d63ce883cdf39e27ce6287023aecf8e4456ae078bdced63bc257ee170eeee4a0e67bd833963e8439cf01024cbe27ab8f0c531226464d0eff80daa14ebb678dc49c959fca10889894c1546e6d5b1743125ba144d4de3b04d1268fdcee09a28b0df0cfadb6246d2fec63b06da06a1d40dbe7cd2e438f8d52e507e3318c2a3e9fdfdc23c4a3968ffadb291a0b7aeb14da674d8d4389edb497862eea426a6ccedb7b86f20ad98e2a3b64f7fae190fa16c689d117b12ef7b7a949008a8ca080ecc7093260ee4e25b9c4e981b1c04dcd1f4b542da186c3f9179b74f8f0bd4f8309d3607989798fdadcb7ae5794f554c2dbe3187d2a5764536b7428f67f25872b09888b82430ac9a80cc2a192b9d19d9c84f2a2af8d8f64c7ee3dd0a6fad8fd4a3797ddec7648decae191a33ddad1c9275bdd17d5bab93b82134decaf235e94013112b05bc198f5d025efa7d0deabe6d76d9ab76311ec30bc5418abac87b10e2620dba3310c8e1322b554a7dadcbe8c74a586c0bc0c3a89806ed593fb82e32c5121c86bec17444634559a3f848dac9537dff72b3dbc51f64ce00a8eb7ce542926b0008bbe71f65c5d28e7667c6ce492d859310fd6a177aa1e09251463e7ccbdfccf998226857ddef0866a01d269b5654d9c7d5d6d4f6a625b439689bbff3438eaf703bc3db2f9444ec6b30a3b9e75dfbf431c8509bbac811e3dfd0d01ecfb85d12b9737bf5cb4a394da83def4d289c7bfdccf5c4fa1ce64c2bd38c05812495e60847b8cb76f8cd74039d7e2841ba3b9450655e1a55c7a37316248bc638db11e7f20465d4a895463eafa35b13a284506df409ac7151b1eab495ab462888871c2a5f7935f7e5e5148c082946db35c838776fb331f3777b649ce418f5a2a78557d6e693c49e0e812df3e72974eb95bb0bcd3aa77faf8ab208c3518f2be4c917cfd855e6f0a4a9f63ee478f372296158a54275a4bef63abff1ad93e629faf5a00ac52be6af18701b0bc7504387a2e8821ef1909374dde43d61c022b548c4b3598be809be433454047302b13d0c69f3c746f69cd0bacd409f6938c8225093e59475bc7ef2d42dafdb69f744d86f246bca48cbe127e7b9d5cafde2c36656e5e459cee218f70f4508a91f702ec8ed78267ee25644f30ac0dac15f5e3858bb5b881d459ecc55a91cdac4f33a3ec3d9ef5866d57013120a51e251dfc13860220900ad2101b5a6862b04d20cb86e9480738f2b2918dd626e79c81d4366aad4e9a57d2bbce1beee14ca74ad33a264142859cbe1fddcb4be75ba8eca8bc6c3c72d2a0b9f3079a23a4cb04b6dd0c35dee8c91ce64c47af89d8d2eca2ac164e254eafe47a04b63a6d9d856bf91476df43362fe18146b20744a494897b150f284af6cb0b31dfda69c1995838a211f2e788a30d0aa69e71f1614601fb0b4f43fc4237affaece4f7bde8b128f74594ad727b40658cbd24cf4efac2266119cb489d56dc00b8d7dd8ad35477a87ea713b93f1136f9e3605875cc61072295910118607a5eaa116e380ddfcf10b2b00d752c4de3db6b1eb8b5cd4f13d233469ffb30082a74a12711448d81e99f0c691432c3ac89b671c81a50efff4b33c293a236f3e9af43db101d577bd350939f7e839ba4386ba606d9a40bef65ca984ce3d41ba71c89ed58d533f95688ef770a132e22edaec367f23226540e1f23b172b84430def5583b3a3704d327aac22a60712ee8898ecc29dab83b6cf6ffccb66e165fcadaf9affe253f468dace6aa5c843d82a7598f0cf173c2e0a3bf3eac9e9a356b761982f52fbe1334bda05ac2a8241adfdb3bde249e103d9be2f800a67db840346a324c9af890f1c0afe2f78a3293503bb64fad105c40e719a24adb6e760f7adfd05673e8c1e7c79a9e80f98314855437d509e7acd18198df48b30884934d69d5c8569744ebebb0a4c43e8b954ebba597fa0ed1aa6055df904789d2ba18925d38112780515fd7379b8f51d5cb6c1ee7a840b68c952603745b22b88d735259dda8bbabc6af2658fd39cd93eea8ba9ce0c4cc5acae62fce15a0f34b350587565f96c67ad9c240597d67f54ed15252856a58bb2ee59827201e76c70bb50fd6e763272dffbb6bd46c3ee2f80bdb86762810e5f07a637af4add801e58643683d7740245a1b9f70cc88aba06154da0ec4eeba85b0349ec7ca7fe7697fca1d947a0fb3f690c2a0a35e8fee7399bb6844a0f48e519e56ad831d140a0f8c02a97fb79ab7febe43a0d83e6418061ecd054e054d47097a1217641fa7f4c45b9adde30209d412ebc659edc16b5ca52966d44cab6e40f71aaa4a991bec9c74554f7a0c1ff4a5eef5088a0d3670d60afa029791425119d8335e94a2fef9326c2eb9ed73b19c33b5742f2b16011e7f8c06faf5d3b5a8b5c412ef000207e53ed6d9a5f0114378c6bc4c36631dfdbfaa3fd23ec141fc66f7ecae2f4adf9eee4fe15d2cfcfbb23aa454320c84a771ad9bd2bcd6c18ed9b81fadaa77c9260059496eaf3cb391b98cca0e034ac5e01c32cd2d697daa31c8c80f1c372674a09894169e835a53b454eb64c660ef22bf2864cbe30e9c006a1058720b475ff611956894638d1a1b77e4ccd1da16a7c6cf76d899ad3e35b522afeb87e5f818df3e2a00be976ce2b9a1adeca4b709fd2b10a9949a8a6d7bc5e1cc343e8b9b2263c3b3d1443bc2c3680a6d17b3c20d06e9bcd5e010df4fad2b3498466462576d79917793e19b3ec7c33f82b9f69eac38d88e10778a184daa9a64166c2a0410b567c7ccaa9a082994c876e169c91df97bc0eedc7f36c0cf8e17d596b21d650220778d2300ea7e3b3be718f13db4a3dc0fda11bb1505aebf9ab24c1c49979c61f460de191541799c7f7ffa91bb39cb03a551bd850a46634d9fa1676d7a0d8ea83cead5f629b4c652bca3cb9effc1144115f039c4e5be2980a948eddef132571b398703813ed52ae8ebd5054bb23da571fe0f3c73b4a9c62f97beebb569acb29b71d64cc50c7bb90ff3da717549123bdf67e23180fe30a9a62bb9789e5c2e46a4a258933231884666e111f522685fab0667771462bcc442174b0e2b4ad23fcacc71728a30fba52cc10c5e69c1f8a7f730b2da5bcffdd2dd9e13f538a47f7380ccaad1f312b42e96e65aba22f5d261c9806fefacc34d3ed03c00c6f7d0e71b700f77830243d6d250b729663d057077ff283a6720d5496554234e18044cfa3360357e3789e5f0a8af7e2a32fb60e6813035dd8cbcd83d47c5a7e8ea8740e3bf473f459541288fe3ea85c03335dff77d4dcba1b52932cf759144aa7ef4328e1c3c8025584aebab18d311e5d35febfade4c40bc61549725ea37f2cf84999753a84a8d9a0a123a44a03af65017b5f369b9a00157d42a10a961f8f7855b54f7fdc8c4dbc254e88a765d4189d266601d430806f54edec7b79c2da25334b1fa9794d4073064854ab9efae469bc651d4c62c23d3c4e80cca1317bb2a7b05101dd205d7dee56519d0acd980fd2e3d3db65f8b6be728b931698dcdee6a325912db6bf81d7626b86073592b0f047e2cc0ed16a922c7efe80ea25a9ced4239725cdaff0611dd9d99298171250c1241430474ab9cdb50fe028eda170f03e9bbdf19b084dae1270640b9f9ecb37839d72a0dc7fe7a18200370d71c498191ad4bed770830eeb587f79d18df3ecbe5050105abedc948cfdc54d9e902c8e6cab4b23cc5421c3ac5c80ae061ea4d802fa6e2f777b511d105b1a73cc7a36e267109beed969a0c5d4b9d6770bf849e5744c4c335a8ff824e34557faf79b9069400c44f1d12728fb334f5296f382ca0b85968890750ac86e36608d8ae7b3c8330e83aed372d207722de4cb02a9d2c3a447a2b02aab1c0cb6e4b89896cc2bc629120cb884fd2080012f036f19bbe531c3d89a19e040839b77740d5a71e1500e8a4fc9945a94f3a0f33e1bda887b52f32ff5e6fd46df584cf03e8450e5feeaffdcce866cadbee0cc3fb3eadfe3c08227dfc3ee62b704c81a1243afa7651bdaa963877bd3e15ee8356a208171bd5160f3ecfca6d8cd80c230dc30fa563f1479366a6cd545ae829913e005680bb5f73f83f7dcb3e20a5e66f5680fe90864095dd50ee7da4965f2e8561bcbe0599bb4da70fdde4018b1914b0a6e0a919763305977fec8a1c165d3135e2ba5018161a2979804aac1b9bff0e88168668b04a740f2a514850454e67d885c05b508409e89887dd0cbce5ae62f2c7049b4a07ab8e692cebae9a6e0a2af59eb1bfd35075b98586200ef88f07e484d5b18cc626c7f5ab9552d13da7346db4f8e54db139ab513ba372d5ea01c6f3029a716d3bc362c3ddeb7e1679f84664cd70b1bf3f5fa3d60935dc15fafa5b9102e60322c8800e77e046c648859792a206b1a02dcd5917adbf1a3fa92f8fb514ca8e63aa7c090620e2682070dc70edd3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
