<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cc77d1d75546f147cd00b16c3e9faf9856628ff3f6eeae15b9e8fb9f72e584b0ddbcc1a9d75710c37121c66d5f317311be5c3baa62b1727e27202415fd0d1aa7f34cafd97ed543d5180422725701420a37ef8ca6bd691c942e4451b2e541f0fd1ffa022ad9605ce753659585623400bc3fd142dd2ac48c71dc2ec10eeb629684be03347709f5f54dbf6684956a32911d324d485af05108d55b41de7b14bb35ad027e6fee2bb7c84588d1219778ab5fb207f676ce8aced7ebb96b6811e1b362c6634b845f506b67e8a396681e598fcf8e32aad234c2ee211a9addd744ce380bf6092079c600b1f1ed7f82ab37131f3ef06d6b27ec4a05a92ad9791258bc98a9b683aec31708815546910660650a1cc1abf93a3a8ec1f0166e0f52203df0ba6518f857f9e32524b33ff8128f2189f2be7ddd2f4760fc133c6e1769df4a79baee880763e3a1de876812a328f7b1e0bca49771384379960a72d18be188dba70b664f5eef739950d532be48bf51dbc6c552763f73c027040e91f36bf6e44c1b0f46efdbbec90fdccefa5372fdbe4f1dc59f52035bcfed01f7ae98e18eca61ee424126f4c6b450b30b896755e5217e351d8912a6c44c89a718b9b13ebc3c383ad5ae82e57c93652e46f978e16f018beb5f1b3da47cf2fed4bd2fc3b782ebb9c9b8c39d8bd6dc233c151f25fe4d034aee86b7a179c70b059b29b60edc8a03b02f60df209eea6d1d15c04b0c8cf094be6491318e71d3fda10c30c72e5ba32ddbbfa240fe5c7bcaa7def71c8d9d6af5fa1f1337fe5da90f1226bb8998269e92556d3bf08d0a7b33b018c919722306cf676e319029dfc088d349671c192c1d5a74afe045bfb0675f1ae06f890ac2a172e1bf30e1f277f86dfeeb9e817d5cd27283d029d0ad1213dc659beb83dc8b428604a28a92bfd9c2abf850c240c9fa5d3c446ef6e68136351ae28e2230682b580faa772abd9d4711b75cae4d4d3be743fc55ece7fe3c4e23b127fd8d67aa04ed9a1b1805a358abce5b2df051dc9779a64b82b54d7afd5cd1a1ef7a8c4cc7607c3a6dc5fd89e40c723edbb3124469450b50e301cc9af77ab9dfcc631ffb22ed0f7b64135611528541ed6879268c5e9b22e0a351f57c9dc2acae8db5d1ce3b70deaf4f344cae855831ef0e171286c6537a015bec7bffd9e495946e7e1039e97027ccd34bd7dfe720874c83f9a5acb97dbe6381983a471bff481362a8554485f82c68bd1bb7128627ea285b8256ce210cd4b44619111e1cddad10ca6bf467ba6e1a4e75751524a8f9e3493900d4088777615b0552103693a54c891d33ccaa58e1ce1b4218afca0f1c271966b21ec87e2a0fada3251061f2b4777a89ae694443343381f581131088b23e5c7a527b9917a2596be460c52074743fb71e2092ecd3f24720a8b5adc1d8fa5d756db71a129aeb46275d65f9225c22fdbf278bbc2eb57ba03568ee8ddf93675aee322552af74903627902d84c7469a760ced9d5065ac4e551e3a1bd326e40d253dfe5b7a3b7046c7e088105bd3277c09a8e46fe96d9712ed3ae5cc5e87ea74e66be1271c4882dc1d1cf21c0da7949b54175de832adf2e8969f0927304745a965d01d3956d0aebc4900749dea3f2ebd040430a363e58df238e2ff1e13a635a220efb9c4c8aa60233b88f149cfde9929bd01001da655912cd32a00012d902cec78b06f3086c45391e2e4d26f28f54ac8ee96f492ca66eb3955b727823eb16e58769e981337156df6e53ae9857637b125622e0b61c8ea78b3d9585ad41b2669c19269d56119de2da862ffe3789a3aa33a91d8ac743acc9179cabd260f13c56df2331dc4feb9809008cfdd607577267ce3ca8d5d86426defa7ae48e778e6d6d9c2bdafea466f2285d58a500062784b11a829b4a382abbf5edad8718b59221e9d3879fafbbdcab73790b148cdcdcc3d08fda1f59de642d99da3e4a113e2d8b6052498b4538e4bb89050f44e27cfaa6ceeffee7f8d92dba657ed41bb7833980439395554ba86ab19314177f150e71c7388bf4f96189dce53fb1c7cc4a6c54d4223ba8f0446db423d53e69a1e4ce076e4d322b83f269ab599ba1f9b7b44b905c92c956d47af98928c0ae1a287dd08d4cf1f1b25c6391bcf64b90b137e7be5f8da6f9e7a4a9373c2bb705b649c13c647f8a15ce28347ea7e1a9ffb3fdd4ce926133a6ffbb31784d6c874bced8e88635edbdcc677faf2d7b7432ec6bb8e1c7e3a132a7ddc8e5207a0cc2f6601dc0ac0199a2b15f1f2d03653a9adc602d0b4d0db6714fc53abaabf0edf7f9d45eeab6d239249bbd17bbece6e9cb59de68fbc22ac11c5404e78b24bc33eb55419f4fdfa5c1fd3bd17b4eaff21d8c4ab3120c7a7bdc93b61b4c2f77a9debefed47ea03b591967cb81365473afc1c01eba4f40f1fbfdcbd8d338cf2c5f45eabf51a0a2ceb90ef536655df7fb3b8cfcff29adccd57fffa62b9c99a139c3a92e3e554a7d06fe5040ebf01f9b85e0ef2d6d81d8ed19ba6ab2fff3f5f2140ce50d7539975ae736408db332f95223d822bf42c79c36d85ae29a6dcfdc5792b9348b4ae874ca1ab52f37df4b75e64958e5c201c90aa3528bfaec6d8042ed1aba532e051a1aed11e6e0becbf20c663f0a9af88bf3ed1773d46e97df9c4194ec0a56d1cc954db0e70236b869dae4af6764a8dc1ede5f4882174c8bb0e66b72206fa0e449a78cbdc43045df54e6d319af8d121011a5a0d1f4f63782a27a1e7d774eddb80b74a4286d5c2ae73ab4968ba63109520ba2af01aebc2877bfd8e8f7cef315f112e5045c657ac62e68521630ed2f8ef65b0896df6ad3ca03e28cb72010843acf3887a4708f95d9bfdbf38cbda099fbbabfc0e44f0595593db2f66c7110c6c8bb5b3bdf9463aa7f6be175d90952fc0141fd479c8ad9e01281a1a9708f8b4edd2756cd2a6a413385ab1af0566ccd05260a124f47dc201a5d9cec5e79646c7e5ff53cf5e49b278e55fe282a32c859b00a36170b11202deeb62c1585bc37f4a50f9392292164a22d76245a5a32a19724217c62b4e4359d25118ccfebc65e8b4a6d60f54d8e0733ba7239b616712306faef2b0b6d35113d1d5d9271f591d7a6fd26073a8692a1771957f0beccf5f303f1ddf77db0e1268bf69a5cc4395bfb0d9a62c74f8ca3d5ae8ff25c4db16562e7821ed793edb6d44ea3bcc6741bc15996d223497730f20d4d9985b6bba805fe144cec7136c667eb388f0502d784f947ba9ef51a71cc49c22e431304e47ac882e4c681635c87a09c50a166f22ddf04d75e113600b86d2fe95ac56391559e5d732110bf288fc0b5605a052d7e7a225feae58627fde8776452e5ff86c48b109250e384acdf10798f68eb7c2be3f748d117c136a6fbc70f0b35bf33ae35b2322ccce978b0f09d08855e46fc24de49772491d165ffb535046e69511f736669c278dbb7d66f9f0ca8ed5be92c7fb2ae490a269e1cb972e3ed44d55415a4729f2f90e5bbcd4b8457c796d865bb5b230b63250cc1382a10bbc7408d2c5489e64870c3c02019e838d3cd934b430cdc79045f68a455374de2da39a9b319ac9da6d7c604518d4f6444aeba0f826eff7ba546a9ababf72097646c318b70da338c915023400abea5fb56f24d7248b349a46d126a09746de4cd2dd8618694ab3e374cf7b9a594651a5cd40f6db03fd1606654682f511f918daf69bca276a2cfee06972ed61192245cb7fb86a1d525ae00e49c32013ab7083fbb04455d449bd45fcbae015800ecd2667b704d7b9486075c9ff68face54b9b513ae37472f4db9e200b63619b833b7aca324307531106dec933c2da9974312dc83c4af8a3ca85b8a5ad417400d973e7ff3fc571c3e13d63604edf4ac65a324402b4257534b262095ba338042e400f3fb9249f0f2cad3e0358dff739d8653aac267a9a57dd57fe5734fffd93a66230a3d9e583b970d1e8033ea9d49d74de75c09ef2524fb198682b8da186f8f8ea98fd829dd49aafc89c1b61cbc066cd9c4dc36d4ed1075db174c02dd91bc008233c07c6e77ec7a5f6f46f66634e093737e9249e869dadf0cb1104dbc40ba0cceaa3ed556eb4bb30d3d76dcc186fd770af2a45a76dfb1bfd14993a3592371ad05de3caaf72f414db06ba36d82dd77871bbcce4ce7a6b0224327886e060c6e44b2c94984e0006f9119980daacdca84bf0a03940cb978e2dcee975b28782f2ec56ab4090aa54fcc712a4164e12f4ee3cbd5d9c0899b69f5773a460f95bd38ad8da6fc8a5593df5632bddf3a6f43c9e7524f86ef930b58cded4a5f9bb0672a9aa155311e990c6330332d424c4322388690f4088e693562c8d292975ad9c8aca1985ce44d85d002366f776ba755e41a32501d3e89014d984cd130f1f1e19386aa003bf7cfacfd5df2eef4d98f5bcd3fe6e248f58329b48079b334e0645598f428c70e4db9ffed3eddeef4a631a927dbd61cfffbe0993a62b4702451a52193d2debf724063adeb621f93e34c3dc5199381b6a45e2c3e0d54298a7868ce5fc5668e77560afccafff92307cd0d004df9b1b0710c2a0e8d56b57767ea6eea3e8227efe9fcaee4abb14caad2238bea909b18ed44b4a18b175a39c6d1215a500050417e55c729d6941cdc111a905d008e9adb7edfcd696fd498cfb3929a14bc217265747520a4572ab1031a26a315e556a2b8a4c48c9e726e2dfb2450fbcd5341d7e784672ddda588048370c108736fb7b7f45b30d0d7ff365108f9549a174b7b912b2e9777b92f6621c586e59ef3e898621e3f58fb966cc6646f2fc72bba952f1d43e09c864ef3d936e6e966028f1ac913a7517710e5070dca5952b53752accd803ae2bc87729d7c5eabff49b5b9bab99101325f568d67f93360a1baa6b94f814f7d4f6ad8084c4bac927ff349e34fb4f9375fc4e601e9a0ef37af7428292899b79bf04b395a3ccf78292e631bab0eed105f6ca7469603fdef02d79d5a416c4c77d5e4d5cd6daef68c4c7975500e13cf391c243c7c2c62f140c14fea763d0a80e42d55386a9fc9c032066152c8b5b76412ea04f5f1f6ffef9051de31d28b643a7a60d4761c6dec79fa1347f6641d72473a746a51c975e03510aed3737ffb2a16dcee5760b94721a58549dea34ea5b28bf8596e3c16a9c28668a479df62679423f7a926efdadd0b021291fbef8b3ede7cc54d085c2ba3b975760afd47b839fac3cd5f2ce6a0d1ba622e8587f1c086f9c934a17940db5414fe8989355991234c7f09556cf5bd5c00026060d5175fddfbb6222a415e1b9ff369d9bc9586e4d5734b747d005998d56f7ef7f5b60dcdf12495b4f50d53da19a9ebf3ce768aeffdc8b11bd1d16e7d036bf16476ab365de1b4e9d86081182b65d9b3066c022f26b2029e5a65bdd0f64c41000e4a2fe9969af35f1e6df7320e4eb6ca3fcaee2202c28fd5453e988e48cb785e82ab4491166e29c171c8b4cda0a6d18682f3abdf6ccf071d4839a501c2c9ab9d19b1deb09419be0c39430c9634bffc62992e07f7cda3dec4bf3a938cb8ba5d39630123107659589f74e6b8ce52a495f32fe936620f1f689ce834477acb579cddbd6be84326cb59195bdac588e934e67c9693e8fd2417bcf9a8bc0c173d6fc9c2742c9d1d6a70e7192ed697a2fd8390071c225574a00d9186244ff051273df7168006383025a13c7b3eef748427686031a02b226f3a7fb337c3a55b4de778fced0379acec0bf479048db24b19e851132064635a2d993dd120e1115f64a880e2f37d6a0ba6c8b8892632350f71af096c837c0ffcfa47ef477cd6d1d4ede3f881cdce27e2bfee850230047d2c268b17f3be76eb2aafd7f51121effcf686df097bbdd92c528b0fb10c51b2836b3b61f2a93c6bca567515bf4b160b29784731c1f0ee60444ab65592a7908bb450e3f6f78c376eb0ac81bbe1a69f77ec589e2a0f2e5712222177b1d3d49f89e3ff2082b4388fe96af13eb4a390b64b7dca76717e3dfb136ffb3a9bb394c6d9413e37ba35de31389a75a32021644614f0c41a1117252d2052873451dd170684e14dc33578fffdffe52d3969258f8b904b882eee7c77db96035c022056a35dc504120c2758e62621dddca909cd7e0b50d3a9031da43f4b2a844c508f6ee847a6c48caad8dce2c275e01aaeb4526109f2e346117431be9824de87d5387ee8b1d4d45f370776d3354c9c7a9d73784a328004f942fc961c99f5299cff77db0b02bfc3aa064a1afad791b02c9cca2cf342c403b6026b1bd576bc9ddff431332fc25f3b9948e78a1d058c4cbb93304003edf22db16298c2c96520407ae5b81211d1e5ce4a060c10b34a5ab09df1f1b144d594e28a62656a19342ae5f439558c9b7f120574216fade83aecbde324223c1a596ddd324b10863c4f98a077cd63b271c4291b23ba7776a4c48763c0cced318571fb616958dda742a24ddbd6eeeec23d4a7f6256fff0cc4643b0b39ea9089165bbbe1db5cdcc52faa3f3be1de560864b31abeb5a00485a27003907f917f0856cde5816c3356e6c7172313da901c2fb0b3b95cfdfa1b2f0f2a19681be04585b8502faf96d444d2d252cb8b2d4413e15ed912e1f2c97cc3f9de7719baabae1f86b2d0fcd74d0dd93451874fc159d81058d278850965a9fa34c3136c957cae70466db91d4d79ceb36977256a3ae142ef844ec45b7ad5c6ca6d401b6bb5e582e78e7835cd8c8a7029440d5c3a5734f1a238b74f76e64bcaf6740fb91b1d9d267be189271c03816b86963acb118f2f5da6a6b2b39ad69b2fcb73375337d37a37d1aeae4d547ab72a26818af4f5377bf01e08975894761dd0bf4336e47eba2c2fe4b7f4852f7f12166627c7931e42ce8021f6b31514115751a27da5e0f664045d081434b6b16c63c2bccb93d21196bfe1898a1102d441216596c44cfe69d306d22739f1283b815a2cfd61bdeb66bb8c7984e796480462f1dd990dbf6a658189ececcbd1222bd4fe64027c3913889b894c3865a666adc7ce2f5fea212d9a00322684bde18a364cd49093c5b73e228583193d7737a432b37ab15143d137844c62d190fbebb79202f5070bec113186b9099e1329a593194a3ddfc5fa965bfb80f1879893f8b2ab16f88a8c0be4c4a2deb3175ae088e24ba4c2f11f79c71df27b847128bd32d3383d90945e57f88e895891c49f9de015647f57f48b2011d46b524b62b2dc84a6ddc5c4e36a378fe376d0965435cf8a58ebb8ce8a19d88f047eea9a57e56de605cb53c86119c9a56bd2692695b578305b66d045570afbe368d1f17493ee7ab1673362f3b18ea61f8d9140afbf9235e5b3940a5c9fc8f21c74adf367568f4eb94a03dfe8024c417abfc8eafc55c848f1e700cd8eded76289203c3ae6020bab07192c02c3a74b0e9f698ee0671fc1b67f01ab1b72b3f1d5dd71db48f60dc133009ba628a32b84cdf5874a2a6188d8416378a923ad9998a66d90f4c7693260bd665755f06ff447ba4b77acb3d368b1393983ec33c441079fb0948f84318725a4f8e0dab08c451453379d3a6e0e86884136640fa98602871328d6ff78c097aad5b6737078f5dd4e4da91d5de5952b190a958537cf6e4f01b1fed30de50e4067b3e42e36df1ad0bd8058fd91aa6c6714050dbcca94f0dd222e18ac4d0613cbb0099adb46b0e466ae22f69c69383fcd2c3f7ac9eb6aa7d4b5974105f30910c38920488b0130bb54485491ebf5c790ca64440873a043fefaa4fbf0a8a8b5c76f31665c767ead2288c4f56c3943a1a24f867cd4b4b82103574c458bbdd171e2aee9c35688a6723c6a00a95ab17e0e567dd17ec0110c3ffb0360c0c907b8a69e46daf2bf65e5d82de091b80f5f197e2a004d0e7bebe04f9acf92ba9b8a46bbce3fc7e6621ebdd9a8ba7e89bb01aa073b88f3bb17c2559145c67543e80310589c4414d7a797e32fc1af69f91da2e88dc19d67d43ddb12237a95f17b08fa2bcb534b8c4f79b001e30327328d049264f3a8b19aab2f4ad2f4584c60a7292ffe590b9123ad9d98d1f721ed1c8e82c40f1a4153ef1bcb735f529b634eaa1da5cae4d03903a64e714e01d9abeb17e2248dc4e9bb2a120722472007be51f2e966076f888cf0bbad473256733f386f4a3d6c146b1c1014f13b2bf118891f9976b5c0b358c0e8bdc4558de74424fdfdd311f59299a8b51c6c94e9b4d3973d2edf81e1ac6e3105ce5374a5102ae9cf855ed74a852dda48b924070c85e02b112c9469e6f22504443b7cb3b015d7c0ec245aa9ad3a72a19218acdb20892c44a4ab27d4aaabbff0116219580577b1533907dac2adbcb3f0814e64bc1e61fa036b32c727e31445728f1b500b6d319458fe112cdc0a6430507f7c132091b730a3ed9fba0250d2a18bb0220021473b67a67e4c2bddae82e9e189aa91ab84657178ee4c51903f5260fb752896dfa76ed51c4716bc2bfc2cc57f679e6501c1f594bc7a8df79146e0a1ae0287e66228dddf0afa84912bd2589a17715fcfaf1de8668bcfbd186dd19803cfb214ddbaa9adbef76dd01cdf34166a427df00acc5404d75f4a629df235a8d8aece5370af2c167bbbd814e15d45de88e4bb403c03e6e6b04fd462c14be32da4ff47d676a7c935b2d460e337751d269fde8d78257cb45bb51b5b03f3021b15a0c2d59a054f1b9f485f5704919ca42ca4f001a97f55fa830226d85f2770ff007b517a184cc6ecb4d7a751d5818b1cc1c8e43b7da5f2bff010ad565e47d383f67857ef1fd6678df69abb19dae619968f68d626440c31c8d18a89d315dacbb350632db3cdd81110d919440e92b032f9a98afe709db5003a678bfeea9fcfc04e1279d47ad55309ec014cd49d70fb780e5cf5d28970d1596600259152508d993ba57520bb9ecc7f8c6d79e7a5f90dd36127031b19189e47d13fb65732e4e94ebf439474b5644a12fa0066364bf40990e1d562ae212a784acbf5f2f48659db15f5647a68e5a14f3f1e7de590e27b2dd1be66ba4d185dc7e492ab88abcaa1f22bc85c959a6bb071bcc990ef5093014abc7873b293d98bca61ba459ada1e14a47ac13dd227f2f08b253462c20bc8c5afde5d4bdd23340e8bc2889b2db14ce925ef7b1c0d29b31e0565c6f911baf0f68292e847b680df4b161b2f3c4831a427c46d601b77685fc95a4873a04280c507436fab86c020cee7d32ed45136aa207633ba1311fa63f50fd62fa83356ffe378177eda4710549548bf5517d2b7fdc1f28b936c4a9dc373bfc5624f1426a8c61112c7dfeaf7c55136e4215d0d9148a5503d994530431aa6dd2d0a299fd0d6e1ddfd076d6240677ffada4e973ffe351b3ce633374ba1db613ef7d9bfeee10dbb855d1973fc8d9e97ef8f50752548ced25ce4d8a7323ff59c129533bd1b3f78de9cf5ef73c2ec574ea31625c4ba0881b6e489fd9f8c25bd52a90cc2ebe8628c5fe84259c3d6d8b6197d87a071630b5da7edb88ab6f587b94cfd536ef91386befa0ca450a8ae79478b709bd4d570c29ee32e226315843ae490e9a70b065508eb96fa8ca0567c586508226ce954172e6407ae373f584abae6ab112f0b778972f7b074252d7cb2e6cbf83cdec5697ce79378ea406e56d28776d131809685b82e0f6729aa1764cdef3b7a1da9c8280d4f2ddb58f0f09ddf1acf9a2ed857a09e2631a48c7354c9e6d531977541a50b460d08f0567338c193dff7c69ddef804682e755a3d0b3a00e61f6d290e9cc248f580910477811a82354b4c8a9b29701ba0842d21d77377e0ee9f80de1ac8fbc414d48ea95b4e2decc95a574889905770da1b028e6f733274ec111a51322ed36687af9a77c10a220b0e7a03e6ff5f6a7a1b64672215cb182b3607d6041a948dce392c0b890a5e6a1d86f67ca5edb9286a2cc017f589d2f26033a0706b0d7f86562267e1b5fc5f235697a041bcd3b32e792d1d0536280a290e9f4ee55865da41b11dab0c09b460b7ee6e04b3f554f56bed114be203331786ee1194f094f96358f7dacf1b435928ebf54e2edd9d2dd1363657e82e339f6bbb147be05dde0b6ed7dc88c9fb612e6485c9e7d628885cf7cf03cf37830cb9728979c8cf6eaf54a54be13fc0cfa499aa0bbe7356df15f37dfc8781862a3db8ad7d2031cea0c9e40257fcdf3fd8ea6df5de1148a13ccf6b4cd133fa79984b7563d5c36945c5675f552b12f678d97f64994f416c488e8c757beacf02339c2251df63d8a124f5c34d55f17737bfcf3cb6379454aa7e6eef33eaca54113a545672275fb87ec47f1fca5c4e072c6362140d1aecd0d0ec8fe6ce56250a6f2d127fad45951c29d0031052238331a19842d3cb3458ebd8d001c46bc60c32b40093fc866e8316f556547eb9f949f693ca13b11a4ca69b2564571f88048661fd9f39f69f422934882fde31e8090e54a50a8c52062e8ecb20d48fd2ae6f5232d4790786c09cb8b3ff47fa8e3b52de973aafffcf271cc943203d6812b263063ee4086abbc5e5d23060150da3c55a159e5be288e2aecdbe1decf157ed79ab8af7dbdbfd0de6cea317111615dfcbb27be9d933e21d9fee7acf20ddf89aecfc2c0f8440d60ce351dcfe0c327d0c18f5bd3d8d0858876171b696718981155fdccd781088ddae688c2bebcc883b730fc662dd88b397334d77012c4f83763b53a6a1c52498efc400f7bb9cfdc1baf24254d066b6a990af1a4243fd6050ce8117cebaa88db933502121cd5aef01cc84bd781e16a953cff620388868deae9806cc568766d3eb101ac495958227186e04f4d68983899b5924eeccae292b33c90fe0391d17516eede6a5f25f7d16f184960c8e6ccdc585799c50e8590d267479207ba4eb697e07ee46bea530e1e7cdf1027760dd26644f1370ca545f8bd768b0f49c0216b9251a53ed8a2cae8b5dcc074e051d901f158b82cc0339bc39e0f350f0a57dbbf1558dabe177b121ba891b2415e2c80855ac73e939ef7c5335fd566957a79bbac05f66eba68d3351134d406a55801f3fd2b805ba770a83b6a6bf862377c285792485117c0cdc48048340fff17591b9d0d3dc622a186b86d8483623fdc594510f789614ce9fc5ac95f8b73daa3f12a6e4ba85a2f67e2258554032f19596981c309be99c43214dd30769dea3239db8a79485c00d317a8ece2c3a4f155c2eb90565224f99fc91daeeebb79497b0488dbccf26d1777d32dff5d48fb9b8e54b6eee744f0b5590c99cb12009a79f997d52eedfbc24f70d86f80fe0685945ca37996244fca9b0448e705ae2fde579525a14bc6dd58213d8ad21d4fc70f14f35acd7f244ffe502317a78dba63f780565e7d23b747b268ad35a17ec174f41159a12e6289ca8c4e4cbd2179746ad7845d8358f517354e4d544dafd9d643bab052560612e981d538b939b72123a955f8b3ee00e0698e5c974f79b9e42af0d24277c63624ccdef679f94cc075e976c7447aa8f2a0e04e23dea1d9d414bdc9fccfb3ab09b557f4b49f7f6b92bb51c289836c855aeaa2c21356860fbc2f2a49832d1c43382278bad58ecc47671668cd02015088a87f00e958f250f822769b64f9a391a84034e038b7de78e240ab9d80129a86b0cef5598e6716f53ec26646cba14883e9ad73b4810719e7fe0a6f5960e6b6dc31f913702e4dc3a3b049fb90470fd988eca252f7b8d01f0f90f7adec3adbd54fd57483f8fc760301085c968d08d70596e9c30335b265d5e68200cd8ac13320fdd282da489d1ad2b06ade3a82dd6232c3ca622973c589f28c7ee37b456ee24968b3f8362ba9b081c30034529dc0ce524ce348c0c8b43c84c30fee94a4e6817055905ddbcf4a774ce114234b192828a19689976aff0c33509ddb9328ebc6e0ebb683d63540591768d0e22a583e6b48c0a6c69d0edae94eebd4b7e45ec770bbcbd39061ce46f2ff22fc7fd862250d338dd05772d865ed4fcdcaec39b1d209823f1069a35f2c807132a1f5b889f3270cb0180494ded7966ce7d612c4e537a41f74076a4ec263166f7462eb8f4fe54fece79ea039a8e3625be987e68a88d578e0fd7297b47eb8d995cdebd254762da72fabc450c63a0c919764f0fa792e27b575ede4e45d239d854db7fd81eade551c0b0fe3fea3566ba0005e1695913caf2ae8b9bbba7e932928108883b4e67f11e3c2422eb89ca504b44b6775c4012abf149e5586f3912e5ab597152b930f850ba2cd5ce17ffed989e1098c06f75ad21bfbcdee82e6db46c24fe9a2662cc6414c5eb1a97148a19f8572ddf0a3d39293aac35758858b24586a727d3b7eb3b883794d1ab260fff3ae0bfa8fc61837987a95508c27310409315136a9ee1fa1c74a5ef75930ecea63bb6b40b6fff89e81e52f63bb6e9201cd385612098ebbee644f277990c1f271001ec32510e330e1ad1bc29b17b022fd0b88ce8b9aad1971a568130ab0705d6df39b9c755e768cfd4cf985184b2978af9de45fe01a5728d520887403546b003251e88321681a73a5d3d47d0aa6af2e8f1dcf7a8431aa1ca2d9ae5006a20fbb9f639ddc6da40485947a4aadb09ecf4f259062889b8d88458cc0bcf67339f34351ffba5f120db29cad1d0f66b2b2a564e4f608a9405514aa71f1a6b3592f1dbb1b85695b647bfb04c575e90b1bef3315228c9102b39c72db1b75a5dcae201aa8b95101e781b4fba636dff130fbfe12ba8fd5a9c722ae5f866c870eb907aaee257c64f2751e137f26fdd9830c55770dd214e6b00ddd1dc361751706247db48d0d0f4a7fbebbe7623e86cef957216969afeb55372ad19689cd4e4875e39b930f148fc01c63940c5576190dc2a502344d3b7b6900696f46344147d0a0fa9c80b3a28a3489c6c7199706cdc5f8a5b3b1c3c5eaa576b14ef326e17ca674e1cc6194566b358678ed5c849c2dc141afd8b706bbfd29c5d0fee11637c1acc23b4220d67d23be1718dac9ccba8cbbbc1456ba9bd2b726e7d4c9f66fd9929f11fe54a76c2d07d0be52bcc7f88022d22bc380b09ae36234011632bda37ef8a21f5cf6283e0a350bce2c0d0d669b058e34c8d91cfeaf2581972da74dfb6f34dca9b74b768af91ce7d3a5eef2c9860c2df2bf668cf60b29125c2066cc56d5c7fea85498abe28439bb436832eef04d889d1db6aa94f9e8e7d7f26f19292524d260559080786273dc7850d0766e21c6ed759d780c968bb270d3ab65021a1d71856759d0f01190200767c159eb21a8b207a76c7a2abdd5c643ca12972bffdb34ff3e8d1cf99f26a8eec6897113d111ba3e677edb4b192fa589d72ca3fb5f3f02637c6f2695cd46f209f293a35bf28ac23fa7877b88c240f64fdcf72024eec582f5fb24bc714a922e5a0038b78347668ddf50be4ecd96b2b934d29b339944ce25984e7361dd4c5a27932f2367a381444eabc19654115c85bcdb0b9d5bba4266eb2530da930f9d78c08b9b104d80451278b35b210132d67f3465af075b826b90a102b2864a56d3361bf7c77300d4fd6683aea3d939e4e5831febe8d6149c24cefea1e84e6c65fb151da750df0d2d073bb83ba31a79f842bb3fa334feaff24ad5ece8508627d4a5c4e2f80cd5ca4d20cd2a149ac8b9e617b90f251c0590917fc1a80da9d00b8a1265004e78c79f92234209748c246fb50cb548fd495583f0433f73a65f1cc75a7b719aa676ad75ff00fae88d1cd56b7fd5e1b4aa77f6c85456534f9c5e70ac68ad330d6ff7fc87e7279f0bc71bbd4542ae6d2189ac1dfd88d97dfd3767ec0d7f0cc2472d7666e7daf52824703a23ee0360092c8caba288ffb0a45c5e0bc894f478feaec7a410f5221fc3febcae9a079a64ba61a21b65782677b7c432314a1335a51afd15cbf872013fc7b1736dd79a32f89f1387cf88a971e62bb4e8c0fa97b0dfa23b3f2ddb1576e0206f8e507d9a3d41379f2e8bbf8ae4c1ce9a3f449a7f321ee03f7c359f68ef4cb5ac10c4682d7a44a9bda07928460c59d90d11acc8f99d75dafc12e3597a7a4a2c7232ada06fa42067d75f70e6f176b834bff2f98bf70cce191a18cd3f358caaa681698fe2e6aaaafcf28fe0e302cf303c87c7854e3fb55a44a28fdbd2837295509ada5d9a809a6289db6ee6dce5e270becf91116ac448f46d2aefc81c599d0729f4116cc6ace52c63b7e6801bae2126385271175ca1a5c7f8ffd5ef85b6a4a0e5555a74030ae4d21df186956f3a2480face8350208084875bfcb781b50bd458fa7fd70a584c8cf7f5bb8ee0abf297cd95dfe9cc01d3bd8b210bdb64828fef65ae9054072bc34e86615d032aa4106ca782dc54b7d73d511cf6cec7209856ea9e6023f7aaa6b8ca528cae13746c36dfe0637da2b6bfa8c2691964795e9795909051d23a87a6d2319e9d868635217f80ecf2ec1fa19f3d475f11204affd2529bcc54a361b34e86435541401979edfa8d463ca3400cf4dc993d3c4e8b478cfdf7d2decb63cf31fc953af78f128fc3b9eb7aebf0d0a6f63a96cf515ff8af4efac50cd20f8bb74e729397fe0260f37b913fdd8d29b5224409f13252f33ef0fb67ee6095f8e200dd36c6c765365b99aefb294ab5866fad82e47f48534952f368d0a32845d622134216f0a38840854ebb7b127c494f928732bbf6c5a71cca744301ab97218e0c7a0531f98a3344ecc89782e4243c190216117c60252db884c6b6d6f0f84953c6c6c0c8bdd0f39b0457ad6250c8224a20e469eae148a4fa735b6a0f2782ee1e4ff1d140cba49862fe40468ca74e1bdc67a5a18a08e4c3c3d6c8df77ab6cc74bda400121b72418fbc11c5aa05166dcae5c75a03c3c15e810e0bd1db212ebdf06cfce770c489fad341918783e54b429af6d9635c0aa736648462349f8cf267d2073c8f49efd0698a8d2c072d73d063f7c45dc426938ea4657554bb9f82ccac82419498afb494ffdfc01d470243c9f88b9543485d7d034f4635bf2e50b08d874f22d78776ff9b02d8d77a8ba3bfc85e396a47176372d655b5e2837efdb447440cd2cf23a6d1db7d856c2ed8b80e352d228f144c119396f3a22d354e873b29c7ddc7bf6a903475a23c57caed378f0dbce7d2d5fd8579ac03ed44d799ae1d97ba31c5749fc367654192f6097dccfab09b76146273833a05b376300b5b7faec403124d901bc78f1236ac11c7febf0ab4971e9683f7035fd97730aa92930452db12691bda7e8c4a420702cf5b34bae714cef0fce2ec3fa66895f6f8d68bb5efed86c73b66bc9616b93c18b70177e4ec7539b0c129d4609203c0355dc6264af62aaab888d7c0c386e1df261cebcdd6f197038a8908293519430038312fc75037e916472f7e7e470c81bb948c47a7ecd94d690004e2303d9e50ca85eb98f2f3bf69199a4c57a81e276b196e5abacb92d1156564d0269961c004b8a0fa1f919fccccd1a82667a5ff5ffc3780626a5147290daf2c9f74bf1a934ebecfd0f5d053081682dee03e3436337a9b0db91be1efca5bf79fd39152a3522bc5c650fea047413740bb421d40b8e811105633fbe0a9a71c4270c6a419e0bf044c10665e120b6bd26d7905718d88dba4ef4f2a87bf8aada32eb4198fcd0d67c51b95bd8cc2bc6a91aacd318c71f4225def135c407f04f7c7257748d6b3fec9bb5ac9094ff2a39c3ea33bba793cb59a6b7acc075277fcc97f901d7100f21e762f95d493121e01c6cf8265c22fdccb95c4ba317f846f280351442d36b824f023d63541e75bb2ae1bac3262b9eeac8890fbb2aa3d63d7b21c5a10d7f5d8d92917643d8f4b15171d9a87b0499f2fca36998797cef23c6c0b5dfc7b654665fae19eb2790fc3d161930a4145c79105a1fec9dbf94b44c8316db82eddf085c02fd22b654226b103558dca44a2379e9ea14d228adf1b3be91b7410144a10ee7d5c5286a72b9f5ab13e90d9743c1db7d66e3942f9f6cc34c79cac98931956e14c7c09c1580489756fd8677c49f9198b2d5339a921c87411ddde1b54e007ee3d7c72c71b79af216874fbd42c88018382ddc65db51865d707b11c5550959fe601919647fe96da84ca2bec6b0148d7a8cdb8962d62bf3c978b83cce9d37992ba7ecf956b40223710a8f1cafedd4969b7359ab1a7088e55d796328ff105fdae6ee676043f32d10f4c76baeaf3c61119f96c663b2f263504a7bf58dbd33414430bd12fade943ff1a2e7da947d75a6e00de6277fef300964ab3ef667c94d664b0275ba738a2fccad8d527997811a32200e37e830017a3fb66e7fef72c4a3dc2954b20c691cfd6a865cd530791336c7da80dc24aa1823012bce5a4f62903f06e0485c33078d6c7c36000b8724d923764feb2699ad908c0e60ff0630caa924d8903c9691cdb9e92f6d047bb6cf0431538ccb1d4e2f292de5c330dfd7a2aa0a8baa1ea850bb3ce104a35afe2f9f9ab1feeab340d0fe1ca16b55b0e929342e9bc5886de591fd3b92f64fe7a9ec5c634aae055b13a3eacee4838cb932ae3fc03281f0c623b38b2d0cc5a9ef8395473aca3d5638b6a84df6624947d4509769dfdff9690f66a491dc49941aa78d0f33287f82bffa24a5ecab75bcd10f16250ec60fd870d9f1568cee3cbac1f5623d8c87105c408b49a943a04e029c60b858626a39ba554a38ce90f156a03a66bf79953f5f4a519dac198314330d43f8350054491355844ef0c9786fa1dbd86a13ffb69f4535d7146fef1615c9853cbbf1321f479a61d9b17737ee803c21a35ff8be91eb7087cea9bade90b27cedd30af0a7f3148da423019837b42270b9734c8aea81014c4bcfc5b57c692a3295e77aabd64f046ae5adc5cbb73eca303f1a24274f9344548f0854f12b1233b573f71cb0b9fbca1d4dfcdd4c613bd84394875a4ee5bfa2db4202ea784b19d6f01615d5c591f23920c509fbe0ab666864de850a6236e0d4139d0514a83596c26e2517fcb63c5c89bb39e0531eb2760c9d84c477e911964b7ff61a2fe1c96b9a8a740ecfeb6068f834355a6ba0a7837b9bca2313279d61fc92f1c98c91ac78ba2b36a1d589c0c738050de944b1882725e546e47248fad6ba83c0be714bb7c9a6e00c9dceb167ccba6f5b3813b8bcce2d76fd8b5b70bb37b62e18a82de955c167576316282b0d7fb7cb87d3632468614126e517a85f146bee1121aea7a6451596dcd0498f1b9cb7658c97e1b1481a8c37d2b1ecce34f919cac722d9414a8eea0c3c6381079fadc236743f2dce7798f874ceaf6bb6ddf78acb30e9b06d8070c56cd9eb6e9f563af4dbf2fb3686a4c604aa6226bb9316689aff1a2cd00cd3b63e70b3e6b6a50884e609397a8b43fd7b46d34c7803dddfc8473e0a4b16f22eded0f52ca7810cc91589257061b037f634cbeef43263743d71527e9283965deea9b368b61c44bb2b9976f6e703b7b8d658a3627104eb9a38f9032e390cde1a4a2776cc753fc9f9522079542053984a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
