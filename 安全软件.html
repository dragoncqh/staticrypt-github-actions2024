<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c4fea1e69f106bbbe60f0948d724fa66edc51b6310a9cff6df021d97273bda943d090fc8540c0a27792ab89d9844d6b22d43222db81477f418643e3d5fc7c41d1f74a90196614830dc47d30a7376eb45be0522f0ff8f3f313e187f50cd6b8b0ddee588f3ab6053460739358eb84c33f39fcf0afbb117e6f5125b165644d6c1e40feb6272214c9f77f3ffd984cd46663b80e5fd8f32e48fbeb230095bd2ec3c0ed28b0fc1aba6bbb058f15a581b9759c41b007573e045a0f7064d98a2c9fe4f9c23fe47b23225275b4e7a7828793e16594551dffb671456ad5a1efedd4ab8fb702b084d77183f53dbbd0dae969c0901236cfdbb29d03788f27f2d952f28cd63d846d88769d81480aaee97c700481e919c4695cd5f255be33ef9ee4edaed5184c4a9c67afb739eec8cfeba532cc91938aea43bbd796af54aa5d8ba108910da6ce22ed6e6be1e8162395d3e2677d1c41819b26066e5ecbb7f1bdf7fdb407049ba260138e188c00ad20cf7484049aadf1c559091d869416030d01eed4d4f696fcc5211cd2dfaf4740ea2f851179fa4b2c395cfcaec2bb8339812aad90a64562b704380d12aff3f8d5a3c168bc5ded99ee5c3d2b4641ed8ee6dc2c7bedf667387851b58d206d6b65bc314f6f43adb8731b64a9fa0818b3c042490940288b00f94a7a296145dc205ebc92672283a03bc2271b945e3e302bafa1f10ba4efc50ead4e9a77f95e28a71e26d579cb649701cc5f13d37cd330a886d9096ddb939071e1cdfcc86dd7918a045f2a3318c345a10e524f4b3c6af9b49865d08e3fa2e97b5733f14de59a7c96ffc775b1808a3e64a5ae3f5e2949138fd1063a84bf87fb0f93ba08ef0ec273170e91fdbea84efab2cdf47b48476f3f38a41c09b59b72cf68bac812cc6f42e4d2374defeb15ba172ddfddc98f8ee689548f4b639e90f66e2342060d82ee55cb19063ecaa2623138bc3605c9cc841ec9fdac204a8537bccd7b2ad5ea8219b37d99fdebf8d573244773af7d229f448150b02dcfed937e25117382c58b1b8a0f995364f695cfc6dda25199f9ce304b1523cf9cd3bd91e651c6e2d7dbfea1cf4b7a48679e16c43e94dff5c16ad461efe1b367aefb059007c8e9efe501f265f5851b90acba32b224cc2d5bf59ac773ad8634266d44b84ae9b21110e74c9d5b1072d059933a7f446eddda3be7e377690fbe2c0c25317468367b5e426acddc791e2fd821642f7b7a28f5c91ab52de3509edb902803eb5e0a4aa45be7c13542fe610f7d151b640945fea8909f011549a0680135cc3d692824784f1ecb6a78a8b8b8174cf041859cd050a4d761c41bd5b5e2a141f973a52d43371c2a0b70399839734b1c7e55f05fe69b3c92c4589bcd04aaf92e1b8cc61b44697486f7815e2150b115f0539010d610d1f86835077f9125b8a7fd6c15d0b9e5957b67a94e3bd283bf28b005a0302cfd0236fe4d2c3918a3f2cbe7a8a8a8d943a3a8277c2cc9457cdb9ae1e6fb1229ef54fbde57e64e662c89fe9d6e2a5a13a2c5558ba25147e1a1ec7e28a6c9872da771de6d7d94e9a0009a3e8bb53d91a3d9ad2550ed9a950cc65ad95592976c505e707bcaedb43e4f21db4c5de920048293c4c638d98990b8c25fd6c4c826f47fc48b8fb0ac2a1299096d901b826d8d00d20c711985ca95ac82e5ae7e71481266ee250ccd26d429bdb6961db950c6a818df53456481a2bb673a39d919c6424367ff7642594a9dd8bcca795bdb3b63cb60e4c266089b7a03b1cc29af5dc87a4305247eb2b53fcc67a5d2aad248e95a2d31e7456cc2e42cd12fed4a162774e2661f57c0a5f8343fb327595f923a0d6401e4333fe86e6866e58d0f660b8ecc77a7e9bd2cf19fd0644722ab9143effb201cafb2a0fc8570a7a624ec2fd7a875ff0ded84022edae1c6233281025e2b6b02fffa028115536a27e1a4788f14f39b75b8c27d679a29915e4dc2fe5be478c04aeda3721ec71b356cc8e6fe0f5926da626570fbbab2ac1754dbda8156e6d7dd030cd11b08e6e70a10b7079bc12150536371095092b710f2a4b914d08fc394270a06ca70de22730f29220bd771de3f8b0cbf505529023bc3bcaf0a4367b23db134fa2dd488621f6d2b2d8acbf0fb53a79722e5b9a1f8c3bb5d721c3a06c80970a1a270580594c4f7ab94e8b7fdf953d6d4e65151430d88379c25c02b3d200faef1174445bd018a29aee8898b99490b853921bf396971eb670ef45685d008bfed7f251d69d3f84bf391c7fc549c2c132cbfd2ae35aa33ff45ac06a4ae081ac2b1b04ba13953500038edb55a8f209c326cfb5691752a75f82ec72fb4592b78a50c785db811c09f2878d227b9145c09ee46e481e77d91bdb5359c38edce715d5df948b5c72e21fa7badea7644d5caf687026cca86f1ace6c8f199baa365f74a1f96208290b1a9c6adf7645bc609116daf0f2c3b57e3bcd36307a5918f177dbe412cea06a091df22c6f6ebb4c8b92c59d4343c7eb28ddaf2a10bdfba62f12cab7192a295e9af00d793aa386d903dc924dc1a3dda75a9512e0176f16b65294c1eb0875383db62cc9a8885032bc01ac67b76dd17dcec2e06e1b0d4c5950913987f9deaee78bd3f72581217eefb988734d21fa623e3a40f738aa5ac54d313b7334f4ea4caf5d6834076d3cba82b3c19e94afb6ab24c65c59bff47d7b623a8b22481de1529f4e0c1f70cf191c206dc3597e1c32eafbd5338b3792db0c31a468fe70771bdd1964221db72b0717ba7322f957462ada4df6cf4f37e604a2f4235656a6519f105914c2d9e6af8d4639d479370203b6ff668b85b9b1d48474fefa0f2b539690fa272d9a65e6b48b4810e55f61318086e315f9cea1a87a33b298eea44cbe348f73fed43b802366e7423b231c02a8b16f8c9082c2ec19723f76932b4f2bd71b294636bbf8df9239c2ec3c0efdff77732e729c394ecda817de4fae22f952c855bc75e4d1358fc4af2846a7b8d469577211bc83963877af477ba1a95029b3d9db6603c8351f7b602614d60155779ef0cc7a5f7e5ff30a607ff2aaa71d70e2da183fd3b95bd3962b11400b311eae7502e52737f5241f3851a1bfb4e4f9579c96a733bdb76538a0fe58d04f9ecb02e39de4ebfa5230f0077836ddadfd2c70039a3c55c45371e3a9ffe630871b950d220666436a8392b5e0abc17c2f05e24bce8055eacc0b4047829ba89f8fd045314aee52d8f55b3b863be5942fe77f4d941a8201c205b4905a1642f66c9ffbe6921bb15a67e27c83929950c66233ba9f308e106cd054fd1cf2c1aebfcf4d2621ff2125872759512d085597994fa4ff8c20563872051c9b7ac8518d6ea944cea06d18d86b6727b33c86992bc19a2e5d972d21a92c54ef6669c276f71559910442d53c9a09605fe8c8cbf356e1e86b22333e17c9fc8723eab55a139d471b07ee59dd8a6b4279356c72b4df5cb3475e001245ab717624a69c156f446cc416038fc244aed39e500c920ace90a2b8ececf00683e6086492e8f4f16772b8ecda530f3c0d47b2cb667d2a0e4083b2849cb546633c750c9e4f40b6618b68ca3943b70a0b4ad8244556da1ff894ef0d72482e451a0b2ba042e2c0bb96f6eb93c0f74d6580b99e9e8dafcf9ac104cb83c23641ad41633cd7b4f7381d408d7cc01f9c3cd2f282c8985839da9e015b95c60e0156b09df1f854b6ed4d76cc33fe866c0a737ee75f6c4f955cd65c8f2d352ccbc03ef768a058870780e58955a09442a0308946763b3c334f248fb8aa7225d8c3e020c835b2c8012f26c020910261f2e9335e4734cdacbd73e7c84786730478a19ee7843772acab2743a630fda64ba9a3ad787b2431af939bc9bf00e065267a9fce8df202b81705bb6f91d29866c996cf7beb650c2b362c648fda93155df63636b0d6367074740afe8e75f7b003a94628a6d93cf34e030243387b0b84c6d7843d6e1f1ddd57e8174475bd6bbddcabb627c37beca8aacad3442983e3675b43e10108e34c38941c4fb2202c47043838d90790ad8e53259096956a6012d63df117c22d80b10b23f65b3051e858268c737848051870817b8e5b7487f516ed40f35c523b69223742b18152b26eba7454bc90e16ebe8370594bc8378e971120a21fc158c3b70efa7046efe593dbe25a7deeb4421f1b4efddcdb10d678630c687e4e7f43935ca4a27d9dc443dfc200cb53fcc952fe1588b344ab758e1216c04477ef2e3a35946f1114fd40ee2e7790af909644c58393edc16120c991b7bf71aab7bd63f09642edd7c576571b5f0b08775d3534d988abb2da0752029d5c727c92f3e09e16c68daac3d6b4ea46e3670d39081bd740d06a98fb4e4426bb597e15584d9e1e27c3d4dbde2c0520284666f8311cdf3e54d7a41998126f31188a0dd08039a37d02f8de3b3babafa1820b362f53573f8553d29f4c635390660347af7e08a9bd7c27e54fcbbef8145d7f68d3ed9393892fb012b17969a099cea65161ac0e9bfee77354a9eb0b4de88f006bc4191caed1db26647593378ae553ab815a61e5ef89d59c066af6c41a2a0d9b52af5441c186509302cd814d4d30cf0535d82a01e67e7f67a9d78cf0a5cfce7c500eda09a3d1ddcfc1fc2b2ebd52e478dfa8dd8b3087132bece59123eba8358fbc9ef0865048ad86440885b7251ff8f3090471fb84a82ac57a33cb26a1b57e1f8fa7cae6da2506edbe2cd9f1304ae7ca2211fa7bba617b72b2f026295b82bfde7954c9058394c9201b9ba98747232a85b47df27b5977f36eaec962fc65892e626d9f6989a1cc24fc38504fb6177edd8361d559a34c009999dd096c4672cc082a4f04fa39a7c981a9d855b3350a74a903441511a1f1686190d2c1f9aafd7082db7367eadb7706978a7385907b882fff4b63eae387ac02f878ee7080b844f375d3b5c16d1ad7b08a6a12d7696bb8b930b3989c7a0a70b6b1e0e85473701bf8258d9a073a0897111d015b6512a79cc4369ad75bfa7762c56943e315dbdbc6c621197374aaa6b9699ffd97080a0c7d93847c4a293d7b7e156a823b8fb405d08aa65c25816e13f97c7ee7d26cbadb5818fa69017eaa3563876e7274f332efa213b53bab94b6b4b3a44ae83d113d3b6d63e5c98d9ec7d2441bc2f05d0d62fd8b26513e72b344bbaccdc7b7a52f3f43d6a14c358ddf8145ba953ed0396bff7bd51a71dcbec0f5d7ba16b271171bf16852d827922ebaf26f181686b11dca437c691a5a1e2cf76b50886419ff1dadcca1399fa72008db717e6630a7927a352ca968050caeab7484b42fdec9021645b82d2da8ad47919a51a6da1a6ce4655304352066fd32b667c81d1e37b9657bc78648e2a0c521ceba32d5c9457c1a1a68021492fe7bf2cc12e9ee9b22939f79eb94f9356ef0065bcec45a0e845c9e57ab20a36a792cc4d7763a6e0d171d0eb215ef15ca05c8b86136a5662dce12aeb77c4bf2dbb33dc9ec61f7bd020c4e83a7267ff5a94bddc729c9a274fc84ed968bff2aef9769dcf84c945e595597a6cb79d81bdf39043589457c987865241a2e3c0800268ce413717987b8b42419361fef04628f66ae6234668963284d5abf68d986ad752c6a56d728b649d3c880e193e83e8bdb8268ba8cfb717c32e9c91b67567eb7990efef3a7bdcc25aba88bc2c730d7f370a60c58405d66d926ad8fbcaa38dc05ab8d656e5e55a3483e1f66c5e063ed6ca85f63ff5ee5f58ca36560517fe285af94ec042c2621fc580884b082e437de77e1b94e031ccb78baaa39d129d7c29af16eeedc38dc79d6823cc2963f2cb54ea0bc153306d7826d9704f3940ffa46758fea12281fff9b35b868bd43d9f730a3def318feb5c0db1862e3d0314d193f103b7c205a54cd1c90272e5a8c3efdfc65749f44202935e899cfa92ec96316ac35af830f1344576b580a2b8558aea356e16c032c52c118b8ad0d6b74d748d9fa442156b5d7a011947574db0005fef17be31c1292f40ac114cc87f1c6dbd6d2b8459afd138eb3d8712891c38982d2e279992f83597326365ef072996ccab7a96abeb5ce6a66daff1f6ef953ddf8180af8b36d57eab41019bc964460314bb433e39bb51dcd815d076f8c58d17f6082e061c2240b3171d2691545ae5d6188acafa58fcd8e4a54023a0bf87adc7bc72ae1a5b049b5b2a39f46b199f72f5955ad79a17b2360e6643fadf9d7dc1fb20422f12a90a240ff34546141daacad7b07fc92dff256e72c1a3c185117d12c978954cd8d307f4559cd804561ab3bba05ba725c10cfa1627c8feccc4951b6520752803a498c8c15772d7e1b74c442225bbf3629915c9aa669629252ef8e309b5f9084b463c1765127ef47ac54615f6d5f663b3956c9d90b6f465eb5c62258e48aca23bec7e5b0fb41a5d1a7180c9543390bc4c70226ff09b1d388ae5619553cbb57f894d7627272b569a535fba1e525c18a05b5f85231d057879aaa2747439038318f7005484055a9d12e9143bb81da43f2bca8d20285a9ad5ddb0d0f631fcb2496de7458396ec1640378210da9645eddf569dc55cb5b9554c7a8e78df76d309b1ea27679ae2a52c60fa837da83b6dfb402807b6afdc9f83da8243fba3df8ef77e81fc6e3d6f88dc5303a665d4ec102061e1c65e9eb79c268d393d6bcab1596801fed3863a7129156b7c70b65679b56cb564b93c4e904b72386b82bfa892103ed81e6809a5e40b6fdfd8d19a3e96d3aa0f7ccd895017d1b404b7ccac01a433a14ddff1d9557b5b1eefdd71aad574012c341354532024d965015d0f4bba7c4dc901c6cb154744899e1749e482b53d066ff3194f20ce703860f1b8bbaf7ad190395ef82eded5f914fcfa68575f547bceea0a6f6bb9bb3b5d91d1916bb70f4fcc3dc3cbd18f9925c0a6de288edb5df6e25d237a32a8f3c393c11328ffd2ce3d5fd1ee50c0b40fa03522d65f683c31d285f08b21f4183f5292c679b6d0d7a00079fe7bee6dc84ed569d2de15c159bb1d89060caf3daf7980fccc812977ebe5775e4953f03700fbc46f116310f06b1b4c09e9382376a960cffdfef1ab17047879762abdd045042abe9bad35fe75fa9c0eafd810b9fa34167ad8590762ccc0b8e8d52dcaed547b24b8b8a6d9b77d85e6b26b0c1abbfa23c053cb5c7edc3dcd93a1c7cf54466325c6c2d7dd5c6cd795e841a3ac0f093f85ce0a61a444316007593be7c4018f50dd5524b72c256930bba4b86fa1598286a9f00ac73da6da86da9e9997e6a10a7b96c67df25da856fe7e5ba84b359da19d290a9f2890d6cc916261c806835e2650fc2afb507e51b3e1b5c032518c5fc040ec87f1b5f19df8efbe8048b3ddcf72a002715d47c0af2c2a4d9db714927a7227d832423cf75251949ef57c4d2c291780f9afb9e6b333f87e361d13b5da3efb261a06041b7bac4b7275b3a976adbf06303753dca8fe610086e4500a4338dcdd772f04706d7d3e71c360c16d974ce374bd62f9a1a58c4e5c237c6b5f2cfa47508bb39c3d935acf0febde389248f83e57caf8a487c2b51838cc245d3e563b255dbc21ef8102a3be0e5a7130492ec978ff1024c4a2ca603178e25bb1ac82ff96c102eadbd1336c4b9736e506acb7429488422e34d2ba4410aa8ca892921b3f9afff2fa697a64aa5c85de0f84a99ea269a8b6147c49976476b227ba010af811726125baabbc8cfa57441a5426910cf1481ec19926f8a668cf5713e289e778827e989d6c3fb82ae485b9ec27467cb557ac84ae9080225fcc38347af75f54411d7dc0eebbf118ea01de51daa1be682f7d112ebafb654ee353c48906d3ccb626d3eeaa0070830d3fe7077ec593136898ceaec2b65896269e4b156e2bcbd5c50f9f120b7c25a0d5f48c223f7e69adb4e306d375c3eff4550b4752e99675fc83734c5fbdd1883b600fddb3b4e07bb7d3a0b2348bc40da1fad56c6cce267afd3a2e10fa0e2acd056acb729b5ec1374115bfc1d5ec4f9f48699b64b80caf957b40791e90b0b828dc557b0bafb4c0c6648a1c6e0ff6d2fa1a135b48f663299291bbb9affc2bffa8021b60c9f6f7170b61f55987953e937ca7f11ee8820b848766b46ce1894f2aba9e8400762138b2a81caa3d98b55c3399853c3cb3ab073ba17cc82cff55663bc9067b890db55f35c388e3265de1c25c5435d7e7f07b0697311f7c34eb0b7272d03eedeb1ce885adf22ab25817abb74f5c6493c49dfb758006864d57249bb1a11f77450e509dda112faa7f7e74865898e6688af2ab38ce1004cb134427897c6bce5a3bda90bb983881b1f6436bf0b58aa03cedb2e7d5fd69422f77ec43ab0ef62a6452130ba88a6828559906fdc8e6553cb1169dd8c13b74c53017e9b3ff8026f74aac57a283295c765f4198e0d4557126eb88cb8d4c44170ba9f763981445442f84a4b59590f9b3406ce5610bdaf7a3ebcff0eab18275f406b0bc0b152411a16decc378883874593bf14bf6dffdc58acd7126eb3ad383dc3a51ba9aade2a909077c2d135ec452531f59d0e69b42308f95892c0d62a702549619bedf6f53c9eaea478b44d73b5b00f64f3ca2785f896fc480c3e853ed781b3fe4ca2c08af1f26e94ea8d9d655a6dd88960e888db0b62023a27098d4a8284999842d4ba7a753cf4c26e50dc86d75352ac990d8122f4093b16cca42fcafe15e070313c0a0a34cc77fcc27df90732ae310c520fb2de7618d4d01fb3ade38e1edadd70dbdf8d03cd0e1c9475fefa41b15e72d5165fea26b187e70e03c26d754b23074bf7e9db0a7593ffd0c4783bfef2e6d6199d134b5dcdcf806ae9f5289afd8188de962abf0889d5f7df23383c3e4a47f49dc467ca2e70eaf34bab2f9f591c869f25aa384c88425f4b4a3e1a36e910883b85e2ce3b9418ae7de7fd9e2ae6e4a7538316bbf7e54b6fafe3ad8ef035a3141bf9cccc73c56eedca92ceecb36c69c73370554621538d991c183235ca256d17f11624f20d3c97cac1347c2bbee770a3ac1ed54e6efecd284f43a6ad181234368e9bbea71594a0db5d690fe263590145f9f00c4851b21edbe38159bd530417b8f82217ebe643618d233e6997d18ac6bf2ffef13c50f3a65b86021dc64b3b5db3e0f65630e3e02a0e3c20ce21baa56b2102e327d88bb6b44c45a0e19312450f07664f073a27750d9cdaa3774ee566e8321a5003abf1a14bb8bfb896acfaf7adac8b0942348b420780f194137434b7f460d2e84aff2584c15ab69a4efac7b81bf756c0f04518208a3d5f057d648e49beabdf46350e35ac8a11ceb055d60f984dd3b8862b9670c29d5e84c6148bce72e32ee85e1e2bc3bc979335e2a8deb6b072f7bea589da07b41dcf7828d9f648f5d4f833a0a7a8b4a5d27222520afcaa4fe11f0abc8d9a4f26138a1dd8670682f5269cb86e9c42ff8ebe405816ce33e5e220bf67e63d56b00d97679cc9fc27d321b36d23e9c783581905660860b2f69bed7adef7489bb46072a1b5757bb84112eb87afec138f36153844dfd30c8a6a1a31604915114415e974183c9b0bd134266d7c89e70ed9bd64205fcdd52470ec285ae2a5555952815573fb8fdd8c687241c3ea0d0a77f53953ad754c25ebc8449c7239263dc1140b7b040ea75bb91a6d73e5b005a92ffde25ba0545e0b97a87f120172795b4a5025ab43e9b1a1cf80ddd8ad06a26335b10109149003c368216224579375e78e736189e6adfcf01e144e6d9b3541d4596ef9907cae838b652d90bc7d0bd11dc7f14b0f9f9ea4fb11a724adbcc560fb3200848f72fcf22ff6d9018fabf13e41009dbfba9a736dfa4b5278111301edd2314fd9e4733b209a3dfa4cbd8404f759625d4f2e3e2920405f01f71a92d961736def18ada7a74c0965a308e455a537c6a8886be2017e127235c3f891cfd8dd3ea9d2328d9accc02b4c9aaa47f7415a0fdddb3a5c1c72754e9818cb054669aac517d6495921854e3fc6db54a51dbdfe5ac1018e82345b6895ecdb4c51871e25a8719a942b1bbbb4ba519ae966c481c055f32ec96ffd5d63845573548b48aa946b374b6f8ad09bbeb464926d68dbcdb5bd37764a9ec708048eca22d64edb9c8ffe6418ec3b61e8e3394fe5ec2c2810e013876becb56941789ba1ffd553a370f1abd59e64b16b75f0334ed8a282235cca3f609ad3b558863d1650c14efecd8742527d4f31a3a2b5040829490a959cd1dc21ff98a6e8a3afdda50d69ab61d21b1c4f8c595311afcb3be9b13b6487d5fa8b4b073c09ee438e72270a5abaa0047f08234bff1077f6752daad1c2af8c45b95d4c321d1dc69002446de39ec67431bde5b0dd49f67634c10d8e05ccb6f1a488677e65e1a4827b1e623c9bcab4a3bb4825ac8942a7568afca80acfe9b4b3d188b9b0be155f09ed4de3ac68ba65737d73f11c4c04917008c6aeb22f9f1969d15722f3d10df004cbc46aa600f74bb9764a59573367311217cb10d42b46e609f0aeb34bc618e8fec76cf7a3088383c42cede16ebf4ee1212d9b99f5508093e934cc30667e95d4646723e72a6240e274c08ce5755b3a2035f5823b017e7988bed50a2505b330b31fcad8145d4447018ac10d2129bfa4bbcca3e1fe1339fef8b34b7030a1100f10abbfff2ca05a9ee959d671a1418930d99db14ca2ed30eedd78e2acc7e4185f1ed2ba2b04f28fdba66ab15148a459c20a4c6f777d50accdbb581879f349fd4621b3a0cd5484aab409cc0bf769e7014ee4a7bdd9c5eacee377260f462499904be90a1f96b2fb957add0c8510a28ddc0bbef66646bce108f05f59cca44569654398911268728b7023dcefea3253703044364e8bf27b81c16984531ba4d40264d1b9866022ebbf6e5361517bd1c8fa190001023c30cc234fcf2207a988cb12f86e7c40fd735dced4ea8a9b6c62437fc12c2a7418f75c1e0a750e332b265957577bd99f859aaa82165de767caae75252c92ffaff30e5b42920e25165d45f9c77079575d6f04818d864fa47a859794fd7c8ecc8b9c8998945027296d02e39e3bf3b4673c9903de6feb9e6e462b0cf37ffc86943784f6e13192190634fb7bb9ac3d775a6e7659ac39e19f4bd694aec5dd59562a384edc76544532103c0393da950e34424c69cf76730228c036c8fcd520b1bc0aa1fc2b0d09b84a585f18fd03cda2dab7d0fce153705a2589fd465599ba026cfd90a0a1c74f90df9607d9e8807ad2c4d8af5890d381f84dea1c5b937c58c6231bb46cc41e19beb3b3fb0c1c5aaa475de61ac0cbba4d1eb3a12e805b4e368ac30087b1556dea0943b39bf0722304d37049dfd08d13612522f0bc20092b0aa192bd50d37c9d88a583166aa6951acb70e410993f76d26bda5a71dc71a38d74f2c80718796cfd3773845186e947030f33b2432efe0b35d8de01de1dd2fb1fe5601bcbd2e065b4067afa72d1643cafe51276216149a32c3e32753d5344c43f8edb687109f096bd62f0bdb5a4e29391abc5826d10d3a84074c3d281282c441e6724090516f491becf9abda6071fd093cae0df661e06ad0b816fd0b9d16c1ec063262a6c47be85d8db889fec24c096bdeeca006c3a68c713f9a3b7337cdb885ed953426edd8c5197b3ebf99941b2c186481037a91160a500b3e1e9c91ac58de279477bad3f32347385188933d8239ee52d21c6a7882db73c695439363a42b432d3212221eeb3b6070c8dd8306b403b6009a8bd368cb29b2cc25b44417556511d6f1d90ccea429d2f3d54f617e2c1a65c88f633570699c35b2829d7b1b0ba4048cb03fa021bbb87304c38ad326591f907ebdf038f78b6d76df7ae63ef84f8cd6c36b1a8e0012132509988e48ee428b5ad6eb7751dbfae0f88ef4bb6c9581acf0cab02b460596a11f78c3981483321aa3f0e62fd94982583379e8faa0c1485c8ff2dea2b4aa47fa0d85827f9d1c41fbe7416292f22213f0962ff3e954893793e991bcde28160c9425102b5d72312baad2d75de3aeffea1847c2e5063d9db1ddf1d0f42eaf4cfa94e53b48785685a1a26cc8f791681873fe83c88806f4adeae023595b0ae1b0f4e629a482f98fcbdbeabdbe54f4d71e5571bf897b1f894cb68899e63446c4dc59673f11ddcc5ec79127f40e5d56bb1c6d2eee2701821e2b1e03b0e5d85fe4eaa994b6f4b611ff3378e0cf583be1f2ef08a8e14ad43d2c01e0622d2a1b10764216761537c719837815719dc7d3506fa1450ba6999f14b094cc62df04a7b70b3f657e5b367a875ca52a36f98fbaf1ab0c3aea571d73b681f595b6990616961e3b0cb5cb10ccf8cfa86e3bef0eb23912e69fd50829581164eb278f6714a0bbdd94ec5e3ad2cdb1bb00c670343de148bec79309ba6d69aadc17e25d5ae172f8beff8ca1d930b6bd16d40ee17600c75bed3b62ca22fef54e8fc3ff20565f7c56be815ce802eb1740035e06803fe1b5c2465a69affe77e9272675c3d04e736cb22c35aa133294a41a7e9f64bf314d6c455c95dd4fd1c2335e7373894667ed454da1a5e709859784c33c28428241453b7b094b67980e14625525dac903cc0c9e8007bcce4a66deb59b2a6fa8251c5d001df25d800384ed479da8f2820e0c4af295c646bd568d331dedd371fddc27e985124c225cde776bbd670e46b088070a6401011af280790216955d2ff10ab0ef6d29caa4efc4a4ef43c3530a94ff4958878e3b06621acc95f1fedca0d2ceb327b69423415670577b49a93576b50ebd084b5a4780bd39dd77500d366b8e569dede35fcd165c87439d438fa9d13a64a4e48a03e3d03a9453717abf61ecf43d965fb89e78882c285b56ec8434d35dc1a554fb3cd8f6b6f9fd51e8eca39e87a9efebb7f9dffc0c8431aa5e941ea093286245b67fbed3f04eddbf3385a188ffe47cc998c82b416fa8bbf3ce440c81423de9c5bb12b0b346127ebf17c785d23c2def42d40f546d03664a350039b39a5ee10cfc139122b0f1eae8e2d3c71128b296edc01cf08217e428f980616916193a760dd4d87f4f54875e455c6bea91953208b455817ad85ac0c6c220ad87d2a116eb7b5384cf4a90c35d3c8958213ca80fd3b6344103cafd18da8a02d57f6bb5695434e22558093e10804fcbb3a66a0dccee0c4f319f5d4d9a449e5bbb2d5703e65991fe15b2e5b4a53dbe3b1555e2de9811359cfa900ffe7a7e724eecef8eda0434b5ba74584b4dcd61066c2a44a0922531a49da696f15e5eae98e42003a79f14c5cecb66236f1b91d3b46d3dd2451b5154839c3e73881fb50f9b013cdb92ee16e04f87506c94cb072ed313eb3b8cd35123293ce94c7cfce06d4b942f599fdd2debab2b20fd212e77e1c34309617418518206614e5419ada14a91043c6ba3baf86612dc85a090e0711a1a819b8e84a077bb77029464ee7fe31f347ab245f4a5fe6aac1e12ed870bc9af1b7fdf84b615b1da148649d89fb365abe234ba1d331e667d7585d0a11c75d21d117d63ff59238b03200ebc9fb17376f47d18baf2d83925ef430056cf77fe4dcc4affb803eaf2b82b4e8bc2dc65bd25e4ac908532187dca84b49d3eb11c688e284cc3cb791e85836afc473e5b9495ef176f3c20ac75dd45c0da6d2ae9c1fd14f83f6845ad146778925288e25bf9aa2a95b2f89ce29ec3260aeaff2ef320bbcfb8780d333a3a2ab12a0bea713cc8546bfc609de3cfc5271de0c066a15c8c8444eafa27212b2ca8cda3a641b4e2e87d9ab0dc07577965e0f180b7cbfd2ea7d62b2a1421a7f56adcb8336e59d4431a98450b5dc4d0403f5619f076313b27ebd4d5ddae131dba78eca533c56ed4d0b17d83a3884be15b8724da0285d6bda2c38c1e0835b57111c68c53bbb1a108a98c154d0a7dcabe25320b8b648442f7263823d03d01a5fe411de0b9df371ddf682c14c56126e1ab9cc558e66d03f7e25c7902263b6b0a2819aa189bc434029886dcaaa129f71593328652f7f95bdc4d7967da33c7879f241d7ee0efff98de5a1af0ce06465ab4471526925e6ef828bdd4e455f08f861a0d5eda65b3d72f96ea8c95d161130e238bbab3565ddea595d57c962690d5e9a492d7e1e1c9b31da5986517d5174280099009d48c20122c9afbcb1e80855779014eae821e535e4b78b314cd0413a4c4db8441863e5b67305a7b06c257b795ac5297bfbd5ebda956cd87535735cacb12921f5a27630967829c02de2473d3eb3de6befc698472b9e9f09ff9b80aee0d15339e3a4cb6eecd23402c32cf0585b68858e2d9408a6d1214a4828dbb06b6d4e2be07c95c5c94af809dd828267ce3e8d6de3ac360ff014180d2d053acaaf0cfc8b52ef011f85e342acf0e302ed2c3ff4a8503ad7adbd2a88e63716d83060b429ec843ce1b86dc9bb443bf67da3e46edb11a611ecacb49828b94c7f0cdae2e8372af2998a2d6242ee333ca8b6afd0e7d92c5d76126a5e2380b2a7304cfcb2f34f38bae9e03d3f6070944a716cf486d0204b65de343890d6f92f78cfd8fcdb523f75ca1440805d20b91b23cd565224858ab8a802f06b4b58d626279ace01af85f2b3053d79a62a86e702271797c7995a7154809aa9a684785eb6d251b059a154fb790e548bde4829d8dc3c9f9b76bb899d85f2358ef13959d41b6674c4cd559c44ce95a85d83850076404c7fa44b21eeac3e6e033b4199d237111499c189106eb25829d9edcf9819bdfa2ec26bb1a6f558e66eaf1ae20981a3199b70231a3e726bc5138aebf7ee699c9cc8bfcc9002551ea75935027cf33cea2c3735c5c3970fe27ee94e28a9a2b709b75d65069eab7a6f3d4415dd0d01cdedf45ff430757446cd62c243c5bdd6f595be788244d379b359300997189b628f8b053e81df3683db4a2687f2f5c86f5d571444b1b74dc1720149267b4cae7a5548d716c3a8d3d3c1080d7bd9ac1e0919f818fcca1486c52138b26b92f8f53e4d3911ebd22d7011d3f700bfd16c09f574e1041b15701c114258d8d36cacd4f2f10b5e94f9f2e650f0fe7595bf93c5ba4bd7a1c5db4e8da86c8c38f12da94e4709694d3c9183cf3b164825255c2479529d61136a049945c76c374a3a721d8445505332de247fa24fe2cc0d3afc1fda0f5b34f1b5b89c98e715046796b221ceb55a893e760d9be437be2bf58fd9e159f446564059b2816b79d6c62af56d54df03d7d63321c9951636f17d183eca42712a1fd88d9580dbd33df3c329815bebe8f9f8b5ff05bfb296827999559cb0891267e7b26284f81288be844f5204f707803fccf0655ff14f83d748e55f118fda0e9216680d7d9ccc2dea83fa402130849a945815c50eb1d694035c3f220b953cdf8efdbf87a424ac0080d157035606c24087a9eda2b2a37e716c65c966822c847af07b6a0f5f09930fb86a33435b3a467223b008b68b1ccef3e62278743eab5cda7005532bd97b23128493193f1cbe2b46bb4ae323d97fcb277697e37912ef4d9303b7255af6b134cad8ff3a90f6d04d769c659c9934706fb3d17eabd39bcaee19887eff4bc4d9e96d810ef43fdfec74000f4cd7d968a46804444a2eb8961161c6c162dc3fa2f60377673918076011da5524a36211ff2038174e3f5634b915e7e12783993fa35b0a4c412166e466bf2184cb18c263e8e9f734f860f304b70e86ec56b88c891e27d35a565b22e5b1ed8a32a1dd7dbcf604d64de51c764d788c6f46df21cb68c5cde6a73d59343ad276e1d70ed6e5fd60d23541d5fe45cd2afdc7b763ceded8b8568f21ef5c16d3456226d9401dcdfd83b9d2f93bc2b6a54c1d34198811f2543d4815d17b2908d1956fa8df749f4ab71d2975e532c0cff79dc786b166280259110e0d786750545d1b21606cfd2fe89c01b7bb8239c771c7d63b8d9be182eb5a4ebc3c78405fc6490dd0af343278cdefb5b56f7d421a8e41f7275b7805c909f78ae09cfc77d4c53b43adb3bbad7ce0a77d40593515e596528222d6155a2e7796cb76f3d85210c9f109423d8e9cca1a9c2562edfce87ee599fea3433abe9b75bdf6be505973e7dbe8395b1411c47f6df123c149fead3a4005f954b19dd53024930ed6a5c7a943b4caa4315e961483c47681dda68750670d2aebbce8d9f7d34d36a82adc015dc09cfee9df786b1e4f39bb529a191dfaa4f5bb7cac0feb8eb137dce83667d1ea4565f5002081467c5be9067506504058a01897d93455b5fc7b4a1f92f37d0e1ec140daf44aa47dde9af2a0e6fe712c2a53958465b5336cf7d65b8b47941ae9c17256fb7daed531f48a313115677853eea01bc49018cc5ce97928a31aa29dcf5b9c14c0ddf2016ac62dd77e884feb67a5c499dd4457d8923f656f0fcc7799a7c9ffd95e997b88cd2bc240523f8d4f85d712fffdc9b0749c5811f34b70e96d16454df875500bf6c739b260708a5d06a0f3a91bc18d27db5876b8b9bd1e79da928662d5419e8b65a7cf202d09a3209264b29d0504b19c446e0de9467d5d82d0828843b71594eea3bb5e6da441a68108aa0649f735ae24487e863b91fa88bdf415b22a48222fbbfab24061aada8f9b0a047638c96ec4ba801f8c1e7f366348047ee2b46a02b064e9048a898f6921df8d7d0f50f64e43e50733aec579a7d824f6736b4d90b8a2a1db93ce81cc5162cf8778814424604c7e6c9870a430a68701dab15ed956cf4f7db9877c91037358a4ff55c1b3cc3de5b553a01892fbb2b28019575be4a7ae1f4600f8a89b6f0935b78f2d6174eafb6aded62e2fa0aa8288f9b852892ecebb1cb1ab94487d32e65eea903f1824f18a7fa558545fde09320ff18e3dfc014d2012eaa2853247fbe799244643cfee3dbfab9a4314a995e5b7b806a17c22aaff30044eb8c02badf4218897968394833182b1ff40872e7373d44343f93d00bb71635a7e161de8d0eabdc5f9b93d09562f16a5dbfaa16980d7049274eda1f89f8df9688dfe497af57aa1ae470f7f677fc193e0c8066a792dd967d0d1a9e2f2d00afc09aa138b2f8526dfb668052d26b452df24e7669f3ae80c96216f9c9684ede10d7f624cff3d1649111d463bbba8f0d08b9df02617b2afff31601a77e56ab7b7c77eb7ebe3c649aa226987c0a895858a019ce941714c2dedd7bb4fa577b8ae4a8987c064cfa2444af7d2f3a13c97e5d8221865061a5a43986625cffe7799c2d1048c6d54d57d617ca57e825d0d6a05096bb74d95079f632b2382ed433140a554bec40d29d83ae2d39c0a58eb6b960857f9031f519719b613a0cca00297b8ec14011c956f3d7b1866a14da35ed7bcf4dc2a249bc49e97df82bea3238ca660febc81afec01ead9b2c7e1d4cfe25a7a20f8ebccdc4017f848fe2be410ccc6b1915261a40e140ddc797531856c51fcd45aff03f0f1faae1cb4fb96d3c919878b2ce52344f0487311667f980c093ae4fe2a61fe4a74bdaabeb3d1c61650024ca3df2f5b9e5528a0cf5baec6810cbb406b3a2d5ffddc305167975e06490f6554c97dfa6881149cd29463b9592d066fae6b78055eff601419cf5fa7d080a95e64f4b19a05b2127b929a44775309aed6b8eb5fed76c09697b1706aad78ffd6c8d5b60b86634f9dc65d971aac24a671058f9730c0b1aed523eb9b104b4c75970de6bb28d4fbd0192c8fb1b3e54afe9396f500d3339d8723099542b600eba21d7aac0acda306ceaf5566ed995247d7e75d34c64dd14f59b6b0dfa76d5e253d73055bb58febf5767c6cb6b0ee5c7a3baca279e47882799499a451e636d538c87bcabe7da9d4508d5ed3061d774a8799642d53ca9ae27a8ee2cf6d94f2eb0ac19ece1572c32823198332367e6a38ebe78d584a22751d97dd39f7db52abc8bf190d9a5d5708594d18f9793e1134611ecc58200c8449a141800e0735c0d257fc0b2521e6053607b2b7cdf79e0b8994bb44ee6533d8739b5afb7dca82995392a47ced11f06b91405cf0d663e28f685525b3b830e3fbfafb97b82493c0bb1c2d2904832fe93a1fce17cff3df93d3b8b0f41aeece01a1cecd1b70585c6fa3ce95f39746f385d43d9787fd68c6d8883ea1d6601224acc6122c4380edb582ca3eeb32d8ba08e1d749d6ce610c1420a07ef0a6b30d82dead97db638611f05209d8fd272fc7678f8c1b61859a939f733fba6bacf92d60a393f7f9ef9ac70d27eb0aef6ddd7ff561cb60a97fd99fa60c4fb95ab89df9ae231398594107b9eea09708698239e24475e54e9a10887e47196e9396894c9cb747d9c50f4b208a0fa230393bd96c080f544376ef397996b9569819b3e1e0b3c4604cbe6d35c2e6eaccc91a2e0ca3c9ef15ecc6c2d82bc3dec9adc9711edd0e4242de64bca4e2c1a6bb602fb74c58febf528da7c7ec58f3a4de2155baa39ccb7169c1ceb13c90888fa44a47f3d9f079dd380eb71d1499d51456e2f0bdb5ef8129b719f32c7f459730b6d9d7fdfeaac7b806bba5811c850d9b95db8893e1ba4845781c2fe44e11fba16ab8cc60ca58f50dd9b89064c5658b8b1cd6706bc079bc27b5be2381046f12106606a3ff1af3a6a95a609e5eb289b0bdacbc0acd81ac4e846f1cbc88dc9be7bd8833da519dfcb375c7539c4c38620d70d12f18c273f8079e90354ecfffe2c19c4a58aacd318e48b3c95855874647874b4bf33bf7ed8aa701e6622d7e5d75a6820fa4b2506f8d6effd1aae8329a12df66f254dbeb80b5120a8ed70092904e0b74dc1f16528356df7b700c1a1a426ccbbb4858a8ef9c3972eaed63f221ff46cb3df8b17f31909057703d29190c23acffbe51ffb4ecc1d19bcdcbb8a6c46a049f831f8999c545dfda691615ceb80f8172139ebbda928b1c5a0e1e90ba186399d58e8905735aff1207ac84b7d0dfeec8866e346455d3acf35547970d5a6a895b00745d272984257aef05afa38ee65061e8a8ff76f30763b7b6c0fdfffee51cc85ab6e736b2bec996ea922efec978c6342fea86f43c431f068b62d5f35314e7af44671eb76b25f5965515177de6efc49d6c91a462304c19ada098d0ece9b953d26b06fb8d8ed7e2ef4d113759d97ee252e4d7841faeaff19d8bebb15ca160fd19d314c3c0f9520d7cd37c2de54ecb3212a8cf45283e7778fe5f258d0ceea55f10905e6bf9efa3d9e7f2ced8ef79efe7f1ff742da559462ee1098a35a0b2710563e2ea792ae7cc865b3bb7ee3524ccbf40d542b1fd043e5df5c23a03da17bc6e45f1e1a28981483274d8e7b9dcf1193b9a1dcc28ec811d68417b009f88df939661c7088e6819dfbd6a26b4c2dd08d62a5059edb7ece150b6faad0567f9d8347f361efac4ad9ca74ef54c09a0f1f37a27022058c824f00ab4fa5da7a348ab0ec065b69bdd41fa3ce7767e1e3333ef5b8ed760b5a346b571cd5f86870ae612c42fb5613e1b833b0a66ea74436d832c28ddbce8767a3d4afd6028b8704dc09ed1f6d53c60d49b1a3f0b99f3c27f49562d2a018cd43fd1fb9f0a9f8042d095f822a0aef51d64fe72f2d20a83edf9e220eb5a1515c7361892760c44434a3e6610c838e7029d1207e809d16b71ec84a3081d47f102fd7a719cdbb60ff7f4a8b8e1a91b886f56dbb83917ae175994b0689a65f68ea33ea341c7e37ebb1f86b042b425d653f33e2bf4331e037f7b124d2e7a9e4ad3ca15b7d9b44f66954d44a2689ec194b90ccd91ab5342e0ec5c0b5e03aeed6d67141e5dda52899a3d4e6a94ddd0754bb16e589d80a0061aa23caaa7e70cc598993067cfaac64e7e259b5d2f51741608da630c3261d2dff3e41fe93d074625410c5e18848dd3ebad873a39ce4ebeb6162db583c5aaea1cbae6baa902942d7c20356fccaac1638568287d7abf631cede84f3dbe805877402a4c4a8136832dbea571d9dfbc6939ff6f468882c1a3011f2c3014c70212cebc8b852baab3ed5d07b8a45f6925bf05d45fbd6038407be204c3e4d7fa9c039000df24f0d090ac2c42aec728ead4ef51ba90441df202e99e7defd664abfdcd234b7fe025608bfa3c947b62d253df2b0f7cc8d3354f141709b26d0544e7f42fb69c4c85ebe276c08b5a17eeaf332779fbabf333205e1fe9c8e71c561e3cc4db9a1f4fc40b95c88984b0d77b25262fce6024e874b6f63eedc1155711e9b19eb36ce3fae48f757b079d1cfe566656b619bf66c54c3268f7268d7778e32fac20707b69dd211f6a51b7d663d0fcf614fa748495a2aa1611db5d23347c6addefc9a569e469456880b4b123ddd55739c4355980c69c4e41d978286063cc0a587a33049bad59e67a74d5da74124cc5aeee8c49fc5a72e71552ae1be0c6f3b214dd70906aca7d4d62a2e1a06a491654cadc7856bfc69889bcb8aff4f28ff043869dd0df7d8e489602922965c5c57179383992b98f9e17cabc256bfd44e0faea64fc7588d5e2199e88b382b11c6a958e2fa397ff752d1c8c7c68d3ec966b3609c018a30b7b8e8736563ab4c86178437f2dfe0e71c7b5527deac2e156f6a80ac10e07b7faae00e3f78229933f60da512c89692d5808e9811f4db5c1713350cff6d6d969bf183e01eed88278464f9bdebd66ef96412817999aeb1028ac70e5b965ec01d0a783642957fe864a0d97a603878bc09f2f805e532b5b305df6c7e2f11a21d57fc79606ced440922f6a777e536c7b274df9f901c9d18b748d72eb52e70371a2d65f3d34484a1e47a8adcbc2aec1a3fa3193510e0d957749db49d7937cc92cad37073ff21ba8090c64dcb04277b7b89d76e010b9bb4a52944fee8f3d2699fa59d881fe610cd9610ca482e7347270e8e10dc84dca9b8674625dd8ea7110cdeaed4aa1d77b259e91eb0db6a6203785fdf8d6fff81ea881436a595dcd09d7ee8b1faae5cbacf73857e0a0f65793647791010123339ccd955588720de348d858555305cfe0ca168bd17a3ac0beadbff2c46daa2c8b6d2a2b988c370bf5b22f8ae897ab416369ad6fe0099a10978e64bba0e56711f765515e4864f041a62f1c1464057e005db8948668801bfddace205155af9bad7a14198aeb70a7aab079f1d1415e6f9aacd682a6767df08615988b3ca2b6fb391284f236295d6d53b39776a687e1bcf31ecc2ac345bbcc4416d3c7f07a6c8a848402e0a994b92110062be29b67c51d37f14bd00c196cb604f4ac62cc78cb3db619a631a8030ae2614daac3d93e94675e291c1ab71be96f73febfbcf7760defcf73549197f4c4f027a85e8cc7697152852a1bb63b20c2f684ccc7b61e5dce454dbd484538d82f1f72193f897ef1f168572f187e10946353f8fda29a44847063be7e8e6a39027bf0b0872234f73e004199ccc1bab8265ddef82e6ffe902ae6d5de910d73edc609c0ce783d19947f1eb1da96a4706f71f21b8ad5993bf30351d95fc8825829b518c67f838c0057ea870f2781a5486981567d066578cd13819670177613956ac22c17599c70cf3e7ef3c17902f8aa084cead9ccfb9f5c35017638480b5c780969308970a24b1f09d1aa39c012076dd221fa0c494fccd5ebea1d540b738f9cc882869fdfc4882cb762d493d0cd1e5a88f811b0ec6f1796c58f0697e2fa9ba73566abdb5aca505f1ce3fb7350eb3cd2308090869c9b80914c394a8ac4f174165fcbfead5381ab3aa9e178cea49876b2aec08f5d99ef468374dcd32522c4a4e2966b02fefa90d7ff1329f6f037ac91ec6477cec18404dcda7804e1586a078a30ccab0d3d897e336751001028dc77e62fa21b46dc9f2b40941648924a3561bd89a3cb406a34491a7f83da7c3053dd533b43530556e47b739bb75c1cd46ba53ff4e49ed663a417cda820e5c8b89485c2260787cb2c49dbcad58f91c8f634a5702d4624b611e8d3bb0de05c807f63263155b8bb4c21b16cf4f2423be82b83cda329edcf5e93a2b9748d41949cef36c0e1ff14966a322026777c652948ce4212cfb69a3ff8a600332d770503b9712d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
