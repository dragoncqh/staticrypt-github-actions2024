<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"62d239d4ec2fbf4436e685ec8edd90716bf6f23d98336b07d5c33d999fff3a00fcc6b0bf73a20703c81c8b05d57e503a9ad4437bd1e7349e824fb12b8355fd40f626be9c386cc34762e5294090415da00ededf6c7349259eaacb7ef687aae0498e516701dbc0778b04fad08333b4953456d22e4d31b294a5312a7c190fc37486211b584139c087c7a6c32e3515361a3b6b262a207fc2a663f6493139c3f979217a283ead3fd8d9de20b729adffc06ba8c357d06691564622980fc185aa74cfd3a2333a169ed648edc365f709901a41398ec98ee7cf2fa4562ad7015335bf2bf53f2a5d5d3638aa8b783792aa62848d0ce37cb13ee57b5b9beedf0af0833e3668518139fca5d320e4f08ae0307b720af197dc38b2317e73bfc6b69bf905d77e3c23760dace302e890109fb8078b903bf4663d0d80a347c6966f1006d99b815523434f69aef5c6fe03836786d8cc6d3ea875c8cf4146757facd3c52346c1afceea4a8c8cda7488360c363854f56363a5d429ba80d98477ec485894593e17e02157572e0e4de5c92828f8fc71f29ee43945dc41db6cb9171bb0b08c3ec5ea68e3d10df8c3bd89decfe769099088d09c594a5c87081593214eb4a09ec9fa8f616c668d31b6a528f77c189b88b586b8f27dc70530050b2217c42564fb31486db7fdf553c19bc702110e080703d5af5c1c2f786abedf1a207c9c39e31f641928257624347d279c3917fa85fc7342020cccf75971922bcb4ca0e97ee239e277bcca61d2ff8b2639e4ddc578b783c76bd4ba382cf94540d537cd45ccffbcdd55db037f8cb9e1847b01a5ad712210159684ef6bb9f4669a613c39cb671c2677e14ca2c5f88b61bfc653661595bd72f102fd253ac029f6b508cc400af58e30af2da0f63d425ed450eebfee8bc63ed1195110ab3e37cce8a6737ad947183feebdba0f5f28c08b186d62048e2397907947b3a6c7cd03ef0a198bd37b5c3d6c8dae34ffb4cd1a726b85612a5cf226766ac03e038bb76556a30d419de190a581dca4fc273d9cab3d9620eac211ce62c08d69c90bfd15ce2685d3e78e5f9a008771b691a0b4e7b813e8ca4fe656b99be3b30d9f1f42c6702a94bf9c3065f6963245f287be38ca96dfbf8990437003fa4b683d2f0d50dde7510cd7c05d56ba75dd0aa84cde872166b2cdab67c0379e193b4b221103ed7bfbd9a463979f95a1d9750e289119d4bd391ea9e0f71c29f85d468158883afd364d067f23db9ef4820adb430fb6203de258b5056272fa21048182a9c55e48d72feb38a30de3e99d341a262fb3539d33e49b2fa05bc3e190b23d8a87d369dce1d6834a1929523ef20d8a1273e78ff88b9612e970059085a145580ae0f4f4c8a05ba147f41f4712fead4b61546688ae9e506f2a6fd404943a219069ff970c5ecc2c1f6c54fcacfdfbd0f89a0a11ea816cffe4db0c4af813f0a7b17c37bc21c7781137529cec544bd026cc18c2d2bcd844bff55e4799c1730fedd76e608f796d83de39957f69a244b2b380500aec17814692f6e4fbd8051030e9c8fa4714249ec5c283cdc8991df9a2bef716e768163d4b83ea9653c75e515bcf2e9011a60bc1a651f7e277513267c066cdb2a8dfc4167adcce367ccd92142eb609e67f87e97c542c7fe091c06e4c9029c5f18a431359b33e8e2b4179050d1fa22235ca4afc1e7965acef88734b3b6a2485093d8453775e8934137c956b3651f190e3a012d7c60d897e7e836e67ac44a6617a1fee04236efd824f68b38d8552627282096bed6a20bc63b0197f03e2913789c7287964311f8f192973bb3b81f82c78e6ccdf43d17c030a645f5a08d91c278a465cdacd3a2be75d9e2dd8a71f35edbc7196a58a04285ae1a7e7a80d7533f2927a3aad1bbcde4cf3ba6994fee2c267083ea31d7d748a93e03e91b73ee8f214d8361c41e8f2d21f34bd64726c51017344fc6649b230091e2382a236d37a9b9ec925b67bf07051a45a3ca7fd6fe426c2794f908cae5292e23756e6c5338cda822619a9c9b3e351e08660293e119d215333baa3f912840c0b136eb88672a3244769e03342c11a5ba94e2938047e8253d114e5c404ced56cf32622c1fbbca248bce2d13037f88faa99a0b5daf5b2ef9fdf84460341622cd42cc8efe6ab32fc32533d848ff3babb325c2602197b6d2c82d37654ec547ca0dc763240bd375601ae5cda8eaf6df3b601d4e6f731b86847203612c352d55adcc29e073474d8a93ef9770ed92858a483d0641de6a4d5cc5009f6fc8e45fbabfc1b64f3645c9006f37f124a4e01c92a8068f4555006f80250ac4365b94a5d760242c4737e228a3266324979b114f7920d52aa1f13e90e60972a7cd84a1bde4e302f8ea211a7ade3fc332775430f9689a0679a29bc22091e5487d01560110002d079ddbb8afd3280e3b4846ead3c46ebbd117affe782de623c9f2a8e3847e24ce815502c93b635b7f6963e214a2b6ff96479f998ece12bc4f6aab309e65b2e7f576b42924bf7833d38528b35e254cd0fcb78c7571ac33fdaf736fad70d5ec86850207d6f957a304570ce839890d0f8b34d83e335883bdb34926f86d29d4ac03b6a6b695358e05248ebcdece4984e764104e0b4b18a2423bec4a7a223ae9c59318e34ae33d3aa80cf9ffef9cd5cd7a60c3ae7c2b010fe29ef558cc0c98e4ba09ff2543e886bca94d58a28b5cf84309adc71adaf871de4ff1ca0941024b8c37b15bcd4f58211deb971e02174cac2a91028ec98bd250f250d4cc155558fb248125e790bb26c1a65ce320e2785269947fa4f2c4ab7117f2b538022bbc9ae629640238a0b6431b2068b5e56e8e10127a2b79d7308689a5f6dbe3972a337c1f352f66832b0b489d01a333c45b3e19f30dcd046270d18fca6697dad29e14266f7a08caa37fe63088a8bae3a852985adc3bc2a430f4121455350c69afdf9218a45edcbdda709e73f2d12ec604fed37ea62ca698f0c7e01d82b03b60dc748ed621791d4e187738a9c19be999c677cdf83339250a28b129decd092fde0cf0e868379e4f345bac4d600f43d96c029978e69b43e176bcfa5e3b8653cf3347e789ca39cf49c5304dff0d2d72eb7145adfd8a57551a5c964b3dbe0f4576bc514d609e71f35de5711c57f6472254b3f4c9f4dbe4da7a6d4f4b85e8d7188ee595a1982d8658e480adba15734853b2d2b017472afce80e98f3941d8519e9040837f4ea4ef3c0b6538d878105b7b45565f16157fcebd27b218b338336e61bc3265ca8068fbe361cfb250c40d2a23378cf39af6525db2dbe0ce71a70bb2113cf7d6d0b044dfe76e1d317f11128e56cdc549a765bd8ce166c39f6413e9e8ce7d8538f3092144068c46fb5bca7627d2cf2ce47d83f24bb0168890fa983c926066169b550782d1fbb9a513df76fc3a04193d12d7e0d0112b3f45a316e6d889f376e436f9fef818e4f1d23c52246be1ca1a6ddfffa4e31158eadd550f20618e75ef0d5049a34341eb3841efa26df27487f82d9d903920d28eb2f7330444f30a9b9c1587054a66dfb9c6f5f8113075a8225e2b511a5ea909fada8db7df68ccf827681bef6563802f1f9232ce30db618e14a97c7446836d4e40fafe44a273023db790cb09cc1425b5ee31f64ce1ea3e8e49490cb4d5b40ff56b622e7f6b2416415e42093461d6f22977e8161006caa0710d2d792ea5345491930a3a913dc2da2a8eaf67d06f5a56dc42232601f2078765a3985a8d358a0f2620a821557859068b7656643691c5b26b4394f67f60d6de2ef13db8bc529ec4571c6166d7bed6cf5a56b5bed13cea7f1b1b35e809ae2a257dd4f2b9410ed6c6e8b7d659a179b14437064abf6cd12449d6764c2c4366bee5e3eb58225ff46e99d0c9fa727262b11c79a228189254a23e1586efac620d795e23dbe3fba27360c8ddb1261ed8da7adb7dfe24ffeadffd58f388fd65785bc625be91ac18797154161065e1b572da5869c9e983e40e30b909b99a193e20564ea206e318ae9d7af4e1b9762a58e400ceb707f3bf7014870dd8379562b331a7e83d9ab01e606388e6a74fb0fe8c5d766db194c5dae3f5d2264b8bd1706a8188e99e17bb03aa3cb489e25baa3f316901160d2f9b98fdffdadef32d591d2b6323b2a7c299a6286ae7636bda39c5d020b07714f422d02448d55e411878d5ded5fcad506ac4d86f4f2398b8424969cbea2f853293c9a888d0419f3f6c224ffc061d48f771b4fa36b36c063001a70209fca5d1c37136686d47ee68aaaae4ed89dce0026ddbd5c923b7bb126030cbab95e6701fd3a59054d90c712a8d3c06a0ee5c9f543a05a6c90ee9624d0999e6f979305e23ce54bfbd9bfeb3e8893c223b322b6b6e8a978672403962ba566f09816b8e29e2b352f9123d01ff9a220919da31b56154a9c11e5ffd97abe98e18dc0a54200d186173fa87d0aec4ec9ffba60ee60dc1bafc5f1e5b11d6075e146d9f24b46880d095cbc25ec582ad21e4b2b4248ccf0d3449d9674792e43da9ae596f5f548a85dcf1555d0c00d83885ec2ea7e20061e81a642f088a5b84ea219c750639333c1588282987fe8387faaaf79c047fed6b0a32937b8fdf069a7d083045a7316904dee34ecb7aeea57c92fc57ed5d02bf0b0f0fc605e09ced3280c84b7c163e933793a1d8e7d98a58afdfb10579ba228cc4417c259ebe3734550a2a2b3e32f272fea3d733e5e65761e89997ef059653579ee91d32980e4f1d28a105acd242ac68a863642b075137e072b22e150e432a8326931ddd4ede84b4848eb7f73b3c4b03b7c4ed29d94c511f4ed5667f007c309bf61f0202ac091aa0971d0a0b83296d846575cfde56a3486cfbd934266d63755e90572bf0f6904ec68aae64dc0926c1d91d363ea0417663d2e5aab45e878da333365a5a11f3f9f93e45de8b560df134f7bd4c7362113016ac21b857de1a797177219977e7f7cc3119a9710411e94052c848e3d09e502f90a775ac0569c8ff4417016b6c2cba92ef2443833e7da9b62f7b913f780416ddbf8a4f0ab94c6b7193769b4740605d8decc0a490fdd3514ae12f5c0484cf373d45f6afcf218bcf89edcc3947164f8ae6bc10bcf1170a8e12a64b52fc85162109163b986a4f3d6474b0e93e907e2f23a451852cc8c008ce4767cb507da2a019f225f7b290151c939e7be61a315cb9721ad1349be61ef84fbb263d5fa4578fd964b7dc53570fd07f53db9bccb9e2dc6d6ecb9c306b756d025536ebebed8c93801deb4d48842b92a9ad5c43f76b180b974fb5cd3febb13ab97251fcda2aba694652604359f1a7cd9eaeda97b48ac91c894f4bfd4ee89fcd9afee2ebf72747b313e72b4961c2e2607d17123e2d580f59fa32152daf7ffcd9bc206046bdfa4b4ba0b6692f8c939ffd73de21788f8cf22ba30b313fa4d14843721791c29102902daf212a3c42bf08cbaa9420a1c7916c23cfed3acb462c2bf7d1a08cdc84c5039179f55c8429a49c3042d34834bb986536830eb06c7c133e9a6291e34e459a121b2fa72f47287bf9fd716c093e26884f9c76cd1ebf0cb3115aa3465c9eb982d3c7f2434d391acc86bc04e892759148c4b9bff85cf2d4cb9666eef375474d7518572e21d5bbb8033cb86620bff8ba34bbf7cc46b941605f245687b74e54e6c1bb797c4d2152247c19a87b0d40c9844b3d61cf6c2e055cbf6cc46e0b30c583d1bd242b321d423ca7b5aad09d5819fa15e49dc816d34dae3a6ce5e2b160b1df992062f3274c70159abbbe372ff2a108b8ff50f94326d910569eba3978dd1874ea9ed3fdd641ef34abb7c4992baa449a7495212276858200c36539b7a61d492fe798fbc663819b35890e224c547c80919087e98208738d9bd07aab5cf27e676d898fab3f9f4a18e74be49ca9031d66307a638237e3c2e2e9fe245bb6d3db69cca21c5175128c788f15bbb778d868f75a86593f8861e874afb3d1b44d1dc3654bdda7e53d2b58d35f8b4ef6e126da89b5ce9b5732a0c323734e5eefef12f2d03892ef2da659b6dd3692ae0646d19c2d5422a65ccac170878915554f6dd385b69c5a3aa0704a30e39ce68ce5a59ddca3ccea1243173353caae8f731c7cee6969368d9b10236da181b08e938a93343933a1c8031d1e34b78a9cafee5b47ef6aca68e77dd7124bc6676519489adf88ca7b02d80912259e908134fa14a65354da23f5e8ce478a00148393cb032892cfa00c651ede4029e25acde2c5c5d99e90cd5b889cf4676d4f5befb3410cee5ee237bb3d0ff4ba59cd09b85d2c0479ab5839483d0110c2d1b942ba525e85abc91a405bc54769f0d13595cb781acbdfae17f478665dcaae25532e74bf4833c73f174afaaa8e454556988e1d44771c7c66c92c21c99ceea2920b758b915a4a7e6968b3cfd55e448fca3962bca0a340687f60fe786bbfb486336e31d9738185df11ed3b3b604b550a7d0d30c24dbd270069e7750ccbd1c83b71751b70e5ef7b6f9880a608691ef9286faf1bec556ed6b1c30286c386acbf47301208941e979f563cc5e34f51df5670d12eb6e768021e66414fb4e15ae4a2842ea5c86ddd4c3e90631507ff13954e861cda0b9bd82654991502ffdcfe2223a6454d22f2f555c09a5ffb9027c8d445366065acda4363836486869eaaded151e3a7a5eed99e34e4f43b8a79a3cd3e6c1d9e0681beedc8ded2b2b516475c7826b9b752881e183aebc296eeb3da7d3b5ac91573de7e97616fba740e1c3fefb9c3b3be8e4cd34436e8610863d1ff446daca0003f883d3b3e2d9facc34b366e51bfba0ca9c8abb9f248dbaa20cafef8ebb7ab0923a55a15b9d2e9364ae8b5fa6065f133db377b3c04df3046d4f06d1ed3c0b6709a0305355fd444a31c5dc045979051a5d6e6d30f90088beea1bf49659ebc3887b86aa760aff58f786b4d485dc97d199f4e2cba44dde960eabfb790845b8910cba12811aee7027557833cd9dcc2d4b82691d155151b25fabc7dfbf2cde1991b2b0111fa5a06f86b01eb3ec0bb9e48ab88acfe819e00f140e8ae611d0a53e98c8fdd6e3a329232e22095f749290ee0d3dc644686821647950df26b3f2feb0cb92d869ae4b4c16f645707004430a042c61c6b3bf2aead58001ef1e61e0ca51f1fd5ccbb6758ee53de181e446cba3e57529933539fbd627918f33cb9f9275952c228e0e2ea306900a5c2b81f4eba2b1259f55801b1fd7ee20841e6610a2faaccc3a7e6463b4a0b76420ee36182836dabe53c6d88f30c0f7031a0a3eab3289f1730bdf762dc4ce4c54a7119165caf94fc73e3c4b562fd4ae7dfda9bf67c71f835c85edc34ebebbe96bd29a66b87c485c92970d29c26a146e455d0faa158237e452eada8e39a18a61df1264bbf66b6252366bc5c2b8f74835a2dac28ab9554fc4c8393fbd993901eeddff01d077ff4b1efae39837d52a508ee7d42983693d8976ef33aa28d57552c60939cc8f82aacd7eb6363d6a3cc9845f68ee1ce7e3df85fa6138a79e1f4261326ee118e6249c794ce3d3694de8c8fea41d393ac9ac3ed05f19c51f763a4ce6f6240cdee41bb9f06188a204f833737fd3a7469a56e4f9b66802bd0c73fdc0fda98cd77f15231c0d91011697d7ee570a2e112da5d3eedab7418132d45b1e8981019e01d972c142a39cee4816dd43e4a9d3baaaf46881dd1380029aa47c967d840db77ef75a162c24067011f93e4faef1af728fa0bed4f72a61d342ecc12428d8bfcfe19034bacd5c7a4a6c6e06a022198368d731cc554271ffee34a5afd8174861753db125f2a1677a1b67ffc4babe84eb48084c8ea8306a883a012464b81871954f93569c653d9e91c272dc9a02f98d888c2b9745333fc660d8e760572ede7bbea49a9105f15e62d4c081af91c1f55d624ceb9f6977d371d86047d79550db4e0ab763976eec42e4950727c0a25a898ccd0aa66c441087b95f2d38a08ddc2380d2e525479bf8fd8b4b5ecc5b9ef68e402da94d9c4066e83858de5f841be7be5bdde7f09e8ecab030ecfc9516853e11df4450354c765e305e3c029e1e35c713bcde9c0b251775228fa6ceb8a5e39a01893d00e04776ba52c8dad071e7cf6b82a357ce56eba2cad1f3187fdc12841b12dfcb29922e9f99dc421ea84fad5fa6b1156b93b43439cc2e9b6073f5c7775b57b05fecc8d096c21ba2ea1cb7d346a6c1a4dc84373f481949a293a8e8be6a8ee1286c50869d859411aec93c2d12837ca4d0fc8d6526e75e39a78d8a6de00ea60ee0eb7d7667ae5d721f9811f526c02e29f8445659a587747276d35aa1acb9368dbf81f900bc67ebf7c331ad1b27cdebcf3b3970b7c8bfc41582d4fdca2ad438c88b935655191bb2a0dfc06e4adde25dfc94cfe03248b65300773daeddb7dc985d5f80922b47ad2f813b88edb9fdb0599d4ce9e6106c4dd7be7740c9cc582e78404424b4ea606bbcad70337b8053e717e35fa0997fab5f6a58df883faa275d8a11b1d6ef49e5bcc4bdee72eeccfb7536d908a64c042d46d46c393ca056e6de68652b86cee993f4eb8a0e272a472c361fbab8890e7eb89e0b4e010669a40b2862efb5a057f83192709a4e4dfdc3e9fb953b7fb40865ac3636cca8df7c6e604b012ad7ea371385922999b19dbf8f799e2892c1e36fc60e1af262bcf375e3a56ad59cab03ab755905429932b40248d4253edbb4aa8f7abdc15c7f629b062ddef060a02700229151062c8a0ab8422769bbaf27d93220c2d71f8e8ba6317508c7efad96670d3f9febb146697e608fc9894e267e432c5ce2aa93e976347324f0b629bf7ce937f8d222a6c2873ce1dcbd80a5c8ba0666ea77a7932ab138111b8a46e876b0833e518627a8027feccc90975decfa7f5d9b7b9b891c897f99238e357d4e63b7b1469a874e40db7ba9a98ec98df839b6bcc1880fad4d006b18a5f2bc224958804888d63f7ac3826db20aabcb23a36e7e4139bebc14f625c945556f6c14a0905885413565eee9bc0af9f68c4f5d3769d570015bdf89788e72e44f5a43a7488a72e0ffcdd46dff2ccd2796289eb55e064803852d6e18de9fc1f883b7b2d8c2a552d1da0d36a4aead4fda77856b86d44271224bd701b0b489769545ef74d0e79b40d35ebcc1f32d988240558467fdbf7e93547ec80acb0addb4f8d40c76879257abece1e122eb55cbf4f785af7b1a937d954fe330ac35429758b5785feb22cedd40c472e9b6ab2aa1409ceced4e5e96c2e7b854a4f77e0379e1bcfe25ac6a64bf86e75310fe939554632073abd3f6052a4a198208263e35e61750b31c414bfe7012c20e6f7752c2ebe727c961ee4ab5cff472f3c840937727fe8dd94288a68b4dcb3e51d32b590d21fd74e86db8c59dbe187df6ad5c77bcbb441765322a72b238844bc3757c223a2b2ab7881f7d1cffa763c4d45987b090a4f6d6d056c70bc1475107cf168e4eed4d1f56dce55001a1e77ede0c578d61341996bb7c4ac9bada48f0677c44d2782a799f2ad1a5e57ef71a1e332f386a922f759456a692d58eebd788d878659c865b6b45d95bb5d63e882aaf6cfde6cd55abe3c49994d6d40aeb4f173c219424de0a678d5bb17b6b60e40bb744c6338312462c024a2bdc900cf7c847fea4aecdeb4624aa7e5f142e127d097a8e56f9ed60bc540bec5894d8b6e696b5cd29de52cf80e6028d6760f39bc0fa4d1e4705f6f8d3a4e7655c50e2870d1a471e571b6822666eff7bb5e77ce20141aff26aa9fc1b35b722a493d8b4f308f9268cd764b7563125691924cd09913778d29cbf804202b2c922d26e971bdf7c233e40c4cf1ca67430880ac7fcf0511da077983bc3bb101eea2859460529b83f34a5df26c1b5dbc7d7f463a9c36bc1b1335c7bb1e90fc3475c067b6a9e141d7addda170286c30228ace656c4972ba379c70bb694c4bc47588b1cc1c024220943e9e71e3d89518d3b5281d2c24b579e4e3237c8233c0ec04c6b0773533e7eb437717960cdbc4a2aac42a909a40c34aa0eb782babe7e552a1e7ad04afa67294721e8c9a0e88dbaa0e1f1ff0a05b65f99d6dd82c916a846d8b2598d7fd87aa7e972aba4ce3db4753db7aa3a025f49c7b4d0d81a86688e0c1a15fb5275eefeb14751a8c727dc275ba455747dbb4dca5a0dc47095928cd5f91c0fa778cdb0ae03616b2d6efbcd821437a3498e91c51b9c29eb22830df01532fa7831a5e55cd1c9ba766fc8ffa1804d4f4ec5e2accabdd35bb7f0f4e3df504fd621a133768702ea2a0c0cf38634bd44f34615a4d0eb47e856bb45fe15f7c3e8a68dcbac795b6fc8bb91562fe5485a525659484978cbc880c2f28584e25ccfaef4e4018812d63228348dc1f3bb09e748e53289ebcf6c926adbbd77a54f79fb2b0f16df95d409b078bc6f693a1efd7b026e309989a19ff3d48a11e57bddc744f4bfc2e5582759f71f5dc6bdad0ffb3ccf50284b655cad52847620e1c33dfb11750a3d1075fa63aff2a1e5d7c8da6745be46b26510003fb1bf184965a5605fe3a1f7260d79a16f51dc5058bdadf211dcc96465b71cddaed322c0d4ad963f899143f64efd01fec0c1e63650c2f3f57e52d90d5ec9df93bac2fb0b4efa0e8ff7d62680bf01b2c05550523608052a87406044395f47b9c4f8cbdb5eadad7fae2e28926d6eb8381cc73fd55773ae4f33eba0026dbb718a0fcc08ead78e7dcd4936672bd69fe911506ed6b89a2cc0af87941658dda3f3f2cb4ed9f41ce7993f3357380221979d2adf5f357d804c272987381146aa7243303257e5c099ff7701a7d3421b97840931779b73372837b4e556fa71ce685eff260aba72467f2396fa1ab18b6dabf0e000c6cb4c9f20871387b49374f44d8692b6b273036a5fce20540348d6211b0c4c7e4da7f16cdb559e0d4d6207b4036767d56ae3798f37b9afa6bb7467a32be19027421d7f54504493e09c007d7728664ee072cd8645d80d0f27f5e25da393b0b0c42f27b382da8f9135924d2cb3a89914264da70ea1686617f81c86c390ebee129b1b1789d837ac9065c674c87b4ab197c65f78157291ff7777762b6ba971a576e8d68b380f21f18c6bd6b1161b5772eafebb5962d1127f34d6311368073deb88cfee931e7916aa21bf03c1a4c6542a08acb4086d86e3f4c1ef245a871d1d807b5bb8efe27dc1868e4edc82369cf4b11a70178ed43609a0565df418e1c8950eba4f2dc2e989dc0a4d417f68e0c85f3b531c3e4d51d5ab7c682853b91f3f68a987bcdcf917cf288c8550ce883980a86e14fbca50a701103fbb68b456d505baaffc0929a0120cd4a28ec20933bc5a13b867d29a98013552528844797573aa1c22e361b23c9b4c3d7c99c151f21d06e8e7a7a07c7ef2f798f889447d26ddf28577ffc15a4f2d559361f61481204f3484c313d5b33678424fc139dcd342737f934d3f5cfe6734a678b1a70dde7b3eb9cd018c1582be8ecbcdf59f9b934a690132688ea5c36bf264667f8670eb22983ee3196792bb8a0eb999c95e5e89bd43c4036a32d8ba1d0f6b98d8eb8ed89908ee9a96ab09baa5f916cf0b2f4bd097c5fb6e2ddf6cae1d52a868b9c95d227c8eecc08abb0d20378772025cb05e55246ebd5dc4533f01a3791b21c13be43f3dc2e6587f07b74be90ebd0708f946c281b9d93732d09c9cc64e288bf30b7ea308fd1a045a06b9c22e0621928f6c4bb84bd45c8179f7aef338e5272dc863787a916fe24d6f47f6e189ae896f3878f909400a92f31891774e1a513878830d8515ff423c0438f35d3c8f2cdd2fdb03d5c68bcf36cbd1db90d3f16e4b26a033c4be10ac3290161789a63d4be577bb0f05f45b9eb4c116561f15c68cab832ed1172db2e1545166dbb74a23410439c2b702b2026d413f4b41e0a5981f38ba80792019603d84839ed7133cc707f3c691057d42e0f2dfaafae460c2e49a75c9df152ae321a760dc9fbf849a34a058c1cc646ea9843536bb80a7c6dece9f9798922495f5ddd2b7ef1cc2e70868a0e87cc8ba8115d3dbf2c040c1333191fb6ef1d7916ad1fe089a6cb97932df410e2228ac9af831ec2dd5203efa76533419c704249ff5a4de4432e25b2e39e70415b7da02d1be42b88bd45f996b08e6605cb67b278af94ecd24c786e416190fecadfafa758ac912b387ebb41fcf752795158e2c42ab835ca3ade8e346b29b83f3d096055581033c1840ea59346cc66e7300af15f0dbba36a4cf602abfa429ee4cbdaeac0fc8f1abe5be8b0a13e1d6a06503341ae5de9aaa204cf38db787e4823d8a400eef7c102e127b2abb2aead773adf74b4fd85bfa6ee042f4c8e0cb7da3b0337e2a45d19bd0587ee49e0784bf0e29f963b3732cda6ab2402f8df151f8cc615024968ff12504819c6e7c75b206a8425fce9a2364f9b950a321dab9bffe1b91310f269c71b713ef825c94ec7166e9b688c2b4eea4e592ed51446c36d5812f7cbbd88941324e24a80f45870359417a91c65b53a02596cd6c3edb47b9ce89ad94ff45df55736b41bdf715f3058a992d5f200b8b57c8cd3dca57556ad225e80ff1cb9b1c525eeec9bdf5d197f080b19e00ac2eb9108ce648b8cb3387d15f9f6d841436f006b78e5e9a6f70cf763d6f951c89275a8bc4c9fbfe60ea578dbba778645d2047618b740a433416d7dfa47c64691f054f77220455fb04e030f514912d127af6cf698eb2a75b49f7c36e5af24160f6db577f4dfd4f2b895902c90873ba330dd3a2b10cc501613b58aae076d8912f8e6ef408a45317449e59cecc9272366c2e015165e5aeff31a0f769025ba547c55850bd1c1ec137e6687ec89262f189ba1e661340a476872ff17b48b35e8ae93bd19589b820d215548b19fa9bde1754aff9650da04e85889bc5277cfa8c577e24b79b11a4ce87e8aa96cc1a169cdc65fd6216e317729c9932e0d084e30c6b16ee1bbb47cd7a91af4ea6deece44bfdbf4c7c9650d7e5823b1b0f56757eb02f2d3fc20d3dad377cf0ad10120725da50fca454a967fe09aa4a250e4bd515724a8d8e6c9db5e2777abc8c2262acdeb809327687531509e5e5d0b86f6a16fd9e47c3804333a2e3e7aebb701730e7277f78f96e56077e59541a58ecaf03efafb2dd2d6c45df96c4e99a4e783fade90fc035aed7380a85b42b0fc70d82e2da27774656740797449a839f8f3ad8926fe78175d7aa01abfe6e96406deca64fa3af14707d6174365e24db84b8774ce4185ba85e0e1089e633fc7cf103b57a9967fdcd3653177d4362f830d77027a8a7e29d45a62a2c503247ac08227a7660abe837067a8e3200a7e7737250c8a93917c66046ef471aa063072725c53056938946bc3520e6fab230ca60881843fddfd819f66aaf713ec687c80f752e051d7e2e6314fc508757c16f43bd18eee6519046e95956ce800ba62b5b19e4afdf756b3ff623893efe837d7262a1ac5c1d4ae097816651b96034287764220ef75601692418abb5f2eed8d5078de32c188a6c909f3847a0bd59c5b0aa282e03e648b73f843bc499376e763c54a97d80e8f76d4b97275a29d62cd9fd2303e0ec4c6859a98fd51499c38cbd06fb59df15e39e53e1bc9bbe47aa902333fc885b68bdac95f3673c4c370c64a69aed97cdf3ee05dac8ade11acd55e5eeb5e0993211da98a2a1e975a68aaa8e3f7e18b87a3a089be62a8b270436df8742a12dd4aafb3d998e038a633b6ef4134ff4f5a3da790fa49a24a6d7920f013bf431c03241af6463b51fd9285cb0487b3d76341abf09b23f92e2a77c8e333b60cea583bb4cc384adbe78aa17b717853c11c5d09cfd8f9b91ad1de1a20af794f0fd42a871f268a0e6eb7cbb5188a6a8e6d2ffa38fc50d27e85970bbdd0ce2921d05d074fad4a8e2d9ef06ee1db6a35d4f94965cf573be9104a6eead626d27630d158c8e04ae868b7c0a7529261d11317c690b62a20b77acccfd3368fd02bb8d654cc0d5c60aeef2c81ed037b77a9f584c200b13f0d595c5eae29e1d4bfe9fc8e4a628ac89300c083a31c60fd602ae12b0da9d39a72a94e719a4bf056b9f59c8c96dbf27a25157ae58396cdafa9712bf0ad47a416cd73c6810feed942b6d1259553d9faa600e12d82b41e487f2041edea17541c0f8b327f42de604b023448a24ee68eb18e67fad7d28a19c0dccba155c7c2e7273675e584d73b6581b52ce2b824a9cbd27450fcce893b0023cece042e6dc4721a36ec8634795ea54ad934e093c13c6f7d27ab23752ae7404b0c289382e3891a2240878b3c63d9f9f8876a5039cde3ef0ce6fcb642e99ed25a734a8c3b32c7ea99fc3d952f5d7bb5bf469cf0f9b6b0b074e165dc519a8a27fdd61520c86fc439760923dab4d3366f512da7fc4f88f44b7977dc72e07be0e7ffa89633d10f35962505921c6df7afdd16c2cf2ea8c00062c6f0f0224a6f8525273ada1d84f941a1f79705b23f635f31bb83811bed53db6b825e7b12d10305f4049d8a4ba879f602fa12cbbc92e0ad2674184ec55db26029a08a613940ab82c90146d53e9a12dabbdc18609841cbe4ec438a03a0963a12bc3d641640e2e0c8e880d40407854da83ee1698708df835b56d8e9823fd606e3df3ba9b05f90d48e56d70cdb9a597f13a5e46eadf3cb3198bb1ed12709c95f537626e95ab951c9c930c9974475fb9170e5e0ad48130bcde8a2d2ed640dd99c0bede67bf0575ff6d8e5a1361332312f1c0a893cbbcd34d42bc97f6d7c5fe414ea91d45bdebe490b1f4eb9596ffb2d7ef10a3a18521d0c8985213e42bf68b38ac3f9f9964e5bd89b6fb44fa0dd505829bd2d885f3b1ce5bf1636aba3e49fdb5785477dea68e38732225eba2a953fe4dc9c9a217281071849a54a57635abba0c0057ad6b64af8908a2a03368bd4b28fe395b9a73331bd026b0b29ed770101fe38958d285d5a18d9cc4b449d29d8559fa0f77615b45fe19c616e819817b2c1e0c378fa85d080f7f0b1a592b67e170254197a2fab0673fba1b134af8dc9188eabe26f0e0342b3ffd3f27bfdbee2d12530bf98766c8ce3c1578d1add9c3a2692b1bf746fd1e74a8db41d599a0f7006d26dd81da6f41b2a8b677ccac713c1eed5c7fc41f359c7db777c4d7c2ed3669e99d412701fc6f23f1c3921fc8c0ace96993aa618f5f65c7816b74516de9498db6cd1fe355e28e9e7bcffc479a20572394b3981044b6e686094fc876317f07efae026a3b1c880eae86903101699d988cd85977cf5dbfbe0170260d3077bd09ec42e25eb2ad640e6cf78b494f3e7dc9c159f7f5bbb8f55667d84ea70aa503fd9739c2b395f80d18c1aa37a48a2728aacdf749b6f835fb140ae0c6a74be3856a57daa9cf1600803faa7132874937e01d1627bb2ffa61e4db027990a862cd8234daa4e47d7cc40429191bc086f7f62b035b6602306e7942d5eb8d19ae84736d9a2510c06e109416d821ea92af9e9d4275a0d4bc92e0bc3404907a0e0733bf1341e820be6bb656a91cbc3436228e3bebcbbd75b4ec5ee162e83a9b81e4e7e82539d72817c9eee3548ac9824f17945a4212a40dbd7c0e831da2579c834e7bcdbfdb783f25193870068ac096cab9053f3c38a4fb5c5c3e1dcfef4edfe3f43c20ae7b3f8db7fef159fe2608b1c6cdfc019634b8f155bfdcc7475f48644414043afa6d36585089f4b5c661381874720d64f14fe5e2aae223477453ff9a2dd7da1727227f9e214ac11e49448dfe83e0f3b86dc4de89a5503ecdf188751e72d4a003b4a463a27fc87a9ffdba97fcdb07f47bef7a1d41431d5af3e5eb12642df6879086dac3bca207457862ed15b3eff1aabf8936681722bd0fd7e65b150d97ac56e2c20368e40cecfba903c2432994f69cffe284311a0e1fe447e65386c23227543e0dc64c52f51c6e4e71c36a659b1148578247ba897be6a23514ba1c774701e50a4fbd404fd2771c94fd27daa0fe76943ea93fcbb86061d436e36d6acb077d215564b84c63c01a09afd6d651d17252f440ffca76d9f3b49e27f547477a9cd9c17334a9bd0f8b94affa36fde8220938a37f4e0ae1aafadcca832a4a361c51c81701367883d25ec124dd8e496058873c94a5ffb0fb73995bd9de9694a2ffb6ee099c53f0d4898a2bc60509e604000e82efd0927d3643806e06db00d4cbb212b23a7faaffa85a70e5ba8aff94f47086a060278993c9461bcb1f3f229b4a984cb997708e7d63739ad9957f3ea6a183631ee7462d11332cb9c1f146189fadaf2f7d1f9810dcfc5e1fd7cd15b7b865aa40ad24344e2a195e9bd0345aa87702ae8d124b96f02024f9e6dc757f6ff4a08587b97472a3c51c821fe5f573c8e61a8be1d036280b9371bbcc63790131b4cc8cef1e9b933a35e425c40b37b2973633822788b1c8bd48c64d72199beb6f2b43e0182cb99f683a12e90677acdd670114f62a27afd1b798ae9e694092d0513cce745743b72aba743c837965d8d0356befe84176a5c6d9c3a5bec482a47923e4794aa7b30a2c18b113454f0b116d4ea2920f63f6128c61173cabfb67ba4e18e55f871d8639b79b4b7197031668e1eba01578f16be4a99b2a0ec94c54a8a42db9251ca127c6abe4ab4d2516b5a66e5ce014ccfa58ffbaed7a20914b7e31bc57fd7a91d97616a191fa2f6978dc8a01455776f1af6101818d7dcbcd45eda638e442b1f9ad35b6c956d361dac0f7b367ea5c2a21f8f7df64060f79db0c683134434b42cf3a41b6651fdc2e530f462ece1dbc78fbaf635f338c5479105c4aa17260922c1628d446b881fcecfdb291a2b2e157f187955f660efd15b43cf4404bd41b89656515bd8c1485628f09e6429aaf912aeb74ad431379daa20d4c37bf3365d903d165702c41835d9007b92ff187350a24f68f22e888ce640af91868f610904077356b127ba27b1c5bd1f40e942a9466bab065f583ecbb2925409c26b1742891a443f446ad19696873a255e65d35a9585996a5dcfa739b2e3bf06ab0f8aa07eb13dd360915e0450ef182043034e993c3d0b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
