<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9279a268bf95fb133bd7f2c1eafe80fa297c263bf071b3ecb086cfa092fc83efe6517e09fa0bfd25159f7bfe2d7e26c657e2830f064df2d6b64b3382e6b490757dd965fbeabfe083f2b1e88f009ade1cdcba2564f422d1ff0d66a644c146231a777a4f923f453a1da3102f2718f61e1ec6ae5f227b4325f8eb1caffe86e00f0f04bda881d4168536f2f335d8b256c92a822bd404dafe60b356ecfb9a11ce540be1dd3f4fbf793db3bec13d618021c7db4aa37518c2caff42e9f888bafa0d20050f0b7475db00142981b8ed12d3f127f62bc03de7a459e60048420dfea5a6f146d3d37be45352f44c34c1d31f698a4ebbf345d548164e687661e16a19df333fae7eede2232346a4fe5ea4019e99515ce4196109e6f26a628aceeebf25aaecaf7ae2207c94f18a6b415e257aa955dea0e666b694bd57b37c48f0648ffbe3eeaafddc3cad3a61cdb97bb9887116a2cf746c684aad185f3a1b9b5a3ed8b277b494ca3d690ab2ad34b2b62cc217cff23777d73270b4578c9c9ea861b10f604cf4122d56a21e7df8458234704c36a2d7ac9fd75449beebce5a399bf695c242fa806fd778467ac7231c8d7c89d6199b9214e246827da08e9ad55e499067efcc584c095762f14087d17fbb1e58099d0f909b4e5a2e0e616f68ebfa348170f01a531e72788b04cb1ed11602474f019fd1047c6166783c6d698c757c33fee3e4e184e58d892b09cd527ef224bdc0ea2b120c5b8b04565ef2ad31af794b686943152b6e7769f4e5239a0fe1bfe27f799a19f30c9320408aad9e9dc47d8570eb63b762be2f69a24f4510cb9396b9ef9313693807752a6b59571c32e2775ea26bc78f9c0c24eb447aadd8a744844ecff8deb3c0d89c45b5a560ddf465bbedf720b0e1e441f9e697bb18afaf0033495c6a59f12c19fe6fcbf477755d35de5965e17e972dfb9df47d5a9f600cdda60e75275f60e519dda86b6e2038d6b8bcae190bab56f61a6a53693d5db3bb303580549610605dcd3520bddf7fd8cb84bf1c5625f71371f4b093aa0d213873777163f98bb0b294ca746f0a390520eb417b035bc9dc39d9399cd140c40b1dd24b9055666f43157fb4ab8d3e299f0f0514b9c74716f4a8faac160bef46330c68d83568c1cf41c6e09b9c70b28d21288098a1e065734c26b596085047a03ece4ffd2a9ce921e63895d0f1e3defdf413822677bc433abe07e343111e57fc0a76edba8546a742054ad451e0bd79cd66489d3bbb10a2885f9dc4be8634f3af55787f1eddf1a150b2779c396180819e5727f304b954e7fcf126296dac4845da69ae5d5efa67c15cb14a47acd1a9f6220c260465587e8fc80bb0b36c615ba018ba198822c6b800870c40585d622fdb57ae8c2113d4dd7dafb70c1b6043c2c57f1433a4a62cc9b9802206142367f15e4c8d1de239676d794a950c81a230a7e7bc770f1498fe289993290508829de262de1307f0bed6c42d87a59a8de1608b39c6ecf12718711c3af86d1c9ac4cccff5d65e720763cbd5b322f97848da754e110002f1c7451db59295d20bb4605d2cd1635e15a14ba58074dc9b6c42d0811990ef8dffc1f48552682db3474b0abdc14754949f2aab6af4b747904928b335d564368aefd7f0c78a6eb0025b1f97aa53b46f50ce3a7cafd7f9ddfa95ab03d1f6abff5fc658a20f535d43a447a2d78fb5590e270857e9770363984b7b2fa6ddc9f67e8ba670101e1ab65002e2dfa78542e9be0f04a01d44ae758ba83c9fbb66b18c098bfb6504b279e63cd02c3a60b1b24b989c9a7f00830933bf2d0857d94983eb417e6953fbf5ec76980f79b8f45ba8f4ef2ec95c1f141125aa47e7c28b344c69a3330732c75749f2d6405ef41d16e713b97417629d138b740760e2206d16795d3ba122a62a34cee44ec558772be01b91933ebba03d8d93e8af96e324379720f3e64523a41e1b149ab625f637e1e300f035af50a390be225c61e393e138b4fcefafb78004c74d4e78b8c161b13b7689408580941531677527e7bcad64b5ea06d9d58fb875ede7d4bb31447d9f7bd2c522fae6112e677887ea5762278eba97af3db06f70de3266b23740a28b3e819bb7341c723f36d949c998982fca9d331c1fbaa8dcc35149b2b63e2f26ab7af7ce0816d121ac08d55f33a0a7dca3335e8e2f4162625566fcb1406c475b9bda15edfaafe77e9eabfae3bd8ac44e5f908611b420cbe7002d06881c96bfb7461b5453657e3562e4a0d4f95ce6e2a04ff1a64351cef23c780c62d02f1cb66abf042809e9550dc09f45880351b4045f5405f16de162814549b2ca6d10b354975a85407a68a071427077e9e424280ac8728d3181fcafd79597adfda88a53b7cdc0abec7eaf19eb7a51a3069e61824a9713e8f36552508cdd7ac24b8c6340b0b3df3f6e8f17cbb0be1ab114334c02e9c19510e833d56bc6153697b7aade2bb9ffd3e731f55377848fe10713ed943accc1de3f8982548aae94c8128ed221ec2dcefca97adf4f424d26c5724c9873d1ec20ad7258d73ed2f4d6073c991131cc738b7aa9ecf3f255dba02236f3f300e903bd4836a12ad3d2e5acf331c4e2f115c77b82d93b4cb2f2244181c92e7fcb9478065fe4c90aaa61a8a06ee696f47dd37ef0bb00a3bd296c3442565b8ec8ee63a3157ca8947460569d34094f138e179f3578ede6020bf63fe1eb3af85109b3ced1a16060259903f243b86cfce18947ae9d5d9d1d310df3fef619abd7d9390558a064ca83bcc2d7ad8810d7aa1c2da1528d6829082d2a903740fd880c8554cba242f118a93326d9d777df81c4d088b2a0dad71b1fc2c6a331f63b9f37af0e462c80077260256ccc7ae51ceec79f3ae7d1fd0e7b4ea7c4b4e476589ae99df2575b809d8414c2de0d673200ac51a7be75498bba7fe398e0e6b444a89650ca23c0fdf30eb16ac8316d21652416056a7064212d8abe247d0754ff640de7fd0ea28334e45eed74d19a787e7899cc622b0cae5bd479455c437e75acbb5eb0c4b64fadfbca2db4945ad93e1aa840adccc9285d1245ac049ca2b7eba331009baf804fa016fd1af4fa4453117c71bd016ee3e5d05c5bce3de4d68e73c20b2ceeea7417bb9aa8fe6631f0780fcae861727d49791cb65e5982ea6a55ac7c5479106a32ba34acb236e3a2452f4218beabc2c02536dc89830fbad6aa9410e836163e316b99d147daf02a5ccfc6675db3d962987beef6569342bf816c585d114aedc469e4f0756f6bc52aa73918675a2ccbb0d4e564b173ea93908b3ad7e99036652501d036b91aa6f61ee50423a81360b46440b18ca6aaa96c98acd3ab12fb168df59e16b7390f75944985b417309600444d7af6561d4561cbd5d99f69208a547ab00bce9185ba19be8ae098d0ca686dcd822d56d80342e78ee961ea5af719fb56619b44ce242d7201959a6d7587be19f57e8609f97d162fd36610f57ddcdfbc1cc09166386b209a8058d07226b95305db5304f77a10eb32d4ad02fc1379e5a333a4d0ef7d7424ed6c64196996f4de179e4b981b0b3ac2cdd423beca3a699fb1bb2e6f14cc80ffb3a415e3be19bb1e649b8c212ae33db6ee74bcaef0dc9af9f5e5c6c6e7ffd14ba47de8b07b82aa77f7c62b3fd5fb56dfdef092034fdb5c0e58a9f87acb033c23155b8cd36e6c5f577125e2801ecf41787294a08a9e8a1fc3e79449d5df419e0eeaa83cd7c3fbe3f139e48c528ab098d9949c004e2a389aa76984fd15d9bcee30eba096799e2bff402c1567582f29ec599a72e50dcafc03211e56de5dfcdf60fd9596197173ee1f9c04077861d44d0ae654c2d680561783ebbc5c72817a15e273e88b9669db3824c5d11a68421f442a2f637232d1409fa62ff49042eae048b8b121b5425583d8601a629594db666170533436c9125408e86b8d6e20b2ed872715ba626a3ad0b7cfb15bf48be0dfe0cd2cb8369b8721bebb443130cf82d2a399cf9b349d96b88ec0832e9ee77fc811007b51bf9bee47d1478ee1060fbdc7305d0aa4f368b04f8bd09dd489339abb86d2117d6897d36548c63d5b4060cc2cb80779fbd482b399b9136a4f09c03f65d60346c73c955e151f1343e1973a5572f8fa751c1690e1b0fa48a156502bca303e86439e61d262c53e9ccd314b5ef97b243b1bac92ac262d5082cc5ba57f80da4502015ece51c396e7ba437117af7167d6af6b967d6cc8711887d006fd6249ccc45d8f8c5593d720727aa5f76e2c375e247c2a3a509e3a20956f1dae94b986c0d95a80bed22758b0488738bcb4b413fe8aa2fba52c19408b916411da800f9a4e678fef64405293215f933eb77bee9026c5b3757d65587d1fc2fb6f56d4ff5474198621072df13648a01ee01350c1cd715f850d59cabe6ac38648e983c2a44e3b9d454eec7dadb61418d81bcb69bbdcdcd784ee8c8d62ba806dfe805308bbc6ce0922decf2eb1eb92ccd1e31c4365b75ed9755df854b303d17b1839f97da771f0fa4d7fb7b9cffe8ed36edfa5b3e31fd4438697e5c61dccd7cdc4fe9aa86ec5ab4200e9b7eb6d5ad47201e1c460951e94100e1147e06b4b6d8f8ef813abb8a1aac91b7a93df01e33c092a37e7e052b700254eaf302e5bd73174c8b8a472ac8a17d00b11819eda73ef99a5d8aee02db2409b394d73358a9ece82940ca9d91c970566ff29a96031cde11ba2868c4081186de9f64a8b664a3415e10931c46835e6601ab299fe676bc28ea24bd283683c06b1efd525f22edc7252e11daa3fd57e69c4161606756dad403c3419d039e9c5cf624bf1617dad9805b50fa74fd7ca1d485ad6aa6d05d83d42f2f266025ce056dd32c384e1bba4db4f911a7a939ed588fd6979b676ba972d10fcd0facc1d29bc7e1e25af61eb23ea1071a054d925cf015301c1d360fccb694303519f577ba5b3eeaa0169d0f559ade76cec0d3ad686c05f462423e03cd4e254dba889658b3b7b48bedd1c80ca62d1d0829bb78d25725aca78d1dfd57b105355920e523fdfe337dacc73b23235cd8020c1023cfd2a470fb092557cbe5d74ffdacfb3f904b75645b8bd297c2107b345670af45711b5a6182d3342596ee63d01b79dd2dc7d41412f853b501d86d9d58aedeb88a3a378f7c9ae6a782ab4efb27f6eb14970f8dac852e0d022ee921856393c4571c87012a3b003488b72569a1ef694a1d6f07e3ce88e8f83b8bb5f2d9dfdc4b524b2f374956b8d60ed77c9820b13be871ad1980034ecfac51d671d77c70479b26dfaaa8500cc7dd3a7e344b510d69bf618417c764ec928f7d67205bf6d8becede3c0c56609411b976a9398b3e303bbee3f841e59c4533bef1cec0aec6faa8c905f96ee1c2bae12b8d2e0459b5afe504a9df9f20e3bfcdd443df9ef7e89709e3ecbcf22d8108cb84fa4be3fd4de9f0ceb847ec0c66af6001ea7f1d59452ed0e56de99a360d4bc1d965823e5c646f1a9b166e8b7e11e9a6b6e4b7c07271aadb8e9d42ac25fb3487e774d198faf42c6ebe686210f83aed5569a5dd50383667e3252e49460f894beb6370ab1c847b239e913ec9ab8e3ffb3404e95a918df4349c3aa4253ca3e1e922685e47c8316232b4bf94f95ba45317e1049bb393f9bc168471fc03d7d4e46df4ea1d525b80612535e1b716f4d14a7eea178a9ff941621bddbcbfa79ec8ff9f202a71d70d586dad4da21a024bd6d8289d8ed7484894a84eefdaf29ae0cd6463b10e5305661da724e98a1c0722ca605a9c4027cbd5a7f5daa3566e31d0cb0fdeed411c613d3b47bcb239256bc3fb05daa7b66ee0b85e43862655dab96f8b6be394e19802c6c4338148b618bbc722b5aba9c3f5ca3c70504c43ddcc9f6378ce35550fed4cc1fff36c8244e1ad596bf6379b29e6bc7514c00deca5aa9808c99c76bab073bc02d4802de129fe4af9eedee7e61df40d0cdd5f3a833d6fec370f19762588e599e8d9a0f8bf05bd5fa28800457da3340f8834610757a0b6f38a1d7d8cd72c537983f2b75f3387e0c8f7520f0e79d7b98dbcb388aeebecb0856244b9b524ecb05e1c33ceb805dbb7fe30083711862cf4ac989a608c0f6e07a1058852c2e23d9129d5fd86b3a68d481f8fa14475f86753b49c9fff1529ea230262fada3c28fa0768978be01970fc1a452f6db790a3f1e69cd7dc892cbd4b012996cfbc86e99d0e35b8e08dccb1466099ec968b517f57388569af236b52ce45afa277dd9438c998f6969130b0dd0842a7de101a614473efcc28bb6b5fe9dfc642d52c047e6345058b51b24f65f27fb43f7eea95c2e6c83506bb2a3be940cdf595c40cce31fd9023ad1182a3ab72504449f74fe3234a3313ebd2e8d09ccde4097339ec1081047ca1fb2edccafbc86603f8abcd0e293d8c2d2e67fcd52a15e60088716abd1d93bdac51360ebf9ae2d6213c1e17c0da70d04d8cffe8d9761d22b17e003cdb3f5269cb83928a7a9a7a4b84b9879c8e52916b7a6c5213ca1640b92688f36b3ef73b2f8a1cc9858c925d3055d5ef733056112f47b24afe8176d8f69881cc78a485f399a38a4f3986c5677ae85b5b682bdfe340f994010015aea80dc573a40887ded6df6ff8cec96352bd12b2f8d11fc9ca75d42a2421d9a49cbed33a34c8dee3dbadff45916cd15a947fb0d37c784d0e567e7a9e8e186cc6728923ecfca700e7cf0f2fb5f544139d9be12420d7f0050c6cdd94204a0fe2dcd1acf4c2a6364d4c1708725acf69032ac185714a9407c100c5ebeb744a94b0dc756a32bb6d9b109978394bd078fd0765ec70a7122d2c89adacee2589d96c27a968b8b7d0d4d11cbaab45a508530e13614c0883a7c9c4a93f60c4ff0084938f744809627d203b4f7bbbce6ff9457035adc6f9c59da36adc3b1e7516c3c0a6df775f1ece9473ef91f738f364d60a0e6020af92d76e5a1926b682a0648c156d17b6e9672cb4deb7ec7b2dfb528e60e3ad510500663f41e427bb8b57c8ac0d6e7758813cd9931a3b12b8a7e20b654f9c93b4ed8cac35ee75ce4cb5c3c835f7293601158343b3e2940e722b1813c346ec07ac900e3a48bc5344306bb72fc32c63e60d1b1f33e891fff7662706a58f5bdf92a46fbb64101d29f9bdece26f25af979190ba7c8adf47637127a412b88521d88e9beacbda4db322ae72988a0e14797746618ae7e4e713d940b4417b147bd909d299ad8cb52f4e5223c07127f6abfb4e86ea7cd6087a124df5ef50dc5ad8219ab5be66c98e47bcf9d071970277be0c987d72eb188a3bbf4d08157f7d74cb5d48fc49f5f7b1ec671ef00a49b15cb7a87d92b52933c712ac202361e9ce27d14e299e6d35467ed5ee665663066226921f7e28c7ba7f6755597773806f9deb6cd3b0c6e5866a1178b731d7d04c2295779db5e406f62f1ff594ad6a113045ce7e05d6f9216fb986fa827224fd7b41f967f0f5fc7fbd9123a6350a59e56dd47c24f958156dc6ec851351ae40ecc7e40dd2000bf8dbc67d61296aa05137dd17fd7ef27e636b09e8b4d277e2015476bd042917e92e9940c326dc5e28bec829a7cee196c37933b82d46f8d69d4f499cdc423fc515a1afdc6d4ffdb88b0a291085ea17d16a40f727d9b8ef99bc10682336213e3ba8b483d6c2d2e281987521fc5caa416855883fdad468ee1544ac7a79104b25dd3aa84eb304e3f4dd9e6a7bffc914a6c722d0d8173202565210bff4ca3ae70bb97adf1917548a6f4313d180dd88d81cd039541c309c750a592f1e9aac5fbbb346492092e15662e5bcd0bead3d86de6b62772a563f2d7906e0940b154228a068502b954f2c2b92d5c51313cc823910962cbbfb5e838c68339f0e2e3b784b5adc34bbbb6db3b414ab2bc855f123397c0e7481f071046a5ea8aed21c74bb066e6cdd38692a553477bb502de984dc5913e0b481d849c14a8e34c8a16e3c756671174b0449a8d6e8f40e401b287437ebec91d95582ab57ff105f5fc4c04e835af0b2df8023e9830ee43bfd0d76adea49eeb58faadbb04d99fbca5f3fc419d92a2825efe46f5423ccc38627d9a1fb9e3d87b551100361ff1696454434fa9623792deaaaa95d8fb6b275511faf24ab42f26609ebfa75ad19c421d9f89ee1b394ed9f7703537f49e5f74cec79fb54c3a83db5f46b389e56650a77ad4af99fa6d2473d4a5d4b0fd9bf207373953c06f239e2ec3eee2f747aa67f5bacabc3a53229b3c61e5329318852f63381375050b0b6a5a2b1dcd5bd7407e00ca6e61ef97f3852644c04693d114ba27be344e462c1eaac5cf665c0487b9c05a2efec885d33277d7dd0e70b2118c4f8bae1b3a5360968dea75d736b5c1f7a58a901969a089b75f7f656f75712d43899cc13b2e1abb52f327b3464b0c993f775c093b116883d482c5e0cc98df368662d4bd826f1c7847cfb491a276eba1a20130bc9c8637cb43abc013bbc3d5adc0423579ac542b9fdfa137634ea1c86216d185cd65fcf0b56e6bb6564eaf7d9ab2cd4f1fa73eff64d191c6bc92725d284b50aed2ef98e0eb6b5251236abf414339d9c8395804a164cccd097b0eb48f8d03ac700838016285949b9e9b0cc4602d20a6ff10588835a0c08a7395d7ba10422c7a884a0c6fd7d3808f712a5d8b216d90b4be95b7760c755a966fff4c47780ad87ac2569889297e8ec658669cef1ad5e8a5dfdfb5c0d141956fb47adbc552b83100d0af6e0e581c0695139e4ffbf8dfc4af91babaa820f151af752afab7e2e672d64896ced0a435633f102b4ed0c9aaa3eed6ab3b9e49f5dabf09f382064e47e3c3fa07e5eef55bc046bbc94e853961f7c9066a81076addec5f2a5cc845d5d98982cb53bb50e18a3679f5fd79c1bd6e93cb6466f485a94bc068dd909539e4c35838083aebda145885b235aca6588cd0e2098dd92cbee46c8e17762cb67e3e4cd586d048fb2bac295672374b5223b60046003f3ba41816fcae81693b4050eaeb4b82ebe2f496b2288bee48530cfdc1d4c6c336a159f5ae406a44c6ca9884e112cf1354a2a26fea0957447874440e83cc681aa896bb301a37268f94a3a7af302d0d24511616cac85c0e85354404c699e7eb58fbae5fcfa5eb99e59195fc883b56320aa47607b428036a41cbc0ba7b438e72216ba97aca95e2b5714b96a3e17165b2474ac1c33f2b0721efa92bad7f8d2c849663b4c1d0cdebfd0f7f1d378aead97bc4f140cdfe31c6d88b95acb27f49238160a8ac584fd2caa6c7906eb86a895b61ffe64703cdbd777c92a9b035cf89574c32158cb839027c4de7009c15345db13572458914c727ed14167c29d5549241b5baa07c482852c688f66ee6628b60f2b3cf003e1d671288d0209283bb17a779ed8a475a8d0edc81659e1a2a2998d12aa593e31d37995afe6398d03546fe7ee53725ff047c64","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
