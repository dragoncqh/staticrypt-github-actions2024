<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"723755f79dc8282afbd97e30f5bea53fa0e5a78a437455a399ff92db1dc94850989901c4e5ac3a7b8e27bb8d0038a4988f4fd6ed39f174c8758bd7e4154a4d297cb44280ff36e30500303585f8031eee4daf943065dc0a279663cb50bb59b76fc8996a004374e7c23d1f9698cf9bc3a2399f0d98901deaa6a2a8149f918135ca0f85595a29bf7c6f24f96db5e493dd63545a453ed1d272680165feba57b811c7e60bee4b465288b6cb6c45b8adc2900f34c2b27fe1b41a246880d765a8bf7a9d05498e02ed6475cf856fac64a560cd9dda73c6fc7054467e577c2e0663f1f6ac3c8ee0b5d1e680b1dba00a7f80c704e88a405815487eff64cef0d398fe5d5179be72ebff5c27c5a2d92dde45f8e0899427e86a8ddda49d279808913b48116bbe9db04bcebc13bade3d596658ae598e70dd10e1ce51b1849b473a61c5c471f8628963b322bb5290ecec6a67a8de0d942ac23bb7d879cf70f85e326bed78d9b9c2989d0a9f8fe8ecdf0ac8246c76021d3a77aed31e93bad9aea9c9bf84dd4ea1ed6b8e12d1ada4ea859a1669d4da84ac676c8dc2a499c8dddaafe4e54cde4296879be42813facea91c3f07f39924400e0092ccfe53daa3268cbb238c8d9c9911eafb16cec2f9f9c39f60797d4cad08a24361e4cec0aa61bf65defaab5be1b282ac8a166f9af927fa50fd9d4f2ea96aff85156c46cd11bafacce949519e241089b86eb116b6f45bde042fb51f459b4592d98e589b917a49af16752afc03cc91c264f6b13b7f6a2088a0ec9a78012fc8b0deae9b797bf1ae42d5a5753fe9cef1ec0db97f91d0ff9d55b640d22ac5af887379b067089945baf73715090cbc5936c22d22cdcaee2d96f8844493b4fa4e5600ae1d8710c3a2486cf71669f24ebbc3a357ec2c0575b5f44dca26bf01088de857501b0c39bea3a2a970590b9bf2d5a7f5ee2166e4fd8dbe41de4b0cbc243b6c1f832c9172e5385b9ed068bf338f47c71806ba220eee61c230851ed94e86daa867b5c9fe488eccebece06e800079ed12a77cd28b3903cfd3e0e05f9d3209023b7309940ea69a360305a465a21bf479beb6728f75e41dbf61727eda355ae65ed01c7a06c678305c8b86a72854809059e476fb8d3544d6d39935510826bf52fba677c77d6aafde993c0f1b9d98c396f9aef52e98780e7489acf3b342850f168dc495fcf1b5a8fec3eb41ec70090c2b05fb4c5334ddba718c17842d5baf46f24afd6659c0ebecec3973983faaf837a88af08f0ba54eea432d41d39510ae637660900125a716e0c0f10b584f08b034aa6922d3d316da6bca45da94c6feb150efacfb7e877ee3ec19ab895d4b38804422cb8e970c0448fcaff4169ac6c44c7256884cec97bda3c3c1f05c75f3edbb8392526abc7d4f98a536997bda512871dad7c3fd6f8925bcb79f2a6adfe10065252973eb20fc0a112c7e1bca5b8391837732132ae33ef75c8324bc7c473c112738798b22417dc06349ab2cfa100667f7e55c7b501d93be1c42701454eef498839b419d54c82bfb8ed40549e9882250b7ea6aa2e7135123e82f8c5bbd23f60e5e10c4e625c8f62d29aba2d499f8186dd3ab40b99b46bc89842fa1958c0f30523ec3c661038bce6dfc8ed6f186ef0f28380f774bd918bc2f876bbd61d1e30dd6dba971c7d3326424fac5b9990a6bb2c352a7101027120dfcb70a9c59a9d58b07d347b8a0e114d98d12cd16cfd8396bb381357127a515dc8776fbc873e39d287ff7d91f6e0fe6ea234ce18e09dd5b831e28cc60b3a9970f98ae07e4bb871672eaadfe3f2a9c7ee0fa71f84ec638602ac736731b1b2749af04a5594883a7dd33176fbc67baf60882461427cd62ed1cf4db3327215bd2cdd2b0bf076450b5ce03f23241112f7d61860097a4b65da0619fdd2f7953b4472416c7e097d894890408b40f28a8c4196ee643da412be9a6e1fd18060d30d11459473f49635e9cd3cb0285b71948cf69d3090c66aed5d310130025e497ca9dac53ca2a3871a8bcc5d29d72c94ae058d424a2a0aac5708834c386d72dae28ec9f14f0cde6e7afc97b842cda01ceed5795f22d9809c08786dc5c10543ed444f1aafed3712211a7982af24244b55dab5a2d26e5839466b1b1b8bd5883790ef40c5ecc20c36314be5afe928c3edb69897430b7aaa0f9b05f12b06a7e6c19d41dea043df98203a25dd7c3553c6aadd22b3effe6dbdd9cc072c178b23fddc6795e01941a26e9a13aae5f1b6283baf7418d20825170f11f51a40119fd8daf1ff8649f49e9ce02aed5c4d66294c68555ec6dd60bfd8ae08259c593972a95fcae3dea1ad7582f5fef127e7dc20434f1319eaaf31ab5b4c03d4d47b9dd70c2e6a098a8bfb8a97d32375b7dd897a4cacba938af3b5295449b7655641bbabe70d764963769d193efd5c3dc19a217bb1058d91f130ea4a6a291ae6404c259faa253d632e478750053893771c0618a9acd231e130c8d5e825d22f4ed47983309b86aea7d8285b86b6f4ef4e9b48b41949eb8a6135dd9766593acfcb56ed7b793280616c90e57eb4d22747f48b89534da3d60136ff6e1b0500c11b63ab1c07097cb2b4deb035b48ca8a003df884d264ce3d485fa975bbedf24d7949a4d71ba6e04dfaab68d87324d80f42d1050d887e30505a830ea6202e7597788fae2e4ff2c0b981f5593725cf6dd8faa9a64f504b3b1bf7a647333ffd601e120848e6094fcd8651a1aaba9878084a8fc3ba2a4f971cfc28b07b035495eada1416cbc8d70033fb811555743694ba5e00d704ff697c54ca9a233b00e1eb3bdeaa9fe5922c3e44ec8200d587c04250eb22532582d5b128bf4809a5c90816b9fad451ef6ffcc7bbce5c11702415693c052fee94ee9ece9fe69590726ffb8df880a549cda0f142fac7f703da59d3341fbb2c7488113568c47bee4510c53a72499374b9a74992754002d9676271c0b9da5f7f1af68e51ccb49d2625184ab2f681c408e1fe57ecc47ad0a4e2cfbf24a866b82cf944a38f1d2f0aeabd580972da3cfa670b6900e6896491b6c96bc80219b598c730f3a45d8b4ede1fd58ccddfe7b5952f2e301f87743d9b743c9d7f699f43df62694e94b6c5fe84cf37454d26bdc1082defe292f0a12d4126c0c7590087dc80f3da3faab1ec9ed9d28becde084e36380e6c8f6221a5bbb38d3b8d5ccd71491120a881534f5a86c596cb6cc6b32609415abe445ab4d9bb0130999184800b72990d55e0eea32d1342ebc87be7f5840687fb7e9f27b99eae100bd09252f205d206a4e7f6f79e11ebadfaf2a027225d34f247522bc539bfc2ae9c0a2b1d5da2220fc948116f7bbb93054a9a9f736d335432943746a59b835f2700793ca0ccdc3256708ae45b50ea8fe29bc894006ccea75d902d6708e2e82127aee73ab6ebc24ef1b91e0e3ab5343fca0db702ecfccc4052795444d9b44336efc66e0634e6eab50ed9289dd040d3373d53b18eaa759aca7f8adee4b260d6e126dc1ac729c06c26cd75b5cabb8acc2ca552e9dcb0a72ff59b4bf3da4bf1422449cca3cfa0df63c59e19eaa346fe791734ca690c3a175d6b17fbf0e7161e668428386fbbf36c3f1e6652abd284ec90c826e69b6c1f71f34f4c7cf26add0c04de4078a9db634a2e472135335929a7ffc99e55fd83ba94f871489b5684a78523bccea759d4461caf7031c99ed19e2eb67299dc59a0d65781692440faa94083862946a77f3da36aa1224fe03d9f44a231f10abcfad3dee0988087e85c8625805c5678e4eccd76692f219eeb89dff6f98257caaa4c905eca48a41270f1aaf85db3a862f5380ec09ff8b730af2ba45db4da4ad57b89384e8111173c6c0385d212c22e89d519edf79a09f42b16f03c6439f11d0f6e2c5538b3087da328e394c4c0c7cf364eb4b5951401ba2fc88810595bc0106d87eef37aaa2471e2a57db6773aa06e843e1d1238fd5a0cac261e874a5a434e0a24641e3450a3e8b97d97a9336fe359c12246f20480d607010aacfe4a523002f1af89b58cda196e395d02ab90f854867bb298a1cf344ab6de5b775669289f2cd5261680835d630a406b699ecaebdc9ab750430c6d95e7aa99f58606f6104b2f8de8534db000f6e9aaef6ed8fc00939970291c59f2ad7e3d03e0bfea3722c6a4b25cac71ddffbe85b739d859d9bc170145d5170f856599dfcb4d6a9bacb073fa2a71fd3f963ea0d147d3d6c5e4469e97b629af4c2e6afb9068b4d53c365d801c7e73cdc0d96a4e42e9fad90ace1ccc9210d16af80e55fe80016a75e6be7e5526ebcfe935205b9924d9237b2f50823f05b56c9e8a80730d8c0dc40162d6d7d73b336fefeac5fc7f6f84e204900a8cd3691ac9c5010aa7d13a9dcff71b66e46a325ec3d1bec19d2a52d1496a21575329278364966491414243667e404b4737fe740899ef1b76a031bb40479dabb7c7fcb10f11a0865851ce50b85e0fc08adc6a844ab7012d7d248c7fbd3cfaa7f68b51e992583ffaacaa5b9d0d12648b66841863c995b26916fe8e0cd096690e332b1b88c0cf37cf2ed292fe3d86a8959f1b58ac28ef073be73186cacd561b835098bd65d868a51957071f0831759e5e82ec86c910fbd939d92df82c3884614290ea6c9b6f9ad8f4d3bc6a33af2ffe81cff32740520386f4a6800daffa21ce52630b460b22cc3e626c1f616cb1098f6cef08de750bd589411948511773df1d8e1a4716b8a2f5374e0aeb51becf5d2058c46e4943227f8429a9c4df6a9fadd03fa271193c772dcd236f48b38370617594233d097d834bb6e92a2cfa52ccfbdc2ca1b28b813e7b88b8d7dc81108e4cfa5de3aadd499f5b59ab6dbfa7fecc723916ad7d6d0ea7b77c88a755c0b9a9346570071a013874a9dbe5853f8b02577145f081447b0c1a14b5eb476ae7ef5d2b8bcb6c684b6bfae95a07e10f28756ed89bfef630d95414f295d7b809a4d9535469513c3b70d82d3ebb379da5c05e9c90949eae1189e822ba12c669df34fa1eee0bfe857533b1fc0d9f022667e1e24d3e9e586f6e75a6a058f9f90f74ac8d5bc9ff88573bf37e4e11a10216fc5d43b937aa97372cebbb7c1643eff7e0735ff9a29aad119fcd4bb011220ba88d7efd7723c09b6c52a4fd13360ce1c6add74906b4c9c65edc124b38859143d9228217781eb645b1d2b3b782e0ba3b830306a10fceffc6cd01f8785ce98027f9fc6639af300694a90a279335bbd9adbc8a90a22ed56bb57853bcd4e07d5801a3210dc8f084482c00c44ff1b82ce0169a2064b946c302c25b3da8ed1951a38bab96b340a0807bc975d506a3b00a1f4051ccd92f4a80f9b036ed848e9bfcfb79b0f14c14765aab89a73bd5dd9427a5b4ab2a2a0bd284735e57eae15b8ccf13128875d7fee880712c6851c484074f50e804033719ca3c50bdd79665232eed86580026b10bcb6a599c362f972c4b8896a4b21dc08391516c0d00a8a7d60b5438f98fd559bba559cd5a4eff4cee775488b6e7be21d0a0903f057928de6faf73bb3c2f2c4ec346565d3c3eb3d9ddfa054c0df5a856680946b98a667afbf9f62254b3b43b3de4cdd40f369b17310b217504c262d6aa6728314daa7bb066787588c16ecf0d773438c8a6215f0689c07489b6721e592e813e9aeba124877d7f8e358524a314304c99c347f91cb54d19196dd47ec5732c2c6ee056cd148b7899e53620f8d6cd988de9fa1733c278d5bac5a1dfe2f10abe93001cc851795bd8e285f1c0f3ad8f04347cd66a9df7d4a68a8eb3b12c9cb2cc88404a14bf6dc19472e977ffd22522037d60eb7d9dbc8d444568dc57e6c975c62ed111bd26299b630f6364e801b457e39b48215eb5e9b78c3683eda712440f4cf1576f4567bf6f13ca36b5c06f03fcb61e99a877bafbdbf569ec69ff170076a0f4db58361f80edb30f52caedeae4bb35956fc4bc3dbbd4c288cc41125d022ec81fdea535641b71d27475b99d41b886106db6033106026a82ce3754d62a3523430464afb69bac587ca7f6a0ebf213560039e6312f31fc5d470837d1174a92dcc608134a4cf3c2f8cd1efe3992ffa2eb52eb68913bcd4e8a6617d5fa6e7cd8e592c4e37b8a64104325a0614fa5f2a11fc93b62078784aa4e5d6aae16951b35580b486ae85b1951bf0b8efd0bba777adbb3c7e5a562f27f923404d16f8b8fc323b33986d11e8671c770db159f91e05173608779a5e7c0f5ece4c52b9b01d19f95059091a7f2c9a5dc17bced612d726bedaa935c2018bbd83cae3e6a58d5e558280127eeba671ff04ea9fb57d3b33ddd56cf6b314f8286f7e369473d6dc901a77bba8c01c6bc6c7f4e2ab26490807ca961a468eb59bc71bcfa3e63b69a626386bbc90ddd9c201b69c1fc00a92250a19c6a1103bdd1a18c3a9d54041a6b7e6eeb445f24d977106d8354eaa8fb889fd99c04dcf7e018d5044546c10271301fd8b729d5295eeb9aa8d523cf807be9942ccf019ea96d3aba9bf15fdc3f32b7d0911d29aa48921589c4f9c0620b6ee020212d416330cf5f52da2385feff571b57a4b5ba1221b3b69339ed1f18180828917d396c8ab6dcad0c11b01eec713a27e6fa66f926a5a3d0bb09c10e3123cf4f09a86b3e9bd937b8192445a9d3f6d09b205619a9829dcd98b1a3840db846d54f13853259a43c751328e8f56234d4261986667ed60923bd16561bb51ffecd8f03679abff04cbda300f73cb1021b908f27f221e7e42ab53c40917657a40d9e0722b9e2a6a9beaa269f72e8179420df2b4d55e39b9a2bf6845013a89dfd7adee1701d2b23ee868e18976f7ac352c5649b759951ad2edf6b883d40551d352b7649096c80a8343a463ce7e0d152bb7427132232951e5d8b5737ceea2bd8adda9f2f4ce219ffa7cf8dbd72f56a9a0465ea3ac1ed1c04432c76f4c4e098cbdb2aa5d2d36e503feba1e46773ccaf19f4a6c5a0d3c84de760221cbccead19ea4bf9ce1db34dbb5187c12aa7a43bd8594a915321c65fdd0da4b196ec8f59572c3cfbff0d1443cce2cb9eb7ef3317d542f348f98d72e489ead260f9adc9d0c33b92895e9fe1e3fce6447ae7bf5da903e12b09402e35c6dc3f7b788ab725b6487ffd8a6bffc8ea1961088cbb25e46b6ed1e9dec57d9d4fb80ae31935b75ab776d716e7cba276e0b0d24ba4e49dd47338d60978586dfe80a7ef8cf2c820517c7e35930705029a56d60057d78217f7df92eb17bfb31d10762855fedd0212fc69f143e43b29be8653bcb85a60d1d9c5d6f1bbee246065af4b8f403fe65940889435156f161254f363fb4064484b1fb3e1cafa3822407f66eee329a99983126bd9fdac0f3bd1f0e1ddde8d964cff24374234983b633e5d8d2ceed3e4c4cc6bdecc0e96a842879317b58fd97e093d9bd3d5756b49e821392366737e4618319ce2816efc09c5c8913ac43306835584d9483c2d2a4ac24598221b8755cc57076d5823d73ed781da17f3eb5b24aee9e72dc0e8775c7a0f9b815b294e556c1bff81df2b9a8579417af87c66a9f7bd4b1bea92655639026b84463c02776e16ef3017280dc54ceb59b0f1a855f7abb944770de4369ab4807f2600f09c83c8baf59f670d5f54f867e8607d0e08ebe7e809aefc7a5c57814ca0c92d6688c0f7da495f85f90cba5223617c497e3c0e816f988e732dfb6afe8b7a0976c5b50a4c4d24c5206f75cb2b7d3381202130799043e246b088f64f43f0da2770edf86ba7ac39e6440ebaa3610a07e1cb1cdd390d93e354c6bdb1767882e6b492dd735cc152dce92fa7e906b906ed76740d0eab1ee19add985c6bb421b9c347bbcbf6ea809509bd054a01dfec2c0c5a694f3a22d771604af6bf442894f666a5e17ff1d1a2e1d841d2e552ef7da5132fa527f11d7d5c0e7346162d88ddee595396283d0df5f85d93494934348a1b73bb89d561140c1d3b38aec0b8a4619c60ce353eda63612302c0d900da7f40c440118078219efbc04060fff53e3cf43ff107b5b257b899cb5ac674da07c0f184bd228a11a2fb08a8d8a4666cc1995908d41a35f28fe9ac26ab8c25294e702760fe2153db9c069ef759af6228e8342c121ca3dab5646978754e3db5e10cd1a210b7d5c69b6f40c87df83277a63f0c91bf86c10e24d94806ca5709a200cddb2ac65c173c68b4ae37ca4a0af10eed66b8bcc28906bc44ae11b16d8b7ec00a14aceb034e857e97561ab0d7fab3a32ba54c559cc0ce17b6559ea4aa5dd85baadf948d78bae708f82cc8142b7e81fb17d20fe8913cdf712545c341c95153cf1461c913d67b6b5a2bff3cb9f1468d3140b77d04fd529c7d5b436c7a49d0aabd7fe610557256c282ca0f1f0af08fcc2b55429e7c840823f0fad543db45fc3b627ff545bd62ac6bf6ab092a25423a6d80e9871d5e3014401439c7d24b1b8cfcc63be4961e5ca0e6d356c73d7311596693e185a35a2f6b011f6341956729a3eb615807160c6ed2294c41c6c383888b6d82319b3bcb63d7eee47c7e807a7f1572d3cabcb3a7da8b1f5a4b33171e1fd81057f6a10c9faf97d056aff35e66b242576ea2a33e5af73a58baed3eb080f8a6b2a7a22a6add2b5e2cc1b807e6a502447a20f053c0d016f298aedf5fa559cfda792b0f384056ebaa5fac14de697d714b62f7eaa849895692c4c2dccbd113041f551a282660a8da4c99a72a9f2a3162dea20c88d68c7888e6330d518be199f5e2ebc1bdb124bda869c308be2d53d07f8332183a0e4a2ca883c60a6297a34be7050f4d6b65e00ac9f6cf34d748740c26024243665bc5b475b5e796ae6f3d7c9e2dadaab6c8d5d0ed6643e27106f9b17a17d1c4d02a41740a8f85eb1bbd237fbc55ee05d03c7338abf34e9c0606b6a60217332f72aa76ecf25209c05243e32ba9d0da320b1de6d0a285df39ea7bd520c458d079bbe97d71ca4facc5bfb1d1cf2c7682c4a096cd0081504a9b0c10c5527cff6b1a0e643f3c0eb7ccd61f2b075282aec178d56652ae158a1d6bf26a0cad9a3c4f00b1c05122241700fdd6778e205f0d578c1d7752678a494e6a9c40635b9059640a7e33147bc752593ef8f748d196b4046aa0f3f8aab757da1360532ef1581ac146295a801661b37b1ee41ce50c33ed8ec883fa950f344f31250d4b42009e8b5ad3d378fb96804c2258d1158ec13b278c3d0f9452052110dbe65edb2bdec407c480714493125a420dda569730bdd0a9ffef0c51a479fd9f12ab4b91a4a9f3105e511da983a8a81021030133cc3d1b1703c7aebb46de8547a1c09b0a9dc38c3ed1b320c2cd06fbf15ed7128370bf58b179ec703e7eba86a25ba6d88feddceb74c803c20413e9c52df3a3b260bee3d96ed116f0016ab7ae0dc2ddd8c3ba13a9cdc0c67cb93e8076ed24d301a0c946c679ff","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9e3b103be60e08815c809bc5d316d01b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
